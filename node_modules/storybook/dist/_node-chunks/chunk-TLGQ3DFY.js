import CJS_COMPAT_NODE_URL_n7xewhgh6ep from 'node:url';
import CJS_COMPAT_NODE_PATH_n7xewhgh6ep from 'node:path';
import CJS_COMPAT_NODE_MODULE_n7xewhgh6ep from "node:module";

var __filename = CJS_COMPAT_NODE_URL_n7xewhgh6ep.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_n7xewhgh6ep.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_n7xewhgh6ep.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  require_picomatch
} from "./chunk-OL4ZPH5W.js";
import {
  versions_default
} from "./chunk-YFJZFOCY.js";
import {
  BUN_LOCKFILE,
  BUN_LOCKFILE_BINARY,
  NPM_LOCKFILE,
  PNPM_LOCKFILE,
  YARN_LOCKFILE,
  execa,
  execaCommandSync,
  findFilesUp,
  getProjectRoot,
  normalizeStoryPath,
  require_cross_spawn
} from "./chunk-AQXXWN5J.js";
import {
  any,
  from,
  up2 as up
} from "./chunk-45XSYU5U.js";
import {
  invariant
} from "./chunk-PEW3VSI4.js";
import {
  importModule,
  resolveModulePath,
  resolvePackageDir,
  safeResolveModule
} from "./chunk-VOOIMEQA.js";
import {
  join,
  parse,
  resolve
} from "./chunk-Q5A4LYDI.js";
import {
  require_prompts
} from "./chunk-BEHQEHCV.js";
import {
  glob,
  globSync
} from "./chunk-YT3QOQMF.js";
import {
  slash
} from "./chunk-PHHWFZ53.js";
import {
  require_dist
} from "./chunk-E3ZVPOWE.js";
import {
  require_picocolors
} from "./chunk-5TEMW2HS.js";
import {
  __commonJS,
  __esm,
  __export,
  __name,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-M7JK3PHD.js";

// ../node_modules/@yarnpkg/fslib/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  __name(__, "__");
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve8) {
      resolve8(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve8, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve8(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, "sent"), trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      if (y = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  __name(verb, "verb");
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  __name(resume, "resume");
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle, "settle");
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
  __name(verb, "verb");
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve8, reject) {
        v = o[n](v), settle(resolve8, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve8, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve8({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "../node_modules/@yarnpkg/fslib/node_modules/tslib/tslib.es6.js"() {
    extendStatics = /* @__PURE__ */ __name(function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    }, "extendStatics");
    __name(__extends, "__extends");
    __assign = /* @__PURE__ */ __name(function() {
      __assign = Object.assign || /* @__PURE__ */ __name(function __assign3(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
        }
        return t2;
      }, "__assign");
      return __assign.apply(this, arguments);
    }, "__assign");
    __name(__rest, "__rest");
    __name(__decorate, "__decorate");
    __name(__param, "__param");
    __name(__metadata, "__metadata");
    __name(__awaiter, "__awaiter");
    __name(__generator, "__generator");
    __name(__createBinding, "__createBinding");
    __name(__exportStar, "__exportStar");
    __name(__values, "__values");
    __name(__read, "__read");
    __name(__spread, "__spread");
    __name(__spreadArrays, "__spreadArrays");
    __name(__await, "__await");
    __name(__asyncGenerator, "__asyncGenerator");
    __name(__asyncDelegator, "__asyncDelegator");
    __name(__asyncValues, "__asyncValues");
    __name(__makeTemplateObject, "__makeTemplateObject");
    __name(__importStar, "__importStar");
    __name(__importDefault, "__importDefault");
    __name(__classPrivateFieldGet, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet, "__classPrivateFieldSet");
  }
});

// ../node_modules/@yarnpkg/fslib/lib/constants.js
var require_constants = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SAFE_TIME = exports.S_IFLNK = exports.S_IFREG = exports.S_IFDIR = exports.S_IFMT = void 0;
    exports.S_IFMT = 61440;
    exports.S_IFDIR = 16384;
    exports.S_IFREG = 32768;
    exports.S_IFLNK = 40960;
    exports.SAFE_TIME = 456789e3;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/statUtils.js
var require_statUtils = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/statUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.areStatsEqual = exports.convertToBigIntStats = exports.clearStats = exports.makeEmptyStats = exports.makeDefaultStats = exports.BigIntStatsEntry = exports.StatEntry = exports.DirEntry = exports.DEFAULT_MODE = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var nodeUtils = tslib_1.__importStar(__require("util"));
    var constants_1 = require_constants();
    exports.DEFAULT_MODE = constants_1.S_IFREG | 420;
    var DirEntry = class {
      static {
        __name(this, "DirEntry");
      }
      constructor() {
        this.name = ``;
        this.mode = 0;
      }
      isBlockDevice() {
        return false;
      }
      isCharacterDevice() {
        return false;
      }
      isDirectory() {
        return (this.mode & constants_1.S_IFMT) === constants_1.S_IFDIR;
      }
      isFIFO() {
        return false;
      }
      isFile() {
        return (this.mode & constants_1.S_IFMT) === constants_1.S_IFREG;
      }
      isSocket() {
        return false;
      }
      isSymbolicLink() {
        return (this.mode & constants_1.S_IFMT) === constants_1.S_IFLNK;
      }
    };
    exports.DirEntry = DirEntry;
    var StatEntry = class {
      static {
        __name(this, "StatEntry");
      }
      constructor() {
        this.uid = 0;
        this.gid = 0;
        this.size = 0;
        this.blksize = 0;
        this.atimeMs = 0;
        this.mtimeMs = 0;
        this.ctimeMs = 0;
        this.birthtimeMs = 0;
        this.atime = /* @__PURE__ */ new Date(0);
        this.mtime = /* @__PURE__ */ new Date(0);
        this.ctime = /* @__PURE__ */ new Date(0);
        this.birthtime = /* @__PURE__ */ new Date(0);
        this.dev = 0;
        this.ino = 0;
        this.mode = exports.DEFAULT_MODE;
        this.nlink = 1;
        this.rdev = 0;
        this.blocks = 1;
      }
      isBlockDevice() {
        return false;
      }
      isCharacterDevice() {
        return false;
      }
      isDirectory() {
        return (this.mode & constants_1.S_IFMT) === constants_1.S_IFDIR;
      }
      isFIFO() {
        return false;
      }
      isFile() {
        return (this.mode & constants_1.S_IFMT) === constants_1.S_IFREG;
      }
      isSocket() {
        return false;
      }
      isSymbolicLink() {
        return (this.mode & constants_1.S_IFMT) === constants_1.S_IFLNK;
      }
    };
    exports.StatEntry = StatEntry;
    var BigIntStatsEntry = class {
      static {
        __name(this, "BigIntStatsEntry");
      }
      constructor() {
        this.uid = BigInt(0);
        this.gid = BigInt(0);
        this.size = BigInt(0);
        this.blksize = BigInt(0);
        this.atimeMs = BigInt(0);
        this.mtimeMs = BigInt(0);
        this.ctimeMs = BigInt(0);
        this.birthtimeMs = BigInt(0);
        this.atimeNs = BigInt(0);
        this.mtimeNs = BigInt(0);
        this.ctimeNs = BigInt(0);
        this.birthtimeNs = BigInt(0);
        this.atime = /* @__PURE__ */ new Date(0);
        this.mtime = /* @__PURE__ */ new Date(0);
        this.ctime = /* @__PURE__ */ new Date(0);
        this.birthtime = /* @__PURE__ */ new Date(0);
        this.dev = BigInt(0);
        this.ino = BigInt(0);
        this.mode = BigInt(exports.DEFAULT_MODE);
        this.nlink = BigInt(1);
        this.rdev = BigInt(0);
        this.blocks = BigInt(1);
      }
      isBlockDevice() {
        return false;
      }
      isCharacterDevice() {
        return false;
      }
      isDirectory() {
        return (this.mode & BigInt(constants_1.S_IFMT)) === BigInt(constants_1.S_IFDIR);
      }
      isFIFO() {
        return false;
      }
      isFile() {
        return (this.mode & BigInt(constants_1.S_IFMT)) === BigInt(constants_1.S_IFREG);
      }
      isSocket() {
        return false;
      }
      isSymbolicLink() {
        return (this.mode & BigInt(constants_1.S_IFMT)) === BigInt(constants_1.S_IFLNK);
      }
    };
    exports.BigIntStatsEntry = BigIntStatsEntry;
    function makeDefaultStats() {
      return new StatEntry();
    }
    __name(makeDefaultStats, "makeDefaultStats");
    exports.makeDefaultStats = makeDefaultStats;
    function makeEmptyStats() {
      return clearStats(makeDefaultStats());
    }
    __name(makeEmptyStats, "makeEmptyStats");
    exports.makeEmptyStats = makeEmptyStats;
    function clearStats(stats) {
      for (const key in stats) {
        if (Object.prototype.hasOwnProperty.call(stats, key)) {
          const element = stats[key];
          if (typeof element === `number`) {
            stats[key] = 0;
          } else if (typeof element === `bigint`) {
            stats[key] = BigInt(0);
          } else if (nodeUtils.types.isDate(element)) {
            stats[key] = /* @__PURE__ */ new Date(0);
          }
        }
      }
      return stats;
    }
    __name(clearStats, "clearStats");
    exports.clearStats = clearStats;
    function convertToBigIntStats(stats) {
      const bigintStats = new BigIntStatsEntry();
      for (const key in stats) {
        if (Object.prototype.hasOwnProperty.call(stats, key)) {
          const element = stats[key];
          if (typeof element === `number`) {
            bigintStats[key] = BigInt(element);
          } else if (nodeUtils.types.isDate(element)) {
            bigintStats[key] = new Date(element);
          }
        }
      }
      bigintStats.atimeNs = bigintStats.atimeMs * BigInt(1e6);
      bigintStats.mtimeNs = bigintStats.mtimeMs * BigInt(1e6);
      bigintStats.ctimeNs = bigintStats.ctimeMs * BigInt(1e6);
      bigintStats.birthtimeNs = bigintStats.birthtimeMs * BigInt(1e6);
      return bigintStats;
    }
    __name(convertToBigIntStats, "convertToBigIntStats");
    exports.convertToBigIntStats = convertToBigIntStats;
    function areStatsEqual(a, b) {
      if (a.atimeMs !== b.atimeMs)
        return false;
      if (a.birthtimeMs !== b.birthtimeMs)
        return false;
      if (a.blksize !== b.blksize)
        return false;
      if (a.blocks !== b.blocks)
        return false;
      if (a.ctimeMs !== b.ctimeMs)
        return false;
      if (a.dev !== b.dev)
        return false;
      if (a.gid !== b.gid)
        return false;
      if (a.ino !== b.ino)
        return false;
      if (a.isBlockDevice() !== b.isBlockDevice())
        return false;
      if (a.isCharacterDevice() !== b.isCharacterDevice())
        return false;
      if (a.isDirectory() !== b.isDirectory())
        return false;
      if (a.isFIFO() !== b.isFIFO())
        return false;
      if (a.isFile() !== b.isFile())
        return false;
      if (a.isSocket() !== b.isSocket())
        return false;
      if (a.isSymbolicLink() !== b.isSymbolicLink())
        return false;
      if (a.mode !== b.mode)
        return false;
      if (a.mtimeMs !== b.mtimeMs)
        return false;
      if (a.nlink !== b.nlink)
        return false;
      if (a.rdev !== b.rdev)
        return false;
      if (a.size !== b.size)
        return false;
      if (a.uid !== b.uid)
        return false;
      const aN = a;
      const bN = b;
      if (aN.atimeNs !== bN.atimeNs)
        return false;
      if (aN.mtimeNs !== bN.mtimeNs)
        return false;
      if (aN.ctimeNs !== bN.ctimeNs)
        return false;
      if (aN.birthtimeNs !== bN.birthtimeNs)
        return false;
      return true;
    }
    __name(areStatsEqual, "areStatsEqual");
    exports.areStatsEqual = areStatsEqual;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/path.js
var require_path = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFilename = exports.convertPath = exports.ppath = exports.npath = exports.Filename = exports.PortablePath = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var path_1 = tslib_1.__importDefault(__require("path"));
    var PathType;
    (function(PathType2) {
      PathType2[PathType2["File"] = 0] = "File";
      PathType2[PathType2["Portable"] = 1] = "Portable";
      PathType2[PathType2["Native"] = 2] = "Native";
    })(PathType || (PathType = {}));
    exports.PortablePath = {
      root: `/`,
      dot: `.`,
      parent: `..`
    };
    exports.Filename = {
      nodeModules: `node_modules`,
      manifest: `package.json`,
      lockfile: `yarn.lock`,
      virtual: `__virtual__`,
      /**
       * @deprecated
       */
      pnpJs: `.pnp.js`,
      pnpCjs: `.pnp.cjs`,
      rc: `.yarnrc.yml`
    };
    exports.npath = Object.create(path_1.default);
    exports.ppath = Object.create(path_1.default.posix);
    exports.npath.cwd = () => process.cwd();
    exports.ppath.cwd = () => toPortablePath(process.cwd());
    exports.ppath.resolve = (...segments) => {
      if (segments.length > 0 && exports.ppath.isAbsolute(segments[0])) {
        return path_1.default.posix.resolve(...segments);
      } else {
        return path_1.default.posix.resolve(exports.ppath.cwd(), ...segments);
      }
    };
    var contains = /* @__PURE__ */ __name(function(pathUtils, from2, to) {
      from2 = pathUtils.normalize(from2);
      to = pathUtils.normalize(to);
      if (from2 === to)
        return `.`;
      if (!from2.endsWith(pathUtils.sep))
        from2 = from2 + pathUtils.sep;
      if (to.startsWith(from2)) {
        return to.slice(from2.length);
      } else {
        return null;
      }
    }, "contains");
    exports.npath.fromPortablePath = fromPortablePath;
    exports.npath.toPortablePath = toPortablePath;
    exports.npath.contains = (from2, to) => contains(exports.npath, from2, to);
    exports.ppath.contains = (from2, to) => contains(exports.ppath, from2, to);
    var WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
    var UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
    var PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
    var UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
    function fromPortablePath(p) {
      if (process.platform !== `win32`)
        return p;
      let portablePathMatch, uncPortablePathMatch;
      if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
        p = portablePathMatch[1];
      else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
        p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
      else
        return p;
      return p.replace(/\//g, `\\`);
    }
    __name(fromPortablePath, "fromPortablePath");
    function toPortablePath(p) {
      if (process.platform !== `win32`)
        return p;
      p = p.replace(/\\/g, `/`);
      let windowsPathMatch, uncWindowsPathMatch;
      if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
        p = `/${windowsPathMatch[1]}`;
      else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
        p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
      return p;
    }
    __name(toPortablePath, "toPortablePath");
    function convertPath(targetPathUtils, sourcePath) {
      return targetPathUtils === exports.npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
    }
    __name(convertPath, "convertPath");
    exports.convertPath = convertPath;
    function toFilename(filename) {
      if (exports.npath.parse(filename).dir !== `` || exports.ppath.parse(filename).dir !== ``)
        throw new Error(`Invalid filename: "${filename}"`);
      return filename;
    }
    __name(toFilename, "toFilename");
    exports.toFilename = toFilename;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/algorithms/copyPromise.js
var require_copyPromise = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/algorithms/copyPromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.copyPromise = exports.LinkStrategy = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs_1 = tslib_1.__importDefault(__require("fs"));
    var constants2 = tslib_1.__importStar(require_constants());
    var path_1 = require_path();
    var defaultTime = new Date(constants2.SAFE_TIME * 1e3);
    var LinkStrategy;
    (function(LinkStrategy2) {
      LinkStrategy2["Allow"] = "allow";
      LinkStrategy2["ReadOnly"] = "readOnly";
    })(LinkStrategy = exports.LinkStrategy || (exports.LinkStrategy = {}));
    async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
      const normalizedDestination = destinationFs.pathUtils.normalize(destination);
      const normalizedSource = sourceFs.pathUtils.normalize(source);
      const prelayout = [];
      const postlayout = [];
      const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
      await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
      const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
      for (const operation of prelayout)
        await operation();
      await Promise.all(postlayout.map((operation) => {
        return operation();
      }));
    }
    __name(copyPromise, "copyPromise");
    exports.copyPromise = copyPromise;
    async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
      var _a, _b;
      const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
      const sourceStat = await sourceFs.lstatPromise(source);
      const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
      let updated;
      switch (true) {
        case sourceStat.isDirectory():
          {
            updated = await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
          }
          break;
        case sourceStat.isFile():
          {
            updated = await copyFile2(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
          }
          break;
        case sourceStat.isSymbolicLink():
          {
            updated = await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
          }
          break;
        default:
          {
            throw new Error(`Unsupported file type (${sourceStat.mode})`);
          }
          break;
      }
      if (updated || ((_a = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.mtime) === null || _a === void 0 ? void 0 : _a.getTime()) !== mtime.getTime() || ((_b = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.atime) === null || _b === void 0 ? void 0 : _b.getTime()) !== atime.getTime()) {
        postlayout.push(() => updateTime(destination, atime, mtime));
        updated = true;
      }
      if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
        postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
        updated = true;
      }
      return updated;
    }
    __name(copyImpl, "copyImpl");
    async function maybeLStat(baseFs, p) {
      try {
        return await baseFs.lstatPromise(p);
      } catch (e) {
        return null;
      }
    }
    __name(maybeLStat, "maybeLStat");
    async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
      if (destinationStat !== null && !destinationStat.isDirectory()) {
        if (opts.overwrite) {
          prelayout.push(async () => destinationFs.removePromise(destination));
          destinationStat = null;
        } else {
          return false;
        }
      }
      let updated = false;
      if (destinationStat === null) {
        prelayout.push(async () => {
          try {
            await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
          } catch (err) {
            if (err.code !== `EEXIST`) {
              throw err;
            }
          }
        });
        updated = true;
      }
      const entries = await sourceFs.readdirPromise(source);
      const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
      if (opts.stableSort) {
        for (const entry of entries.sort()) {
          if (await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
            updated = true;
          }
        }
      } else {
        const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
          await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
        }));
        if (entriesUpdateStatus.some((status) => status)) {
          updated = true;
        }
      }
      return updated;
    }
    __name(copyFolder, "copyFolder");
    var isCloneSupportedCache = /* @__PURE__ */ new WeakMap();
    function makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
      return async () => {
        await opFs.linkPromise(source, destination);
        if (linkStrategy === LinkStrategy.ReadOnly) {
          sourceStat.mode &= ~146;
          await opFs.chmodPromise(destination, sourceStat.mode);
        }
      };
    }
    __name(makeLinkOperation, "makeLinkOperation");
    function makeCloneLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
      const isCloneSupported = isCloneSupportedCache.get(opFs);
      if (typeof isCloneSupported === `undefined`) {
        return async () => {
          try {
            await opFs.copyFilePromise(source, destination, fs_1.default.constants.COPYFILE_FICLONE_FORCE);
            isCloneSupportedCache.set(opFs, true);
          } catch (err) {
            if (err.code === `ENOSYS` || err.code === `ENOTSUP`) {
              isCloneSupportedCache.set(opFs, false);
              await makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy)();
            } else {
              throw err;
            }
          }
        };
      } else {
        if (isCloneSupported) {
          return async () => opFs.copyFilePromise(source, destination, fs_1.default.constants.COPYFILE_FICLONE_FORCE);
        } else {
          return makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy);
        }
      }
    }
    __name(makeCloneLinkOperation, "makeCloneLinkOperation");
    async function copyFile2(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
      var _a;
      if (destinationStat !== null) {
        if (opts.overwrite) {
          prelayout.push(async () => destinationFs.removePromise(destination));
          destinationStat = null;
        } else {
          return false;
        }
      }
      const linkStrategy = (_a = opts.linkStrategy) !== null && _a !== void 0 ? _a : null;
      const op = destinationFs === sourceFs ? linkStrategy !== null ? makeCloneLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.copyFilePromise(source, destination, fs_1.default.constants.COPYFILE_FICLONE) : linkStrategy !== null ? makeLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
      prelayout.push(async () => op());
      return true;
    }
    __name(copyFile2, "copyFile");
    async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
      if (destinationStat !== null) {
        if (opts.overwrite) {
          prelayout.push(async () => destinationFs.removePromise(destination));
          destinationStat = null;
        } else {
          return false;
        }
      }
      prelayout.push(async () => {
        await destinationFs.symlinkPromise((0, path_1.convertPath)(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
      });
      return true;
    }
    __name(copySymlink, "copySymlink");
  }
});

// ../node_modules/@yarnpkg/fslib/lib/errors.js
var require_errors = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibzipError = exports.ERR_DIR_CLOSED = exports.EOPNOTSUPP = exports.ENOTEMPTY = exports.EROFS = exports.EEXIST = exports.EISDIR = exports.ENOTDIR = exports.ENOENT = exports.EBADF = exports.EINVAL = exports.ENOSYS = exports.EBUSY = void 0;
    function makeError(code, message) {
      return Object.assign(new Error(`${code}: ${message}`), { code });
    }
    __name(makeError, "makeError");
    function EBUSY(message) {
      return makeError(`EBUSY`, message);
    }
    __name(EBUSY, "EBUSY");
    exports.EBUSY = EBUSY;
    function ENOSYS(message, reason) {
      return makeError(`ENOSYS`, `${message}, ${reason}`);
    }
    __name(ENOSYS, "ENOSYS");
    exports.ENOSYS = ENOSYS;
    function EINVAL(reason) {
      return makeError(`EINVAL`, `invalid argument, ${reason}`);
    }
    __name(EINVAL, "EINVAL");
    exports.EINVAL = EINVAL;
    function EBADF(reason) {
      return makeError(`EBADF`, `bad file descriptor, ${reason}`);
    }
    __name(EBADF, "EBADF");
    exports.EBADF = EBADF;
    function ENOENT(reason) {
      return makeError(`ENOENT`, `no such file or directory, ${reason}`);
    }
    __name(ENOENT, "ENOENT");
    exports.ENOENT = ENOENT;
    function ENOTDIR(reason) {
      return makeError(`ENOTDIR`, `not a directory, ${reason}`);
    }
    __name(ENOTDIR, "ENOTDIR");
    exports.ENOTDIR = ENOTDIR;
    function EISDIR(reason) {
      return makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
    }
    __name(EISDIR, "EISDIR");
    exports.EISDIR = EISDIR;
    function EEXIST(reason) {
      return makeError(`EEXIST`, `file already exists, ${reason}`);
    }
    __name(EEXIST, "EEXIST");
    exports.EEXIST = EEXIST;
    function EROFS(reason) {
      return makeError(`EROFS`, `read-only filesystem, ${reason}`);
    }
    __name(EROFS, "EROFS");
    exports.EROFS = EROFS;
    function ENOTEMPTY(reason) {
      return makeError(`ENOTEMPTY`, `directory not empty, ${reason}`);
    }
    __name(ENOTEMPTY, "ENOTEMPTY");
    exports.ENOTEMPTY = ENOTEMPTY;
    function EOPNOTSUPP(reason) {
      return makeError(`EOPNOTSUPP`, `operation not supported, ${reason}`);
    }
    __name(EOPNOTSUPP, "EOPNOTSUPP");
    exports.EOPNOTSUPP = EOPNOTSUPP;
    function ERR_DIR_CLOSED() {
      return makeError(`ERR_DIR_CLOSED`, `Directory handle was closed`);
    }
    __name(ERR_DIR_CLOSED, "ERR_DIR_CLOSED");
    exports.ERR_DIR_CLOSED = ERR_DIR_CLOSED;
    var LibzipError = class extends Error {
      static {
        __name(this, "LibzipError");
      }
      constructor(message, code) {
        super(message);
        this.name = `Libzip Error`;
        this.code = code;
      }
    };
    exports.LibzipError = LibzipError;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/algorithms/opendir.js
var require_opendir = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/algorithms/opendir.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opendir = exports.CustomDir = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors = tslib_1.__importStar(require_errors());
    var CustomDir = class {
      static {
        __name(this, "CustomDir");
      }
      constructor(path, nextDirent, opts = {}) {
        this.path = path;
        this.nextDirent = nextDirent;
        this.opts = opts;
        this.closed = false;
      }
      throwIfClosed() {
        if (this.closed) {
          throw errors.ERR_DIR_CLOSED();
        }
      }
      async *[Symbol.asyncIterator]() {
        try {
          let dirent;
          while ((dirent = await this.read()) !== null) {
            yield dirent;
          }
        } finally {
          await this.close();
        }
      }
      read(cb) {
        const dirent = this.readSync();
        if (typeof cb !== `undefined`)
          return cb(null, dirent);
        return Promise.resolve(dirent);
      }
      readSync() {
        this.throwIfClosed();
        return this.nextDirent();
      }
      close(cb) {
        this.closeSync();
        if (typeof cb !== `undefined`)
          return cb(null);
        return Promise.resolve();
      }
      closeSync() {
        var _a, _b;
        this.throwIfClosed();
        (_b = (_a = this.opts).onClose) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.closed = true;
      }
    };
    exports.CustomDir = CustomDir;
    function opendir(fakeFs, path, entries, opts) {
      const nextDirent = /* @__PURE__ */ __name(() => {
        const filename = entries.shift();
        if (typeof filename === `undefined`)
          return null;
        return Object.assign(fakeFs.statSync(fakeFs.pathUtils.join(path, filename)), {
          name: filename
        });
      }, "nextDirent");
      return new CustomDir(path, nextDirent, opts);
    }
    __name(opendir, "opendir");
    exports.opendir = opendir;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/FakeFS.js
var require_FakeFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/FakeFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeLineEndings = exports.BasePortableFakeFS = exports.FakeFS = void 0;
    var os_1 = __require("os");
    var copyPromise_1 = require_copyPromise();
    var path_1 = require_path();
    var FakeFS = class {
      static {
        __name(this, "FakeFS");
      }
      constructor(pathUtils) {
        this.pathUtils = pathUtils;
      }
      async *genTraversePromise(init, { stableSort = false } = {}) {
        const stack = [init];
        while (stack.length > 0) {
          const p = stack.shift();
          const entry = await this.lstatPromise(p);
          if (entry.isDirectory()) {
            const entries = await this.readdirPromise(p);
            if (stableSort) {
              for (const entry2 of entries.sort()) {
                stack.push(this.pathUtils.join(p, entry2));
              }
            } else {
              throw new Error(`Not supported`);
            }
          } else {
            yield p;
          }
        }
      }
      async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
        let stat;
        try {
          stat = await this.lstatPromise(p);
        } catch (error) {
          if (error.code === `ENOENT`) {
            return;
          } else {
            throw error;
          }
        }
        if (stat.isDirectory()) {
          if (recursive) {
            const entries = await this.readdirPromise(p);
            await Promise.all(entries.map((entry) => {
              return this.removePromise(this.pathUtils.resolve(p, entry));
            }));
          }
          for (let t2 = 0; t2 <= maxRetries; t2++) {
            try {
              await this.rmdirPromise(p);
              break;
            } catch (error) {
              if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
                throw error;
              } else if (t2 < maxRetries) {
                await new Promise((resolve8) => setTimeout(resolve8, t2 * 100));
              }
            }
          }
        } else {
          await this.unlinkPromise(p);
        }
      }
      removeSync(p, { recursive = true } = {}) {
        let stat;
        try {
          stat = this.lstatSync(p);
        } catch (error) {
          if (error.code === `ENOENT`) {
            return;
          } else {
            throw error;
          }
        }
        if (stat.isDirectory()) {
          if (recursive)
            for (const entry of this.readdirSync(p))
              this.removeSync(this.pathUtils.resolve(p, entry));
          this.rmdirSync(p);
        } else {
          this.unlinkSync(p);
        }
      }
      async mkdirpPromise(p, { chmod, utimes } = {}) {
        p = this.resolve(p);
        if (p === this.pathUtils.dirname(p))
          return void 0;
        const parts = p.split(this.pathUtils.sep);
        let createdDirectory;
        for (let u = 2; u <= parts.length; ++u) {
          const subPath = parts.slice(0, u).join(this.pathUtils.sep);
          if (!this.existsSync(subPath)) {
            try {
              await this.mkdirPromise(subPath);
            } catch (error) {
              if (error.code === `EEXIST`) {
                continue;
              } else {
                throw error;
              }
            }
            createdDirectory !== null && createdDirectory !== void 0 ? createdDirectory : createdDirectory = subPath;
            if (chmod != null)
              await this.chmodPromise(subPath, chmod);
            if (utimes != null) {
              await this.utimesPromise(subPath, utimes[0], utimes[1]);
            } else {
              const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
              await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
            }
          }
        }
        return createdDirectory;
      }
      mkdirpSync(p, { chmod, utimes } = {}) {
        p = this.resolve(p);
        if (p === this.pathUtils.dirname(p))
          return void 0;
        const parts = p.split(this.pathUtils.sep);
        let createdDirectory;
        for (let u = 2; u <= parts.length; ++u) {
          const subPath = parts.slice(0, u).join(this.pathUtils.sep);
          if (!this.existsSync(subPath)) {
            try {
              this.mkdirSync(subPath);
            } catch (error) {
              if (error.code === `EEXIST`) {
                continue;
              } else {
                throw error;
              }
            }
            createdDirectory !== null && createdDirectory !== void 0 ? createdDirectory : createdDirectory = subPath;
            if (chmod != null)
              this.chmodSync(subPath, chmod);
            if (utimes != null) {
              this.utimesSync(subPath, utimes[0], utimes[1]);
            } else {
              const parentStat = this.statSync(this.pathUtils.dirname(subPath));
              this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
            }
          }
        }
        return createdDirectory;
      }
      async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
        return await (0, copyPromise_1.copyPromise)(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
      }
      copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
        const stat = baseFs.lstatSync(source);
        const exists = this.existsSync(destination);
        if (stat.isDirectory()) {
          this.mkdirpSync(destination);
          const directoryListing = baseFs.readdirSync(source);
          for (const entry of directoryListing) {
            this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
          }
        } else if (stat.isFile()) {
          if (!exists || overwrite) {
            if (exists)
              this.removeSync(destination);
            const content = baseFs.readFileSync(source);
            this.writeFileSync(destination, content);
          }
        } else if (stat.isSymbolicLink()) {
          if (!exists || overwrite) {
            if (exists)
              this.removeSync(destination);
            const target = baseFs.readlinkSync(source);
            this.symlinkSync((0, path_1.convertPath)(this.pathUtils, target), destination);
          }
        } else {
          throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
        }
        const mode = stat.mode & 511;
        this.chmodSync(destination, mode);
      }
      async changeFilePromise(p, content, opts = {}) {
        if (Buffer.isBuffer(content)) {
          return this.changeFileBufferPromise(p, content, opts);
        } else {
          return this.changeFileTextPromise(p, content, opts);
        }
      }
      async changeFileBufferPromise(p, content, { mode } = {}) {
        let current = Buffer.alloc(0);
        try {
          current = await this.readFilePromise(p);
        } catch (error) {
        }
        if (Buffer.compare(current, content) === 0)
          return;
        await this.writeFilePromise(p, content, { mode });
      }
      async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
        let current = ``;
        try {
          current = await this.readFilePromise(p, `utf8`);
        } catch (error) {
        }
        const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
        if (current === normalizedContent)
          return;
        await this.writeFilePromise(p, normalizedContent, { mode });
      }
      changeFileSync(p, content, opts = {}) {
        if (Buffer.isBuffer(content)) {
          return this.changeFileBufferSync(p, content, opts);
        } else {
          return this.changeFileTextSync(p, content, opts);
        }
      }
      changeFileBufferSync(p, content, { mode } = {}) {
        let current = Buffer.alloc(0);
        try {
          current = this.readFileSync(p);
        } catch (error) {
        }
        if (Buffer.compare(current, content) === 0)
          return;
        this.writeFileSync(p, content, { mode });
      }
      changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
        let current = ``;
        try {
          current = this.readFileSync(p, `utf8`);
        } catch (error) {
        }
        const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
        if (current === normalizedContent)
          return;
        this.writeFileSync(p, normalizedContent, { mode });
      }
      async movePromise(fromP, toP) {
        try {
          await this.renamePromise(fromP, toP);
        } catch (error) {
          if (error.code === `EXDEV`) {
            await this.copyPromise(toP, fromP);
            await this.removePromise(fromP);
          } else {
            throw error;
          }
        }
      }
      moveSync(fromP, toP) {
        try {
          this.renameSync(fromP, toP);
        } catch (error) {
          if (error.code === `EXDEV`) {
            this.copySync(toP, fromP);
            this.removeSync(fromP);
          } else {
            throw error;
          }
        }
      }
      async lockPromise(affectedPath, callback) {
        const lockPath = `${affectedPath}.flock`;
        const interval = 1e3 / 60;
        const startTime = Date.now();
        let fd = null;
        const isAlive = /* @__PURE__ */ __name(async () => {
          let pid;
          try {
            [pid] = await this.readJsonPromise(lockPath);
          } catch (error) {
            return Date.now() - startTime < 500;
          }
          try {
            process.kill(pid, 0);
            return true;
          } catch (error) {
            return false;
          }
        }, "isAlive");
        while (fd === null) {
          try {
            fd = await this.openPromise(lockPath, `wx`);
          } catch (error) {
            if (error.code === `EEXIST`) {
              if (!await isAlive()) {
                try {
                  await this.unlinkPromise(lockPath);
                  continue;
                } catch (error2) {
                }
              }
              if (Date.now() - startTime < 60 * 1e3) {
                await new Promise((resolve8) => setTimeout(resolve8, interval));
              } else {
                throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
              }
            } else {
              throw error;
            }
          }
        }
        await this.writePromise(fd, JSON.stringify([process.pid]));
        try {
          return await callback();
        } finally {
          try {
            await this.closePromise(fd);
            await this.unlinkPromise(lockPath);
          } catch (error) {
          }
        }
      }
      async readJsonPromise(p) {
        const content = await this.readFilePromise(p, `utf8`);
        try {
          return JSON.parse(content);
        } catch (error) {
          error.message += ` (in ${p})`;
          throw error;
        }
      }
      readJsonSync(p) {
        const content = this.readFileSync(p, `utf8`);
        try {
          return JSON.parse(content);
        } catch (error) {
          error.message += ` (in ${p})`;
          throw error;
        }
      }
      async writeJsonPromise(p, data) {
        return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}
`);
      }
      writeJsonSync(p, data) {
        return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}
`);
      }
      async preserveTimePromise(p, cb) {
        const stat = await this.lstatPromise(p);
        const result = await cb();
        if (typeof result !== `undefined`)
          p = result;
        if (this.lutimesPromise) {
          await this.lutimesPromise(p, stat.atime, stat.mtime);
        } else if (!stat.isSymbolicLink()) {
          await this.utimesPromise(p, stat.atime, stat.mtime);
        }
      }
      async preserveTimeSync(p, cb) {
        const stat = this.lstatSync(p);
        const result = cb();
        if (typeof result !== `undefined`)
          p = result;
        if (this.lutimesSync) {
          this.lutimesSync(p, stat.atime, stat.mtime);
        } else if (!stat.isSymbolicLink()) {
          this.utimesSync(p, stat.atime, stat.mtime);
        }
      }
    };
    exports.FakeFS = FakeFS;
    var BasePortableFakeFS = class extends FakeFS {
      static {
        __name(this, "BasePortableFakeFS");
      }
      constructor() {
        super(path_1.ppath);
      }
    };
    exports.BasePortableFakeFS = BasePortableFakeFS;
    function getEndOfLine(content) {
      const matches = content.match(/\r?\n/g);
      if (matches === null)
        return os_1.EOL;
      const crlf = matches.filter((nl) => nl === `\r
`).length;
      const lf = matches.length - crlf;
      return crlf > lf ? `\r
` : `
`;
    }
    __name(getEndOfLine, "getEndOfLine");
    function normalizeLineEndings(originalContent, newContent) {
      return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
    }
    __name(normalizeLineEndings, "normalizeLineEndings");
    exports.normalizeLineEndings = normalizeLineEndings;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/NodeFS.js
var require_NodeFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/NodeFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeFS = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs_1 = tslib_1.__importDefault(__require("fs"));
    var FakeFS_1 = require_FakeFS();
    var errors_1 = require_errors();
    var path_1 = require_path();
    var NodeFS = class extends FakeFS_1.BasePortableFakeFS {
      static {
        __name(this, "NodeFS");
      }
      constructor(realFs = fs_1.default) {
        super();
        this.realFs = realFs;
        if (typeof this.realFs.lutimes !== `undefined`) {
          this.lutimesPromise = this.lutimesPromiseImpl;
          this.lutimesSync = this.lutimesSyncImpl;
        }
      }
      getExtractHint() {
        return false;
      }
      getRealPath() {
        return path_1.PortablePath.root;
      }
      resolve(p) {
        return path_1.ppath.resolve(p);
      }
      async openPromise(p, flags, mode) {
        return await new Promise((resolve8, reject) => {
          this.realFs.open(path_1.npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve8, reject));
        });
      }
      openSync(p, flags, mode) {
        return this.realFs.openSync(path_1.npath.fromPortablePath(p), flags, mode);
      }
      async opendirPromise(p, opts) {
        return await new Promise((resolve8, reject) => {
          if (typeof opts !== `undefined`) {
            this.realFs.opendir(path_1.npath.fromPortablePath(p), opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.opendir(path_1.npath.fromPortablePath(p), this.makeCallback(resolve8, reject));
          }
        }).then((dir) => {
          return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
        });
      }
      opendirSync(p, opts) {
        const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(path_1.npath.fromPortablePath(p), opts) : this.realFs.opendirSync(path_1.npath.fromPortablePath(p));
        return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
      }
      async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
        return await new Promise((resolve8, reject) => {
          this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
            if (error) {
              reject(error);
            } else {
              resolve8(bytesRead);
            }
          });
        });
      }
      readSync(fd, buffer, offset, length, position) {
        return this.realFs.readSync(fd, buffer, offset, length, position);
      }
      async writePromise(fd, buffer, offset, length, position) {
        return await new Promise((resolve8, reject) => {
          if (typeof buffer === `string`) {
            return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve8, reject));
          } else {
            return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve8, reject));
          }
        });
      }
      writeSync(fd, buffer, offset, length, position) {
        if (typeof buffer === `string`) {
          return this.realFs.writeSync(fd, buffer, offset);
        } else {
          return this.realFs.writeSync(fd, buffer, offset, length, position);
        }
      }
      async closePromise(fd) {
        await new Promise((resolve8, reject) => {
          this.realFs.close(fd, this.makeCallback(resolve8, reject));
        });
      }
      closeSync(fd) {
        this.realFs.closeSync(fd);
      }
      createReadStream(p, opts) {
        const realPath = p !== null ? path_1.npath.fromPortablePath(p) : p;
        return this.realFs.createReadStream(realPath, opts);
      }
      createWriteStream(p, opts) {
        const realPath = p !== null ? path_1.npath.fromPortablePath(p) : p;
        return this.realFs.createWriteStream(realPath, opts);
      }
      async realpathPromise(p) {
        return await new Promise((resolve8, reject) => {
          this.realFs.realpath(path_1.npath.fromPortablePath(p), {}, this.makeCallback(resolve8, reject));
        }).then((path) => {
          return path_1.npath.toPortablePath(path);
        });
      }
      realpathSync(p) {
        return path_1.npath.toPortablePath(this.realFs.realpathSync(path_1.npath.fromPortablePath(p), {}));
      }
      async existsPromise(p) {
        return await new Promise((resolve8) => {
          this.realFs.exists(path_1.npath.fromPortablePath(p), resolve8);
        });
      }
      accessSync(p, mode) {
        return this.realFs.accessSync(path_1.npath.fromPortablePath(p), mode);
      }
      async accessPromise(p, mode) {
        return await new Promise((resolve8, reject) => {
          this.realFs.access(path_1.npath.fromPortablePath(p), mode, this.makeCallback(resolve8, reject));
        });
      }
      existsSync(p) {
        return this.realFs.existsSync(path_1.npath.fromPortablePath(p));
      }
      async statPromise(p, opts) {
        return await new Promise((resolve8, reject) => {
          if (opts) {
            this.realFs.stat(path_1.npath.fromPortablePath(p), opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.stat(path_1.npath.fromPortablePath(p), this.makeCallback(resolve8, reject));
          }
        });
      }
      statSync(p, opts) {
        if (opts) {
          return this.realFs.statSync(path_1.npath.fromPortablePath(p), opts);
        } else {
          return this.realFs.statSync(path_1.npath.fromPortablePath(p));
        }
      }
      async fstatPromise(fd, opts) {
        return await new Promise((resolve8, reject) => {
          if (opts) {
            this.realFs.fstat(fd, opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.fstat(fd, this.makeCallback(resolve8, reject));
          }
        });
      }
      fstatSync(fd, opts) {
        if (opts) {
          return this.realFs.fstatSync(fd, opts);
        } else {
          return this.realFs.fstatSync(fd);
        }
      }
      async lstatPromise(p, opts) {
        return await new Promise((resolve8, reject) => {
          if (opts) {
            this.realFs.lstat(path_1.npath.fromPortablePath(p), opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.lstat(path_1.npath.fromPortablePath(p), this.makeCallback(resolve8, reject));
          }
        });
      }
      lstatSync(p, opts) {
        if (opts) {
          return this.realFs.lstatSync(path_1.npath.fromPortablePath(p), opts);
        } else {
          return this.realFs.lstatSync(path_1.npath.fromPortablePath(p));
        }
      }
      async fchmodPromise(fd, mask) {
        return await new Promise((resolve8, reject) => {
          this.realFs.fchmod(fd, mask, this.makeCallback(resolve8, reject));
        });
      }
      fchmodSync(fd, mask) {
        return this.realFs.fchmodSync(fd, mask);
      }
      async chmodPromise(p, mask) {
        return await new Promise((resolve8, reject) => {
          this.realFs.chmod(path_1.npath.fromPortablePath(p), mask, this.makeCallback(resolve8, reject));
        });
      }
      chmodSync(p, mask) {
        return this.realFs.chmodSync(path_1.npath.fromPortablePath(p), mask);
      }
      async fchownPromise(fd, uid, gid) {
        return await new Promise((resolve8, reject) => {
          this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve8, reject));
        });
      }
      fchownSync(fd, uid, gid) {
        return this.realFs.fchownSync(fd, uid, gid);
      }
      async chownPromise(p, uid, gid) {
        return await new Promise((resolve8, reject) => {
          this.realFs.chown(path_1.npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve8, reject));
        });
      }
      chownSync(p, uid, gid) {
        return this.realFs.chownSync(path_1.npath.fromPortablePath(p), uid, gid);
      }
      async renamePromise(oldP, newP) {
        return await new Promise((resolve8, reject) => {
          this.realFs.rename(path_1.npath.fromPortablePath(oldP), path_1.npath.fromPortablePath(newP), this.makeCallback(resolve8, reject));
        });
      }
      renameSync(oldP, newP) {
        return this.realFs.renameSync(path_1.npath.fromPortablePath(oldP), path_1.npath.fromPortablePath(newP));
      }
      async copyFilePromise(sourceP, destP, flags = 0) {
        return await new Promise((resolve8, reject) => {
          this.realFs.copyFile(path_1.npath.fromPortablePath(sourceP), path_1.npath.fromPortablePath(destP), flags, this.makeCallback(resolve8, reject));
        });
      }
      copyFileSync(sourceP, destP, flags = 0) {
        return this.realFs.copyFileSync(path_1.npath.fromPortablePath(sourceP), path_1.npath.fromPortablePath(destP), flags);
      }
      async appendFilePromise(p, content, opts) {
        return await new Promise((resolve8, reject) => {
          const fsNativePath = typeof p === `string` ? path_1.npath.fromPortablePath(p) : p;
          if (opts) {
            this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve8, reject));
          }
        });
      }
      appendFileSync(p, content, opts) {
        const fsNativePath = typeof p === `string` ? path_1.npath.fromPortablePath(p) : p;
        if (opts) {
          this.realFs.appendFileSync(fsNativePath, content, opts);
        } else {
          this.realFs.appendFileSync(fsNativePath, content);
        }
      }
      async writeFilePromise(p, content, opts) {
        return await new Promise((resolve8, reject) => {
          const fsNativePath = typeof p === `string` ? path_1.npath.fromPortablePath(p) : p;
          if (opts) {
            this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve8, reject));
          }
        });
      }
      writeFileSync(p, content, opts) {
        const fsNativePath = typeof p === `string` ? path_1.npath.fromPortablePath(p) : p;
        if (opts) {
          this.realFs.writeFileSync(fsNativePath, content, opts);
        } else {
          this.realFs.writeFileSync(fsNativePath, content);
        }
      }
      async unlinkPromise(p) {
        return await new Promise((resolve8, reject) => {
          this.realFs.unlink(path_1.npath.fromPortablePath(p), this.makeCallback(resolve8, reject));
        });
      }
      unlinkSync(p) {
        return this.realFs.unlinkSync(path_1.npath.fromPortablePath(p));
      }
      async utimesPromise(p, atime, mtime) {
        return await new Promise((resolve8, reject) => {
          this.realFs.utimes(path_1.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve8, reject));
        });
      }
      utimesSync(p, atime, mtime) {
        this.realFs.utimesSync(path_1.npath.fromPortablePath(p), atime, mtime);
      }
      async lutimesPromiseImpl(p, atime, mtime) {
        const lutimes = this.realFs.lutimes;
        if (typeof lutimes === `undefined`)
          throw (0, errors_1.ENOSYS)(`unavailable Node binding`, `lutimes '${p}'`);
        return await new Promise((resolve8, reject) => {
          lutimes.call(this.realFs, path_1.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve8, reject));
        });
      }
      lutimesSyncImpl(p, atime, mtime) {
        const lutimesSync = this.realFs.lutimesSync;
        if (typeof lutimesSync === `undefined`)
          throw (0, errors_1.ENOSYS)(`unavailable Node binding`, `lutimes '${p}'`);
        lutimesSync.call(this.realFs, path_1.npath.fromPortablePath(p), atime, mtime);
      }
      async mkdirPromise(p, opts) {
        return await new Promise((resolve8, reject) => {
          this.realFs.mkdir(path_1.npath.fromPortablePath(p), opts, this.makeCallback(resolve8, reject));
        });
      }
      mkdirSync(p, opts) {
        return this.realFs.mkdirSync(path_1.npath.fromPortablePath(p), opts);
      }
      async rmdirPromise(p, opts) {
        return await new Promise((resolve8, reject) => {
          if (opts) {
            this.realFs.rmdir(path_1.npath.fromPortablePath(p), opts, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.rmdir(path_1.npath.fromPortablePath(p), this.makeCallback(resolve8, reject));
          }
        });
      }
      rmdirSync(p, opts) {
        return this.realFs.rmdirSync(path_1.npath.fromPortablePath(p), opts);
      }
      async linkPromise(existingP, newP) {
        return await new Promise((resolve8, reject) => {
          this.realFs.link(path_1.npath.fromPortablePath(existingP), path_1.npath.fromPortablePath(newP), this.makeCallback(resolve8, reject));
        });
      }
      linkSync(existingP, newP) {
        return this.realFs.linkSync(path_1.npath.fromPortablePath(existingP), path_1.npath.fromPortablePath(newP));
      }
      async symlinkPromise(target, p, type) {
        return await new Promise((resolve8, reject) => {
          this.realFs.symlink(path_1.npath.fromPortablePath(target.replace(/\/+$/, ``)), path_1.npath.fromPortablePath(p), type, this.makeCallback(resolve8, reject));
        });
      }
      symlinkSync(target, p, type) {
        return this.realFs.symlinkSync(path_1.npath.fromPortablePath(target.replace(/\/+$/, ``)), path_1.npath.fromPortablePath(p), type);
      }
      async readFilePromise(p, encoding) {
        return await new Promise((resolve8, reject) => {
          const fsNativePath = typeof p === `string` ? path_1.npath.fromPortablePath(p) : p;
          this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve8, reject));
        });
      }
      readFileSync(p, encoding) {
        const fsNativePath = typeof p === `string` ? path_1.npath.fromPortablePath(p) : p;
        return this.realFs.readFileSync(fsNativePath, encoding);
      }
      async readdirPromise(p, opts) {
        return await new Promise((resolve8, reject) => {
          if (opts === null || opts === void 0 ? void 0 : opts.withFileTypes) {
            this.realFs.readdir(path_1.npath.fromPortablePath(p), { withFileTypes: true }, this.makeCallback(resolve8, reject));
          } else {
            this.realFs.readdir(path_1.npath.fromPortablePath(p), this.makeCallback((value) => resolve8(value), reject));
          }
        });
      }
      readdirSync(p, opts) {
        if (opts === null || opts === void 0 ? void 0 : opts.withFileTypes) {
          return this.realFs.readdirSync(path_1.npath.fromPortablePath(p), { withFileTypes: true });
        } else {
          return this.realFs.readdirSync(path_1.npath.fromPortablePath(p));
        }
      }
      async readlinkPromise(p) {
        return await new Promise((resolve8, reject) => {
          this.realFs.readlink(path_1.npath.fromPortablePath(p), this.makeCallback(resolve8, reject));
        }).then((path) => {
          return path_1.npath.toPortablePath(path);
        });
      }
      readlinkSync(p) {
        return path_1.npath.toPortablePath(this.realFs.readlinkSync(path_1.npath.fromPortablePath(p)));
      }
      async truncatePromise(p, len) {
        return await new Promise((resolve8, reject) => {
          this.realFs.truncate(path_1.npath.fromPortablePath(p), len, this.makeCallback(resolve8, reject));
        });
      }
      truncateSync(p, len) {
        return this.realFs.truncateSync(path_1.npath.fromPortablePath(p), len);
      }
      async ftruncatePromise(fd, len) {
        return await new Promise((resolve8, reject) => {
          this.realFs.ftruncate(fd, len, this.makeCallback(resolve8, reject));
        });
      }
      ftruncateSync(fd, len) {
        return this.realFs.ftruncateSync(fd, len);
      }
      watch(p, a, b) {
        return this.realFs.watch(
          path_1.npath.fromPortablePath(p),
          // @ts-expect-error
          a,
          b
        );
      }
      watchFile(p, a, b) {
        return this.realFs.watchFile(
          path_1.npath.fromPortablePath(p),
          // @ts-expect-error
          a,
          b
        );
      }
      unwatchFile(p, cb) {
        return this.realFs.unwatchFile(path_1.npath.fromPortablePath(p), cb);
      }
      makeCallback(resolve8, reject) {
        return (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve8(result);
          }
        };
      }
    };
    exports.NodeFS = NodeFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/algorithms/watchFile/CustomStatWatcher.js
var require_CustomStatWatcher = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/algorithms/watchFile/CustomStatWatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomStatWatcher = exports.assertStatus = exports.Status = exports.Event = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = __require("events");
    var statUtils = tslib_1.__importStar(require_statUtils());
    var Event;
    (function(Event2) {
      Event2["Change"] = "change";
      Event2["Stop"] = "stop";
    })(Event = exports.Event || (exports.Event = {}));
    var Status;
    (function(Status2) {
      Status2["Ready"] = "ready";
      Status2["Running"] = "running";
      Status2["Stopped"] = "stopped";
    })(Status = exports.Status || (exports.Status = {}));
    function assertStatus(current, expected) {
      if (current !== expected) {
        throw new Error(`Invalid StatWatcher status: expected '${expected}', got '${current}'`);
      }
    }
    __name(assertStatus, "assertStatus");
    exports.assertStatus = assertStatus;
    var CustomStatWatcher = class _CustomStatWatcher extends events_1.EventEmitter {
      static {
        __name(this, "CustomStatWatcher");
      }
      static create(fakeFs, path, opts) {
        const statWatcher = new _CustomStatWatcher(fakeFs, path, opts);
        statWatcher.start();
        return statWatcher;
      }
      constructor(fakeFs, path, { bigint = false } = {}) {
        super();
        this.status = Status.Ready;
        this.changeListeners = /* @__PURE__ */ new Map();
        this.startTimeout = null;
        this.fakeFs = fakeFs;
        this.path = path;
        this.bigint = bigint;
        this.lastStats = this.stat();
      }
      start() {
        assertStatus(this.status, Status.Ready);
        this.status = Status.Running;
        this.startTimeout = setTimeout(() => {
          this.startTimeout = null;
          if (!this.fakeFs.existsSync(this.path)) {
            this.emit(Event.Change, this.lastStats, this.lastStats);
          }
        }, 3);
      }
      stop() {
        assertStatus(this.status, Status.Running);
        this.status = Status.Stopped;
        if (this.startTimeout !== null) {
          clearTimeout(this.startTimeout);
          this.startTimeout = null;
        }
        this.emit(Event.Stop);
      }
      stat() {
        try {
          return this.fakeFs.statSync(this.path, { bigint: this.bigint });
        } catch (error) {
          const statInstance = this.bigint ? new statUtils.BigIntStatsEntry() : new statUtils.StatEntry();
          return statUtils.clearStats(statInstance);
        }
      }
      /**
       * Creates an interval whose callback compares the current stats with the previous stats and notifies all listeners in case of changes.
       *
       * @param opts.persistent Decides whether the interval should be immediately unref-ed.
       */
      makeInterval(opts) {
        const interval = setInterval(() => {
          const currentStats = this.stat();
          const previousStats = this.lastStats;
          if (statUtils.areStatsEqual(currentStats, previousStats))
            return;
          this.lastStats = currentStats;
          this.emit(Event.Change, currentStats, previousStats);
        }, opts.interval);
        return opts.persistent ? interval : interval.unref();
      }
      /**
       * Registers a listener and assigns it an interval.
       */
      registerChangeListener(listener, opts) {
        this.addListener(Event.Change, listener);
        this.changeListeners.set(listener, this.makeInterval(opts));
      }
      /**
       * Unregisters the listener and clears the assigned interval.
       */
      unregisterChangeListener(listener) {
        this.removeListener(Event.Change, listener);
        const interval = this.changeListeners.get(listener);
        if (typeof interval !== `undefined`)
          clearInterval(interval);
        this.changeListeners.delete(listener);
      }
      /**
       * Unregisters all listeners and clears all assigned intervals.
       */
      unregisterAllChangeListeners() {
        for (const listener of this.changeListeners.keys()) {
          this.unregisterChangeListener(listener);
        }
      }
      hasChangeListeners() {
        return this.changeListeners.size > 0;
      }
      /**
       * Refs all stored intervals.
       */
      ref() {
        for (const interval of this.changeListeners.values())
          interval.ref();
        return this;
      }
      /**
       * Unrefs all stored intervals.
       */
      unref() {
        for (const interval of this.changeListeners.values())
          interval.unref();
        return this;
      }
    };
    exports.CustomStatWatcher = CustomStatWatcher;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/algorithms/watchFile.js
var require_watchFile = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/algorithms/watchFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwatchAllFiles = exports.unwatchFile = exports.watchFile = void 0;
    var CustomStatWatcher_1 = require_CustomStatWatcher();
    var statWatchersByFakeFS = /* @__PURE__ */ new WeakMap();
    function watchFile(fakeFs, path, a, b) {
      let bigint;
      let persistent;
      let interval;
      let listener;
      switch (typeof a) {
        case `function`:
          {
            bigint = false;
            persistent = true;
            interval = 5007;
            listener = a;
          }
          break;
        default:
          {
            ({
              bigint = false,
              persistent = true,
              interval = 5007
            } = a);
            listener = b;
          }
          break;
      }
      let statWatchers = statWatchersByFakeFS.get(fakeFs);
      if (typeof statWatchers === `undefined`)
        statWatchersByFakeFS.set(fakeFs, statWatchers = /* @__PURE__ */ new Map());
      let statWatcher = statWatchers.get(path);
      if (typeof statWatcher === `undefined`) {
        statWatcher = CustomStatWatcher_1.CustomStatWatcher.create(fakeFs, path, { bigint });
        statWatchers.set(path, statWatcher);
      }
      statWatcher.registerChangeListener(listener, { persistent, interval });
      return statWatcher;
    }
    __name(watchFile, "watchFile");
    exports.watchFile = watchFile;
    function unwatchFile(fakeFs, path, cb) {
      const statWatchers = statWatchersByFakeFS.get(fakeFs);
      if (typeof statWatchers === `undefined`)
        return;
      const statWatcher = statWatchers.get(path);
      if (typeof statWatcher === `undefined`)
        return;
      if (typeof cb === `undefined`)
        statWatcher.unregisterAllChangeListeners();
      else
        statWatcher.unregisterChangeListener(cb);
      if (!statWatcher.hasChangeListeners()) {
        statWatcher.stop();
        statWatchers.delete(path);
      }
    }
    __name(unwatchFile, "unwatchFile");
    exports.unwatchFile = unwatchFile;
    function unwatchAllFiles(fakeFs) {
      const statWatchers = statWatchersByFakeFS.get(fakeFs);
      if (typeof statWatchers === `undefined`)
        return;
      for (const path of statWatchers.keys()) {
        unwatchFile(fakeFs, path);
      }
    }
    __name(unwatchAllFiles, "unwatchAllFiles");
    exports.unwatchAllFiles = unwatchAllFiles;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/ZipFS.js
var require_ZipFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/ZipFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZipFS = exports.makeEmptyArchive = exports.DEFAULT_COMPRESSION_LEVEL = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs_1 = __require("fs");
    var stream_1 = __require("stream");
    var util_1 = __require("util");
    var zlib_1 = tslib_1.__importDefault(__require("zlib"));
    var FakeFS_1 = require_FakeFS();
    var NodeFS_1 = require_NodeFS();
    var opendir_1 = require_opendir();
    var watchFile_1 = require_watchFile();
    var constants_1 = require_constants();
    var errors = tslib_1.__importStar(require_errors());
    var path_1 = require_path();
    var statUtils = tslib_1.__importStar(require_statUtils());
    exports.DEFAULT_COMPRESSION_LEVEL = `mixed`;
    function toUnixTimestamp(time) {
      if (typeof time === `string` && String(+time) === time)
        return +time;
      if (typeof time === `number` && Number.isFinite(time)) {
        if (time < 0) {
          return Date.now() / 1e3;
        } else {
          return time;
        }
      }
      if (util_1.types.isDate(time))
        return time.getTime() / 1e3;
      throw new Error(`Invalid time`);
    }
    __name(toUnixTimestamp, "toUnixTimestamp");
    function makeEmptyArchive() {
      return Buffer.from([
        80,
        75,
        5,
        6,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
    }
    __name(makeEmptyArchive, "makeEmptyArchive");
    exports.makeEmptyArchive = makeEmptyArchive;
    var ZipFS = class extends FakeFS_1.BasePortableFakeFS {
      static {
        __name(this, "ZipFS");
      }
      constructor(source, opts) {
        super();
        this.lzSource = null;
        this.listings = /* @__PURE__ */ new Map();
        this.entries = /* @__PURE__ */ new Map();
        this.fileSources = /* @__PURE__ */ new Map();
        this.fds = /* @__PURE__ */ new Map();
        this.nextFd = 0;
        this.ready = false;
        this.readOnly = false;
        this.libzip = opts.libzip;
        const pathOptions = opts;
        this.level = typeof pathOptions.level !== `undefined` ? pathOptions.level : exports.DEFAULT_COMPRESSION_LEVEL;
        source !== null && source !== void 0 ? source : source = makeEmptyArchive();
        if (typeof source === `string`) {
          const { baseFs = new NodeFS_1.NodeFS() } = pathOptions;
          this.baseFs = baseFs;
          this.path = source;
        } else {
          this.path = null;
          this.baseFs = null;
        }
        if (opts.stats) {
          this.stats = opts.stats;
        } else {
          if (typeof source === `string`) {
            try {
              this.stats = this.baseFs.statSync(source);
            } catch (error) {
              if (error.code === `ENOENT` && pathOptions.create) {
                this.stats = statUtils.makeDefaultStats();
              } else {
                throw error;
              }
            }
          } else {
            this.stats = statUtils.makeDefaultStats();
          }
        }
        const errPtr = this.libzip.malloc(4);
        try {
          let flags = 0;
          if (typeof source === `string` && pathOptions.create)
            flags |= this.libzip.ZIP_CREATE | this.libzip.ZIP_TRUNCATE;
          if (opts.readOnly) {
            flags |= this.libzip.ZIP_RDONLY;
            this.readOnly = true;
          }
          if (typeof source === `string`) {
            this.zip = this.libzip.open(path_1.npath.fromPortablePath(source), flags, errPtr);
          } else {
            const lzSource = this.allocateUnattachedSource(source);
            try {
              this.zip = this.libzip.openFromSource(lzSource, flags, errPtr);
              this.lzSource = lzSource;
            } catch (error) {
              this.libzip.source.free(lzSource);
              throw error;
            }
          }
          if (this.zip === 0) {
            const error = this.libzip.struct.errorS();
            this.libzip.error.initWithCode(error, this.libzip.getValue(errPtr, `i32`));
            throw this.makeLibzipError(error);
          }
        } finally {
          this.libzip.free(errPtr);
        }
        this.listings.set(path_1.PortablePath.root, /* @__PURE__ */ new Set());
        const entryCount = this.libzip.getNumEntries(this.zip, 0);
        for (let t2 = 0; t2 < entryCount; ++t2) {
          const raw = this.libzip.getName(this.zip, t2, 0);
          if (path_1.ppath.isAbsolute(raw))
            continue;
          const p = path_1.ppath.resolve(path_1.PortablePath.root, raw);
          this.registerEntry(p, t2);
          if (raw.endsWith(`/`)) {
            this.registerListing(p);
          }
        }
        this.symlinkCount = this.libzip.ext.countSymlinks(this.zip);
        if (this.symlinkCount === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        this.ready = true;
      }
      makeLibzipError(error) {
        const errorCode = this.libzip.struct.errorCodeZip(error);
        const strerror = this.libzip.error.strerror(error);
        const libzipError = new errors.LibzipError(strerror, this.libzip.errors[errorCode]);
        if (errorCode === this.libzip.errors.ZIP_ER_CHANGED)
          throw new Error(`Assertion failed: Unexpected libzip error: ${libzipError.message}`);
        return libzipError;
      }
      getExtractHint(hints) {
        for (const fileName of this.entries.keys()) {
          const ext = this.pathUtils.extname(fileName);
          if (hints.relevantExtensions.has(ext)) {
            return true;
          }
        }
        return false;
      }
      getAllFiles() {
        return Array.from(this.entries.keys());
      }
      getRealPath() {
        if (!this.path)
          throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
        return this.path;
      }
      getBufferAndClose() {
        this.prepareClose();
        if (!this.lzSource)
          throw new Error(`ZipFS was not created from a Buffer`);
        if (this.entries.size === 0) {
          this.discardAndClose();
          return makeEmptyArchive();
        }
        try {
          this.libzip.source.keep(this.lzSource);
          if (this.libzip.close(this.zip) === -1)
            throw this.makeLibzipError(this.libzip.getError(this.zip));
          if (this.libzip.source.open(this.lzSource) === -1)
            throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
          if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_END) === -1)
            throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
          const size = this.libzip.source.tell(this.lzSource);
          if (size === -1)
            throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
          if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_SET) === -1)
            throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
          const buffer = this.libzip.malloc(size);
          if (!buffer)
            throw new Error(`Couldn't allocate enough memory`);
          try {
            const rc = this.libzip.source.read(this.lzSource, buffer, size);
            if (rc === -1)
              throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
            else if (rc < size)
              throw new Error(`Incomplete read`);
            else if (rc > size)
              throw new Error(`Overread`);
            const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
            return Buffer.from(memory);
          } finally {
            this.libzip.free(buffer);
          }
        } finally {
          this.libzip.source.close(this.lzSource);
          this.libzip.source.free(this.lzSource);
          this.ready = false;
        }
      }
      prepareClose() {
        if (!this.ready)
          throw errors.EBUSY(`archive closed, close`);
        (0, watchFile_1.unwatchAllFiles)(this);
      }
      saveAndClose() {
        if (!this.path || !this.baseFs)
          throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
        this.prepareClose();
        if (this.readOnly) {
          this.discardAndClose();
          return;
        }
        const newMode = this.baseFs.existsSync(this.path) || this.stats.mode === statUtils.DEFAULT_MODE ? void 0 : this.stats.mode;
        if (this.entries.size === 0) {
          this.discardAndClose();
          this.baseFs.writeFileSync(this.path, makeEmptyArchive(), { mode: newMode });
        } else {
          const rc = this.libzip.close(this.zip);
          if (rc === -1)
            throw this.makeLibzipError(this.libzip.getError(this.zip));
          if (typeof newMode !== `undefined`) {
            this.baseFs.chmodSync(this.path, newMode);
          }
        }
        this.ready = false;
      }
      discardAndClose() {
        this.prepareClose();
        this.libzip.discard(this.zip);
        this.ready = false;
      }
      resolve(p) {
        return path_1.ppath.resolve(path_1.PortablePath.root, p);
      }
      async openPromise(p, flags, mode) {
        return this.openSync(p, flags, mode);
      }
      openSync(p, flags, mode) {
        const fd = this.nextFd++;
        this.fds.set(fd, { cursor: 0, p });
        return fd;
      }
      hasOpenFileHandles() {
        return !!this.fds.size;
      }
      async opendirPromise(p, opts) {
        return this.opendirSync(p, opts);
      }
      opendirSync(p, opts = {}) {
        const resolvedP = this.resolveFilename(`opendir '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`opendir '${p}'`);
        const directoryListing = this.listings.get(resolvedP);
        if (!directoryListing)
          throw errors.ENOTDIR(`opendir '${p}'`);
        const entries = [...directoryListing];
        const fd = this.openSync(resolvedP, `r`);
        const onClose = /* @__PURE__ */ __name(() => {
          this.closeSync(fd);
        }, "onClose");
        return (0, opendir_1.opendir)(this, resolvedP, entries, { onClose });
      }
      async readPromise(fd, buffer, offset, length, position) {
        return this.readSync(fd, buffer, offset, length, position);
      }
      readSync(fd, buffer, offset = 0, length = buffer.byteLength, position = -1) {
        const entry = this.fds.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`read`);
        const realPosition = position === -1 || position === null ? entry.cursor : position;
        const source = this.readFileSync(entry.p);
        source.copy(buffer, offset, realPosition, realPosition + length);
        const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
        if (position === -1 || position === null)
          entry.cursor += bytesRead;
        return bytesRead;
      }
      async writePromise(fd, buffer, offset, length, position) {
        if (typeof buffer === `string`) {
          return this.writeSync(fd, buffer, position);
        } else {
          return this.writeSync(fd, buffer, offset, length, position);
        }
      }
      writeSync(fd, buffer, offset, length, position) {
        const entry = this.fds.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`read`);
        throw new Error(`Unimplemented`);
      }
      async closePromise(fd) {
        return this.closeSync(fd);
      }
      closeSync(fd) {
        const entry = this.fds.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`read`);
        this.fds.delete(fd);
      }
      createReadStream(p, { encoding } = {}) {
        if (p === null)
          throw new Error(`Unimplemented`);
        const fd = this.openSync(p, `r`);
        const stream = Object.assign(new stream_1.PassThrough({
          emitClose: true,
          autoDestroy: true,
          destroy: /* @__PURE__ */ __name((error, callback) => {
            clearImmediate(immediate);
            this.closeSync(fd);
            callback(error);
          }, "destroy")
        }), {
          close() {
            stream.destroy();
          },
          bytesRead: 0,
          path: p
        });
        const immediate = setImmediate(async () => {
          try {
            const data = await this.readFilePromise(p, encoding);
            stream.bytesRead = data.length;
            stream.end(data);
          } catch (error) {
            stream.destroy(error);
          }
        });
        return stream;
      }
      createWriteStream(p, { encoding } = {}) {
        if (this.readOnly)
          throw errors.EROFS(`open '${p}'`);
        if (p === null)
          throw new Error(`Unimplemented`);
        const chunks = [];
        const fd = this.openSync(p, `w`);
        const stream = Object.assign(new stream_1.PassThrough({
          autoDestroy: true,
          emitClose: true,
          destroy: /* @__PURE__ */ __name((error, callback) => {
            try {
              if (error) {
                callback(error);
              } else {
                this.writeFileSync(p, Buffer.concat(chunks), encoding);
                callback(null);
              }
            } catch (err) {
              callback(err);
            } finally {
              this.closeSync(fd);
            }
          }, "destroy")
        }), {
          bytesWritten: 0,
          path: p,
          close() {
            stream.destroy();
          }
        });
        stream.on(`data`, (chunk) => {
          const chunkBuffer = Buffer.from(chunk);
          stream.bytesWritten += chunkBuffer.length;
          chunks.push(chunkBuffer);
        });
        return stream;
      }
      async realpathPromise(p) {
        return this.realpathSync(p);
      }
      realpathSync(p) {
        const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`lstat '${p}'`);
        return resolvedP;
      }
      async existsPromise(p) {
        return this.existsSync(p);
      }
      existsSync(p) {
        if (!this.ready)
          throw errors.EBUSY(`archive closed, existsSync '${p}'`);
        if (this.symlinkCount === 0) {
          const resolvedP2 = path_1.ppath.resolve(path_1.PortablePath.root, p);
          return this.entries.has(resolvedP2) || this.listings.has(resolvedP2);
        }
        let resolvedP;
        try {
          resolvedP = this.resolveFilename(`stat '${p}'`, p, void 0, false);
        } catch (error) {
          return false;
        }
        if (resolvedP === void 0)
          return false;
        return this.entries.has(resolvedP) || this.listings.has(resolvedP);
      }
      async accessPromise(p, mode) {
        return this.accessSync(p, mode);
      }
      accessSync(p, mode = fs_1.constants.F_OK) {
        const resolvedP = this.resolveFilename(`access '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`access '${p}'`);
        if (this.readOnly && mode & fs_1.constants.W_OK) {
          throw errors.EROFS(`access '${p}'`);
        }
      }
      async statPromise(p, opts = { bigint: false }) {
        if (opts.bigint)
          return this.statSync(p, { bigint: true });
        return this.statSync(p);
      }
      statSync(p, opts = { bigint: false, throwIfNoEntry: true }) {
        const resolvedP = this.resolveFilename(`stat '${p}'`, p, void 0, opts.throwIfNoEntry);
        if (resolvedP === void 0)
          return void 0;
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) {
          if (opts.throwIfNoEntry === false)
            return void 0;
          throw errors.ENOENT(`stat '${p}'`);
        }
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
          throw errors.ENOTDIR(`stat '${p}'`);
        return this.statImpl(`stat '${p}'`, resolvedP, opts);
      }
      async fstatPromise(fd, opts) {
        return this.fstatSync(fd, opts);
      }
      fstatSync(fd, opts) {
        const entry = this.fds.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fstatSync`);
        const { p } = entry;
        const resolvedP = this.resolveFilename(`stat '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`stat '${p}'`);
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
          throw errors.ENOTDIR(`stat '${p}'`);
        return this.statImpl(`fstat '${p}'`, resolvedP, opts);
      }
      async lstatPromise(p, opts = { bigint: false }) {
        if (opts.bigint)
          return this.lstatSync(p, { bigint: true });
        return this.lstatSync(p);
      }
      lstatSync(p, opts = { bigint: false, throwIfNoEntry: true }) {
        const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false, opts.throwIfNoEntry);
        if (resolvedP === void 0)
          return void 0;
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) {
          if (opts.throwIfNoEntry === false)
            return void 0;
          throw errors.ENOENT(`lstat '${p}'`);
        }
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
          throw errors.ENOTDIR(`lstat '${p}'`);
        return this.statImpl(`lstat '${p}'`, resolvedP, opts);
      }
      statImpl(reason, p, opts = {}) {
        const entry = this.entries.get(p);
        if (typeof entry !== `undefined`) {
          const stat = this.libzip.struct.statS();
          const rc = this.libzip.statIndex(this.zip, entry, 0, 0, stat);
          if (rc === -1)
            throw this.makeLibzipError(this.libzip.getError(this.zip));
          const uid = this.stats.uid;
          const gid = this.stats.gid;
          const size = this.libzip.struct.statSize(stat) >>> 0;
          const blksize = 512;
          const blocks = Math.ceil(size / blksize);
          const mtimeMs = (this.libzip.struct.statMtime(stat) >>> 0) * 1e3;
          const atimeMs = mtimeMs;
          const birthtimeMs = mtimeMs;
          const ctimeMs = mtimeMs;
          const atime = new Date(atimeMs);
          const birthtime = new Date(birthtimeMs);
          const ctime = new Date(ctimeMs);
          const mtime = new Date(mtimeMs);
          const type = this.listings.has(p) ? constants_1.S_IFDIR : this.isSymbolicLink(entry) ? constants_1.S_IFLNK : constants_1.S_IFREG;
          const defaultMode = type === constants_1.S_IFDIR ? 493 : 420;
          const mode = type | this.getUnixMode(entry, defaultMode) & 511;
          const crc = this.libzip.struct.statCrc(stat);
          const statInstance = Object.assign(new statUtils.StatEntry(), { uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode, crc });
          return opts.bigint === true ? statUtils.convertToBigIntStats(statInstance) : statInstance;
        }
        if (this.listings.has(p)) {
          const uid = this.stats.uid;
          const gid = this.stats.gid;
          const size = 0;
          const blksize = 512;
          const blocks = 0;
          const atimeMs = this.stats.mtimeMs;
          const birthtimeMs = this.stats.mtimeMs;
          const ctimeMs = this.stats.mtimeMs;
          const mtimeMs = this.stats.mtimeMs;
          const atime = new Date(atimeMs);
          const birthtime = new Date(birthtimeMs);
          const ctime = new Date(ctimeMs);
          const mtime = new Date(mtimeMs);
          const mode = constants_1.S_IFDIR | 493;
          const crc = 0;
          const statInstance = Object.assign(new statUtils.StatEntry(), { uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode, crc });
          return opts.bigint === true ? statUtils.convertToBigIntStats(statInstance) : statInstance;
        }
        throw new Error(`Unreachable`);
      }
      getUnixMode(index, defaultMode) {
        const rc = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
        if (rc === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
        if (opsys !== this.libzip.ZIP_OPSYS_UNIX)
          return defaultMode;
        return this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
      }
      registerListing(p) {
        const existingListing = this.listings.get(p);
        if (existingListing)
          return existingListing;
        const parentListing = this.registerListing(path_1.ppath.dirname(p));
        parentListing.add(path_1.ppath.basename(p));
        const newListing = /* @__PURE__ */ new Set();
        this.listings.set(p, newListing);
        return newListing;
      }
      registerEntry(p, index) {
        const parentListing = this.registerListing(path_1.ppath.dirname(p));
        parentListing.add(path_1.ppath.basename(p));
        this.entries.set(p, index);
      }
      unregisterListing(p) {
        this.listings.delete(p);
        const parentListing = this.listings.get(path_1.ppath.dirname(p));
        parentListing === null || parentListing === void 0 ? void 0 : parentListing.delete(path_1.ppath.basename(p));
      }
      unregisterEntry(p) {
        this.unregisterListing(p);
        const entry = this.entries.get(p);
        this.entries.delete(p);
        if (typeof entry === `undefined`)
          return;
        this.fileSources.delete(entry);
        if (this.isSymbolicLink(entry)) {
          this.symlinkCount--;
        }
      }
      deleteEntry(p, index) {
        this.unregisterEntry(p);
        const rc = this.libzip.delete(this.zip, index);
        if (rc === -1) {
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        }
      }
      resolveFilename(reason, p, resolveLastComponent = true, throwIfNoEntry = true) {
        if (!this.ready)
          throw errors.EBUSY(`archive closed, ${reason}`);
        let resolvedP = path_1.ppath.resolve(path_1.PortablePath.root, p);
        if (resolvedP === `/`)
          return path_1.PortablePath.root;
        const fileIndex = this.entries.get(resolvedP);
        if (resolveLastComponent && fileIndex !== void 0) {
          if (this.symlinkCount !== 0 && this.isSymbolicLink(fileIndex)) {
            const target = this.getFileSource(fileIndex).toString();
            return this.resolveFilename(reason, path_1.ppath.resolve(path_1.ppath.dirname(resolvedP), target), true, throwIfNoEntry);
          } else {
            return resolvedP;
          }
        }
        while (true) {
          const parentP = this.resolveFilename(reason, path_1.ppath.dirname(resolvedP), true, throwIfNoEntry);
          if (parentP === void 0)
            return parentP;
          const isDir = this.listings.has(parentP);
          const doesExist = this.entries.has(parentP);
          if (!isDir && !doesExist) {
            if (throwIfNoEntry === false)
              return void 0;
            throw errors.ENOENT(reason);
          }
          if (!isDir)
            throw errors.ENOTDIR(reason);
          resolvedP = path_1.ppath.resolve(parentP, path_1.ppath.basename(resolvedP));
          if (!resolveLastComponent || this.symlinkCount === 0)
            break;
          const index = this.libzip.name.locate(this.zip, resolvedP.slice(1), 0);
          if (index === -1)
            break;
          if (this.isSymbolicLink(index)) {
            const target = this.getFileSource(index).toString();
            resolvedP = path_1.ppath.resolve(path_1.ppath.dirname(resolvedP), target);
          } else {
            break;
          }
        }
        return resolvedP;
      }
      allocateBuffer(content) {
        if (!Buffer.isBuffer(content))
          content = Buffer.from(content);
        const buffer = this.libzip.malloc(content.byteLength);
        if (!buffer)
          throw new Error(`Couldn't allocate enough memory`);
        const heap = new Uint8Array(this.libzip.HEAPU8.buffer, buffer, content.byteLength);
        heap.set(content);
        return { buffer, byteLength: content.byteLength };
      }
      allocateUnattachedSource(content) {
        const error = this.libzip.struct.errorS();
        const { buffer, byteLength } = this.allocateBuffer(content);
        const source = this.libzip.source.fromUnattachedBuffer(buffer, byteLength, 0, 1, error);
        if (source === 0) {
          this.libzip.free(error);
          throw this.makeLibzipError(error);
        }
        return source;
      }
      allocateSource(content) {
        const { buffer, byteLength } = this.allocateBuffer(content);
        const source = this.libzip.source.fromBuffer(this.zip, buffer, byteLength, 0, 1);
        if (source === 0) {
          this.libzip.free(buffer);
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        }
        return source;
      }
      setFileSource(p, content) {
        const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content);
        const target = path_1.ppath.relative(path_1.PortablePath.root, p);
        const lzSource = this.allocateSource(content);
        try {
          const newIndex = this.libzip.file.add(this.zip, target, lzSource, this.libzip.ZIP_FL_OVERWRITE);
          if (newIndex === -1)
            throw this.makeLibzipError(this.libzip.getError(this.zip));
          if (this.level !== `mixed`) {
            const method = this.level === 0 ? this.libzip.ZIP_CM_STORE : this.libzip.ZIP_CM_DEFLATE;
            const rc = this.libzip.file.setCompression(this.zip, newIndex, 0, method, this.level);
            if (rc === -1) {
              throw this.makeLibzipError(this.libzip.getError(this.zip));
            }
          }
          this.fileSources.set(newIndex, buffer);
          return newIndex;
        } catch (error) {
          this.libzip.source.free(lzSource);
          throw error;
        }
      }
      isSymbolicLink(index) {
        if (this.symlinkCount === 0)
          return false;
        const attrs = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
        if (attrs === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
        if (opsys !== this.libzip.ZIP_OPSYS_UNIX)
          return false;
        const attributes = this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
        return (attributes & constants_1.S_IFMT) === constants_1.S_IFLNK;
      }
      getFileSource(index, opts = { asyncDecompress: false }) {
        const cachedFileSource = this.fileSources.get(index);
        if (typeof cachedFileSource !== `undefined`)
          return cachedFileSource;
        const stat = this.libzip.struct.statS();
        const rc = this.libzip.statIndex(this.zip, index, 0, 0, stat);
        if (rc === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        const size = this.libzip.struct.statCompSize(stat);
        const compressionMethod = this.libzip.struct.statCompMethod(stat);
        const buffer = this.libzip.malloc(size);
        try {
          const file = this.libzip.fopenIndex(this.zip, index, 0, this.libzip.ZIP_FL_COMPRESSED);
          if (file === 0)
            throw this.makeLibzipError(this.libzip.getError(this.zip));
          try {
            const rc2 = this.libzip.fread(file, buffer, size, 0);
            if (rc2 === -1)
              throw this.makeLibzipError(this.libzip.file.getError(file));
            else if (rc2 < size)
              throw new Error(`Incomplete read`);
            else if (rc2 > size)
              throw new Error(`Overread`);
            const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
            const data = Buffer.from(memory);
            if (compressionMethod === 0) {
              this.fileSources.set(index, data);
              return data;
            } else if (opts.asyncDecompress) {
              return new Promise((resolve8, reject) => {
                zlib_1.default.inflateRaw(data, (error, result) => {
                  if (error) {
                    reject(error);
                  } else {
                    this.fileSources.set(index, result);
                    resolve8(result);
                  }
                });
              });
            } else {
              const decompressedData = zlib_1.default.inflateRawSync(data);
              this.fileSources.set(index, decompressedData);
              return decompressedData;
            }
          } finally {
            this.libzip.fclose(file);
          }
        } finally {
          this.libzip.free(buffer);
        }
      }
      async fchmodPromise(fd, mask) {
        return this.chmodPromise(this.fdToPath(fd, `fchmod`), mask);
      }
      fchmodSync(fd, mask) {
        return this.chmodSync(this.fdToPath(fd, `fchmodSync`), mask);
      }
      async chmodPromise(p, mask) {
        return this.chmodSync(p, mask);
      }
      chmodSync(p, mask) {
        if (this.readOnly)
          throw errors.EROFS(`chmod '${p}'`);
        mask &= 493;
        const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
        const entry = this.entries.get(resolvedP);
        if (typeof entry === `undefined`)
          throw new Error(`Assertion failed: The entry should have been registered (${resolvedP})`);
        const oldMod = this.getUnixMode(entry, constants_1.S_IFREG | 0);
        const newMod = oldMod & ~511 | mask;
        const rc = this.libzip.file.setExternalAttributes(this.zip, entry, 0, 0, this.libzip.ZIP_OPSYS_UNIX, newMod << 16);
        if (rc === -1) {
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        }
      }
      async fchownPromise(fd, uid, gid) {
        return this.chownPromise(this.fdToPath(fd, `fchown`), uid, gid);
      }
      fchownSync(fd, uid, gid) {
        return this.chownSync(this.fdToPath(fd, `fchownSync`), uid, gid);
      }
      async chownPromise(p, uid, gid) {
        return this.chownSync(p, uid, gid);
      }
      chownSync(p, uid, gid) {
        throw new Error(`Unimplemented`);
      }
      async renamePromise(oldP, newP) {
        return this.renameSync(oldP, newP);
      }
      renameSync(oldP, newP) {
        throw new Error(`Unimplemented`);
      }
      async copyFilePromise(sourceP, destP, flags) {
        const { indexSource, indexDest, resolvedDestP } = this.prepareCopyFile(sourceP, destP, flags);
        const source = await this.getFileSource(indexSource, { asyncDecompress: true });
        const newIndex = this.setFileSource(resolvedDestP, source);
        if (newIndex !== indexDest) {
          this.registerEntry(resolvedDestP, newIndex);
        }
      }
      copyFileSync(sourceP, destP, flags = 0) {
        const { indexSource, indexDest, resolvedDestP } = this.prepareCopyFile(sourceP, destP, flags);
        const source = this.getFileSource(indexSource);
        const newIndex = this.setFileSource(resolvedDestP, source);
        if (newIndex !== indexDest) {
          this.registerEntry(resolvedDestP, newIndex);
        }
      }
      prepareCopyFile(sourceP, destP, flags = 0) {
        if (this.readOnly)
          throw errors.EROFS(`copyfile '${sourceP} -> '${destP}'`);
        if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
          throw errors.ENOSYS(`unsupported clone operation`, `copyfile '${sourceP}' -> ${destP}'`);
        const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
        const indexSource = this.entries.get(resolvedSourceP);
        if (typeof indexSource === `undefined`)
          throw errors.EINVAL(`copyfile '${sourceP}' -> '${destP}'`);
        const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
        const indexDest = this.entries.get(resolvedDestP);
        if ((flags & (fs_1.constants.COPYFILE_EXCL | fs_1.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`)
          throw errors.EEXIST(`copyfile '${sourceP}' -> '${destP}'`);
        return {
          indexSource,
          resolvedDestP,
          indexDest
        };
      }
      async appendFilePromise(p, content, opts) {
        if (this.readOnly)
          throw errors.EROFS(`open '${p}'`);
        if (typeof opts === `undefined`)
          opts = { flag: `a` };
        else if (typeof opts === `string`)
          opts = { flag: `a`, encoding: opts };
        else if (typeof opts.flag === `undefined`)
          opts = { flag: `a`, ...opts };
        return this.writeFilePromise(p, content, opts);
      }
      appendFileSync(p, content, opts = {}) {
        if (this.readOnly)
          throw errors.EROFS(`open '${p}'`);
        if (typeof opts === `undefined`)
          opts = { flag: `a` };
        else if (typeof opts === `string`)
          opts = { flag: `a`, encoding: opts };
        else if (typeof opts.flag === `undefined`)
          opts = { flag: `a`, ...opts };
        return this.writeFileSync(p, content, opts);
      }
      fdToPath(fd, reason) {
        var _a;
        const path = (_a = this.fds.get(fd)) === null || _a === void 0 ? void 0 : _a.p;
        if (typeof path === `undefined`)
          throw errors.EBADF(reason);
        return path;
      }
      async writeFilePromise(p, content, opts) {
        const { encoding, mode, index, resolvedP } = this.prepareWriteFile(p, opts);
        if (index !== void 0 && typeof opts === `object` && opts.flag && opts.flag.includes(`a`))
          content = Buffer.concat([await this.getFileSource(index, { asyncDecompress: true }), Buffer.from(content)]);
        if (encoding !== null)
          content = content.toString(encoding);
        const newIndex = this.setFileSource(resolvedP, content);
        if (newIndex !== index)
          this.registerEntry(resolvedP, newIndex);
        if (mode !== null) {
          await this.chmodPromise(resolvedP, mode);
        }
      }
      writeFileSync(p, content, opts) {
        const { encoding, mode, index, resolvedP } = this.prepareWriteFile(p, opts);
        if (index !== void 0 && typeof opts === `object` && opts.flag && opts.flag.includes(`a`))
          content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
        if (encoding !== null)
          content = content.toString(encoding);
        const newIndex = this.setFileSource(resolvedP, content);
        if (newIndex !== index)
          this.registerEntry(resolvedP, newIndex);
        if (mode !== null) {
          this.chmodSync(resolvedP, mode);
        }
      }
      prepareWriteFile(p, opts) {
        if (typeof p === `number`)
          p = this.fdToPath(p, `read`);
        if (this.readOnly)
          throw errors.EROFS(`open '${p}'`);
        const resolvedP = this.resolveFilename(`open '${p}'`, p);
        if (this.listings.has(resolvedP))
          throw errors.EISDIR(`open '${p}'`);
        let encoding = null, mode = null;
        if (typeof opts === `string`) {
          encoding = opts;
        } else if (typeof opts === `object`) {
          ({
            encoding = null,
            mode = null
          } = opts);
        }
        const index = this.entries.get(resolvedP);
        return {
          encoding,
          mode,
          resolvedP,
          index
        };
      }
      async unlinkPromise(p) {
        return this.unlinkSync(p);
      }
      unlinkSync(p) {
        if (this.readOnly)
          throw errors.EROFS(`unlink '${p}'`);
        const resolvedP = this.resolveFilename(`unlink '${p}'`, p);
        if (this.listings.has(resolvedP))
          throw errors.EISDIR(`unlink '${p}'`);
        const index = this.entries.get(resolvedP);
        if (typeof index === `undefined`)
          throw errors.EINVAL(`unlink '${p}'`);
        this.deleteEntry(resolvedP, index);
      }
      async utimesPromise(p, atime, mtime) {
        return this.utimesSync(p, atime, mtime);
      }
      utimesSync(p, atime, mtime) {
        if (this.readOnly)
          throw errors.EROFS(`utimes '${p}'`);
        const resolvedP = this.resolveFilename(`utimes '${p}'`, p);
        this.utimesImpl(resolvedP, mtime);
      }
      async lutimesPromise(p, atime, mtime) {
        return this.lutimesSync(p, atime, mtime);
      }
      lutimesSync(p, atime, mtime) {
        if (this.readOnly)
          throw errors.EROFS(`lutimes '${p}'`);
        const resolvedP = this.resolveFilename(`utimes '${p}'`, p, false);
        this.utimesImpl(resolvedP, mtime);
      }
      utimesImpl(resolvedP, mtime) {
        if (this.listings.has(resolvedP)) {
          if (!this.entries.has(resolvedP))
            this.hydrateDirectory(resolvedP);
        }
        const entry = this.entries.get(resolvedP);
        if (entry === void 0)
          throw new Error(`Unreachable`);
        const rc = this.libzip.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);
        if (rc === -1) {
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        }
      }
      async mkdirPromise(p, opts) {
        return this.mkdirSync(p, opts);
      }
      mkdirSync(p, { mode = 493, recursive = false } = {}) {
        if (recursive)
          return this.mkdirpSync(p, { chmod: mode });
        if (this.readOnly)
          throw errors.EROFS(`mkdir '${p}'`);
        const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
        if (this.entries.has(resolvedP) || this.listings.has(resolvedP))
          throw errors.EEXIST(`mkdir '${p}'`);
        this.hydrateDirectory(resolvedP);
        this.chmodSync(resolvedP, mode);
        return void 0;
      }
      async rmdirPromise(p, opts) {
        return this.rmdirSync(p, opts);
      }
      rmdirSync(p, { recursive = false } = {}) {
        if (this.readOnly)
          throw errors.EROFS(`rmdir '${p}'`);
        if (recursive) {
          this.removeSync(p);
          return;
        }
        const resolvedP = this.resolveFilename(`rmdir '${p}'`, p);
        const directoryListing = this.listings.get(resolvedP);
        if (!directoryListing)
          throw errors.ENOTDIR(`rmdir '${p}'`);
        if (directoryListing.size > 0)
          throw errors.ENOTEMPTY(`rmdir '${p}'`);
        const index = this.entries.get(resolvedP);
        if (typeof index === `undefined`)
          throw errors.EINVAL(`rmdir '${p}'`);
        this.deleteEntry(p, index);
      }
      hydrateDirectory(resolvedP) {
        const index = this.libzip.dir.add(this.zip, path_1.ppath.relative(path_1.PortablePath.root, resolvedP));
        if (index === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        this.registerListing(resolvedP);
        this.registerEntry(resolvedP, index);
        return index;
      }
      async linkPromise(existingP, newP) {
        return this.linkSync(existingP, newP);
      }
      linkSync(existingP, newP) {
        throw errors.EOPNOTSUPP(`link '${existingP}' -> '${newP}'`);
      }
      async symlinkPromise(target, p) {
        return this.symlinkSync(target, p);
      }
      symlinkSync(target, p) {
        if (this.readOnly)
          throw errors.EROFS(`symlink '${target}' -> '${p}'`);
        const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
        if (this.listings.has(resolvedP))
          throw errors.EISDIR(`symlink '${target}' -> '${p}'`);
        if (this.entries.has(resolvedP))
          throw errors.EEXIST(`symlink '${target}' -> '${p}'`);
        const index = this.setFileSource(resolvedP, target);
        this.registerEntry(resolvedP, index);
        const rc = this.libzip.file.setExternalAttributes(this.zip, index, 0, 0, this.libzip.ZIP_OPSYS_UNIX, (constants_1.S_IFLNK | 511) << 16);
        if (rc === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        this.symlinkCount += 1;
      }
      async readFilePromise(p, encoding) {
        if (typeof encoding === `object`)
          encoding = encoding ? encoding.encoding : void 0;
        const data = await this.readFileBuffer(p, { asyncDecompress: true });
        return encoding ? data.toString(encoding) : data;
      }
      readFileSync(p, encoding) {
        if (typeof encoding === `object`)
          encoding = encoding ? encoding.encoding : void 0;
        const data = this.readFileBuffer(p);
        return encoding ? data.toString(encoding) : data;
      }
      readFileBuffer(p, opts = { asyncDecompress: false }) {
        if (typeof p === `number`)
          p = this.fdToPath(p, `read`);
        const resolvedP = this.resolveFilename(`open '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`open '${p}'`);
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
          throw errors.ENOTDIR(`open '${p}'`);
        if (this.listings.has(resolvedP))
          throw errors.EISDIR(`read`);
        const entry = this.entries.get(resolvedP);
        if (entry === void 0)
          throw new Error(`Unreachable`);
        return this.getFileSource(entry, opts);
      }
      async readdirPromise(p, opts) {
        return this.readdirSync(p, opts);
      }
      readdirSync(p, opts) {
        const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`scandir '${p}'`);
        const directoryListing = this.listings.get(resolvedP);
        if (!directoryListing)
          throw errors.ENOTDIR(`scandir '${p}'`);
        const entries = [...directoryListing];
        if (!(opts === null || opts === void 0 ? void 0 : opts.withFileTypes))
          return entries;
        return entries.map((name) => {
          return Object.assign(this.statImpl(`lstat`, path_1.ppath.join(p, name)), {
            name
          });
        });
      }
      async readlinkPromise(p) {
        const entry = this.prepareReadlink(p);
        return (await this.getFileSource(entry, { asyncDecompress: true })).toString();
      }
      readlinkSync(p) {
        const entry = this.prepareReadlink(p);
        return this.getFileSource(entry).toString();
      }
      prepareReadlink(p) {
        const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
          throw errors.ENOENT(`readlink '${p}'`);
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
          throw errors.ENOTDIR(`open '${p}'`);
        if (this.listings.has(resolvedP))
          throw errors.EINVAL(`readlink '${p}'`);
        const entry = this.entries.get(resolvedP);
        if (entry === void 0)
          throw new Error(`Unreachable`);
        if (!this.isSymbolicLink(entry))
          throw errors.EINVAL(`readlink '${p}'`);
        return entry;
      }
      async truncatePromise(p, len = 0) {
        const resolvedP = this.resolveFilename(`open '${p}'`, p);
        const index = this.entries.get(resolvedP);
        if (typeof index === `undefined`)
          throw errors.EINVAL(`open '${p}'`);
        const source = await this.getFileSource(index, { asyncDecompress: true });
        const truncated = Buffer.alloc(len, 0);
        source.copy(truncated);
        return await this.writeFilePromise(p, truncated);
      }
      truncateSync(p, len = 0) {
        const resolvedP = this.resolveFilename(`open '${p}'`, p);
        const index = this.entries.get(resolvedP);
        if (typeof index === `undefined`)
          throw errors.EINVAL(`open '${p}'`);
        const source = this.getFileSource(index);
        const truncated = Buffer.alloc(len, 0);
        source.copy(truncated);
        return this.writeFileSync(p, truncated);
      }
      async ftruncatePromise(fd, len) {
        return this.truncatePromise(this.fdToPath(fd, `ftruncate`), len);
      }
      ftruncateSync(fd, len) {
        return this.truncateSync(this.fdToPath(fd, `ftruncateSync`), len);
      }
      watch(p, a, b) {
        let persistent;
        switch (typeof a) {
          case `function`:
          case `string`:
          case `undefined`:
            {
              persistent = true;
            }
            break;
          default:
            {
              ({ persistent = true } = a);
            }
            break;
        }
        if (!persistent)
          return { on: /* @__PURE__ */ __name(() => {
          }, "on"), close: /* @__PURE__ */ __name(() => {
          }, "close") };
        const interval = setInterval(() => {
        }, 24 * 60 * 60 * 1e3);
        return { on: /* @__PURE__ */ __name(() => {
        }, "on"), close: /* @__PURE__ */ __name(() => {
          clearInterval(interval);
        }, "close") };
      }
      watchFile(p, a, b) {
        const resolvedP = path_1.ppath.resolve(path_1.PortablePath.root, p);
        return (0, watchFile_1.watchFile)(this, resolvedP, a, b);
      }
      unwatchFile(p, cb) {
        const resolvedP = path_1.ppath.resolve(path_1.PortablePath.root, p);
        return (0, watchFile_1.unwatchFile)(this, resolvedP, cb);
      }
    };
    exports.ZipFS = ZipFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/ProxiedFS.js
var require_ProxiedFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/ProxiedFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxiedFS = void 0;
    var FakeFS_1 = require_FakeFS();
    var ProxiedFS = class extends FakeFS_1.FakeFS {
      static {
        __name(this, "ProxiedFS");
      }
      getExtractHint(hints) {
        return this.baseFs.getExtractHint(hints);
      }
      resolve(path) {
        return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
      }
      getRealPath() {
        return this.mapFromBase(this.baseFs.getRealPath());
      }
      async openPromise(p, flags, mode) {
        return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
      }
      openSync(p, flags, mode) {
        return this.baseFs.openSync(this.mapToBase(p), flags, mode);
      }
      async opendirPromise(p, opts) {
        return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
      }
      opendirSync(p, opts) {
        return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
      }
      async readPromise(fd, buffer, offset, length, position) {
        return await this.baseFs.readPromise(fd, buffer, offset, length, position);
      }
      readSync(fd, buffer, offset, length, position) {
        return this.baseFs.readSync(fd, buffer, offset, length, position);
      }
      async writePromise(fd, buffer, offset, length, position) {
        if (typeof buffer === `string`) {
          return await this.baseFs.writePromise(fd, buffer, offset);
        } else {
          return await this.baseFs.writePromise(fd, buffer, offset, length, position);
        }
      }
      writeSync(fd, buffer, offset, length, position) {
        if (typeof buffer === `string`) {
          return this.baseFs.writeSync(fd, buffer, offset);
        } else {
          return this.baseFs.writeSync(fd, buffer, offset, length, position);
        }
      }
      async closePromise(fd) {
        return this.baseFs.closePromise(fd);
      }
      closeSync(fd) {
        this.baseFs.closeSync(fd);
      }
      createReadStream(p, opts) {
        return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
      }
      createWriteStream(p, opts) {
        return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
      }
      async realpathPromise(p) {
        return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
      }
      realpathSync(p) {
        return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
      }
      async existsPromise(p) {
        return this.baseFs.existsPromise(this.mapToBase(p));
      }
      existsSync(p) {
        return this.baseFs.existsSync(this.mapToBase(p));
      }
      accessSync(p, mode) {
        return this.baseFs.accessSync(this.mapToBase(p), mode);
      }
      async accessPromise(p, mode) {
        return this.baseFs.accessPromise(this.mapToBase(p), mode);
      }
      async statPromise(p, opts) {
        return this.baseFs.statPromise(this.mapToBase(p), opts);
      }
      statSync(p, opts) {
        return this.baseFs.statSync(this.mapToBase(p), opts);
      }
      async fstatPromise(fd, opts) {
        return this.baseFs.fstatPromise(fd, opts);
      }
      fstatSync(fd, opts) {
        return this.baseFs.fstatSync(fd, opts);
      }
      lstatPromise(p, opts) {
        return this.baseFs.lstatPromise(this.mapToBase(p), opts);
      }
      lstatSync(p, opts) {
        return this.baseFs.lstatSync(this.mapToBase(p), opts);
      }
      async fchmodPromise(fd, mask) {
        return this.baseFs.fchmodPromise(fd, mask);
      }
      fchmodSync(fd, mask) {
        return this.baseFs.fchmodSync(fd, mask);
      }
      async chmodPromise(p, mask) {
        return this.baseFs.chmodPromise(this.mapToBase(p), mask);
      }
      chmodSync(p, mask) {
        return this.baseFs.chmodSync(this.mapToBase(p), mask);
      }
      async fchownPromise(fd, uid, gid) {
        return this.baseFs.fchownPromise(fd, uid, gid);
      }
      fchownSync(fd, uid, gid) {
        return this.baseFs.fchownSync(fd, uid, gid);
      }
      async chownPromise(p, uid, gid) {
        return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
      }
      chownSync(p, uid, gid) {
        return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
      }
      async renamePromise(oldP, newP) {
        return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
      }
      renameSync(oldP, newP) {
        return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
      }
      async copyFilePromise(sourceP, destP, flags = 0) {
        return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
      }
      copyFileSync(sourceP, destP, flags = 0) {
        return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
      }
      async appendFilePromise(p, content, opts) {
        return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
      }
      appendFileSync(p, content, opts) {
        return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
      }
      async writeFilePromise(p, content, opts) {
        return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
      }
      writeFileSync(p, content, opts) {
        return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
      }
      async unlinkPromise(p) {
        return this.baseFs.unlinkPromise(this.mapToBase(p));
      }
      unlinkSync(p) {
        return this.baseFs.unlinkSync(this.mapToBase(p));
      }
      async utimesPromise(p, atime, mtime) {
        return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
      }
      utimesSync(p, atime, mtime) {
        return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
      }
      async mkdirPromise(p, opts) {
        return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
      }
      mkdirSync(p, opts) {
        return this.baseFs.mkdirSync(this.mapToBase(p), opts);
      }
      async rmdirPromise(p, opts) {
        return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
      }
      rmdirSync(p, opts) {
        return this.baseFs.rmdirSync(this.mapToBase(p), opts);
      }
      async linkPromise(existingP, newP) {
        return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
      }
      linkSync(existingP, newP) {
        return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
      }
      async symlinkPromise(target, p, type) {
        const mappedP = this.mapToBase(p);
        if (this.pathUtils.isAbsolute(target))
          return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
        const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
        const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
        return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
      }
      symlinkSync(target, p, type) {
        const mappedP = this.mapToBase(p);
        if (this.pathUtils.isAbsolute(target))
          return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
        const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
        const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
        return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
      }
      async readFilePromise(p, encoding) {
        if (encoding === `utf8`) {
          return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
        } else {
          return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
        }
      }
      readFileSync(p, encoding) {
        if (encoding === `utf8`) {
          return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
        } else {
          return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
        }
      }
      async readdirPromise(p, opts) {
        return this.baseFs.readdirPromise(this.mapToBase(p), opts);
      }
      readdirSync(p, opts) {
        return this.baseFs.readdirSync(this.mapToBase(p), opts);
      }
      async readlinkPromise(p) {
        return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
      }
      readlinkSync(p) {
        return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
      }
      async truncatePromise(p, len) {
        return this.baseFs.truncatePromise(this.mapToBase(p), len);
      }
      truncateSync(p, len) {
        return this.baseFs.truncateSync(this.mapToBase(p), len);
      }
      async ftruncatePromise(fd, len) {
        return this.baseFs.ftruncatePromise(fd, len);
      }
      ftruncateSync(fd, len) {
        return this.baseFs.ftruncateSync(fd, len);
      }
      watch(p, a, b) {
        return this.baseFs.watch(
          this.mapToBase(p),
          // @ts-expect-error
          a,
          b
        );
      }
      watchFile(p, a, b) {
        return this.baseFs.watchFile(
          this.mapToBase(p),
          // @ts-expect-error
          a,
          b
        );
      }
      unwatchFile(p, cb) {
        return this.baseFs.unwatchFile(this.mapToBase(p), cb);
      }
      fsMapToBase(p) {
        if (typeof p === `number`) {
          return p;
        } else {
          return this.mapToBase(p);
        }
      }
    };
    exports.ProxiedFS = ProxiedFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/AliasFS.js
var require_AliasFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/AliasFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AliasFS = void 0;
    var ProxiedFS_1 = require_ProxiedFS();
    var AliasFS = class extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "AliasFS");
      }
      constructor(target, { baseFs, pathUtils }) {
        super(pathUtils);
        this.target = target;
        this.baseFs = baseFs;
      }
      getRealPath() {
        return this.target;
      }
      getBaseFs() {
        return this.baseFs;
      }
      mapFromBase(p) {
        return p;
      }
      mapToBase(p) {
        return p;
      }
    };
    exports.AliasFS = AliasFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/CwdFS.js
var require_CwdFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/CwdFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CwdFS = void 0;
    var NodeFS_1 = require_NodeFS();
    var ProxiedFS_1 = require_ProxiedFS();
    var path_1 = require_path();
    var CwdFS = class extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "CwdFS");
      }
      constructor(target, { baseFs = new NodeFS_1.NodeFS() } = {}) {
        super(path_1.ppath);
        this.target = this.pathUtils.normalize(target);
        this.baseFs = baseFs;
      }
      getRealPath() {
        return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
      }
      resolve(p) {
        if (this.pathUtils.isAbsolute(p)) {
          return path_1.ppath.normalize(p);
        } else {
          return this.baseFs.resolve(path_1.ppath.join(this.target, p));
        }
      }
      mapFromBase(path) {
        return path;
      }
      mapToBase(path) {
        if (this.pathUtils.isAbsolute(path)) {
          return path;
        } else {
          return this.pathUtils.join(this.target, path);
        }
      }
    };
    exports.CwdFS = CwdFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/JailFS.js
var require_JailFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/JailFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JailFS = void 0;
    var NodeFS_1 = require_NodeFS();
    var ProxiedFS_1 = require_ProxiedFS();
    var path_1 = require_path();
    var JAIL_ROOT = path_1.PortablePath.root;
    var JailFS = class extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "JailFS");
      }
      constructor(target, { baseFs = new NodeFS_1.NodeFS() } = {}) {
        super(path_1.ppath);
        this.target = this.pathUtils.resolve(path_1.PortablePath.root, target);
        this.baseFs = baseFs;
      }
      getRealPath() {
        return this.pathUtils.resolve(this.baseFs.getRealPath(), this.pathUtils.relative(path_1.PortablePath.root, this.target));
      }
      getTarget() {
        return this.target;
      }
      getBaseFs() {
        return this.baseFs;
      }
      mapToBase(p) {
        const normalized = this.pathUtils.normalize(p);
        if (this.pathUtils.isAbsolute(p))
          return this.pathUtils.resolve(this.target, this.pathUtils.relative(JAIL_ROOT, p));
        if (normalized.match(/^\.\.\/?/))
          throw new Error(`Resolving this path (${p}) would escape the jail`);
        return this.pathUtils.resolve(this.target, p);
      }
      mapFromBase(p) {
        return this.pathUtils.resolve(JAIL_ROOT, this.pathUtils.relative(this.target, p));
      }
    };
    exports.JailFS = JailFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/LazyFS.js
var require_LazyFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/LazyFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LazyFS = void 0;
    var ProxiedFS_1 = require_ProxiedFS();
    var LazyFS = class extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "LazyFS");
      }
      constructor(factory, pathUtils) {
        super(pathUtils);
        this.instance = null;
        this.factory = factory;
      }
      get baseFs() {
        if (!this.instance)
          this.instance = this.factory();
        return this.instance;
      }
      set baseFs(value) {
        this.instance = value;
      }
      mapFromBase(p) {
        return p;
      }
      mapToBase(p) {
        return p;
      }
    };
    exports.LazyFS = LazyFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/NoFS.js
var require_NoFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/NoFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoFS = void 0;
    var FakeFS_1 = require_FakeFS();
    var path_1 = require_path();
    var makeError = /* @__PURE__ */ __name(() => Object.assign(new Error(`ENOSYS: unsupported filesystem access`), { code: `ENOSYS` }), "makeError");
    var NoFS = class extends FakeFS_1.FakeFS {
      static {
        __name(this, "NoFS");
      }
      constructor() {
        super(path_1.ppath);
      }
      getExtractHint() {
        throw makeError();
      }
      getRealPath() {
        throw makeError();
      }
      resolve() {
        throw makeError();
      }
      async openPromise() {
        throw makeError();
      }
      openSync() {
        throw makeError();
      }
      async opendirPromise() {
        throw makeError();
      }
      opendirSync() {
        throw makeError();
      }
      async readPromise() {
        throw makeError();
      }
      readSync() {
        throw makeError();
      }
      async writePromise() {
        throw makeError();
      }
      writeSync() {
        throw makeError();
      }
      async closePromise() {
        throw makeError();
      }
      closeSync() {
        throw makeError();
      }
      createWriteStream() {
        throw makeError();
      }
      createReadStream() {
        throw makeError();
      }
      async realpathPromise() {
        throw makeError();
      }
      realpathSync() {
        throw makeError();
      }
      async readdirPromise() {
        throw makeError();
      }
      readdirSync() {
        throw makeError();
      }
      async existsPromise(p) {
        throw makeError();
      }
      existsSync(p) {
        throw makeError();
      }
      async accessPromise() {
        throw makeError();
      }
      accessSync() {
        throw makeError();
      }
      async statPromise() {
        throw makeError();
      }
      statSync() {
        throw makeError();
      }
      async fstatPromise(fd) {
        throw makeError();
      }
      fstatSync(fd) {
        throw makeError();
      }
      async lstatPromise(p) {
        throw makeError();
      }
      lstatSync(p) {
        throw makeError();
      }
      async fchmodPromise() {
        throw makeError();
      }
      fchmodSync() {
        throw makeError();
      }
      async chmodPromise() {
        throw makeError();
      }
      chmodSync() {
        throw makeError();
      }
      async fchownPromise() {
        throw makeError();
      }
      fchownSync() {
        throw makeError();
      }
      async chownPromise() {
        throw makeError();
      }
      chownSync() {
        throw makeError();
      }
      async mkdirPromise() {
        throw makeError();
      }
      mkdirSync() {
        throw makeError();
      }
      async rmdirPromise() {
        throw makeError();
      }
      rmdirSync() {
        throw makeError();
      }
      async linkPromise() {
        throw makeError();
      }
      linkSync() {
        throw makeError();
      }
      async symlinkPromise() {
        throw makeError();
      }
      symlinkSync() {
        throw makeError();
      }
      async renamePromise() {
        throw makeError();
      }
      renameSync() {
        throw makeError();
      }
      async copyFilePromise() {
        throw makeError();
      }
      copyFileSync() {
        throw makeError();
      }
      async appendFilePromise() {
        throw makeError();
      }
      appendFileSync() {
        throw makeError();
      }
      async writeFilePromise() {
        throw makeError();
      }
      writeFileSync() {
        throw makeError();
      }
      async unlinkPromise() {
        throw makeError();
      }
      unlinkSync() {
        throw makeError();
      }
      async utimesPromise() {
        throw makeError();
      }
      utimesSync() {
        throw makeError();
      }
      async readFilePromise() {
        throw makeError();
      }
      readFileSync() {
        throw makeError();
      }
      async readlinkPromise() {
        throw makeError();
      }
      readlinkSync() {
        throw makeError();
      }
      async truncatePromise() {
        throw makeError();
      }
      truncateSync() {
        throw makeError();
      }
      async ftruncatePromise(fd, len) {
        throw makeError();
      }
      ftruncateSync(fd, len) {
        throw makeError();
      }
      watch() {
        throw makeError();
      }
      watchFile() {
        throw makeError();
      }
      unwatchFile() {
        throw makeError();
      }
    };
    NoFS.instance = new NoFS();
    exports.NoFS = NoFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/PosixFS.js
var require_PosixFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/PosixFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PosixFS = void 0;
    var ProxiedFS_1 = require_ProxiedFS();
    var path_1 = require_path();
    var PosixFS2 = class extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "PosixFS");
      }
      constructor(baseFs) {
        super(path_1.npath);
        this.baseFs = baseFs;
      }
      mapFromBase(path) {
        return path_1.npath.fromPortablePath(path);
      }
      mapToBase(path) {
        return path_1.npath.toPortablePath(path);
      }
    };
    exports.PosixFS = PosixFS2;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/VirtualFS.js
var require_VirtualFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/VirtualFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VirtualFS = void 0;
    var NodeFS_1 = require_NodeFS();
    var ProxiedFS_1 = require_ProxiedFS();
    var path_1 = require_path();
    var NUMBER_REGEXP = /^[0-9]+$/;
    var VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
    var VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
    var VirtualFS2 = class _VirtualFS extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "VirtualFS");
      }
      static makeVirtualPath(base, component, to) {
        if (path_1.ppath.basename(base) !== `__virtual__`)
          throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
        if (!path_1.ppath.basename(component).match(VALID_COMPONENT))
          throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
        const target = path_1.ppath.relative(path_1.ppath.dirname(base), to);
        const segments = target.split(`/`);
        let depth = 0;
        while (depth < segments.length && segments[depth] === `..`)
          depth += 1;
        const finalSegments = segments.slice(depth);
        const fullVirtualPath = path_1.ppath.join(base, component, String(depth), ...finalSegments);
        return fullVirtualPath;
      }
      static resolveVirtual(p) {
        const match = p.match(VIRTUAL_REGEXP);
        if (!match || !match[3] && match[5])
          return p;
        const target = path_1.ppath.dirname(match[1]);
        if (!match[3] || !match[4])
          return target;
        const isnum = NUMBER_REGEXP.test(match[4]);
        if (!isnum)
          return p;
        const depth = Number(match[4]);
        const backstep = `../`.repeat(depth);
        const subpath = match[5] || `.`;
        return _VirtualFS.resolveVirtual(path_1.ppath.join(target, backstep, subpath));
      }
      constructor({ baseFs = new NodeFS_1.NodeFS() } = {}) {
        super(path_1.ppath);
        this.baseFs = baseFs;
      }
      getExtractHint(hints) {
        return this.baseFs.getExtractHint(hints);
      }
      getRealPath() {
        return this.baseFs.getRealPath();
      }
      realpathSync(p) {
        const match = p.match(VIRTUAL_REGEXP);
        if (!match)
          return this.baseFs.realpathSync(p);
        if (!match[5])
          return p;
        const realpath2 = this.baseFs.realpathSync(this.mapToBase(p));
        return _VirtualFS.makeVirtualPath(match[1], match[3], realpath2);
      }
      async realpathPromise(p) {
        const match = p.match(VIRTUAL_REGEXP);
        if (!match)
          return await this.baseFs.realpathPromise(p);
        if (!match[5])
          return p;
        const realpath2 = await this.baseFs.realpathPromise(this.mapToBase(p));
        return _VirtualFS.makeVirtualPath(match[1], match[3], realpath2);
      }
      mapToBase(p) {
        if (p === ``)
          return p;
        if (this.pathUtils.isAbsolute(p))
          return _VirtualFS.resolveVirtual(p);
        const resolvedRoot = _VirtualFS.resolveVirtual(this.baseFs.resolve(path_1.PortablePath.dot));
        const resolvedP = _VirtualFS.resolveVirtual(this.baseFs.resolve(p));
        return path_1.ppath.relative(resolvedRoot, resolvedP) || path_1.PortablePath.dot;
      }
      mapFromBase(p) {
        return p;
      }
    };
    exports.VirtualFS = VirtualFS2;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/ZipOpenFS.js
var require_ZipOpenFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/ZipOpenFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZipOpenFS = exports.getArchivePart = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs_1 = __require("fs");
    var FakeFS_1 = require_FakeFS();
    var NodeFS_1 = require_NodeFS();
    var ZipFS_1 = require_ZipFS();
    var watchFile_1 = require_watchFile();
    var errors = tslib_1.__importStar(require_errors());
    var path_1 = require_path();
    var ZIP_MASK = 4278190080;
    var ZIP_MAGIC = 704643072;
    var getArchivePart = /* @__PURE__ */ __name((path, extension) => {
      let idx = path.indexOf(extension);
      if (idx <= 0)
        return null;
      let nextCharIdx = idx;
      while (idx >= 0) {
        nextCharIdx = idx + extension.length;
        if (path[nextCharIdx] === path_1.ppath.sep)
          break;
        if (path[idx - 1] === path_1.ppath.sep)
          return null;
        idx = path.indexOf(extension, nextCharIdx);
      }
      if (path.length > nextCharIdx && path[nextCharIdx] !== path_1.ppath.sep)
        return null;
      return path.slice(0, nextCharIdx);
    }, "getArchivePart");
    exports.getArchivePart = getArchivePart;
    var ZipOpenFS2 = class _ZipOpenFS extends FakeFS_1.BasePortableFakeFS {
      static {
        __name(this, "ZipOpenFS");
      }
      static async openPromise(fn, opts) {
        const zipOpenFs = new _ZipOpenFS(opts);
        try {
          return await fn(zipOpenFs);
        } finally {
          zipOpenFs.saveAndClose();
        }
      }
      get libzip() {
        if (typeof this.libzipInstance === `undefined`)
          this.libzipInstance = this.libzipFactory();
        return this.libzipInstance;
      }
      constructor({ libzip, baseFs = new NodeFS_1.NodeFS(), filter = null, maxOpenFiles = Infinity, readOnlyArchives = false, useCache = true, maxAge = 5e3, fileExtensions = null }) {
        super();
        this.fdMap = /* @__PURE__ */ new Map();
        this.nextFd = 3;
        this.isZip = /* @__PURE__ */ new Set();
        this.notZip = /* @__PURE__ */ new Set();
        this.realPaths = /* @__PURE__ */ new Map();
        this.limitOpenFilesTimeout = null;
        this.libzipFactory = typeof libzip !== `function` ? () => libzip : libzip;
        this.baseFs = baseFs;
        this.zipInstances = useCache ? /* @__PURE__ */ new Map() : null;
        this.filter = filter;
        this.maxOpenFiles = maxOpenFiles;
        this.readOnlyArchives = readOnlyArchives;
        this.maxAge = maxAge;
        this.fileExtensions = fileExtensions;
      }
      getExtractHint(hints) {
        return this.baseFs.getExtractHint(hints);
      }
      getRealPath() {
        return this.baseFs.getRealPath();
      }
      saveAndClose() {
        (0, watchFile_1.unwatchAllFiles)(this);
        if (this.zipInstances) {
          for (const [path, { zipFs }] of this.zipInstances.entries()) {
            zipFs.saveAndClose();
            this.zipInstances.delete(path);
          }
        }
      }
      discardAndClose() {
        (0, watchFile_1.unwatchAllFiles)(this);
        if (this.zipInstances) {
          for (const [path, { zipFs }] of this.zipInstances.entries()) {
            zipFs.discardAndClose();
            this.zipInstances.delete(path);
          }
        }
      }
      resolve(p) {
        return this.baseFs.resolve(p);
      }
      remapFd(zipFs, fd) {
        const remappedFd = this.nextFd++ | ZIP_MAGIC;
        this.fdMap.set(remappedFd, [zipFs, fd]);
        return remappedFd;
      }
      async openPromise(p, flags, mode) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.openPromise(p, flags, mode);
        }, async (zipFs, { subPath }) => {
          return this.remapFd(zipFs, await zipFs.openPromise(subPath, flags, mode));
        });
      }
      openSync(p, flags, mode) {
        return this.makeCallSync(p, () => {
          return this.baseFs.openSync(p, flags, mode);
        }, (zipFs, { subPath }) => {
          return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
        });
      }
      async opendirPromise(p, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.opendirPromise(p, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.opendirPromise(subPath, opts);
        }, {
          requireSubpath: false
        });
      }
      opendirSync(p, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.opendirSync(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.opendirSync(subPath, opts);
        }, {
          requireSubpath: false
        });
      }
      async readPromise(fd, buffer, offset, length, position) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return await this.baseFs.readPromise(fd, buffer, offset, length, position);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`read`);
        const [zipFs, realFd] = entry;
        return await zipFs.readPromise(realFd, buffer, offset, length, position);
      }
      readSync(fd, buffer, offset, length, position) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.readSync(fd, buffer, offset, length, position);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`readSync`);
        const [zipFs, realFd] = entry;
        return zipFs.readSync(realFd, buffer, offset, length, position);
      }
      async writePromise(fd, buffer, offset, length, position) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC) {
          if (typeof buffer === `string`) {
            return await this.baseFs.writePromise(fd, buffer, offset);
          } else {
            return await this.baseFs.writePromise(fd, buffer, offset, length, position);
          }
        }
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`write`);
        const [zipFs, realFd] = entry;
        if (typeof buffer === `string`) {
          return await zipFs.writePromise(realFd, buffer, offset);
        } else {
          return await zipFs.writePromise(realFd, buffer, offset, length, position);
        }
      }
      writeSync(fd, buffer, offset, length, position) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC) {
          if (typeof buffer === `string`) {
            return this.baseFs.writeSync(fd, buffer, offset);
          } else {
            return this.baseFs.writeSync(fd, buffer, offset, length, position);
          }
        }
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`writeSync`);
        const [zipFs, realFd] = entry;
        if (typeof buffer === `string`) {
          return zipFs.writeSync(realFd, buffer, offset);
        } else {
          return zipFs.writeSync(realFd, buffer, offset, length, position);
        }
      }
      async closePromise(fd) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return await this.baseFs.closePromise(fd);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`close`);
        this.fdMap.delete(fd);
        const [zipFs, realFd] = entry;
        return await zipFs.closePromise(realFd);
      }
      closeSync(fd) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.closeSync(fd);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`closeSync`);
        this.fdMap.delete(fd);
        const [zipFs, realFd] = entry;
        return zipFs.closeSync(realFd);
      }
      createReadStream(p, opts) {
        if (p === null)
          return this.baseFs.createReadStream(p, opts);
        return this.makeCallSync(p, () => {
          return this.baseFs.createReadStream(p, opts);
        }, (zipFs, { archivePath, subPath }) => {
          const stream = zipFs.createReadStream(subPath, opts);
          stream.path = path_1.npath.fromPortablePath(this.pathUtils.join(archivePath, subPath));
          return stream;
        });
      }
      createWriteStream(p, opts) {
        if (p === null)
          return this.baseFs.createWriteStream(p, opts);
        return this.makeCallSync(p, () => {
          return this.baseFs.createWriteStream(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.createWriteStream(subPath, opts);
        });
      }
      async realpathPromise(p) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.realpathPromise(p);
        }, async (zipFs, { archivePath, subPath }) => {
          let realArchivePath = this.realPaths.get(archivePath);
          if (typeof realArchivePath === `undefined`) {
            realArchivePath = await this.baseFs.realpathPromise(archivePath);
            this.realPaths.set(archivePath, realArchivePath);
          }
          return this.pathUtils.join(realArchivePath, this.pathUtils.relative(path_1.PortablePath.root, await zipFs.realpathPromise(subPath)));
        });
      }
      realpathSync(p) {
        return this.makeCallSync(p, () => {
          return this.baseFs.realpathSync(p);
        }, (zipFs, { archivePath, subPath }) => {
          let realArchivePath = this.realPaths.get(archivePath);
          if (typeof realArchivePath === `undefined`) {
            realArchivePath = this.baseFs.realpathSync(archivePath);
            this.realPaths.set(archivePath, realArchivePath);
          }
          return this.pathUtils.join(realArchivePath, this.pathUtils.relative(path_1.PortablePath.root, zipFs.realpathSync(subPath)));
        });
      }
      async existsPromise(p) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.existsPromise(p);
        }, async (zipFs, { subPath }) => {
          return await zipFs.existsPromise(subPath);
        });
      }
      existsSync(p) {
        return this.makeCallSync(p, () => {
          return this.baseFs.existsSync(p);
        }, (zipFs, { subPath }) => {
          return zipFs.existsSync(subPath);
        });
      }
      async accessPromise(p, mode) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.accessPromise(p, mode);
        }, async (zipFs, { subPath }) => {
          return await zipFs.accessPromise(subPath, mode);
        });
      }
      accessSync(p, mode) {
        return this.makeCallSync(p, () => {
          return this.baseFs.accessSync(p, mode);
        }, (zipFs, { subPath }) => {
          return zipFs.accessSync(subPath, mode);
        });
      }
      async statPromise(p, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.statPromise(p, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.statPromise(subPath, opts);
        });
      }
      statSync(p, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.statSync(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.statSync(subPath, opts);
        });
      }
      async fstatPromise(fd, opts) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.fstatPromise(fd, opts);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fstat`);
        const [zipFs, realFd] = entry;
        return zipFs.fstatPromise(realFd, opts);
      }
      fstatSync(fd, opts) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.fstatSync(fd, opts);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fstatSync`);
        const [zipFs, realFd] = entry;
        return zipFs.fstatSync(realFd, opts);
      }
      async lstatPromise(p, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.lstatPromise(p, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.lstatPromise(subPath, opts);
        });
      }
      lstatSync(p, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.lstatSync(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.lstatSync(subPath, opts);
        });
      }
      async fchmodPromise(fd, mask) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.fchmodPromise(fd, mask);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fchmod`);
        const [zipFs, realFd] = entry;
        return zipFs.fchmodPromise(realFd, mask);
      }
      fchmodSync(fd, mask) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.fchmodSync(fd, mask);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fchmodSync`);
        const [zipFs, realFd] = entry;
        return zipFs.fchmodSync(realFd, mask);
      }
      async chmodPromise(p, mask) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.chmodPromise(p, mask);
        }, async (zipFs, { subPath }) => {
          return await zipFs.chmodPromise(subPath, mask);
        });
      }
      chmodSync(p, mask) {
        return this.makeCallSync(p, () => {
          return this.baseFs.chmodSync(p, mask);
        }, (zipFs, { subPath }) => {
          return zipFs.chmodSync(subPath, mask);
        });
      }
      async fchownPromise(fd, uid, gid) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.fchownPromise(fd, uid, gid);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fchown`);
        const [zipFs, realFd] = entry;
        return zipFs.fchownPromise(realFd, uid, gid);
      }
      fchownSync(fd, uid, gid) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.fchownSync(fd, uid, gid);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`fchownSync`);
        const [zipFs, realFd] = entry;
        return zipFs.fchownSync(realFd, uid, gid);
      }
      async chownPromise(p, uid, gid) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.chownPromise(p, uid, gid);
        }, async (zipFs, { subPath }) => {
          return await zipFs.chownPromise(subPath, uid, gid);
        });
      }
      chownSync(p, uid, gid) {
        return this.makeCallSync(p, () => {
          return this.baseFs.chownSync(p, uid, gid);
        }, (zipFs, { subPath }) => {
          return zipFs.chownSync(subPath, uid, gid);
        });
      }
      async renamePromise(oldP, newP) {
        return await this.makeCallPromise(oldP, async () => {
          return await this.makeCallPromise(newP, async () => {
            return await this.baseFs.renamePromise(oldP, newP);
          }, async () => {
            throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
          });
        }, async (zipFsO, { subPath: subPathO }) => {
          return await this.makeCallPromise(newP, async () => {
            throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
          }, async (zipFsN, { subPath: subPathN }) => {
            if (zipFsO !== zipFsN) {
              throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
            } else {
              return await zipFsO.renamePromise(subPathO, subPathN);
            }
          });
        });
      }
      renameSync(oldP, newP) {
        return this.makeCallSync(oldP, () => {
          return this.makeCallSync(newP, () => {
            return this.baseFs.renameSync(oldP, newP);
          }, () => {
            throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
          });
        }, (zipFsO, { subPath: subPathO }) => {
          return this.makeCallSync(newP, () => {
            throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
          }, (zipFsN, { subPath: subPathN }) => {
            if (zipFsO !== zipFsN) {
              throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
            } else {
              return zipFsO.renameSync(subPathO, subPathN);
            }
          });
        });
      }
      async copyFilePromise(sourceP, destP, flags = 0) {
        const fallback = /* @__PURE__ */ __name(async (sourceFs, sourceP2, destFs, destP2) => {
          if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
            throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP2}' -> ${destP2}'`), { code: `EXDEV` });
          if (flags & fs_1.constants.COPYFILE_EXCL && await this.existsPromise(sourceP2))
            throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP2}' -> '${destP2}'`), { code: `EEXIST` });
          let content;
          try {
            content = await sourceFs.readFilePromise(sourceP2);
          } catch (error) {
            throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP2}' -> '${destP2}'`), { code: `EINVAL` });
          }
          await destFs.writeFilePromise(destP2, content);
        }, "fallback");
        return await this.makeCallPromise(sourceP, async () => {
          return await this.makeCallPromise(destP, async () => {
            return await this.baseFs.copyFilePromise(sourceP, destP, flags);
          }, async (zipFsD, { subPath: subPathD }) => {
            return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
          });
        }, async (zipFsS, { subPath: subPathS }) => {
          return await this.makeCallPromise(destP, async () => {
            return await fallback(zipFsS, subPathS, this.baseFs, destP);
          }, async (zipFsD, { subPath: subPathD }) => {
            if (zipFsS !== zipFsD) {
              return await fallback(zipFsS, subPathS, zipFsD, subPathD);
            } else {
              return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
            }
          });
        });
      }
      copyFileSync(sourceP, destP, flags = 0) {
        const fallback = /* @__PURE__ */ __name((sourceFs, sourceP2, destFs, destP2) => {
          if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
            throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP2}' -> ${destP2}'`), { code: `EXDEV` });
          if (flags & fs_1.constants.COPYFILE_EXCL && this.existsSync(sourceP2))
            throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP2}' -> '${destP2}'`), { code: `EEXIST` });
          let content;
          try {
            content = sourceFs.readFileSync(sourceP2);
          } catch (error) {
            throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP2}' -> '${destP2}'`), { code: `EINVAL` });
          }
          destFs.writeFileSync(destP2, content);
        }, "fallback");
        return this.makeCallSync(sourceP, () => {
          return this.makeCallSync(destP, () => {
            return this.baseFs.copyFileSync(sourceP, destP, flags);
          }, (zipFsD, { subPath: subPathD }) => {
            return fallback(this.baseFs, sourceP, zipFsD, subPathD);
          });
        }, (zipFsS, { subPath: subPathS }) => {
          return this.makeCallSync(destP, () => {
            return fallback(zipFsS, subPathS, this.baseFs, destP);
          }, (zipFsD, { subPath: subPathD }) => {
            if (zipFsS !== zipFsD) {
              return fallback(zipFsS, subPathS, zipFsD, subPathD);
            } else {
              return zipFsS.copyFileSync(subPathS, subPathD, flags);
            }
          });
        });
      }
      async appendFilePromise(p, content, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.appendFilePromise(p, content, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.appendFilePromise(subPath, content, opts);
        });
      }
      appendFileSync(p, content, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.appendFileSync(p, content, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.appendFileSync(subPath, content, opts);
        });
      }
      async writeFilePromise(p, content, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.writeFilePromise(p, content, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.writeFilePromise(subPath, content, opts);
        });
      }
      writeFileSync(p, content, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.writeFileSync(p, content, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.writeFileSync(subPath, content, opts);
        });
      }
      async unlinkPromise(p) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.unlinkPromise(p);
        }, async (zipFs, { subPath }) => {
          return await zipFs.unlinkPromise(subPath);
        });
      }
      unlinkSync(p) {
        return this.makeCallSync(p, () => {
          return this.baseFs.unlinkSync(p);
        }, (zipFs, { subPath }) => {
          return zipFs.unlinkSync(subPath);
        });
      }
      async utimesPromise(p, atime, mtime) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.utimesPromise(p, atime, mtime);
        }, async (zipFs, { subPath }) => {
          return await zipFs.utimesPromise(subPath, atime, mtime);
        });
      }
      utimesSync(p, atime, mtime) {
        return this.makeCallSync(p, () => {
          return this.baseFs.utimesSync(p, atime, mtime);
        }, (zipFs, { subPath }) => {
          return zipFs.utimesSync(subPath, atime, mtime);
        });
      }
      async mkdirPromise(p, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.mkdirPromise(p, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.mkdirPromise(subPath, opts);
        });
      }
      mkdirSync(p, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.mkdirSync(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.mkdirSync(subPath, opts);
        });
      }
      async rmdirPromise(p, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.rmdirPromise(p, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.rmdirPromise(subPath, opts);
        });
      }
      rmdirSync(p, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.rmdirSync(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.rmdirSync(subPath, opts);
        });
      }
      async linkPromise(existingP, newP) {
        return await this.makeCallPromise(newP, async () => {
          return await this.baseFs.linkPromise(existingP, newP);
        }, async (zipFs, { subPath }) => {
          return await zipFs.linkPromise(existingP, subPath);
        });
      }
      linkSync(existingP, newP) {
        return this.makeCallSync(newP, () => {
          return this.baseFs.linkSync(existingP, newP);
        }, (zipFs, { subPath }) => {
          return zipFs.linkSync(existingP, subPath);
        });
      }
      async symlinkPromise(target, p, type) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.symlinkPromise(target, p, type);
        }, async (zipFs, { subPath }) => {
          return await zipFs.symlinkPromise(target, subPath);
        });
      }
      symlinkSync(target, p, type) {
        return this.makeCallSync(p, () => {
          return this.baseFs.symlinkSync(target, p, type);
        }, (zipFs, { subPath }) => {
          return zipFs.symlinkSync(target, subPath);
        });
      }
      async readFilePromise(p, encoding) {
        return this.makeCallPromise(p, async () => {
          switch (encoding) {
            case `utf8`:
              return await this.baseFs.readFilePromise(p, encoding);
            default:
              return await this.baseFs.readFilePromise(p, encoding);
          }
        }, async (zipFs, { subPath }) => {
          return await zipFs.readFilePromise(subPath, encoding);
        });
      }
      readFileSync(p, encoding) {
        return this.makeCallSync(p, () => {
          switch (encoding) {
            case `utf8`:
              return this.baseFs.readFileSync(p, encoding);
            default:
              return this.baseFs.readFileSync(p, encoding);
          }
        }, (zipFs, { subPath }) => {
          return zipFs.readFileSync(subPath, encoding);
        });
      }
      async readdirPromise(p, opts) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.readdirPromise(p, opts);
        }, async (zipFs, { subPath }) => {
          return await zipFs.readdirPromise(subPath, opts);
        }, {
          requireSubpath: false
        });
      }
      readdirSync(p, opts) {
        return this.makeCallSync(p, () => {
          return this.baseFs.readdirSync(p, opts);
        }, (zipFs, { subPath }) => {
          return zipFs.readdirSync(subPath, opts);
        }, {
          requireSubpath: false
        });
      }
      async readlinkPromise(p) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.readlinkPromise(p);
        }, async (zipFs, { subPath }) => {
          return await zipFs.readlinkPromise(subPath);
        });
      }
      readlinkSync(p) {
        return this.makeCallSync(p, () => {
          return this.baseFs.readlinkSync(p);
        }, (zipFs, { subPath }) => {
          return zipFs.readlinkSync(subPath);
        });
      }
      async truncatePromise(p, len) {
        return await this.makeCallPromise(p, async () => {
          return await this.baseFs.truncatePromise(p, len);
        }, async (zipFs, { subPath }) => {
          return await zipFs.truncatePromise(subPath, len);
        });
      }
      truncateSync(p, len) {
        return this.makeCallSync(p, () => {
          return this.baseFs.truncateSync(p, len);
        }, (zipFs, { subPath }) => {
          return zipFs.truncateSync(subPath, len);
        });
      }
      async ftruncatePromise(fd, len) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.ftruncatePromise(fd, len);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`ftruncate`);
        const [zipFs, realFd] = entry;
        return zipFs.ftruncatePromise(realFd, len);
      }
      ftruncateSync(fd, len) {
        if ((fd & ZIP_MASK) !== ZIP_MAGIC)
          return this.baseFs.ftruncateSync(fd, len);
        const entry = this.fdMap.get(fd);
        if (typeof entry === `undefined`)
          throw errors.EBADF(`ftruncateSync`);
        const [zipFs, realFd] = entry;
        return zipFs.ftruncateSync(realFd, len);
      }
      watch(p, a, b) {
        return this.makeCallSync(p, () => {
          return this.baseFs.watch(
            p,
            // @ts-expect-error
            a,
            b
          );
        }, (zipFs, { subPath }) => {
          return zipFs.watch(
            subPath,
            // @ts-expect-error
            a,
            b
          );
        });
      }
      watchFile(p, a, b) {
        return this.makeCallSync(p, () => {
          return this.baseFs.watchFile(
            p,
            // @ts-expect-error
            a,
            b
          );
        }, () => {
          return (0, watchFile_1.watchFile)(this, p, a, b);
        });
      }
      unwatchFile(p, cb) {
        return this.makeCallSync(p, () => {
          return this.baseFs.unwatchFile(p, cb);
        }, () => {
          return (0, watchFile_1.unwatchFile)(this, p, cb);
        });
      }
      async makeCallPromise(p, discard, accept, { requireSubpath = true } = {}) {
        if (typeof p !== `string`)
          return await discard();
        const normalizedP = this.resolve(p);
        const zipInfo = this.findZip(normalizedP);
        if (!zipInfo)
          return await discard();
        if (requireSubpath && zipInfo.subPath === `/`)
          return await discard();
        return await this.getZipPromise(zipInfo.archivePath, async (zipFs) => await accept(zipFs, zipInfo));
      }
      makeCallSync(p, discard, accept, { requireSubpath = true } = {}) {
        if (typeof p !== `string`)
          return discard();
        const normalizedP = this.resolve(p);
        const zipInfo = this.findZip(normalizedP);
        if (!zipInfo)
          return discard();
        if (requireSubpath && zipInfo.subPath === `/`)
          return discard();
        return this.getZipSync(zipInfo.archivePath, (zipFs) => accept(zipFs, zipInfo));
      }
      findZip(p) {
        if (this.filter && !this.filter.test(p))
          return null;
        let filePath = ``;
        while (true) {
          const pathPartWithArchive = p.substring(filePath.length);
          let archivePart;
          if (!this.fileExtensions) {
            archivePart = (0, exports.getArchivePart)(pathPartWithArchive, `.zip`);
          } else {
            for (const ext of this.fileExtensions) {
              archivePart = (0, exports.getArchivePart)(pathPartWithArchive, ext);
              if (archivePart) {
                break;
              }
            }
          }
          if (!archivePart)
            return null;
          filePath = this.pathUtils.join(filePath, archivePart);
          if (this.isZip.has(filePath) === false) {
            if (this.notZip.has(filePath))
              continue;
            try {
              if (!this.baseFs.lstatSync(filePath).isFile()) {
                this.notZip.add(filePath);
                continue;
              }
            } catch {
              return null;
            }
            this.isZip.add(filePath);
          }
          return {
            archivePath: filePath,
            subPath: this.pathUtils.join(path_1.PortablePath.root, p.substring(filePath.length))
          };
        }
      }
      limitOpenFiles(max) {
        if (this.zipInstances === null)
          return;
        const now = Date.now();
        let nextExpiresAt = now + this.maxAge;
        let closeCount = max === null ? 0 : this.zipInstances.size - max;
        for (const [path, { zipFs, expiresAt, refCount }] of this.zipInstances.entries()) {
          if (refCount !== 0 || zipFs.hasOpenFileHandles()) {
            continue;
          } else if (now >= expiresAt) {
            zipFs.saveAndClose();
            this.zipInstances.delete(path);
            closeCount -= 1;
            continue;
          } else if (max === null || closeCount <= 0) {
            nextExpiresAt = expiresAt;
            break;
          }
          zipFs.saveAndClose();
          this.zipInstances.delete(path);
          closeCount -= 1;
        }
        if (this.limitOpenFilesTimeout === null && (max === null && this.zipInstances.size > 0 || max !== null)) {
          this.limitOpenFilesTimeout = setTimeout(() => {
            this.limitOpenFilesTimeout = null;
            this.limitOpenFiles(null);
          }, nextExpiresAt - now).unref();
        }
      }
      async getZipPromise(p, accept) {
        const getZipOptions = /* @__PURE__ */ __name(async () => ({
          baseFs: this.baseFs,
          libzip: this.libzip,
          readOnly: this.readOnlyArchives,
          stats: await this.baseFs.statPromise(p)
        }), "getZipOptions");
        if (this.zipInstances) {
          let cachedZipFs = this.zipInstances.get(p);
          if (!cachedZipFs) {
            const zipOptions = await getZipOptions();
            cachedZipFs = this.zipInstances.get(p);
            if (!cachedZipFs) {
              cachedZipFs = {
                zipFs: new ZipFS_1.ZipFS(p, zipOptions),
                expiresAt: 0,
                refCount: 0
              };
            }
          }
          this.zipInstances.delete(p);
          this.limitOpenFiles(this.maxOpenFiles - 1);
          this.zipInstances.set(p, cachedZipFs);
          cachedZipFs.expiresAt = Date.now() + this.maxAge;
          cachedZipFs.refCount += 1;
          try {
            return await accept(cachedZipFs.zipFs);
          } finally {
            cachedZipFs.refCount -= 1;
          }
        } else {
          const zipFs = new ZipFS_1.ZipFS(p, await getZipOptions());
          try {
            return await accept(zipFs);
          } finally {
            zipFs.saveAndClose();
          }
        }
      }
      getZipSync(p, accept) {
        const getZipOptions = /* @__PURE__ */ __name(() => ({
          baseFs: this.baseFs,
          libzip: this.libzip,
          readOnly: this.readOnlyArchives,
          stats: this.baseFs.statSync(p)
        }), "getZipOptions");
        if (this.zipInstances) {
          let cachedZipFs = this.zipInstances.get(p);
          if (!cachedZipFs) {
            cachedZipFs = {
              zipFs: new ZipFS_1.ZipFS(p, getZipOptions()),
              expiresAt: 0,
              refCount: 0
            };
          }
          this.zipInstances.delete(p);
          this.limitOpenFiles(this.maxOpenFiles - 1);
          this.zipInstances.set(p, cachedZipFs);
          cachedZipFs.expiresAt = Date.now() + this.maxAge;
          return accept(cachedZipFs.zipFs);
        } else {
          const zipFs = new ZipFS_1.ZipFS(p, getZipOptions());
          try {
            return accept(zipFs);
          } finally {
            zipFs.saveAndClose();
          }
        }
      }
    };
    exports.ZipOpenFS = ZipOpenFS2;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/NodePathFS.js
var require_NodePathFS = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/NodePathFS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodePathFS = void 0;
    var url_1 = __require("url");
    var util_1 = __require("util");
    var ProxiedFS_1 = require_ProxiedFS();
    var path_1 = require_path();
    var NodePathFS = class extends ProxiedFS_1.ProxiedFS {
      static {
        __name(this, "NodePathFS");
      }
      constructor(baseFs) {
        super(path_1.npath);
        this.baseFs = baseFs;
      }
      mapFromBase(path) {
        return path;
      }
      mapToBase(path) {
        if (typeof path === `string`)
          return path;
        if (path instanceof url_1.URL)
          return (0, url_1.fileURLToPath)(path);
        if (Buffer.isBuffer(path)) {
          const str = path.toString();
          if (Buffer.byteLength(str) !== path.byteLength)
            throw new Error(`Non-utf8 buffers are not supported at the moment. Please upvote the following issue if you encounter this error: https://github.com/yarnpkg/berry/issues/4942`);
          return str;
        }
        throw new Error(`Unsupported path type: ${(0, util_1.inspect)(path)}`);
      }
    };
    exports.NodePathFS = NodePathFS;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/patchFs/FileHandle.js
var require_FileHandle = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/patchFs/FileHandle.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileHandle = void 0;
    var readline_1 = __require("readline");
    var kBaseFs = Symbol(`kBaseFs`);
    var kFd = Symbol(`kFd`);
    var kClosePromise = Symbol(`kClosePromise`);
    var kCloseResolve = Symbol(`kCloseResolve`);
    var kCloseReject = Symbol(`kCloseReject`);
    var kRefs = Symbol(`kRefs`);
    var kRef = Symbol(`kRef`);
    var kUnref = Symbol(`kUnref`);
    var FileHandle = class {
      static {
        __name(this, "FileHandle");
      }
      constructor(fd, baseFs) {
        this[_a] = 1;
        this[_b] = void 0;
        this[_c] = void 0;
        this[_d] = void 0;
        this[kBaseFs] = baseFs;
        this[kFd] = fd;
      }
      get fd() {
        return this[kFd];
      }
      async appendFile(data, options) {
        var _e;
        try {
          this[kRef](this.appendFile);
          const encoding = (_e = typeof options === `string` ? options : options === null || options === void 0 ? void 0 : options.encoding) !== null && _e !== void 0 ? _e : void 0;
          return await this[kBaseFs].appendFilePromise(this.fd, data, encoding ? { encoding } : void 0);
        } finally {
          this[kUnref]();
        }
      }
      async chown(uid, gid) {
        try {
          this[kRef](this.chown);
          return await this[kBaseFs].fchownPromise(this.fd, uid, gid);
        } finally {
          this[kUnref]();
        }
      }
      async chmod(mode) {
        try {
          this[kRef](this.chmod);
          return await this[kBaseFs].fchmodPromise(this.fd, mode);
        } finally {
          this[kUnref]();
        }
      }
      createReadStream(options) {
        return this[kBaseFs].createReadStream(null, { ...options, fd: this.fd });
      }
      createWriteStream(options) {
        return this[kBaseFs].createWriteStream(null, { ...options, fd: this.fd });
      }
      // FIXME: Missing FakeFS version
      datasync() {
        throw new Error(`Method not implemented.`);
      }
      // FIXME: Missing FakeFS version
      sync() {
        throw new Error(`Method not implemented.`);
      }
      async read(bufferOrOptions, offset, length, position) {
        var _e, _f, _g;
        try {
          this[kRef](this.read);
          let buffer;
          if (!Buffer.isBuffer(bufferOrOptions)) {
            bufferOrOptions !== null && bufferOrOptions !== void 0 ? bufferOrOptions : bufferOrOptions = {};
            buffer = (_e = bufferOrOptions.buffer) !== null && _e !== void 0 ? _e : Buffer.alloc(16384);
            offset = bufferOrOptions.offset || 0;
            length = (_f = bufferOrOptions.length) !== null && _f !== void 0 ? _f : buffer.byteLength;
            position = (_g = bufferOrOptions.position) !== null && _g !== void 0 ? _g : null;
          } else {
            buffer = bufferOrOptions;
          }
          offset !== null && offset !== void 0 ? offset : offset = 0;
          length !== null && length !== void 0 ? length : length = 0;
          if (length === 0) {
            return {
              bytesRead: length,
              buffer
            };
          }
          const bytesRead = await this[kBaseFs].readPromise(this.fd, buffer, offset, length, position);
          return {
            bytesRead,
            buffer
          };
        } finally {
          this[kUnref]();
        }
      }
      async readFile(options) {
        var _e;
        try {
          this[kRef](this.readFile);
          const encoding = (_e = typeof options === `string` ? options : options === null || options === void 0 ? void 0 : options.encoding) !== null && _e !== void 0 ? _e : void 0;
          return await this[kBaseFs].readFilePromise(this.fd, encoding);
        } finally {
          this[kUnref]();
        }
      }
      readLines(options) {
        return (0, readline_1.createInterface)({
          input: this.createReadStream(options),
          crlfDelay: Infinity
        });
      }
      async stat(opts) {
        try {
          this[kRef](this.stat);
          return await this[kBaseFs].fstatPromise(this.fd, opts);
        } finally {
          this[kUnref]();
        }
      }
      async truncate(len) {
        try {
          this[kRef](this.truncate);
          return await this[kBaseFs].ftruncatePromise(this.fd, len);
        } finally {
          this[kUnref]();
        }
      }
      // FIXME: Missing FakeFS version
      utimes(atime, mtime) {
        throw new Error(`Method not implemented.`);
      }
      async writeFile(data, options) {
        var _e;
        try {
          this[kRef](this.writeFile);
          const encoding = (_e = typeof options === `string` ? options : options === null || options === void 0 ? void 0 : options.encoding) !== null && _e !== void 0 ? _e : void 0;
          await this[kBaseFs].writeFilePromise(this.fd, data, encoding);
        } finally {
          this[kUnref]();
        }
      }
      async write(...args) {
        try {
          this[kRef](this.write);
          if (ArrayBuffer.isView(args[0])) {
            const [buffer, offset, length, position] = args;
            const bytesWritten = await this[kBaseFs].writePromise(this.fd, buffer, offset !== null && offset !== void 0 ? offset : void 0, length !== null && length !== void 0 ? length : void 0, position !== null && position !== void 0 ? position : void 0);
            return { bytesWritten, buffer };
          } else {
            const [data, position, encoding] = args;
            const bytesWritten = await this[kBaseFs].writePromise(this.fd, data, position, encoding);
            return { bytesWritten, buffer: data };
          }
        } finally {
          this[kUnref]();
        }
      }
      // TODO: Use writev from FakeFS when that is implemented
      async writev(buffers, position) {
        try {
          this[kRef](this.writev);
          let bytesWritten = 0;
          if (typeof position !== `undefined`) {
            for (const buffer of buffers) {
              const writeResult = await this.write(buffer, void 0, void 0, position);
              bytesWritten += writeResult.bytesWritten;
              position += writeResult.bytesWritten;
            }
          } else {
            for (const buffer of buffers) {
              const writeResult = await this.write(buffer);
              bytesWritten += writeResult.bytesWritten;
            }
          }
          return {
            buffers,
            bytesWritten
          };
        } finally {
          this[kUnref]();
        }
      }
      // FIXME: Missing FakeFS version
      readv(buffers, position) {
        throw new Error(`Method not implemented.`);
      }
      close() {
        if (this[kFd] === -1)
          return Promise.resolve();
        if (this[kClosePromise])
          return this[kClosePromise];
        this[kRefs]--;
        if (this[kRefs] === 0) {
          const fd = this[kFd];
          this[kFd] = -1;
          this[kClosePromise] = this[kBaseFs].closePromise(fd).finally(() => {
            this[kClosePromise] = void 0;
          });
        } else {
          this[kClosePromise] = new Promise((resolve8, reject) => {
            this[kCloseResolve] = resolve8;
            this[kCloseReject] = reject;
          }).finally(() => {
            this[kClosePromise] = void 0;
            this[kCloseReject] = void 0;
            this[kCloseResolve] = void 0;
          });
        }
        return this[kClosePromise];
      }
      [(_a = kRefs, _b = kClosePromise, _c = kCloseResolve, _d = kCloseReject, kRef)](caller) {
        if (this[kFd] === -1) {
          const err = new Error(`file closed`);
          err.code = `EBADF`;
          err.syscall = caller.name;
          throw err;
        }
        this[kRefs]++;
      }
      [kUnref]() {
        this[kRefs]--;
        if (this[kRefs] === 0) {
          const fd = this[kFd];
          this[kFd] = -1;
          this[kBaseFs].closePromise(fd).then(this[kCloseResolve], this[kCloseReject]);
        }
      }
    };
    exports.FileHandle = FileHandle;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/patchFs/patchFs.js
var require_patchFs = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/patchFs/patchFs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendFs = exports.patchFs = void 0;
    var util_1 = __require("util");
    var NodePathFS_1 = require_NodePathFS();
    var FileHandle_1 = require_FileHandle();
    var SYNC_IMPLEMENTATIONS = /* @__PURE__ */ new Set([
      `accessSync`,
      `appendFileSync`,
      `createReadStream`,
      `createWriteStream`,
      `chmodSync`,
      `fchmodSync`,
      `chownSync`,
      `fchownSync`,
      `closeSync`,
      `copyFileSync`,
      `linkSync`,
      `lstatSync`,
      `fstatSync`,
      `lutimesSync`,
      `mkdirSync`,
      `openSync`,
      `opendirSync`,
      `readlinkSync`,
      `readFileSync`,
      `readdirSync`,
      `readlinkSync`,
      `realpathSync`,
      `renameSync`,
      `rmdirSync`,
      `statSync`,
      `symlinkSync`,
      `truncateSync`,
      `ftruncateSync`,
      `unlinkSync`,
      `unwatchFile`,
      `utimesSync`,
      `watch`,
      `watchFile`,
      `writeFileSync`,
      `writeSync`
    ]);
    var ASYNC_IMPLEMENTATIONS = /* @__PURE__ */ new Set([
      `accessPromise`,
      `appendFilePromise`,
      `fchmodPromise`,
      `chmodPromise`,
      `fchownPromise`,
      `chownPromise`,
      `closePromise`,
      `copyFilePromise`,
      `linkPromise`,
      `fstatPromise`,
      `lstatPromise`,
      `lutimesPromise`,
      `mkdirPromise`,
      `openPromise`,
      `opendirPromise`,
      `readdirPromise`,
      `realpathPromise`,
      `readFilePromise`,
      `readdirPromise`,
      `readlinkPromise`,
      `renamePromise`,
      `rmdirPromise`,
      `statPromise`,
      `symlinkPromise`,
      `truncatePromise`,
      `ftruncatePromise`,
      `unlinkPromise`,
      `utimesPromise`,
      `writeFilePromise`,
      `writeSync`
    ]);
    function patchFs(patchedFs, fakeFs) {
      fakeFs = new NodePathFS_1.NodePathFS(fakeFs);
      const setupFn = /* @__PURE__ */ __name((target, name, replacement) => {
        const orig = target[name];
        target[name] = replacement;
        if (typeof (orig === null || orig === void 0 ? void 0 : orig[util_1.promisify.custom]) !== `undefined`) {
          replacement[util_1.promisify.custom] = orig[util_1.promisify.custom];
        }
      }, "setupFn");
      {
        setupFn(patchedFs, `exists`, (p, ...args) => {
          const hasCallback = typeof args[args.length - 1] === `function`;
          const callback = hasCallback ? args.pop() : () => {
          };
          process.nextTick(() => {
            fakeFs.existsPromise(p).then((exists) => {
              callback(exists);
            }, () => {
              callback(false);
            });
          });
        });
        setupFn(patchedFs, `read`, (...args) => {
          let [fd, buffer, offset, length, position, callback] = args;
          if (args.length <= 3) {
            let options = {};
            if (args.length < 3) {
              callback = args[1];
            } else {
              options = args[1];
              callback = args[2];
            }
            ({
              buffer = Buffer.alloc(16384),
              offset = 0,
              length = buffer.byteLength,
              position
            } = options);
          }
          if (offset == null)
            offset = 0;
          length |= 0;
          if (length === 0) {
            process.nextTick(() => {
              callback(null, 0, buffer);
            });
            return;
          }
          if (position == null)
            position = -1;
          process.nextTick(() => {
            fakeFs.readPromise(fd, buffer, offset, length, position).then((bytesRead) => {
              callback(null, bytesRead, buffer);
            }, (error) => {
              callback(error, 0, buffer);
            });
          });
        });
        for (const fnName of ASYNC_IMPLEMENTATIONS) {
          const origName = fnName.replace(/Promise$/, ``);
          if (typeof patchedFs[origName] === `undefined`)
            continue;
          const fakeImpl = fakeFs[fnName];
          if (typeof fakeImpl === `undefined`)
            continue;
          const wrapper = /* @__PURE__ */ __name((...args) => {
            const hasCallback = typeof args[args.length - 1] === `function`;
            const callback = hasCallback ? args.pop() : () => {
            };
            process.nextTick(() => {
              fakeImpl.apply(fakeFs, args).then((result) => {
                callback(null, result);
              }, (error) => {
                callback(error);
              });
            });
          }, "wrapper");
          setupFn(patchedFs, origName, wrapper);
        }
        patchedFs.realpath.native = patchedFs.realpath;
      }
      {
        setupFn(patchedFs, `existsSync`, (p) => {
          try {
            return fakeFs.existsSync(p);
          } catch (error) {
            return false;
          }
        });
        setupFn(patchedFs, `readSync`, (...args) => {
          let [fd, buffer, offset, length, position] = args;
          if (args.length <= 3) {
            const options = args[2] || {};
            ({ offset = 0, length = buffer.byteLength, position } = options);
          }
          if (offset == null)
            offset = 0;
          length |= 0;
          if (length === 0)
            return 0;
          if (position == null)
            position = -1;
          return fakeFs.readSync(fd, buffer, offset, length, position);
        });
        for (const fnName of SYNC_IMPLEMENTATIONS) {
          const origName = fnName;
          if (typeof patchedFs[origName] === `undefined`)
            continue;
          const fakeImpl = fakeFs[fnName];
          if (typeof fakeImpl === `undefined`)
            continue;
          setupFn(patchedFs, origName, fakeImpl.bind(fakeFs));
        }
        patchedFs.realpathSync.native = patchedFs.realpathSync;
      }
      {
        const origEmitWarning = process.emitWarning;
        process.emitWarning = () => {
        };
        let patchedFsPromises;
        try {
          patchedFsPromises = patchedFs.promises;
        } finally {
          process.emitWarning = origEmitWarning;
        }
        if (typeof patchedFsPromises !== `undefined`) {
          for (const fnName of ASYNC_IMPLEMENTATIONS) {
            const origName = fnName.replace(/Promise$/, ``);
            if (typeof patchedFsPromises[origName] === `undefined`)
              continue;
            const fakeImpl = fakeFs[fnName];
            if (typeof fakeImpl === `undefined`)
              continue;
            if (fnName === `open`)
              continue;
            setupFn(patchedFsPromises, origName, (pathLike, ...args) => {
              if (pathLike instanceof FileHandle_1.FileHandle) {
                return pathLike[origName].apply(pathLike, args);
              } else {
                return fakeImpl.call(fakeFs, pathLike, ...args);
              }
            });
          }
          setupFn(patchedFsPromises, `open`, async (...args) => {
            const fd = await fakeFs.openPromise(...args);
            return new FileHandle_1.FileHandle(fd, fakeFs);
          });
        }
      }
      {
        patchedFs.read[util_1.promisify.custom] = async (fd, buffer, ...args) => {
          const res = fakeFs.readPromise(fd, buffer, ...args);
          return { bytesRead: await res, buffer };
        };
        patchedFs.write[util_1.promisify.custom] = async (fd, buffer, ...args) => {
          const res = fakeFs.writePromise(fd, buffer, ...args);
          return { bytesWritten: await res, buffer };
        };
      }
    }
    __name(patchFs, "patchFs");
    exports.patchFs = patchFs;
    function extendFs(realFs, fakeFs) {
      const patchedFs = Object.create(realFs);
      patchFs(patchedFs, fakeFs);
      return patchedFs;
    }
    __name(extendFs, "extendFs");
    exports.extendFs = extendFs;
  }
});

// ../node_modules/@yarnpkg/fslib/lib/xfs.js
var require_xfs = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/xfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xfs = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var os_1 = tslib_1.__importDefault(__require("os"));
    var NodeFS_1 = require_NodeFS();
    var path_1 = require_path();
    function getTempName(prefix) {
      const hash = Math.ceil(Math.random() * 4294967296).toString(16).padStart(8, `0`);
      return `${prefix}${hash}`;
    }
    __name(getTempName, "getTempName");
    var tmpdirs = /* @__PURE__ */ new Set();
    var tmpEnv = null;
    function initTmpEnv() {
      if (tmpEnv)
        return tmpEnv;
      const tmpdir2 = path_1.npath.toPortablePath(os_1.default.tmpdir());
      const realTmpdir = exports.xfs.realpathSync(tmpdir2);
      process.once(`exit`, () => {
        exports.xfs.rmtempSync();
      });
      return tmpEnv = {
        tmpdir: tmpdir2,
        realTmpdir
      };
    }
    __name(initTmpEnv, "initTmpEnv");
    exports.xfs = Object.assign(new NodeFS_1.NodeFS(), {
      detachTemp(p) {
        tmpdirs.delete(p);
      },
      mktempSync(cb) {
        const { tmpdir: tmpdir2, realTmpdir } = initTmpEnv();
        while (true) {
          const name = getTempName(`xfs-`);
          try {
            this.mkdirSync(path_1.ppath.join(tmpdir2, name));
          } catch (error) {
            if (error.code === `EEXIST`) {
              continue;
            } else {
              throw error;
            }
          }
          const realP = path_1.ppath.join(realTmpdir, name);
          tmpdirs.add(realP);
          if (typeof cb === `undefined`)
            return realP;
          try {
            return cb(realP);
          } finally {
            if (tmpdirs.has(realP)) {
              tmpdirs.delete(realP);
              try {
                this.removeSync(realP);
              } catch {
              }
            }
          }
        }
      },
      async mktempPromise(cb) {
        const { tmpdir: tmpdir2, realTmpdir } = initTmpEnv();
        while (true) {
          const name = getTempName(`xfs-`);
          try {
            await this.mkdirPromise(path_1.ppath.join(tmpdir2, name));
          } catch (error) {
            if (error.code === `EEXIST`) {
              continue;
            } else {
              throw error;
            }
          }
          const realP = path_1.ppath.join(realTmpdir, name);
          tmpdirs.add(realP);
          if (typeof cb === `undefined`)
            return realP;
          try {
            return await cb(realP);
          } finally {
            if (tmpdirs.has(realP)) {
              tmpdirs.delete(realP);
              try {
                await this.removePromise(realP);
              } catch {
              }
            }
          }
        }
      },
      async rmtempPromise() {
        await Promise.all(Array.from(tmpdirs.values()).map(async (p) => {
          try {
            await exports.xfs.removePromise(p, { maxRetries: 0 });
            tmpdirs.delete(p);
          } catch {
          }
        }));
      },
      rmtempSync() {
        for (const p of tmpdirs) {
          try {
            exports.xfs.removeSync(p);
            tmpdirs.delete(p);
          } catch {
          }
        }
      }
    });
  }
});

// ../node_modules/@yarnpkg/fslib/lib/index.js
var require_lib = __commonJS({
  "../node_modules/@yarnpkg/fslib/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xfs = exports.extendFs = exports.patchFs = exports.ZipOpenFS = exports.ZipFS = exports.VirtualFS = exports.ProxiedFS = exports.PosixFS = exports.NodeFS = exports.NoFS = exports.LazyFS = exports.JailFS = exports.CwdFS = exports.FakeFS = exports.AliasFS = exports.toFilename = exports.ppath = exports.npath = exports.Filename = exports.PortablePath = exports.DEFAULT_COMPRESSION_LEVEL = exports.normalizeLineEndings = exports.statUtils = exports.CustomDir = exports.opendir = exports.LinkStrategy = exports.constants = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants2 = tslib_1.__importStar(require_constants());
    exports.constants = constants2;
    var statUtils = tslib_1.__importStar(require_statUtils());
    exports.statUtils = statUtils;
    var copyPromise_1 = require_copyPromise();
    Object.defineProperty(exports, "LinkStrategy", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return copyPromise_1.LinkStrategy;
    }, "get") });
    var opendir_1 = require_opendir();
    Object.defineProperty(exports, "opendir", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return opendir_1.opendir;
    }, "get") });
    Object.defineProperty(exports, "CustomDir", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return opendir_1.CustomDir;
    }, "get") });
    var FakeFS_1 = require_FakeFS();
    Object.defineProperty(exports, "normalizeLineEndings", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return FakeFS_1.normalizeLineEndings;
    }, "get") });
    var ZipFS_1 = require_ZipFS();
    Object.defineProperty(exports, "DEFAULT_COMPRESSION_LEVEL", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ZipFS_1.DEFAULT_COMPRESSION_LEVEL;
    }, "get") });
    var path_1 = require_path();
    Object.defineProperty(exports, "PortablePath", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return path_1.PortablePath;
    }, "get") });
    Object.defineProperty(exports, "Filename", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return path_1.Filename;
    }, "get") });
    var path_2 = require_path();
    Object.defineProperty(exports, "npath", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return path_2.npath;
    }, "get") });
    Object.defineProperty(exports, "ppath", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return path_2.ppath;
    }, "get") });
    Object.defineProperty(exports, "toFilename", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return path_2.toFilename;
    }, "get") });
    var AliasFS_1 = require_AliasFS();
    Object.defineProperty(exports, "AliasFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return AliasFS_1.AliasFS;
    }, "get") });
    var FakeFS_2 = require_FakeFS();
    Object.defineProperty(exports, "FakeFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return FakeFS_2.FakeFS;
    }, "get") });
    var CwdFS_1 = require_CwdFS();
    Object.defineProperty(exports, "CwdFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return CwdFS_1.CwdFS;
    }, "get") });
    var JailFS_1 = require_JailFS();
    Object.defineProperty(exports, "JailFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return JailFS_1.JailFS;
    }, "get") });
    var LazyFS_1 = require_LazyFS();
    Object.defineProperty(exports, "LazyFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return LazyFS_1.LazyFS;
    }, "get") });
    var NoFS_1 = require_NoFS();
    Object.defineProperty(exports, "NoFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoFS_1.NoFS;
    }, "get") });
    var NodeFS_1 = require_NodeFS();
    Object.defineProperty(exports, "NodeFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NodeFS_1.NodeFS;
    }, "get") });
    var PosixFS_1 = require_PosixFS();
    Object.defineProperty(exports, "PosixFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return PosixFS_1.PosixFS;
    }, "get") });
    var ProxiedFS_1 = require_ProxiedFS();
    Object.defineProperty(exports, "ProxiedFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxiedFS_1.ProxiedFS;
    }, "get") });
    var VirtualFS_1 = require_VirtualFS();
    Object.defineProperty(exports, "VirtualFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return VirtualFS_1.VirtualFS;
    }, "get") });
    var ZipFS_2 = require_ZipFS();
    Object.defineProperty(exports, "ZipFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ZipFS_2.ZipFS;
    }, "get") });
    var ZipOpenFS_1 = require_ZipOpenFS();
    Object.defineProperty(exports, "ZipOpenFS", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ZipOpenFS_1.ZipOpenFS;
    }, "get") });
    var patchFs_1 = require_patchFs();
    Object.defineProperty(exports, "patchFs", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return patchFs_1.patchFs;
    }, "get") });
    Object.defineProperty(exports, "extendFs", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return patchFs_1.extendFs;
    }, "get") });
    var xfs_1 = require_xfs();
    Object.defineProperty(exports, "xfs", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return xfs_1.xfs;
    }, "get") });
  }
});

// ../node_modules/@yarnpkg/libzip/node_modules/tslib/tslib.es6.js
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate2,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __read: () => __read2,
  __rest: () => __rest2,
  __spread: () => __spread2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  __name(__, "__");
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest2(s, e) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve8) {
      resolve8(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve8, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve8(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, "sent"), trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      if (y = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
function __createBinding2(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
}
function __exportStar2(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread2() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read2(arguments[i]));
  return ar;
}
function __spreadArrays2() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await2(v) {
  return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  __name(verb, "verb");
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  __name(resume, "resume");
  function step(r) {
    r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle, "settle");
}
function __asyncDelegator2(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
  __name(verb, "verb");
}
function __asyncValues2(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve8, reject) {
        v = o[n](v), settle(resolve8, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve8, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve8({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
}
function __makeTemplateObject2(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar2(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet2(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics2, __assign2;
var init_tslib_es62 = __esm({
  "../node_modules/@yarnpkg/libzip/node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = /* @__PURE__ */ __name(function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    }, "extendStatics");
    __name(__extends2, "__extends");
    __assign2 = /* @__PURE__ */ __name(function() {
      __assign2 = Object.assign || /* @__PURE__ */ __name(function __assign3(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
        }
        return t2;
      }, "__assign");
      return __assign2.apply(this, arguments);
    }, "__assign");
    __name(__rest2, "__rest");
    __name(__decorate2, "__decorate");
    __name(__param2, "__param");
    __name(__metadata2, "__metadata");
    __name(__awaiter2, "__awaiter");
    __name(__generator2, "__generator");
    __name(__createBinding2, "__createBinding");
    __name(__exportStar2, "__exportStar");
    __name(__values2, "__values");
    __name(__read2, "__read");
    __name(__spread2, "__spread");
    __name(__spreadArrays2, "__spreadArrays");
    __name(__await2, "__await");
    __name(__asyncGenerator2, "__asyncGenerator");
    __name(__asyncDelegator2, "__asyncDelegator");
    __name(__asyncValues2, "__asyncValues");
    __name(__makeTemplateObject2, "__makeTemplateObject");
    __name(__importStar2, "__importStar");
    __name(__importDefault2, "__importDefault");
    __name(__classPrivateFieldGet2, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet2, "__classPrivateFieldSet");
  }
});

// ../node_modules/@yarnpkg/libzip/lib/libzipSync.js
var require_libzipSync = __commonJS({
  "../node_modules/@yarnpkg/libzip/lib/libzipSync.js"(exports, module) {
    var frozenFs = Object.assign({}, __require("fs"));
    var createModule = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
      return function(createModule2) {
        createModule2 = createModule2 || {};
        var Module = typeof createModule2 !== "undefined" ? createModule2 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve8, reject) {
          readyPromiseResolve = resolve8;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = /* @__PURE__ */ __name(function(status, toThrow) {
          throw toThrow;
        }, "quit_");
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = true;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        __name(locateFile, "locateFile");
        var read_, readBinary;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = /* @__PURE__ */ __name(function shell_read(filename, binary) {
            var ret = tryParseAsDataURI(filename);
            if (ret) {
              return binary ? ret : ret.toString();
            }
            if (!nodeFS) nodeFS = frozenFs;
            if (!nodePath) nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          }, "shell_read");
          readBinary = /* @__PURE__ */ __name(function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          }, "readBinary");
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          quit_ = /* @__PURE__ */ __name(function(status) {
            process["exit"](status);
          }, "quit_");
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else {
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"]) arguments_ = Module["arguments"];
        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        if (Module["quit"]) quit_ = Module["quit"];
        var STACK_ALIGN = 16;
        function alignMemory(size, factor) {
          if (!factor) factor = STACK_ALIGN;
          return Math.ceil(size / factor) * factor;
        }
        __name(alignMemory, "alignMemory");
        var tempRet0 = 0;
        var setTempRet0 = /* @__PURE__ */ __name(function(value) {
          tempRet0 = value;
        }, "setTempRet0");
        var wasmBinary;
        if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        function getValue(ptr, type, noSafe) {
          type = type || "i8";
          if (type.charAt(type.length - 1) === "*") type = "i32";
          switch (type) {
            case "i1":
              return HEAP8[ptr >> 0];
            case "i8":
              return HEAP8[ptr >> 0];
            case "i16":
              return HEAP16[ptr >> 1];
            case "i32":
              return HEAP32[ptr >> 2];
            case "i64":
              return HEAP32[ptr >> 2];
            case "float":
              return HEAPF32[ptr >> 2];
            case "double":
              return HEAPF64[ptr >> 3];
            default:
              abort("invalid type for getValue: " + type);
          }
          return null;
        }
        __name(getValue, "getValue");
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        __name(assert, "assert");
        function getCFunc(ident) {
          var func = Module["_" + ident];
          assert(
            func,
            "Cannot call unknown function " + ident + ", make sure it is exported"
          );
          return func;
        }
        __name(getCFunc, "getCFunc");
        function ccall(ident, returnType, argTypes, args, opts) {
          var toC = {
            string: /* @__PURE__ */ __name(function(str) {
              var ret2 = 0;
              if (str !== null && str !== void 0 && str !== 0) {
                var len = (str.length << 2) + 1;
                ret2 = stackAlloc(len);
                stringToUTF8(str, ret2, len);
              }
              return ret2;
            }, "string"),
            array: /* @__PURE__ */ __name(function(arr) {
              var ret2 = stackAlloc(arr.length);
              writeArrayToMemory(arr, ret2);
              return ret2;
            }, "array")
          };
          function convertReturnValue(ret2) {
            if (returnType === "string") return UTF8ToString(ret2);
            if (returnType === "boolean") return Boolean(ret2);
            return ret2;
          }
          __name(convertReturnValue, "convertReturnValue");
          var func = getCFunc(ident);
          var cArgs = [];
          var stack = 0;
          if (args) {
            for (var i = 0; i < args.length; i++) {
              var converter = toC[argTypes[i]];
              if (converter) {
                if (stack === 0) stack = stackSave();
                cArgs[i] = converter(args[i]);
              } else {
                cArgs[i] = args[i];
              }
            }
          }
          var ret = func.apply(null, cArgs);
          ret = convertReturnValue(ret);
          if (stack !== 0) stackRestore(stack);
          return ret;
        }
        __name(ccall, "ccall");
        function cwrap(ident, returnType, argTypes, opts) {
          argTypes = argTypes || [];
          var numericArgs = argTypes.every(function(type) {
            return type === "number";
          });
          var numericRet = returnType !== "string";
          if (numericRet && numericArgs && !opts) {
            return getCFunc(ident);
          }
          return function() {
            return ccall(ident, returnType, argTypes, arguments, opts);
          };
        }
        __name(cwrap, "cwrap");
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx, endPtr));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        __name(UTF8ArrayToString, "UTF8ArrayToString");
        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        __name(UTF8ToString, "UTF8ToString");
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0)) return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx) break;
              heap[outIdx++] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx) break;
              heap[outIdx++] = 192 | u >> 6;
              heap[outIdx++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx) break;
              heap[outIdx++] = 224 | u >> 12;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx) break;
              heap[outIdx++] = 240 | u >> 18;
              heap[outIdx++] = 128 | u >> 12 & 63;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        }
        __name(stringToUTF8Array, "stringToUTF8Array");
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        __name(stringToUTF8, "stringToUTF8");
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127) ++len;
            else if (u <= 2047) len += 2;
            else if (u <= 65535) len += 3;
            else len += 4;
          }
          return len;
        }
        __name(lengthBytesUTF8, "lengthBytesUTF8");
        function allocateUTF8(str) {
          var size = lengthBytesUTF8(str) + 1;
          var ret = _malloc(size);
          if (ret) stringToUTF8Array(str, HEAP8, ret, size);
          return ret;
        }
        __name(allocateUTF8, "allocateUTF8");
        function writeArrayToMemory(array, buffer2) {
          HEAP8.set(array, buffer2);
        }
        __name(writeArrayToMemory, "writeArrayToMemory");
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        __name(alignUp, "alignUp");
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        __name(preRun, "preRun");
        function initRuntime() {
          runtimeInitialized = true;
          if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
          TTY.init();
          callRuntimeCallbacks(__ATINIT__);
        }
        __name(initRuntime, "initRuntime");
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        __name(postRun, "postRun");
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        __name(addOnPreRun, "addOnPreRun");
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        __name(addOnInit, "addOnInit");
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        __name(addOnPostRun, "addOnPostRun");
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        __name(getUniqueRunDependency, "getUniqueRunDependency");
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        __name(addRunDependency, "addRunDependency");
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        __name(removeRunDependency, "removeRunDependency");
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          what += "";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        __name(abort, "abort");
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        __name(isDataURI, "isDataURI");
        var wasmBinaryFile = "data:application/octet-stream;base64,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ACgCFC0AAiAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQADIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhQtAAQgACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0ABSAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQAGIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhQtAAcgACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0ACCAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQAJIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhQtAAogACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0ACyAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQAMIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhQtAA0gACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0ADiAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQAPIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhRBEGo2AhQgACAAKAIIQQFrIgE2AgggAQ0ACyAAIAAoAhhB8f8DcDYCGCAAIAAoAgxB8f8DcDYCDAwBCwsgACgCEARAA0AgACgCEEEQTwRAIAAgACgCEEEQazYCECAAIAAoAhQtAAAgACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0AASAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQACIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhQtAAMgACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0ABCAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQAFIAAoAhhqNgIYIAAgACgCGCAAKAIMajYCDCAAIAAoAhQtAAYgACgCGGo2AhggACAAKAIYIAAoAgxqNgIMIAAgACgCFC0AByAAKAIYajYCGCAAIAAoAhggACgCDGo2AgwgACAAKAIULQAIIAAoAhhqNgIYIAAgACgCGCAAKAIMajYC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NgIYIAEoAgxCADcDICABKAIMQgA3AyggASgCDEEANgIwIAEoAgxBADYCNCABKAIMQQA2AjggASgCDEEANgI8IAEoAgxBADsBQCABKAIMQYCA2I14NgJEIAEoAgxCADcDSCABKAIMQQA7AVAgASgCDEEAOwFSIAEoAgxBADYCVAvSEwEBfyMAQbABayIDJAAgAyAANgKoASADIAE2AqQBIAMgAjYCoAEgA0EANgKQASADIAMoAqQBKAIwQQAQOjYClAEgAyADKAKkASgCOEEAEDo2ApgBAkACQAJAAkAgAygClAFBAkYEQCADKAKYAUEBRg0BCyADKAKUAUEBRgRAIAMoApgBQQJGDQELIAMoApQBQQJHDQEgAygCmAFBAkcNAQsgAygCpAEiACAALwEMQYAQcjsBDAwBCyADKAKkASIAIAAvAQxB/+8DcTsBDCADKAKUAUECRgRAIANB9eABIAMoAqQBKAIwIAMoAqgBQQhqEI4BNgKQASADKAKQAUUEQCADQX82AqwBDAMLCwJAIAMoAqABQYACcQ0AIAMoApgBQQJHDQAgA0H1xgEgAygCpAEoAjggAygCqAFBCGoQjgE2AkggAygCSEUEQCADKAKQARAjIANBfzYCrAEMAwsgAygCSCADKAKQATYCACADIAMoAkg2ApABCwsCQCADKAKkAS8BUkUEQCADKAKkASIAIAAvAQxB/v8DcTsBDAwBCyADKAKkASIAIAAvAQxBAXI7AQwLIAMgAygCpAEgAygCoAEQZUEBcToAhgEgAyADKAKgAUGACnFBgApHBH8gAy0AhgEFQQELQQFxOgCHASADAn9BASADKAKkAS8BUkGBAkYNABpBASADKAKkAS8BUkGCAkYNABogAygCpAEvAVJBgwJGC0EBcToAhQEgAy0AhwFBAXEEQCADIANBIGpCHBApNgIcIAMoAhxFBEAgAygCqAFBCGpBDkEAEBQgAygCkAEQIyADQX82AqwBDAILAkAgAygCoAFBgAJxBEACQCADKAKgAUGACHENACADKAKkASkDIEL/////D1YNACADKAKkASkDKEL/////D1gNAgsgAygCHCADKAKkASkDKBAtIAMoAhwgAygCpAEpAyAQLQwBCwJAAkAgAygCoAFBgAhxDQAgAygCpAEpAyBC/////w9WDQAgAygCpAEpAyhC/////w9WDQAgAygCpAEpA0hC/////w9YDQELIAMoAqQBKQMoQv////8PWgRAIAMoAhwgAygCpAEpAygQLQsgAygCpAEpAyBC/////w9aBEAgAygCHCADKAKkASkDIBAtCyADKAKkASkDSEL/////D1oEQCADKAIcIAMoAqQBKQNIEC0LCwsCfyMAQRBrIgAgAygCHDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFCADKAIcEBYgAygCkAEQIyADQX82AqwBDAILIANBAQJ/IwBBEGsiACADKAIcNgIMAn4gACgCDC0AAEEBcQRAIAAoAgwpAxAMAQtCAAunQf//A3ELIANBIGpBgAYQVTYCjAEgAygCHBAWIAMoAowBIAMoApABNgIAIAMgAygCjAE2ApABCyADLQCFAUEBcQRAIAMgA0EVakIHECk2AhAgAygCEEUEQCADKAKoAUEIakEOQQAQFCADKAKQARAjIANBfzYCrAEMAgsgAygCEEECEB8gAygCEEG9EkECEEEgAygCECADKAKkAS8BUkH/AXEQlgEgAygCECADKAKkASgCEEH//wNxEB8CfyMAQRBrIgAgAygCEDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFCADKAIQEBYgAygCkAEQIyADQX82AqwBDAILIANBgbICQQcgA0EVakGABhBVNgIMIAMoAhAQFiADKAIMIAMoApABNgIAIAMgAygCDDYCkAELIAMgA0HQAGpCLhApIgA2AkwgAEUEQCADKAKoAUEIakEOQQAQFCADKAKQARAjIANBfzYCrAEMAQsgAygCTEHxEkH2EiADKAKgAUGAAnEbQQQQQSADKAKgAUGAAnFFBEAgAygCTCADLQCGAUEBcQR/QS0FIAMoAqQBLwEIC0H//wNxEB8LIAMoAkwgAy0AhgFBAXEEf0EtBSADKAKkAS8BCgtB//8DcRAfIAMoAkwgAygCpAEvAQwQHwJAIAMtAIUBQQFxBEAgAygCTEHjABAfDAELIAMoAkwgAygCpAEoAhBB//8DcRAfCyADKAKkASgCFCADQZ4BaiADQZwBahCNASADKAJMIAMvAZ4BEB8gAygCTCADLwGcARAfAkACQCADLQCFAUEBcUUNACADKAKkASkDKEIUWg0AIAMoAkxBABAhDAELIAMoAkwgAygCpAEoAhgQIQsCQAJAIAMoAqABQYACcUGAAkcNACADKAKkASkDIEL/////D1QEQCADKAKkASkDKEL/////D1QNAQsgAygCTEF/ECEgAygCTEF/ECEMAQsCQCADKAKkASkDIEL/////D1QEQCADKAJMIAMoAqQBKQMgpxAhDAELIAMoAkxBfxAhCwJAIAMoAqQBKQMoQv////8PVARAIAMoAkwgAygCpAEpAyinECEMAQsgAygCTEF/ECELCyADKAJMIAMoAqQBKAIwEFFB//8DcRAfIAMgAygCpAEoAjQgAygCoAEQkgFB//8DcSADKAKQAUGABhCSAUH//wNxajYCiAEgAygCTCADKAKIAUH//wNxEB8gAygCoAFBgAJxRQRAIAMoAkwgAygCpAEoAjgQUUH//wNxEB8gAygCTCADKAKkASgCPEH//wNxEB8gAygCTCADKAKkAS8BQBAfIAMoAkwgAygCpAEoAkQQIQJAIAMoAqQBKQNIQv////8PVARAIAMoAkwgAygCpAEpA0inECEMAQsgAygCTEF/ECELCwJ/IwBBEGsiACADKAJMNgIMIAAoAgwtAABBAXFFCwRAIAMoAqgBQQhqQRRBABAUIAMoAkwQFiADKAKQARAjIANBfzYCrAEMAQsgAygCqAEgA0HQAGoCfiMAQRBrIgAgAygCTDYCDAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALCxA2QQBIBEAgAygCTBAWIAMoApABECMgA0F/NgKsAQwBCyADKAJMEBYgAygCpAEoAjAEQCADKAKoASADKAKkASgCMBCFAUEASARAIAMoApABECMgA0F/NgKsAQwCCwsgAygCkAEEQCADKAKoASADKAKQAUGABhCRAUEASARAIAMoApABECMgA0F/NgKsAQwCCwsgAygCkAEQIyADKAKkASgCNARAIAMoAqgBIAMoAqQBKAI0IAMoAqABEJEBQQBIBEAgA0F/NgKsAQwCCwsgAygCoAFBgAJxRQRAIAMoAqQBKAI4BEAgAygCqAEgAygCpAEoAjgQhQFBAEgEQCADQX82AqwBDAMLCwsgAyADLQCHAUEBcTYCrAELIAMoAqwBIQAgA0GwAWokACAAC+ACAQF/IwBBIGsiBCQAIAQgADsBGiAEIAE7ARggBCACNgIUIAQgAzYCECAEQRAQGCIANgIMAkAg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AAAgAygCHEHcFmogAygCDEECdGooAgAgAygCHEHYKGpqLQAASg0ADAELIAMoAhxB3BZqIAMoAhRBAnRqIAMoAhxB3BZqIAMoAgxBAnRqKAIANgIAIAMgAygCDDYCFCADIAMoAgxBAXQ2AgwMAQsLIAMoAhxB3BZqIAMoAhRBAnRqIAMoAhA2AgAL1xMBA38jAEEwayICJAAgAiAANgIsIAIgATYCKCACIAIoAigoAgA2AiQgAiACKAIoKAIIKAIANgIgIAIgAigCKCgCCCgCDDYCHCACQX82AhAgAigCLEEANgLQKCACKAIsQb0ENgLUKCACQQA2AhgDQCACKAIYIAIoAhxIBEACQCACKAIkIAIoAhhBAnRqLwEABEAgAiACKAIYIgE2AhAgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQAgBCAANgLQKCAAQQJ0IANqIAE2AgAgAigCGCACKAIsQdgoampBADoAAAwBCyACKAIkIAIoAhhBAnRqQQA7AQILIAIgAigCGEEBajYCGAwBCwsDQCACKAIsKALQKEECSARAAkAgAigCEEECSARAIAIgAigCEEEBaiIANgIQDAELQQAhAAsgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQEgBCABNgLQKCABQQJ0IANqIAA2AgAgAiAANgIMIAIoAiQgAigCDEECdGpBATsBACACKAIMIAIoAixB2ChqakEAOgAAIAIoAiwiACAAKAKoLUEBazYCqC0gAigCIARAIAIoAiwiACAAKAKsLSACKAIgIAIoAgxBAnRqLwECazYCrC0LDAELCyACKAIoIAIoAhA2AgQgAiACKAIsKALQKEECbTYCGANAIAIoAhhBAU4EQCACKAIsIAIoAiQgAigCGBB5IAIgAigCGEEBazYCGAwBCwsgAiACKAIcNgIMA0AgAiACKAIsKALgFjYCGCACKAIsQdwWaiEBIAIoAiwiAygC0CghACADIABBAWs2AtAoIAIoAiwgAEECdCABaigCADYC4BYgAigCLCACKAIkQQEQeSACIAIoAiwoAuAWNgIUIAIoAhghASACKAIsQdwWaiEDIAIoAiwiBCgC1ChBAWshACAEIAA2AtQoIABBAnQgA2ogATYCACACKAIUIQEgAigCLEHcFmohAyACKAIsIgQoAtQoQQFrIQAgBCAANgLUKCAA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AQsgAigCCEEANgIAIAIoAghCADcDECACKAIIQgA3AwggAigCCEIANwMgIAIoAghCADcDGCACKAIIQQA2AiggAigCCEEAOgAsIAIoAgggAikDECACKAIMEI8BQQFxRQRAIAIoAggQJSACQQA2AhwMAQsgAiACKAIINgIcCyACKAIcIQEgAkEgaiQAIAEL1gIBAX8jAEEgayIDJAAgAyAANgIYIAMgATYCFCADIAI2AhAgAyADQQxqQgQQKTYCCAJAIAMoAghFBEAgA0F/NgIcDAELA0AgAygCFARAIAMoAhQoAgQgAygCEHFBgAZxBEAgAygCCEIAECwaIAMoAgggAygCFC8BCBAfIAMoAgggAygCFC8BChAfAn8jAEEQayIAIAMoAgg2AgwgACgCDC0AAEEBcUULBEAgAygCGEEIakEUQQAQFCADKAIIEBYgA0F/NgIcDAQLIAMoAhggA0EMakIEEDZBAEgEQCADKAIIEBYgA0F/NgIcDAQLIAMoAhQvAQoEQCADKAIYIAMoAhQoAgwgAygCFC8BCq0QNkEASARAIAMoAggQFiADQX82AhwMBQsLCyADIAMoAhQoAgA2AhQMAQsLIAMoAggQFiADQQA2AhwLIAMoAhwhACADQSBqJAAgAAtoAQF/IwBBEGsiAiAANgIMIAIgATYCCCACQQA7AQYDQCACKAIMBEAgAigCDCgCBCACKAIIcUGABnEEQCACIAIoAgwvAQogAi8BBkEEamo7AQYLIAIgAigCDCgCADYCDAwBCwsgAi8BBgvwAQEBfyMAQRBrIgEkACABIAA2AgwgASABKAIMNgIIIAFBADYCBANAIAEoAgwEQAJAAkAgASgCDC8BCEH1xgFGDQAgASgCDC8BCEH14AFGDQAgASgCDC8BCEGBsgJGDQAgASgCDC8BCEEBRw0BCyABIAEoAgwoAgA2AgAgASgCCCABKAIMRgRAIAEgASgCADYCCAsgASgCDEEANgIAIAEoAgwQIyABKAIEBEAgASgCBCABKAIANgIACyABIAEoAgA2AgwMAgsgASABKAIMNgIEIAEgASgCDCgCADYCDAwBCwsgASgCCCEAIAFBEGokACAAC7IEAQF/IwBBQGoiBSQAIAUgADYCOCAFIAE7ATYgBSACNgIwIAUgAzYCLCAFIAQ2AiggBSAFKAI4IAUvATatECkiADYC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IAEoAhBB//8DRgRAIAEgASgCDDYCEAsgASgCCEH//wNGBEAgASABKAIENgIICwJAIAEoApQBQQRxRQ0AIAEoAgggASgCBEYEQCABKAIQIAEoAgxGDQELIAEoApABQRVBABAUIAEtABdBAXEEQCABKAKkARAWCyABQQA2AqwBDAELAkAgASgCEEUEQCABKAIIRQ0BCyABKAKQAUEBQQAQFCABLQAXQQFxBEAgASgCpAEQFgsgAUEANgKsAQwBCyABIAEoAqQBEDE3AyggASABKAKkARAxNwMgIAEpAyggASkDIFIEQCABKAKQAUEBQQAQFCABLQAXQQFxBEAgASgCpAEQFgsgAUEANgKsAQwBCyABIAEoAqQBEDE3AzAgASABKAKkARAxNwOAAQJ/IwBBEGsiBSABKAKkATYCDCAFKAIMLQAAQQFxRQsEQCABKAKQAUEUQQAQFCABLQAXQQFxBEAgASgCpAEQFgsgAUEANgKsAQwBCyABLQAXQQFxBEAgASgCpAEQFgsCQCABKQOAAUL///////////8AWARAIAEpA4ABIAEpA4ABIAEpAzB8WA0BCyABKAKQAUEEQRYQFCABQQA2AqwBDAELIAEpA4ABIAEpAzB8IAEpA5gBIAEpAzh8VgRAIAEoApABQRVBABAUIAFBADYCrAEMAQsCQCABKAKUAUEEcUUNACABKQOAASABKQMwfCABKQOYASABKQM4fFENACABKAKQAUEVQQAQFCABQQA2AqwBDAELIAEpAyggASkDMEIugFYEQCABKAKQAUEVQQAQFCABQQA2AqwBDAELIAEgASkDKCABKAKQARCQASIFNgKMASAFRQRAIAFBADYCrAEMAQsgASgCjAFBAToALCABKAKMASABKQMwNwMYIAEoAowBIAEpA4ABNwMgIAEgASgCjAE2AqwBCyABKAKsASEFIAFBsAFqJAAgACAFNgJQDAELIAAoAmQgACkDMBAsGiAAKAJkIQUgACkDWCEJIAAoAmgoAhQhBiAAKAJUIQcjAEHQAGsiASQAIAEgBTYCSCABIAk3A0AgASAGNgI8IAEgBzYCOAJAIAEoAkgQMEIWVARAIAEoAjhBFUEAEBQgAUEANgJMDAELIwBBEGsiBSABKAJINgIMIAECfiAFKAIMLQAAQQFxBEAgBSgCDCkDEAwBC0IACzcDCCABKAJI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ECADQcgAEBgiADYCDAJAIABFBEAgAygCEEEBQbSbASgCABAUIANBADYCHAwBCyADKAIMIAMoAhA2AgAgAygCDCADLQAbQQFxOgAEIAMoAgwgAygCFDYCCAJAIAMoAgwoAghBAU4EQCADKAIMKAIIQQlMDQELIAMoAgxBCTYCCAsgAygCDEEAOgAMIAMoAgxBADYCMCADKAIMQQA2AjQgAygCDEEANgI4IAMgAygCDDYCHAsgAygCHCEAIANBIGokACAACzgBAX8jAEEQayIBIAA2AgwgASgCDEEANgIAIAEoAgxBADYCBCABKAIMQQA2AgggASgCDEEAOgAMC+MIAQF/IwBBQGoiAiAANgI4IAIgATYCNCACIAIoAjgoAnw2AjAgAiACKAI4KAI4IAIoAjgoAmxqNgIsIAIgAigCOCgCeDYCICACIAIoAjgoApABNgIcIAICfyACKAI4KAJsIAIoAjgoAixBhgJrSwRAIAIoAjgoAmwgAigCOCgCLEGGAmtrDAELQQALNgIYIAIgAigCOCgCQDYCFCACIAIoAjgoAjQ2AhAgAiACKAI4KAI4IAIoAjgoAmxqQYICajYCDCACIAIoAiwgAigCIEEBa2otAAA6AAsgAiACKAIsIAIoAiBqLQAAOgAKIAIoAjgoAnggAigCOCgCjAFPBEAgAiACKAIwQQJ2NgIwCyACKAIcIAIoAjgoAnRLBEAgAiACKAI4KAJ0NgIcCwNAAkAgAiACKAI4KAI4IAIoAjRqNgIoAkAgAigCKCACKAIgai0AACACLQAKRw0AIAIoAiggAigCIEEBa2otAAAgAi0AC0cNACACKAIoLQAAIAIoAiwtAABHDQAgAiACKAIoIgBBAWo2AiggAC0AASACKAIsLQABRwRADAELIAIgAigCLEECajYCLCACIAIoAihBAWo2AigDQCACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AigCf0EAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACKAIsIAIoAgxJC0EBcQ0ACyACQYICIAIoAgwgAigCLGtrNgIkIAIgAigCDEGCAms2AiwgAigCJCACKAIgSgRAIAIoAjggAigCNDYCcCACIAIoAiQ2AiAgAigCJCACKAIcTg0CIAIgAigCLCACKAIgQQFrai0AADoACyACIAIoAiwgAigCIGotAAA6AAoLCyACIAIoAhQgAigCNCACKAIQcUEBdGovAQAiATYCNEEAIQAgASACKAIYSwR/IAIgAigCMEEBayIANgIwIABBAEcFQQALQQFxDQELCwJAIAIoAiAgAigCOCgCdE0EQCACIAIoAiA2AjwMAQsgAiACKAI4KAJ0NgI8CyACKAI8C5IQAQF/IwBBMGsiAiQAIAIgADYCKCACIAE2AiQgAgJ/IAIoAigoAiwgAigCKCgCDEEFa0kEQCACKAIoKAIsDAELIAIoAigoAgxBBWsLNgIgIAJBADYCECACIAIoAigoAgAoAgQ2AgwDQAJAIAJB//8DNgIcIAIgAigCKCgCvC1BKmpBA3U2AhQgAigCKCgCACgCECACKAIUSQ0AIAIgAigCKCgCACgCECACKAIUazYCFCACIAIoAigoAmwgAigCKCgCXGs2AhggAigCHCACKAIYIAIoAigoAgAoAgRqSwRAIAIgAigCGCACKAIoKAIAKAIEajYCHAsgAigCHCACKAIUSwRAIAIgAigCFDYCHAsCQCACKAIcIAIoAiBPDQACQCACKAIcRQRAIAIoAiRBBEcNAQsgAigCJEUNACACKAIcIAIoAhggAigCKCgCACgCBGpGDQELDAELQQAhACACIAIoAiRBBEYEfyACKAIcIAIoAhggAigCKCgCACgCBGpGBUEAC0EBcTYCECACKAIoQQBBACACKAIQEF0gAigCKCgCCCACKAIoKAIUQQRraiACKAIcOgAAIAIoAigoAgggAigCKCgCFEEDa2ogAigCHEEIdjoAACACKAIoKAIIIAIoAigoAhRBAmtqIAIoAhxBf3M6AAAgAigCKCgCCCACKAIoKAIUQQFraiACKAIcQX9zQQh2OgAAIAIoAigoAgAQHCACKAIYBEAgAigCGCACKAIcSwRAIAIgAigCHDYCGAsgAigCKCgCACgCDCACKAIoKAI4IAIoAigoAlxqIAIoAhgQGRogAigCKCgCACIAIAIoAhggACgCDGo2AgwgAigCKCgCACIAIAAoAhAgAigCGGs2AhAgAigCKCgCACIAIAIoAhggACgCFGo2AhQgAigCKCIAIAIoAhggACgCXGo2AlwgAiACKAIcIAIoAhhrNgIcCyACKAIcBEAgAigCKCgCACACKAIoKAIAKAIMIAIoAhwQdhogAigCKCgCACIAIAIoAhwgACgCDGo2AgwgAigCKCgCACIAIAAoAhAgAigCHGs2AhAgAigCKCgCACIAIAIoAhwgACgCFGo2AhQLIAIoAhBFDQELCyACIAIoAgwgAigCKCgCACgCBGs2AgwgAigCDARAAkAgAigCDCACKAIoKAIsTwRAIAIoAihBAjYCsC0gAigCKCgCOCACKAIoKAIAKAIAIAIoAigoAixrIAIoAigoAiwQGRogAigCKCACKAIoKAIsNgJsDAELIAIoAgwgAigCKCgCPCACKAIoKAJsa08EQCACKAIoIgAgACgCbCACKAIoKAIsazYCbCACKAIoKAI4IAIoAigoAjggAigCKCgCLGogAigCKCgCbBAZGiACKAIoKAKwLUECSQRAIAIoAigiACAAKAKwLUEBajYCsC0LCyACKAIoKAI4IAIoAigoAmxqIAIoAigoAgAoAgAgAigCDGsgAigCDBAZGiACKAIoIgAgAigCDCAAKAJsajYCbAsgAigCKCACKAIoKAJsNgJcIAIoAigiAQJ/IAIoAgwgAigCKCgCLCACKAIoKAK0LWtLBEAgAigCKCgCLCACKAIoKAK0LWsMAQsgAigCDAsgASgCtC1qNgK0LQsgAigCKCgCwC0gAigCKCgCbEkEQCACKAIoIAIoAigoAmw2AsAtCwJAIAIoAhAEQCACQQM2AiwMAQsCQCACKAIkRQ0AIAIoAiRBBEYNACACKAIoKAIAKAIEDQAgAigCKCgCbCACKAIoKAJcRw0AIAJBATYCLAwBCyACIAIoAigoAjwgAigCKCgCbGtBAWs2AhQCQCACKAIoKAIAKAIEIAIoAhRNDQAgAigCKCgCXCACKAIoKAIsSA0AIAIoAigiACAAKAJcIAIoAigoAixrNgJcIAIoAigiACAAKAJsIAIoAigoAixrNgJsIAIoAigoAjggAigCKCgCOCACKAIoKAIsaiACKAIoKAJsEBkaIAIoAigoArAtQQJJBEAgAigCKCIAIAAoArAtQQFqNgKwLQsgAiACKAIoKAIsIAIoAhRqNgIUCyACKAIUIAIoAigoAgAoAgRLBEAgAiACKAIoKAIAKAIENgIUCyACKAIUBEAgAigCKCgCACACKAIoKAI4IAIoAigoAmxqIAIoAhQQdhogAigCKCIAIAIoAhQgACgCbGo2AmwLIAIoAigoAsAtIAIoAigoAmxJBEAgAigCKCACKAIoKAJsNgLALQsgAiACKAIoKAK8LUEqakEDdTYCFCACIAIoAigoAgwgAigCFGtB//8DSwR/Qf//AwUgAigCKCgCDCACKAIUaws2AhQgAgJ/IAIoAhQgAigCKCgCLEsEQCACKAIoKAIsDAELIAIoAhQLNgIgIAIgAigCKCgCbCACKAIoKAJcazYCGAJAIAIoAhggAigCIEkEQCACKAIYRQRAIAIoAiRBBEcNAgsgAigCJEUNASACKAIoKAIAKAIEDQEgAigCGCACKAIUSw0BCyACAn8gAigCGCACKAIUSwRAIAIoAhQMAQsgAigCGAs2AhwgAgJ/QQAgAigCJEEERw0AGkEAIAIoAigoAgAoAgQNABogAigCHCACKAIYRgtBAXE2AhAgAigCKCACKAIoKAI4IAIoAigoAlxqIAIoAhwgAigCEBBdIAIoAigiACACKAIcIAAoAlxqNgJcIAIoAigoAgAQHAsgAkECQQAgAigCEBs2AiwLIAIoAiwhACACQTBqJAAgAAuyAgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEHgEQCABQX42AgwMAQsgASABKAIIKAIcKAIENgIEIAEoAggoAhwoAggEQCABKAIIKAIoIAEoAggoAhwoAgggASgCCCgCJBEEAAsgASgCCCgCHCgCRARAIAEoAggoAiggASgCCCgCHCgCRCABKAIIKAIkEQQACyABKAIIKAIc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DQAgAiEAIANBAWsiAw0ACwsgBCgCFBogASACNgKgAQwCCyMAQRBrIgAgASgCqAEoAgQ2AgwgAUEAIAAoAgxrQQJ0QajZAGooAgA2AqABDAELIAFBADYCoAELCwJAIAEoAqABRQRAIAEgASgCpAE2AqwBDAELIAEgASgCoAEQLgJ/IAEoAqQBBEAgASgCpAEQLkECagwBC0EAC2pBAWoQGCIANgIcIABFBEAgAUG4EygCADYCrAEMAQsgASgCHCEAAn8gASgCpAEEQCABKAKkAQwBC0H6EgshA0HfEkH6EiABKAKkARshAiABIAEoAqABNgIIIAEgAjYCBCABIAM2AgAgAEG+CiABEG8gASgCqAEgASgCHDYCCCABIAEoAhw2AqwBCyABKAKsASEAIAFBsAFqJAAgAAsIAEEBQTgQfwszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQGRogACAAKAIUIAFqNgIUIAILjwUCBn4BfyABIAEoAgBBD2pBcHEiAUEQajYCACAAAnwgASkDACEDIAEpAwghBiMAQSBrIggkAAJAIAZC////////////AIMiBEKAgICAgIDAgDx9IARCgICAgICAwP/DAH1UBEAgBkIEhiADQjyIhCEEIANC//////////8PgyIDQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQIMAgsgBEKAgICAgICAgEB9IQIgA0KAgICAgICAgAiFQgBSDQEgAiAEQgGDfCECDAELIANQIARCgICAgICAwP//AFQgBEKAgICAgIDA//8AURtFBEAgBkIEhiADQjyIhEL/////////A4NCgICAgICAgPz/AIQhAgwBC0KAgICAgICA+P8AIQIgBEL///////+//8MAVg0AQgAhAiAEQjCIpyIAQZH3AEkNACADIQIgBkL///////8/g0KAgICAgIDAAIQiBSEHAkAgAEGB9wBrIgFBwABxBEAgAiABQUBqrYYhB0IAIQIMAQsgAUUNACAHIAGtIgSGIAJBwAAgAWutiIQhByACIASGIQILIAggAjcDECAIIAc3AxgCQEGB+AAgAGsiAEHAAHEEQCAFIABBQGqtiCEDQgAhBQwBCyAARQ0AIAVBwAAgAGuthiADIACtIgKIhCEDIAUgAoghBQsgCCADNwMAIAggBTcDCCAIKQMIQgSGIAgpAwAiA0I8iIQhAiAIKQMQIAgpAxiEQgBSrSADQv//////////D4OEIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACIVCAFINACACQgGDIAJ8IQILIAhBIGokACACIAZCgICAgICAgICAf4OEvws5AwALrRcDEn8CfgF8IwBBsARrIgkkACAJQQA2AiwCQCABvSIYQn9XBEBBASESQa4IIRMgAZoiAb0hGAwBCyAEQYAQcQRAQQEhEkGxCCETDAELQbQIQa8IIARBAXEiEhshEyASRSEXCwJAIBhCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiASQQNqIg0gBEH//3txECYgACATIBIQIiAAQeQLQbUSIAVBIHEiAxtBjw1BuRIgAxsgASABYhtBAxAiDAELIAlBEGohEAJAAn8CQCABIAlBLGoQqQEiASABoCIBRAAAAAAAAAAAYgRAIAkgCSgCLCIGQQFrNgIsIAVBIHIiFEHhAEcNAQwDCyAFQSByIhRB4QBGDQIgCSgCLCELQQYgAyADQQBIGwwBCyAJIAZBHWsiCzYCLCABRAAAAAAAALBBoiEBQQYgAyADQQBIGwshCiAJQTBqIAlB0AJqIAtBAEgbIg4hBwNAIAcCfyABRAAAAAAAAPBBYyABRAAAAAAAAAAAZnEEQCABqwwBC0EACyIDNgIAIAdBBGohByABIAO4oUQAAAAAZc3NQaIiAUQAAAAAAAAAAGINAAsCQCALQQFIBEAgCyEDIAchBiAOIQgMAQsgDiEIIAshAwNAIANBHSADQR1IGyEMAkAgB0EEayIGIAhJDQAgDK0hGUIAIRgDQCAGIAY1AgAgGYYgGHwiGCAYQoCU69wDgCIYQoCU69wDfn0+AgAgCCAGQQRrIgZNBEAgGEL/////D4MhGAwBCwsgGKciA0UNACAIQQRrIgggAzYCAAsDQCAIIAciBkkEQCAGQQRrIgcoAgBFDQELCyAJIAkoAiwgDGsiAzYCLCAGIQcgA0EASg0ACwsgCkEZakEJbSEHIANBf0wEQCAHQQFqIQ0gFEHmAEYhFQNAQQlBACADayADQXdIGyEWAkAgBiAISwRAQYCU69wDIBZ2IQ9BfyAWdEF/cyERQQAhAyAIIQcDQCAHIAMgBygCACIMIBZ2ajYCACAMIBFxIA9sIQMgB0EEaiIHIAZJDQALIAggCEEEaiAIKAIAGyEIIANFDQEgBiADNgIAIAZBBGohBgwBCyAIIAhBBGogCCgCABshCAsgCSAJKAIsIBZqIgM2AiwgDiAIIBUbIgcgDUECdGogBiAGIAdrQQJ1IA1KGyEGIANBAEgNAAsLQQAhBwJAIAYgCE0NACAOIAhrQQJ1QQlsIQcgCCgCACIMQQpJDQBB5AAhAwNAIAdBAWohByADIAxLDQEgA0EKbCEDDAALAAsgCkEAIAcgFEHmAEYbayAUQecARiAKQQBHcWsiAyAGIA5rQQJ1QQlsQQlrSARAIANBgMgAaiIRQQltIgxBAnQgCUEwakEEciAJQdQCaiALQQBIG2pBgCBrIQ1BCiEDAkAgESAMQQlsayIMQQdKDQBB5AAhAwNAIAxBAWoiDEEIRg0BIANBCmwhAwwACwALAkAgDSgCACIRIBEgA24iDCADbGsiD0EBIA1BBGoiCyAGRhtFDQBEAAAAAAAA4D9EAAAAAAAA8D9EAAAAAAAA+D8gBiALRhtEAAAAAAAA+D8gDyADQQF2IgtGGyALIA9LGyEaRAEAAAAAAEBDRAAAAAAAAEBDIAxBAXEbIQECQCAXDQAgEy0AAEEtRw0AIBqaIRogAZohAQsgDSARIA9rIgs2AgAgASAaoCABYQ0AIA0gAyALaiIDNgIAIANBgJTr3ANPBEADQCANQQA2AgAgCCANQQRrIg1LBEAgCEEEayIIQQA2AgALIA0gDSgCAEEBaiIDNgIAIANB/5Pr3ANLDQALCyAOIAhrQQJ1QQlsIQcgCCgCACILQQpJDQBB5AAhAwNAIAdBAWohByADIAtLDQEgA0EKbCEDDAALAAsgDUEEaiIDIAYgAyAGSRshBgsDQCAGIgsgCE0iDEUEQCALQQRrIgYoAgBFDQELCwJAIBRB5wBHBEAgBEEIcSEPDAELIAdBf3NBfyAKQQEgChsiBiAHSiAHQXtKcSIDGyAGaiEKQX9BfiADGyAFaiEFIARBCHEiDw0AQXchBgJAIAwNACALQQRrKAIAIgNFDQBBACEGIANBCnANAEEAIQxB5AAhBgNAIAMgBnBFBEAgDEEBaiEMIAZBCmwhBgwBCwsgDEF/cyEGCyALIA5rQQJ1QQlsIQMgBUFfcUHGAEYEQEEAIQ8gCiADIAZqQQlrIgNBACADQQBKGyIDIAMgCkobIQoMAQtBACEPIAogAyAHaiAGakEJayIDQQAgA0EAShsiAyADIApKGyEKCyAKIA9yQQBHIREgAEEgIAIgBUFfcSIMQcYARgR/IAdBACAHQQBKGwUgECAHIAdBH3UiA2ogA3OtIBAQRCIGa0EBTARAA0AgBkEBayIGQTA6AAAgECAGa0ECSA0ACwsgBkECayIVIAU6AAAgBkEBa0EtQSsgB0EASBs6AAAgECAVawsgCiASaiARampBAWoiDSAEECYgACATIBIQIiAAQTAgAiANIARBgIAEcxAmAkACQAJAIAxBxgBGBEAgCUEQakEIciEDIAlBEGpBCXIhByAOIAggCCAOSxsiBSEIA0AgCDUCACAHEEQhBgJAIAUgCEcEQCAGIAlBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAlBEGpLDQALDAELIAYgB0cNACAJQTA6ABggAyEGCyAAIAYgByAGaxAiIAhBBGoiCCAOTQ0AC0EAIQYgEUUNAiAAQdYSQQEQIiAIIAtPDQEgCkEBSA0BA0AgCDUCACAHEEQiBiAJQRBqSwRAA0AgBkEBayIGQTA6AAAgBiAJQRBqSw0ACwsgACAGIApBCSAKQQlIGxAiIApBCWshBiAIQQRqIgggC08NAyAKQQlKIQMgBiEKIAMNAAsMAgsCQCAKQQBIDQAgCyAIQQRqIAggC0kbIQUgCUEQakEJciELIAlBEGpBCHIhAyAIIQcDQCALIAc1AgAgCxBEIgZGBEAgCUEwOgAYIAMhBgsCQCAHIAhHBEAgBiAJQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAJQRBqSw0ACwwBCyAAIAZBARAiIAZBAWohBkEAIApBAEwgDxsNACAAQdYSQQEQIgsgACAGIAsgBmsiBiAKIAYgCkgbECIgCiAGayEKIAdBBGoiByAFTw0BIApBf0oNAAsLIABBMCAKQRJqQRJBABAmIAAgFSAQIBVrECIMAgsgCiEGCyAAQTAgBkEJakEJQQAQJgsMAQsgE0EJaiATIAVBIHEiCxshCgJAIANBC0sNAEEMIANrIgZFDQBEAAAAAAAAIEAhGgNAIBpEAAAAAAAAMECiIRogBkEBayIGDQALIAotAABBLUYEQCAaIAGaIBqhoJohAQwBCyABIBqgIBqhIQELIBAgCSgCLCIGIAZBH3UiBmogBnOtIBAQRCIGRgRAIAlBMDoADyAJQQ9qIQYLIBJBAnIhDiAJKAIsIQcgBkECayIMIAVBD2o6AAAgBkEBa0EtQSsgB0EASBs6AAAgBEEIcSEHIAlBEGohCANAIAgiBQJ/IAGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4CyIGQYCHAWotAAAgC3I6AAAgASAGt6FEAAAAAAAAMECiIQECQCAFQQFqIgggCUEQamtBAUcNAAJAIAFEAAAAAAAAAABiDQAgA0EASg0AIAdFDQELIAVBLjoAASAFQQJqIQgLIAFEAAAAAAAAAABiDQALIABBICACIA4CfwJAIANFDQAgCCAJa0ESayADTg0AIAMgEGogDGtBAmoMAQsgECAJQRBqIAxqayAIagsiA2oiDSAEECYgACAKIA4QIiAAQTAgAiANIARBgIAEcxAmIAAgCUEQaiAIIAlBEGprIgUQIiAAQTAgAyAFIBAgDGsiA2prQQBBABAmIAAgDCADECILIABBICACIA0gBEGAwABzECYgCUGwBGokACACIA0gAiANShsLBgBB4J8BCwYAQdyfAQsGAEHUnwELGAEBfyMAQRBrIgEgADYCDCABKAIMQQRqCxgBAX8jAEEQayIBIAA2AgwgASgCDEEIagtpAQF/IwBBEGsiASQAIAEgADYCDCABKAIMKAIUBEAgASgCDCgCFBAbCyABQQA2AgggASgCDCgCBARAIAEgASgCDCgCBDYCCAsgASgCDEEEahA4IAEoAgwQFSABKAIIIQAgAUEQaiQAIAALqQEBA38CQCAALQAAIgJFDQADQCABLQAAIgRFBEAgAiEDDAILAkAgAiAERg0AIAJBIHIgAiACQcEAa0EaSRsgAS0AACICQSByIAIgAkHBAGtBGkkbRg0AIAAtAAAhAwwCCyABQQFqIQEgAC0AASECIABBAWohACACDQALCyADQf8BcSIAQSByIAAgAEHBAGtBGkkbIAEtAAAiAEEgciAAIABBwQBrQRpJG2sLiAEBAX8jAEEQayICJAAgAiAANgIMIAIgATYCCCMAQRBrIgAgAigCDDYCDCAAKAIMQQA2AgAgACgCDEEANgIEIAAoAgxBADYCCCACKAIMIAIoAgg2AgACQCACKAIMEKwBQQFGBEAgAigCDEG0mwEoAgA2AgQMAQsgAigCDEEANgIECyACQRBqJAAL2AkBAX8jAEGwAWsiBSQAIAUgADYCpAEgBSABNgKgASAFIAI2ApwBIAUgAzcDkAEgBSAENgKMASAFIAUoAqABNgKIAQJAAkACQAJAAkACQAJAAkACQAJAAkAgBSgCjAEODwABAgMEBQcICQkJCQkJBgkLIAUoAogBQgA3AyAgBUIANwOoAQwJCyAFIAUoAqQBIAUoApwBIAUpA5ABECsiAzcDgAEgA0IAUwRAIAUoAogBQQhqIAUoAqQBEBcgBUJ/NwOoAQwJCwJAIAUpA4ABUARAIAUoAogBKQMoIAUoAogBKQMgUQRAIAUoAogBQQE2AgQgBSgCiAEgBSgCiAEpAyA3AxggBSgCiAEoAgAEQCAFKAKkASAFQcgAahA5QQBIBEAgBSgCiAFBCGogBSgCpAEQFyAFQn83A6gBDA0LAkAgBSkDSEIgg1ANACAFKAJ0IAUoAogBKAIwRg0AIAUoAogBQQhqQQdBABAUIAVCfzcDqAEMDQsCQCAFKQNIQgSDUA0AIAUpA2AgBSgCiAEpAxhRDQAgBSgCiAFBCGpBFUEAEBQgBUJ/NwOoAQwNCwsLDAELAkAgBSgCiAEoAgQNACAFKAKIASkDICAFKAKIASkDKFYNACAFIAUoAogBKQMoIAUoAogBKQMgfTcDQANAIAUpA0AgBSkDgAFUBEAgBSAFKQOAASAFKQNAfUL/////D1YEfkL/////DwUgBSkDgAEgBSkDQH0LNwM4IAUoAogBKAIwIAUoApwBIAUpA0CnaiAFKQM4pxAaIQAgBSgCiAEgADYCMCAFKAKIASIAIAUpAzggACkDKHw3AyggBSAFKQM4IAUpA0B8NwNADAELCwsLIAUoAogBIgAgBSkDgAEgACkDIHw3AyAgBSAFKQOAATcDqAEMCAsgBUIANwOoAQwHCyAFIAUoApwBNgI0IAUoAogBKAIEBEAgBSgCNCAFKAKIASkDGDcDGCAFKAI0IAUoAogBKAIwNgIsIAUoAjQgBSgCiAEpAxg3AyAgBSgCNEEAOwEwIAUoAjRBADsBMiAFKAI0IgAgACkDAELsAYQ3AwALIAVCADcDqAEMBgsgBSAFKAKIAUEIaiAFKAKcASAFKQOQARBDNwOoAQwFCyAFKAKIARAVIAVCADcDqAEMBAsjAEEQayIAIAUoAqQBNgIMIAUgACgCDCkDGDcDKCAFKQMoQgBTBEAgBSgCiAFBCGogBSgCpAEQFyAFQn83A6gBDAQLIAUpAyghAyAFQX82AhggBUEQNgIUIAVBDzYCECAFQQ02AgwgBUEMNgIIIAVBCjYCBCAFQQk2AgAgBUEIIAUQNEJ/hSADgzcDqAEMAwsgBQJ/IAUpA5ABQhBUBEAgBSgCiAFBCGpBEkEAEBRBAAwBCyAFKAKcAQs2AhwgBSgCHEUEQCAFQn83A6gBDAMLAkAgBSgCpAEgBSgCHCkDACAFKAIcKAIIECdBAE4EQCAFIAUoAqQBEEkiAzcDICADQgBZDQELIAUoAogBQQhqIAUoAqQBEBcgBUJ/NwOoAQwDCyAFKAKIASAFKQMgNwMgIAVCADcDqAEMAgsgBSAFKAKIASkDIDcDqAEMAQsgBSgCiAFBCGpBHEEAEBQgBUJ/NwOoAQsgBSkDqAEhAyAFQbABaiQAIAMLnAwBAX8jAEEwayIFJAAgBSAANgIkIAUgATYCICAFIAI2AhwgBSADNwMQIAUgBDYCDCAFIAUoAiA2AggCQAJAAkACQAJAAkACQAJAAkACQCAFKAIMDhEAAQIDBQYICAgICAgICAcIBAgLIAUoAghCADcDGCAFKAIIQQA6AAwgBSgCCEEAOgANIAUoAghBADoADyAFKAIIQn83AyAgBSgCCCgCrEAgBSgCCCgCqEAoAgwRAABBAXFFBEAgBUJ/NwMoDAkLIAVCADcDKAwICyAFKAIkIQEgBSgCCCECIAUoAhwhBCAFKQMQIQMjAEFAaiIAJAAgACABNgI0IAAgAjYCMCAAIAQ2AiwgACADNwMgAkACfyMAQRBrIgEgACgCMDYCDCABKAIMKAIACwRAIABCfzcDOAwBCwJAIAApAyBQRQRAIAAoAjAtAA1BAXFFDQELIABCADcDOAwBCyAAQgA3AwggAEEAOgAbA0AgAC0AG0EBcQR/QQAFIAApAwggACkDIFQLQQFxBEAgACAAKQMgIAApAwh9NwMAIAAgACgCMCgCrEAgACgCLCAAKQMIp2ogACAAKAIwKAKoQCgCHBEBADYCHCAAKAIcQQJHBEAgACAAKQMAIAApAwh8NwMICwJAAkACQAJAIAAoAhxBAWsOAwACAQMLIAAoAjBBAToADQJAIAAoAjAtAAxBAXENAAsgACgCMCkDIEIAUwRAIAAoAjBBFEEAEBQgAEEBOgAbDAMLAkAgACgCMC0ADkEBcUUNACAAKAIwKQMgIAApAwhWDQAgACgCMEEBOgAPIAAoAjAgACgCMCkDIDcDGCAAKAIsIAAoAjBBKGogACgCMCkDGKcQGRogACAAKAIwKQMYNwM4DAYLIABBAToAGwwCCyAAKAIwLQAMQQFxBEAgAEEBOgAbDAILIAAgACgCNCAAKAIwQShqQoDAABArIgM3AxAgA0IAUwRAIAAoAjAgACgCNBAXIABBAToAGwwCCwJAIAApAxBQBEAgACgCMEEBOgAMIAAoAjAoAqxAIAAoAjAoAqhAKAIYEQIAIAAoAjApAyBCAFMEQCAAKAIwQgA3AyALDAELAkAgACgCMCkDIEIAWQRAIAAoAjBBADoADgwBCyAAKAIwIAApAxA3AyALIAAoAjAoAqxAIAAoAjBBKGogACkDECAAKAIwKAKoQCgCFBEQABoLDAELAn8jAEEQayIBIAAoAjA2AgwgASgCDCgCAEULBEAgACgCMEEUQQAQFAsgAEEBOgAbCwwBCwsgACkDCEIAUgRAIAAoAjBBADoADiAAKAIwIgEgACkDCCABKQMYfDcDGCAAIAApAwg3AzgMAQsgAEF/QQACfyMAQRBrIgEgACgCMDYCDCABKAIMKAIACxusNwM4CyAAKQM4IQMgAEFAayQAIAUgAzcDKAwHCyAFKAIIKAKsQCAFKAIIKAKoQCgCEBEAAEEBcUUEQCAFQn83AygMBwsgBUIANwMoDAYLIAUgBSgCHDYCBAJAIAUoAggtABBBAXEEQCAFKAIILQANQQFxBEAgBSgCBCAFKAIILQAPQQFxBH9BAAUCfwJAIAUoAggoAhRBf0cEQCAFKAIIKAIUQX5HDQELQQgMAQsgBSgCCCgCFAtB//8DcQs7ATAgBSgCBCAFKAIIKQMYNwMgIAUoAgQiACAAKQMAQsgAhDcDAAwCCyAFKAIEIgAgACkDAEK3////D4M3AwAMAQsgBSgCBEEAOwEwIAUoAgQiACAAKQMAQsAAhDcDAAJAIAUoAggtAA1BAXEEQCAFKAIEIAUoAggpAxg3AxggBSgCBCIAIAApAwBCBIQ3AwAMAQsgBSgCBCIAIAApAwBC+////w+DNwMACwsgBUIANwMoDAULIAUgBSgCCC0AD0EBcQR/QQAFIAUoAggoAqxAIAUoAggoAqhAKAIIEQAAC6w3AygMBAsgBSAFKAIIIAUoAhwgBSkDEBBDNwMoDAMLIAUoAggQsQEgBUIANwMoDAILIAVBfzYCACAFQRAgBRA0Qj+ENwMoDAELIAUoAghBFEEAEBQgBUJ/NwMoCyAFKQMoIQMgBUEwaiQAIAMLPAEBfyMAQRBrIgMkACADIAA7AQ4gAyABNgIIIAMgAjYCBEEAIAMoAgggAygCBBC0ASEAIANBEGokACAAC46nAQEEfyMAQSBrIgUkACAFIAA2AhggBSABNgIUIAUgAjYCECAFIAUoAhg2AgwgBSgCDCAFKAIQKQMAQv////8PVgR+Qv////8PBSAFKAIQKQMACz4CICAFKAIMIAUoAhQ2AhwCQCAFKAIMLQAEQQFxBEAgBSgCDEEQaiEBQQRBACAFKAIMLQAMQQFxGyECIwBBQGoiACQAIAAgATYCOCAAIAI2AjQCQAJAAkAgACgCOBB4DQAgACgCNEEFSg0AIAAoAjRBAE4NAQsgAEF+NgI8DAELIAAgACgCOCgCHDYCLAJAAkAgACgCOCgCDEUNACAAKAI4KAIEBEAgACgCOCgCAEUNAQsgACgCLCgCBEGaBUcNASAAKAI0QQRGDQELIAAoAjhBsNkAKAIANgIYIABBfjYCPAwBCyAAKAI4KAIQRQRAIAAoAjhBvNkAKAIANgIYIABBezYCPAwBCyAAIAAoAiwoAig2AjAgACgCLCAAKAI0NgIoAkAgACgCLCgCFARAIAAoAjgQHCAAKAI4KAIQRQRAIAAoAixBfzYCKCAAQQA2AjwMAwsMAQsCQCAAKAI4KAIEDQAgACgCNEEBdEEJQQAgACgCNEEEShtrIAAoAjBBAXRBCUEAIAAoAjBBBEoba0oNACAAKAI0QQRGDQAgACgCOEG82QAoAgA2AhggAEF7NgI8DAILCwJAIAAoAiwoAgRBmgVHDQAgACgCOCgCBEUNACAAKAI4QbzZACgCADYCGCAAQXs2AjwMAQsgACgCLCgCBEEqRgRAIAAgACgCLCgCMEEEdEH4AGtBCHQ2AigCQAJAIAAoAiwoAogBQQJIBEAgACgCLCgChAFBAk4NAQsgAEEANgIkDAELAkAgACgCLCgChAFBBkgEQCAAQQE2AiQMAQsCQCAAKAIsKAKEAUEGRgRAIABBAjYCJAwBCyAAQQM2AiQLCwsgACAAKAIoIAAoAiRBBnRyNgIoIAAoAiwoAmwEQCAAIAAoAihBIHI2AigLIAAgACgCKEEfIAAoAihBH3BrajYCKCAAKAIsIAAoAigQSyAAKAIsKAJsBEAgACgCLCAAKAI4KAIwQRB2EEsgACgCLCAAKAI4KAIwQf//A3EQSwtBAEEAQQAQPSEBIAAoAjggATYCMCAAKAIsQfEANgIEIAAoAjgQHCAAKAIsKAIUBEAgACgCLEF/NgIoIABBADYCPAwCCwsgACgCLCgCBEE5RgRAQQBBAEEAEBohASAAKAI4IAE2AjAgACgCLCgCCCECIAAoAiwiAygCFCEBIAMgAUEBajYCFCABIAJqQR86AAAgACgCLCgCCCECIAAoAiwiAygCFCEBIAMgAUEBajYCFCABIAJqQYsBOgAAIAAoAiwoAgghAiAAKAIsIgMoAhQhASADIAFBAWo2AhQgASACakEIOgAAAkAgACgCLCgCHEUEQCAAKAIsKAIIIQIgACgCLCIDKAIUIQEgAyABQQFqNgIUIAEgAmpBADoAACAAKAIsKAIIIQIgACgCLCIDKAIUIQEgAyABQQFqNgIUIAEgAmpBADoAACAAKAIsKAIIIQIgACgCLCIDKAIUIQEgAyABQQFqNgIUIAEgAmpBADoAACAAKAIsKAIIIQIgACgCLCIDKAIUIQEgAyABQQFqNgIUIAEgAmpBADoAACAAKAIsKAIIIQIgACgCLCIDKAIUIQEgAyABQQFqNgIUIAEgAmpBADoAACAAKAIsKAKEAUEJRgR/QQIFQQRBACAAKAIsKAKIAUECSAR/IAAoAiwoAoQBQQJIBUEBC0EBcRsLIQIgACgCLCgCCCEDIAAoAiwiBCgCFCEBIAQgAUEBajYCFCABIANqIAI6AAAgACgCLCgCCCECIAAoAiwiAygCFCEBIAMgAUEBajYCFCABIAJqQQM6AAAgACgCLEHxADYCBCAAKAI4EBwgACgCLCgCFARAIAAoAixBfzYCKCAAQQA2AjwMBAsMAQsgACgCLCgCHCgCAEVFQQJBACAAKAIsKAIcKAIsG2pBBEEAIAAoAiwoAhwoAhAbakEIQQAgACgCLCgCHCgCHBtqQRBBACAAKAIsKAIcKAIkG2ohAiAAKAIsKAIIIQMgACgCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogAjoAACAAKAIsKAIcKAIEQf8BcSECIAAoAiwoAgghAyAAKAIsIgQoAhQhASAEIAFBAWo2AhQgASADaiACOgAAIAAoAiwoAhwoAgRBCHZB/wFxIQIgACgCLCgCCCEDIAAoAiwiBCgCFCEBIAQgAUEBajYCFCABIANqIAI6AAAgACgCLCgCHCgCBEEQdkH/AXEhAiAAKAIsKAIIIQMgACgCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogAjoAACAAKAIsKAIcKAIEQRh2IQIgACgCLCgCCCEDIAAoAiwiBCgCFCEBIAQgAUEBajYCFCABIANqIAI6AAAgACgCLCgChAFBCUYEf0ECBUEEQQAgACgCLCgCiAFBAkgEfyAAKAIsKAKEAUECSAVBAQtBAXEbCyECIAAoAiwoAgghAyAAKAIsIgQoAhQhASAEIAFBAWo2AhQgASADaiACOgAAIAAoAiwoAhwoAgxB/wFxIQIgACgCLCgCCCEDIAAoAiwiBCgCFCEBIAQgAUEBajYCFCABIANqIAI6AAAgACgCLCgCHCgCEARAIAAoAiwoAhwoAhRB/wFxIQIgACgCLCgCCCEDIAAoAiwiBCgCFCEBIAQgAUEBajYCFCABIANqIAI6AAAgACgCLCgCHCgCFEEIdkH/AXEhAiAAKAIsKAIIIQMgACgCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogAjoAAAsgACgCLCgCHCgCLARAIAAoAjgoAjAgACgCLCgCCCAAKAIsKAIUEBohASAAKAI4IAE2AjALIAAoAixBADYCICAAKAIsQcUANgIECwsgACgCLCgCBEHFAEYEQCAAKAIsKAIcKAIQBEAgACAAKAIsKAIUNgIgIAAgACgCLCgCHCgCFEH//wNxIAAoAiwoAiBrNgIcA0AgACgCLCgCDCAAKAIsKAIUIAAoAhxqSQRAIAAgACgCLCgCDCAAKAIsKAIUazYCGCAAKAIsKAIIIAAoAiwoAhRqIAAoAiwoAhwoAhAgACgCLCgCIGogACgCGBAZGiAAKAIsIAAoAiwoAgw2AhQCQCAAKAIsKAIcKAIsRQ0AIAAoAiwoAhQgACgCIE0NACAAKAI4KAIwIAAoAiwoAgggACgCIGogACgCLCgCFCAAKAIgaxAaIQEgACgCOCABNgIwCyAAKAIsIgEgACgCGCABKAIgajYCICAAKAI4EBwgACgCLCgCFARAIAAoAixBfzYCKCAAQQA2AjwMBQUgAEEANgIgIAAgACgCHCAAKAIYazYCHAwCCwALCyAAKAIsKAIIIAAoAiwoAhRqIAAoAiwoAhwoAhAgACgCLCgCIGogACgCHBAZGiAAKAIsIgEgACgCHCABKAIUajYCFAJAIAAoAiwoAhwoAixFDQAgACgCLCgCFCAAKAIgTQ0AIAAoAjgoAjAgACgCLCgCCCAAKAIgaiAAKAIsKAIUIAAoAiBrEBohASAAKAI4IAE2AjALIAAoAixBADYCIAsgACgCLEHJADYCBAsgACgCLCgCBEHJAEYEQCAAKAIsKAIcKAIcBEAgACAAKAIsKAIUNgIUA0AgACgCLCgCFCAAKAIsKAIMRgRAAkAgACgCLCgCHCgCLEUNACAAKAIsKAIUIAAoAhRNDQAgACgCOCgCMCAAKAIsKAIIIAAoAhRqIAAoAiwoAhQgACgCFGsQGiEBIAAoAjggATYCMAsgACgCOBAcIAAoAiwoAhQEQCAAKAIsQX82AiggAEEANgI8DAULIABBADYCFAsgACgCLCgCHCgCHCECIAAoAiwiAygCICEBIAMgAUEBajYCICAAIAEgAmotAAA2AhAgACgCECECIAAoAiwoAgghAyAAKAIsIgQoAhQhASAEIAFBAWo2AhQgASADaiACOgAAIAAoAhANAAsCQCAAKAIsKAIcKAIsRQ0AIAAoAiwoAhQgACgCFE0NACAAKAI4KAIwIAAoAiwoAgggACgCFGogACgCLCgCFCAAKAIUaxAaIQEgACgCOCABNgIwCyAAKAIsQQA2AiALIAAoAixB2wA2AgQLIAAoAiwoAgRB2wBGBEAgACgCLCgCHCgCJARAIAAgACgCLCgCFDYCDANAIAAoAiwoAhQgACgCLCgCDEYEQAJAIAAoAiwoAhwoAixFDQAgACgCLCgCFCAAKAIMTQ0AIAAoAjgoAjAgACgCLCgCCCAAKAIMaiAAKAIsKAIUIAAoAgxrEBohASAAKAI4IAE2AjALIAAoAjgQHCAAKAIsKAIUBEAgACgCLEF/NgIoIABBADYCPAwFCyAAQQA2AgwLIAAoAiwoAhwoAiQhAiAAKAIsIgMoAiAhASADIAFBAWo2AiAgACABIAJqLQAANgIIIAAoAgghAiAAKAIsKAIIIQMgACgCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogAjoAACAAKAIIDQALAkAgACgCLCgCHCgCLEUNACAAKAIsKAIUIAAoAgxNDQAgACgCOCgCMCAAKAIsKAIIIAAoAgxqIAAoAiwoAhQgACgCDGsQGiEBIAAoAjggATYCMAsLIAAoAixB5wA2AgQLIAAoAiwoAgRB5wBGBEAgACgCLCgCHCgCLARAIAAoAiwoAgwgACgCLCgCFEECakkEQCAAKAI4EBwgACgCLCgCFARAIAAoAixBfzYCKCAAQQA2AjwMBAsLIAAoAjgoAjBB/wFxIQIgACgCLCgCCCEDIAAoAiwiBCgCFCEBIAQgAUEBajYCFCABIANqIAI6AAAgACgCOCgCMEEIdkH/AXEhAiAAKAIsKAIIIQMgACgCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogAjoAAEEAQQBBABAaIQEgACgCOCABNgIwCyAAKAIsQfEANgIEIAAoAjgQHCAAKAIsKAIUBEAgACgCLEF/NgIoIABBADYCPAwCCwsCQAJAIAAoAjgoAgQNACAAKAIsKAJ0DQAgACgCNEUNASAAKAIsKAIEQZoFRg0BCyAAAn8gACgCLCgChAFFBEAgACgCLCAAKAI0ELcBDAELAn8gACgCLCgCiAFBAkYEQCAAKAIsIQIgACgCNCEDIwBBIGsiASQAIAEgAjYCGCABIAM2AhQCQANAAkAgASgCGCgCdEUEQCABKAIYEFwgASgCGCgCdEUEQCABKAIURQRAIAFBADYCHAwFCwwCCwsgASgCGEEANgJgIAEgASgCGCICKAI4IAIoAmxqLQAAOgAPIAEoAhgiAigCpC0gAigCoC1BAXRqQQA7AQAgAS0ADyEDIAEoAhgiAigCmC0hBCACIAIoAqAtIgJBAWo2AqAtIAIgBGogAzoAACABKAIYIAEtAA9BAnRqIgIgAi8BlAFBAWo7AZQBIAEgASgCGCgCoC0gASgCGCgCnC1BAWtGNgIQIAEoAhgiAiACKAJ0QQFrNgJ0IAEoAhgiAiACKAJsQQFqNgJsIAEoAhAEQCABKAIYAn8gASgCGCgCXEEATgRAIAEoAhgoAjggASgCGCgCXGoMAQtBAAsgASgCGCgCbCABKAIYKAJca0EAECggASgCGCABKAIYKAJsNgJcIAEoAhgoAgAQHCABKAIYKAIAKAIQRQRAIAFBADYCHAwECwsMAQsLIAEoAhhBADYCtC0gASgCFEEERgRAIAEoAhgCfyABKAIYKAJcQQBOBEAgASgCGCgCOCABKAIYKAJcagwBC0EACyABKAIYKAJsIAEoAhgoAlxrQQEQKCABKAIYIAEoAhgoAmw2AlwgASgCGCgCABAcIAEoAhgoAgAoAhBFBEAgAUECNgIcDAILIAFBAzYCHAwBCyABKAIYKAKgLQRAIAEoAhgCfyABKAIYKAJcQQBOBEAgASgCGCgCOCABKAIYKAJcagwBC0EACyABKAIYKAJsIAEoAhgoAlxrQQAQKCABKAIYIAEoAhgoAmw2AlwgASgCGCgCABAcIAEoAhgoAgAoAhBFBEAgAUEANgIcDAILCyABQQE2AhwLIAEoAhwhAiABQSBqJAAgAgwBCwJ/IAAoAiwoAogBQQNGBEAgACgCLCECIAAoAjQhAyMAQTBrIgEkACABIAI2AiggASADNgIkAkADQAJAIAEoAigoAnRBggJNBEAgASgCKBBcAkAgASgCKCgCdEGCAksNACABKAIkDQAgAUEANgIsDAQLIAEoAigoAnRFDQELIAEoAihBADYCYAJAIAEoAigoAnRBA0kNACABKAIoKAJsRQ0AIAEgASgCKCgCOCABKAIoKAJsakEBazYCGCABIAEoAhgtAAA2AhwgASgCHCECIAEgASgCGCIDQQFqNgIYAkAgAy0AASACRw0AIAEoAhwhAiABIAEoAhgiA0EBajYCGCADLQABIAJHDQAgASgCHCECIAEgASgCGCIDQQFqNgIYIAMtAAEgAkcNACABIAEoAigoAjggASgCKCgCbGpBggJqNgIUA0AgASgCHCECIAEgASgCGCIDQQFqNgIYAn9BACADLQABIAJHDQAaIAEoAhwhAiABIAEoAhgiA0EBajYCGEEAIAMtAAEgAkcNABogASgCHCECIAEgASgCGCIDQQFqNgIYQQAgAy0AASACRw0AGiABKAIcIQIgASABKAIYIgNBAWo2AhhBACADLQABIAJHDQAaIAEoAhwhAiABIAEoAhgiA0EBajYCGEEAIAMtAAEgAkcNABogASgCHCECIAEgASgCGCIDQQFqNgIYQQAgAy0AASACRw0AGiABKAIcIQIgASABKAIYIgNBAWo2AhhBACADLQABIAJHDQAaIAEoAhwhAiABIAEoAhgiA0EBajYCGEEAIAMtAAEgAkcNABog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AS8BEiECIAEgASgCSCIDQQFqNgJIIAMgAjoAAAwCCyABKAIMQRBxBEAgASABLwESNgIIIAEgASgCDEEPcTYCDCABKAIMBEAgASgCKCABKAIMSQRAIAEgASgCUCICQQFqNgJQIAEgASgCLCACLQAAIAEoAih0ajYCLCABIAEoAihBCGo2AigLIAEgASgCCCABKAIsQQEgASgCDHRBAWtxajYCCCABIAEoAiwgASgCDHY2AiwgASABKAIoIAEoAgxrNgIoCyABKAIoQQ9JBEAgASABKAJQIgJBAWo2AlAgASABKAIsIAItAAAgASgCKHRqNgIsIAEgASgCKEEIajYCKCABIAEoAlAiAkEBajYCUCABIAEoAiwgAi0AACABKAIodGo2AiwgASABKAIoQQhqNgIoCyABIAEoAiAgASgCLCABKAIYcUECdGooAQA2ARACQANAIAEgAS0AETYCDCABIAEoAiwgASgCDHY2AiwgASABKAIoIAEoAgxrNgIoIAEgAS0AEDYCDCABKAIMQRBxBEAgASABLwESNgIEIAEgASgCDEEPcTYCDCABKAIoIAEoAgxJBEAgASABKAJQIgJBAWo2AlAgASABKAIsIAItAAAgASgCKHRqNgIsIAEgASgCKEEIajYCKCABKAIoIAEoAgxJBEAgASABKAJQIgJBAWo2AlAgASABKAIsIAItAAAgASgCKHRqNgIsIAEgASgCKEEIajYCKAsLIAEgASgCBCABKAIsQQEgASgCDHRBAWtxajYCBCABIAEoAiwgASgCDHY2AiwgASABKAIoIAEoAgxrNgIoIAEgASgCSCABKAJEazYCDAJAIAEoAgQgASgCDEsEQCABIAEoAgQgASgCDGs2AgwgASgCDCABKAI4SwRAIAEoAlQoAsQ3BEAgASgCXEHdDDYCGCABKAJUQdH+ADYCBAwKCwsgASABKAIwNgIAAkAgASgCNEUEQCABIAEoAgAgASgCPCABKAIMa2o2AgAgASgCDCABKAIISQRAIAEgASgCCCABKAIMazYCCANAIAEgASgCACICQQFqNgIAIAItAAAhAiABIAEoAkgiA0EBajYCSCADIAI6AAAgASABKAIMQQFrIgI2AgwgAg0ACyABIAEoAkggASgCBGs2AgALDAELAkAgASgCNCABKAIMSQRAIAEgASgCACABKAI8IAEoAjRqIAEoAgxrajYCACABIAEoAgwgASgCNGs2AgwgASgCDCABKAIISQRAIAEgASgCCCABKAIMazYCCANAIAEgASgCACICQQFqNgIAIAItAAAhAiABIAEoAkgiA0EBajYCSCADIAI6AAAgASABKAIMQQFrIgI2AgwgAg0ACyABIAEoAjA2AgAgASgCNCABKAIISQRAIAEgASgCNDYCDCABIAEoAgggASgCDGs2AggDQCABIAEoAgAiAkEBajYCACACLQAAIQIgASABKAJIIgNBAWo2AkggAyACOgAAIAEgASgCDEEBayICNgIMIAINAAsgASABKAJIIAEoAgRrNgIACwsMAQsgASABKAIAIAEoAjQgASgCDGtqNgIAIAEoAgwgASgCCEkEQCABIAEoAgggASgCDGs2AggDQCABIAEoAgAiAkEBajYCACACLQAAIQIgASABKAJIIgNBAWo2AkggAyACOgAAIAEgASgCDEEBayICNgIMIAINAAsgASABKAJIIAEoAgRrNgIACwsLA0AgASgCCEECSwRAIAEgASgCACICQQFqNgIAIAItAAAhAiABIAEoAkgiA0EBajYCSCADIAI6AAAgASABKAIAIgJBAWo2AgAgAi0AACECIAEgASgCSCIDQQFqNgJIIAMgAjoAACABIAEoAgAiAkEBajYCACACLQAAIQIgASABKAJIIgNBAWo2AkggAyACOgAAIAEgASgCCEEDazYCCAwBCwsMAQsgASABKAJIIAEoAgRrNgIAA0AgASABKAIAIgJBAWo2AgAgAi0AACECIAEgASgCSCIDQQFqNgJIIAMgAjoAACABIAEoAgAiAkEBajYCACACLQAAIQIgASABKAJIIgNBAWo2AkggAyACOgAAIAEgASgCACICQQFqNgIAIAItAAAhAiABIAEoAkgiA0EBajYCSCADIAI6AAAgASABKAIIQQNrNgIIIAEoAghBAksNAAsLIAEoAggEQCABIAEoAgAiAkEBajYCACACLQAAIQIgASABKAJIIgNBAWo2AkggAyACOgAAIAEoAghBAUsEQCABIAEoAgAiAkEBajYCACACLQAAIQIgASABKAJIIgNBAWo2AkggAyACOgAACwsMAgsgASgCDEHAAHFFBEAgASABKAIgIAEvARIgASgCLEEBIAEoAgx0QQFrcWpBAnRqKAEANgEQDAELCyAB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AG5hbgAvZGV2L3VyYW5kb20AaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrAGluY29ycmVjdCBoZWFkZXIgY2hlY2sAaW5jb3JyZWN0IGxlbmd0aCBjaGVjawBpbmNvcnJlY3QgZGF0YSBjaGVjawBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjawBoZWFkZXIgY3JjIG1pc21hdGNoAGluZgBpbnZhbGlkIHdpbmRvdyBzaXplAFJlYWQtb25seSBhcmNoaXZlAE5vdCBhIHppcCBhcmNoaXZlAFJlc291cmNlIHN0aWxsIGluIHVzZQBNYWxsb2MgZmFpbHVyZQBpbnZhbGlkIGJsb2NrIHR5cGUARmFpbHVyZSB0byBjcmVhdGUgdGVtcG9yYXJ5IGZpbGUAQ2FuJ3Qgb3BlbiBmaWxlAE5vIHN1Y2ggZmlsZQBQcmVtYXR1cmUgZW5kIG9mIGZpbGUAQ2FuJ3QgcmVtb3ZlIGZpbGUAaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlAGludmFsaWQgZGlzdGFuY2UgY29kZQB1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZABzdHJlYW0gZW5kAENvbXByZXNzZWQgZGF0YSBpbnZhbGlkAE11bHRpLWRpc2sgemlwIGFyY2hpdmVzIG5vdCBzdXBwb3J0ZWQAT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQARW5jcnlwdGlvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABFbnRyeSBoYXMgYmVlbiBkZWxldGVkAENvbnRhaW5pbmcgemlwIGFyY2hpdmUgd2FzIGNsb3NlZABDbG9zaW5nIHppcCBhcmNoaXZlIGZhaWxlZABSZW5hbWluZyB0ZW1wb3JhcnkgZmlsZSBmYWlsZWQARW50cnkgaGFzIGJlZW4gY2hhbmdlZABObyBwYXNzd29yZCBwcm92aWRlZABXcm9uZyBwYXNzd29yZCBwcm92aWRlZABVbmtub3duIGVycm9yICVkAHJiAHIrYgByd2EAJXMuWFhYWFhYAE5BTgBJTkYAQUUAMS4yLjExAC9wcm9jL3NlbGYvZmQvAC4AKG51bGwpADogAFBLBgcA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0gAIADIACACyAAgAcgAIAPIACAAKAAgAigAIAEoACADKAAgAKgAIAKoACABqAAgA6gAIABoACACaAAgAWgAIANoACAA6AAgAugAIAHoACAD6AAgABgAIAIYACABGAAgAxgAIACYACACmAAgAZgAIAOYACAAWAAgAlgAIAFYACADWAAgANgAIALYACAB2AAgA9gAIAA4ACACOAAgATgAIAM4ACAAuAAgArgAIAG4ACADuAAgAHgAIAJ4ACABeAAgA3gAIAD4ACAC+AAgAfgAIAP4ACAABAAgAgQAIAEEACADBAAgAIQAIAKEACABhAAgA4QAIABEACACRAAgAUQAIANEACAAxAAgAsQAIAHEACADxAAgACQAIAIkACABJAAgAyQAIACkACACpAAgAaQAIAOkACAAZAAgAmQAIAFkACADZAAgAOQAIALkACAB5AAgA+QAIAAUACACFAAgARQAIAMUACAAlAAgApQAIAGUACADlAAgAFQAIAJUACABVAAgA1QAIADUACAC1AAgAdQAIAPUACAANAAgAjQAIAE0ACADNAAgALQAIAK0ACABtAAgA7QAIAB0ACACdAAgAXQAIAN0ACAA9AAgAvQAIAH0ACAD9AAgAEwAJABMBCQCTAAkAkwEJAFMACQBTAQkA0wAJANMBCQAzAAkAMwEJALMACQCzAQkAcwAJAHMBCQDzAAkA8wEJAAsACQALAQkAiwAJAIsBCQBLAAkASwEJAMsACQDLAQkAKwAJACsBCQCrAAkAqwEJAGsACQBrAQkA6wAJAOsBCQAbAAkAGwEJAJsACQCbAQkAWwAJAFsBCQDbAAkA2wEJADsACQA7AQkAuwAJALsBCQB7AAkAewEJAPsACQD7AQkABwAJAAcBCQCHAAkAhwEJAEcACQBHAQkAxwAJAMcBCQAnAAkAJwEJAKcACQCnAQkAZwAJAGcBCQDnAAkA5wEJABcACQAXAQkAlwAJAJcBCQBXAAkAVwEJANcACQDXAQkANwAJADcBCQC3AAkAtwEJAHcACQB3AQkA9wAJAPcBCQAPAAkADwEJAI8ACQCPAQkATwAJAE8BCQDPAAkAzwEJAC8ACQAvAQkArwAJAK8BCQBvAAkAbwEJAO8ACQDvAQkAHwAJAB8BCQCfAAkAnwEJAF8ACQBfAQkA3wAJAN8BCQA/AAkAPwEJAL8ACQC/AQkAfwAJAH8BCQD/AAkA/wEJAAAABwBAAAcAIAAHAGAABwAQAAcAUAAHADAABwBwAAcACAAHAEgABwAoAAcAaAAHABgABwBYAAcAOAAHAHgABwAEAAcARAAHACQABwBkAAcAFAAHAFQABwA0AAcAdAAHAAMACACDAAgAQwAIAMMACAAjAAgAowAIAGMACADjAAgAAAAFABAABQAIAAUAGAAFAAQABQAUAAUADAAFABwABQACAAUAEgAFAAoABQAaAAUABgAFABYABQAOAAUAHgAFAAEABQARAAUACQAFABkABQAFAAUAFQAFAA0ABQAdAAUAAwAFABMABQALAAUAGwAFAAcABQAXAAUAQbDqAAtNAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAADAAAAAwAAAAMAAAADAAAABAAAAAQAAAAEAAAABAAAAAUAAAAFAAAABQAAAAUAQaDrAAtlAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAQAAAAFAAAABQAAAAYAAAAGAAAABwAAAAcAAAAIAAAACAAAAAkAAAAJAAAACgAAAAoAAAALAAAACwAAAAwAAAAMAAAADQAAAA0AQdDsAAsjAgAAAAMAAAAHAAAAAAAAABAREgAIBwkGCgULBAwDDQIOAQ8AQYTtAAtpAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4AAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAEGE7gALegEAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAAABAACAAQAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAMS4yLjExAEGI7wALbQcAAAAEAAQACAAEAAgAAAAEAAUAEAAIAAgAAAAEAAYAIAAgAAgAAAAEAAQAEAAQAAkAAAAIABAAIAAgAAkAAAAIABAAgACAAAkAAAAIACAAgAAAAQkAAAAgAIAAAgEABAkAAAAgAAIBAgEAEAkAQYDwAAulAgMABAAFAAYABwAIAAkACgALAA0ADwARABMAFwAbAB8AIwArADMAOwBDAFMAYwBzAIMAowDDAOMAAgEAAAAAAAAQABAAEAAQABAAEAAQABAAEQARABEAEQASABIAEgASABMAEwATABMAFAAUABQAFAAVABUAFQAVABAATQDKAAAAAQACAAMABAAFAAcACQANABEAGQAhADEAQQBhAIEAwQABAYEBAQIBAwEEAQYBCAEMARABGAEgATABQAFgAAAAABAAEAAQABAAEQARABIAEgATABMAFAAUABUAFQAWABYAFwAXABgAGAAZABkAGgAaABsAGwAcABwAHQAdAEAAQAAQABEAEgAAAAgABwAJAAYACgAFAAsABAAMAAMADQACAA4AAQAPAEGw8gALwRFgBwAAAAhQAAAIEAAUCHMAEgcfAAAIcAAACDAAAAnAABAHCgAACGAAAAggAAAJoAAACAAAAAiAAAAIQAAACeAAEAcGAAAIWAAACBgAAAmQABMHOwAACHgAAAg4AAAJ0AARBxEAAAhoAAAIKAAACbAAAAgIAAAIiAAACEgAAAnwABAHBAAACFQAAAgUABUI4wATBysAAAh0AAAINAAACcgAEQcNAAAIZAAACCQAAAmoAAAIBAAACIQAAAhEAAAJ6AAQBwgAAAhcAAAIHAAACZgAFAdTAAAIfAAACDwAAAnYABIHFwAACGwAAAgsAAAJuAAACAwAAAiMAAAITAAACfgAEAcDAAAIUgAACBIAFQijABMHIwAACHIAAAgyAAAJxAARBwsAAAhiAAAIIgAACaQAAAgCAAAIggAACEIAAAnkABAHBwAACFoAAAgaAAAJlAAUB0MAAAh6AAAIOgAACdQAEgcTAAAIagAACCoAAAm0AAAICgAACIoAAAhKAAAJ9AAQBwUAAAhWAAAIFgBACAAAEwczAAAIdgAACDYAAAnMABEHDwAACGYAAAgmAAAJrAAACAYAAAiGAAAIRgAACewAEAcJAAAIXgAACB4AAAmcABQHYwAACH4AAAg+AAAJ3AASBxsAAAhuAAAILgAACbwAAAgOAAAIjgAACE4AAAn8AGAHAAAACFEAAAgRABUIgwASBx8AAAhxAAAIMQAACcIAEAcKAAAIYQAACCEAAAmiAAAIAQAACIEAAAhBAAAJ4gAQBwYAAAhZAAAIGQAACZIAEwc7AAAIeQAACDkAAAnSABEHEQAACGkAAAgpAAAJsgAACAkAAAiJAAAISQAACfIAEAcEAAAIVQAACBUAEAgCARMHKwAACHUAAAg1AAAJygARBw0AAAhlAAAIJQAACaoAAAgFAAAIhQAACEUAAAnqABAHCAAACF0AAAgdAAAJmgAUB1MAAAh9AAAIPQAACdoAEgcXAAAIbQAACC0AAAm6AAAIDQAACI0AAAhNAAAJ+gAQBwMAAAhTAAAIEwAVCMMAEwcjAAAIcwAACDMAAAnGABEHCwAACGMAAAgjAAAJpgAACAMAAAiDAAAIQwAACeYAEAcHAAAIWwAACBsAAAmWABQHQwAACHsAAAg7AAAJ1gASBxMAAAhrAAAIKwAACbYAAAgLAAAIiwAACEsAAAn2ABAHBQAACFcAAAgXAEAIAAATBzMAAAh3AAAINwAACc4AEQcPAAAIZwAACCcAAAmuAAAIBwAACIcAAAhHAAAJ7gAQBwkAAAhfAAAIHwAACZ4AFAdjAAAIfwAACD8AAAneABIHGwAACG8AAAgvAAAJvgAACA8AAAiPAAAITwAACf4AYAcAAAAIUAAACBAAFAhzABIHHwAACHAAAAgwAAAJwQAQBwoAAAhgAAAIIAAACaEAAAgAAAAIgAAACEAAAAnhABAHBgAACFgAAAgYAAAJkQATBzsAAAh4AAAIOAAACdEAEQcRAAAIaAAACCgAAAmxAAAICAAACIgAAAhIAAAJ8QAQBwQAAAhUAAAIFAAVCOMAEwcrAAAIdAAACDQAAAnJABEHDQAACGQAAAgkAAAJqQAACAQAAAiEAAAIRAAACekAEAcIAAAIXAAACBwAAAmZABQHUwAACHwAAAg8AAAJ2QASBxcAAAhsAAAILAAACbkAAAgMAAAIjAAACEwAAAn5ABAHAwAACFIAAAgSABUIowATByMAAAhyAAAIMgAACcUAEQcLAAAIYgAACCIAAAmlAAAIAgAACIIAAAhCAAAJ5QAQBwcAAAhaAAAIGgAACZUAFAdDAAAIegAACDoAAAnVABIHEwAACGoAAAgqAAAJtQAACAoAAAiKAAAISgAACfUAEAcFAAAIVgAACBYAQAgAABMHMwAACHYAAAg2AAAJzQARBw8AAAhmAAAIJgAACa0AAAgGAAAIhgAACEYAAAntABAHCQAACF4AAAgeAAAJnQAUB2MAAAh+AAAIPgAACd0AEgcbAAAIbgAACC4AAAm9AAAIDgAACI4AAAhOAAAJ/QBgBwAAAAhRAAAIEQAVCIMAEgcfAAAIcQAACDEAAAnDABAHCgAACGEAAAghAAAJowAACAEAAAiBAAAIQQAACeMAEAcGAAAIWQAACBkAAAmTABMHOwAACHkAAAg5AAAJ0wARBxEAAAhpAAAIKQAACbMAAAgJAAAIiQAACEkAAAnzABAHBAAACFUAAAgVABAIAgETBysAAAh1AAAINQAACcsAEQcNAAAIZQAACCUAAAmrAAAIBQAACIUAAAhFAAAJ6wAQBwgAAAhdAAAIHQAACZsAFAdTAAAIfQAACD0AAAnbABIHFwAACG0AAAgtAAAJuwAACA0AAAiNAAAITQAACfsAEAcDAAAIUwAACBMAFQjDABMHIwAACHMAAAgzAAAJxwARBwsAAAhjAAAIIwAACacAAAgDAAAIgwAACEMAAAnnABAHBwAACFsAAAgbAAAJlwAUB0MAAAh7AAAIOwAACdcAEgcTAAAIawAACCsAAAm3AAAICwAACIsAAAhLAAAJ9wAQBwUAAAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnPABEHDwAACGcAAAgnAAAJrwAACAcAAAiHAAAIRwAACe8AEAcJAAAIXwAACB8AAAmfABQHYwAACH8AAAg/AAAJ3wASBxsAAAhvAAAILwAACb8AAAgPAAAIjwAACE8AAAn/ABAFAQAXBQEBEwURABsFARARBQUAGQUBBBUFQQAdBQFAEAUDABgFAQIUBSEAHAUBIBIFCQAaBQEIFgWBAEAFAAAQBQIAFwWBARMFGQAbBQEYEQUHABkFAQYVBWEAHQUBYBAFBAAYBQEDFAUxABwFATASBQ0AGgUBDBYFwQBABQAAEQAKABEREQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAARAA8KERERAwoHAAEACQsLAAAJBgsAAAsABhEAAAAREREAQYGEAQshCwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAALAEG7hAELAQwAQceEAQsVDAAAAAAMAAAAAAkMAAAAAAAMAAAMAEH1hAELAQ4AQYGFAQsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEGvhQELARAAQbuFAQseDwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAEHyhQELDhIAAAASEhIAAAAAAAAJAEGjhgELAQsAQa+GAQsVCgAAAAAKAAAAAAkLAAAAAAALAAALAEHdhgELAQwAQemGAQsnDAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGAEG0hwELARkAQduHAQsF//////8AQaCIAQtXGRJEOwI/LEcUPTMwChsGRktFNw9JDo4XA0AdPGkrNh9KLRwBICUpIQgMFRYiLhA4Pgs0MRhkdHV2L0EJfzkRI0MyQomKiwUEJignDSoeNYwHGkiTE5SVAEGAiQELig5JbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbgBBkJcBC1JQUFAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAAAEAAAAIAAAAlEsAALRLAEGQmQELAgxQAEHImQELCR8AAADkTAAAAwBB5JkBC4wBLfRRWM+MscBG9rXLKTEDxwRbcDC0Xf0geH+LmthZKVBoSImrp1YDbP+3zYg/1He0K6WjcPG65Kj8QYP92W/hinovLXSWBx8NCV4Ddixw90ClLKdvV0GoqnTfoFhkA0rHxDxTrq9fGAQVseNtKIarDKS/Q/DpUIE5VxZSN/////////////////////8=";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            var binary = tryParseAsDataURI(file);
            if (binary) {
              return binary;
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        __name(getBinary, "getBinary");
        function instantiateSync(file, info) {
          var instance;
          var module2;
          var binary;
          try {
            binary = getBinary(file);
            module2 = new WebAssembly.Module(binary);
            instance = new WebAssembly.Instance(module2, info);
          } catch (e) {
            var str = e.toString();
            err("failed to compile wasm module: " + str);
            if (str.includes("imported Memory") || str.includes("memory import")) {
              err(
                "Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time)."
              );
            }
            throw e;
          }
          return [instance, module2];
        }
        __name(instantiateSync, "instantiateSync");
        function createWasm() {
          var info = { a: asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmMemory = Module["asm"]["u"];
            updateGlobalBufferAndViews(wasmMemory.buffer);
            wasmTable = Module["asm"]["pa"];
            addOnInit(Module["asm"]["v"]);
            removeRunDependency("wasm-instantiate");
          }
          __name(receiveInstance, "receiveInstance");
          addRunDependency("wasm-instantiate");
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          var result = instantiateSync(wasmBinaryFile, info);
          receiveInstance(result[0]);
          return Module["asm"];
        }
        __name(createWasm, "createWasm");
        var tempDouble;
        var tempI64;
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        __name(callRuntimeCallbacks, "callRuntimeCallbacks");
        function _gmtime_r(time, tmPtr) {
          var date = new Date(HEAP32[time >> 2] * 1e3);
          HEAP32[tmPtr >> 2] = date.getUTCSeconds();
          HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
          HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
          HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
          HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
          HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
          HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
          HEAP32[tmPtr + 36 >> 2] = 0;
          HEAP32[tmPtr + 32 >> 2] = 0;
          var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
          var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
          HEAP32[tmPtr + 28 >> 2] = yday;
          if (!_gmtime_r.GMTString) _gmtime_r.GMTString = allocateUTF8("GMT");
          HEAP32[tmPtr + 40 >> 2] = _gmtime_r.GMTString;
          return tmPtr;
        }
        __name(_gmtime_r, "_gmtime_r");
        function ___gmtime_r(a0, a1) {
          return _gmtime_r(a0, a1);
        }
        __name(___gmtime_r, "___gmtime_r");
        var PATH = {
          splitPath: /* @__PURE__ */ __name(function(filename) {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, "splitPath"),
          normalizeArray: /* @__PURE__ */ __name(function(parts, allowAboveRoot) {
            var up3 = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up3++;
              } else if (up3) {
                parts.splice(i, 1);
                up3--;
              }
            }
            if (allowAboveRoot) {
              for (; up3; up3--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, "normalizeArray"),
          normalize: /* @__PURE__ */ __name(function(path) {
            var isAbsolute2 = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(
              path.split("/").filter(function(p) {
                return !!p;
              }),
              !isAbsolute2
            ).join("/");
            if (!path && !isAbsolute2) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute2 ? "/" : "") + path;
          }, "normalize"),
          dirname: /* @__PURE__ */ __name(function(path) {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, "dirname"),
          basename: /* @__PURE__ */ __name(function(path) {
            if (path === "/") return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1) return path;
            return path.substr(lastSlash + 1);
          }, "basename"),
          extname: /* @__PURE__ */ __name(function(path) {
            return PATH.splitPath(path)[3];
          }, "extname"),
          join: /* @__PURE__ */ __name(function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          }, "join"),
          join2: /* @__PURE__ */ __name(function(l, r) {
            return PATH.normalize(l + "/" + r);
          }, "join2")
        };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = __require("crypto");
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        __name(getRandomDevice, "getRandomDevice");
        var PATH_FS = {
          resolve: /* @__PURE__ */ __name(function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : FS.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = PATH.normalizeArray(
              resolvedPath.split("/").filter(function(p) {
                return !!p;
              }),
              !resolvedAbsolute
            ).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, "resolve"),
          relative: /* @__PURE__ */ __name(function(from2, to) {
            from2 = PATH_FS.resolve(from2).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            __name(trim, "trim");
            var fromParts = trim(from2.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          }, "relative")
        };
        var TTY = {
          ttys: [],
          init: /* @__PURE__ */ __name(function() {
          }, "init"),
          shutdown: /* @__PURE__ */ __name(function() {
          }, "shutdown"),
          register: /* @__PURE__ */ __name(function(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, "register"),
          stream_ops: {
            open: /* @__PURE__ */ __name(function(stream) {
              var tty = TTY.ttys[stream.node.rdev];
              if (!tty) {
                throw new FS.ErrnoError(43);
              }
              stream.tty = tty;
              stream.seekable = false;
            }, "open"),
            close: /* @__PURE__ */ __name(function(stream) {
              stream.tty.ops.flush(stream.tty);
            }, "close"),
            flush: /* @__PURE__ */ __name(function(stream) {
              stream.tty.ops.flush(stream.tty);
            }, "flush"),
            read: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(60);
              }
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = stream.tty.ops.get_char(stream.tty);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0) break;
                bytesRead++;
                buffer2[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, "read"),
            write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(60);
              }
              try {
                for (var i = 0; i < length; i++) {
                  stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
                }
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            }, "write")
          },
          default_tty_ops: {
            get_char: /* @__PURE__ */ __name(function(tty) {
              if (!tty.input.length) {
                var result = null;
                if (ENVIRONMENT_IS_NODE) {
                  var BUFSIZE = 256;
                  var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
                  var bytesRead = 0;
                  try {
                    bytesRead = nodeFS.readSync(
                      process.stdin.fd,
                      buf,
                      0,
                      BUFSIZE,
                      null
                    );
                  } catch (e) {
                    if (e.toString().includes("EOF")) bytesRead = 0;
                    else throw e;
                  }
                  if (bytesRead > 0) {
                    result = buf.slice(0, bytesRead).toString("utf-8");
                  } else {
                    result = null;
                  }
                } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                  result = window.prompt("Input: ");
                  if (result !== null) {
                    result += "\n";
                  }
                } else if (typeof readline == "function") {
                  result = readline();
                  if (result !== null) {
                    result += "\n";
                  }
                }
                if (!result) {
                  return null;
                }
                tty.input = intArrayFromString(result, true);
              }
              return tty.input.shift();
            }, "get_char"),
            put_char: /* @__PURE__ */ __name(function(tty, val) {
              if (val === null || val === 10) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0) tty.output.push(val);
              }
            }, "put_char"),
            flush: /* @__PURE__ */ __name(function(tty) {
              if (tty.output && tty.output.length > 0) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            }, "flush")
          },
          default_tty1_ops: {
            put_char: /* @__PURE__ */ __name(function(tty, val) {
              if (val === null || val === 10) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0) tty.output.push(val);
              }
            }, "put_char"),
            flush: /* @__PURE__ */ __name(function(tty) {
              if (tty.output && tty.output.length > 0) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            }, "flush")
          }
        };
        function mmapAlloc(size) {
          var alignedSize = alignMemory(size, 65536);
          var ptr = _malloc(alignedSize);
          while (size < alignedSize) HEAP8[ptr + size++] = 0;
          return ptr;
        }
        __name(mmapAlloc, "mmapAlloc");
        var MEMFS = {
          ops_table: null,
          mount: /* @__PURE__ */ __name(function(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, "mount"),
          createNode: /* @__PURE__ */ __name(function(parent, name, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = {
                dir: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    lookup: MEMFS.node_ops.lookup,
                    mknod: MEMFS.node_ops.mknod,
                    rename: MEMFS.node_ops.rename,
                    unlink: MEMFS.node_ops.unlink,
                    rmdir: MEMFS.node_ops.rmdir,
                    readdir: MEMFS.node_ops.readdir,
                    symlink: MEMFS.node_ops.symlink
                  },
                  stream: { llseek: MEMFS.stream_ops.llseek }
                },
                file: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek,
                    read: MEMFS.stream_ops.read,
                    write: MEMFS.stream_ops.write,
                    allocate: MEMFS.stream_ops.allocate,
                    mmap: MEMFS.stream_ops.mmap,
                    msync: MEMFS.stream_ops.msync
                  }
                },
                link: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    readlink: MEMFS.node_ops.readlink
                  },
                  stream: {}
                },
                chrdev: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr
                  },
                  stream: FS.chrdev_stream_ops
                }
              };
            }
            var node = FS.createNode(parent, name, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          }, "createNode"),
          getFileDataAsTypedArray: /* @__PURE__ */ __name(function(node) {
            if (!node.contents) return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, "getFileDataAsTypedArray"),
          expandFileStorage: /* @__PURE__ */ __name(function(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity) return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(
              newCapacity,
              prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
            );
            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          }, "expandFileStorage"),
          resizeFileStorage: /* @__PURE__ */ __name(function(node, newSize) {
            if (node.usedBytes == newSize) return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(
                  oldContents.subarray(0, Math.min(newSize, node.usedBytes))
                );
              }
              node.usedBytes = newSize;
            }
          }, "resizeFileStorage"),
          node_ops: {
            getattr: /* @__PURE__ */ __name(function(node) {
              var attr = {};
              attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
              attr.ino = node.id;
              attr.mode = node.mode;
              attr.nlink = 1;
              attr.uid = 0;
              attr.gid = 0;
              attr.rdev = node.rdev;
              if (FS.isDir(node.mode)) {
                attr.size = 4096;
              } else if (FS.isFile(node.mode)) {
                attr.size = node.usedBytes;
              } else if (FS.isLink(node.mode)) {
                attr.size = node.link.length;
              } else {
                attr.size = 0;
              }
              attr.atime = new Date(node.timestamp);
              attr.mtime = new Date(node.timestamp);
              attr.ctime = new Date(node.timestamp);
              attr.blksize = 4096;
              attr.blocks = Math.ceil(attr.size / attr.blksize);
              return attr;
            }, "getattr"),
            setattr: /* @__PURE__ */ __name(function(node, attr) {
              if (attr.mode !== void 0) {
                node.mode = attr.mode;
              }
              if (attr.timestamp !== void 0) {
                node.timestamp = attr.timestamp;
              }
              if (attr.size !== void 0) {
                MEMFS.resizeFileStorage(node, attr.size);
              }
            }, "setattr"),
            lookup: /* @__PURE__ */ __name(function(parent, name) {
              throw FS.genericErrors[44];
            }, "lookup"),
            mknod: /* @__PURE__ */ __name(function(parent, name, mode, dev) {
              return MEMFS.createNode(parent, name, mode, dev);
            }, "mknod"),
            rename: /* @__PURE__ */ __name(function(old_node, new_dir, new_name) {
              if (FS.isDir(old_node.mode)) {
                var new_node;
                try {
                  new_node = FS.lookupNode(new_dir, new_name);
                } catch (e) {
                }
                if (new_node) {
                  for (var i in new_node.contents) {
                    throw new FS.ErrnoError(55);
                  }
                }
              }
              delete old_node.parent.contents[old_node.name];
              old_node.parent.timestamp = Date.now();
              old_node.name = new_name;
              new_dir.contents[new_name] = old_node;
              new_dir.timestamp = old_node.parent.timestamp;
              old_node.parent = new_dir;
            }, "rename"),
            unlink: /* @__PURE__ */ __name(function(parent, name) {
              delete parent.contents[name];
              parent.timestamp = Date.now();
            }, "unlink"),
            rmdir: /* @__PURE__ */ __name(function(parent, name) {
              var node = FS.lookupNode(parent, name);
              for (var i in node.contents) {
                throw new FS.ErrnoError(55);
              }
              delete parent.contents[name];
              parent.timestamp = Date.now();
            }, "rmdir"),
            readdir: /* @__PURE__ */ __name(function(node) {
              var entries = [".", ".."];
              for (var key2 in node.contents) {
                if (!node.contents.hasOwnProperty(key2)) {
                  continue;
                }
                entries.push(key2);
              }
              return entries;
            }, "readdir"),
            symlink: /* @__PURE__ */ __name(function(parent, newname, oldpath) {
              var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
              node.link = oldpath;
              return node;
            }, "symlink"),
            readlink: /* @__PURE__ */ __name(function(node) {
              if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              return node.link;
            }, "readlink")
          },
          stream_ops: {
            read: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= stream.node.usedBytes) return 0;
              var size = Math.min(stream.node.usedBytes - position, length);
              if (size > 8 && contents.subarray) {
                buffer2.set(contents.subarray(position, position + size), offset);
              } else {
                for (var i = 0; i < size; i++)
                  buffer2[offset + i] = contents[position + i];
              }
              return size;
            }, "read"),
            write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position, canOwn) {
              if (buffer2.buffer === HEAP8.buffer) {
                canOwn = false;
              }
              if (!length) return 0;
              var node = stream.node;
              node.timestamp = Date.now();
              if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                  node.contents = buffer2.subarray(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (node.usedBytes === 0 && position === 0) {
                  node.contents = buffer2.slice(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (position + length <= node.usedBytes) {
                  node.contents.set(
                    buffer2.subarray(offset, offset + length),
                    position
                  );
                  return length;
                }
              }
              MEMFS.expandFileStorage(node, position + length);
              if (node.contents.subarray && buffer2.subarray) {
                node.contents.set(
                  buffer2.subarray(offset, offset + length),
                  position
                );
              } else {
                for (var i = 0; i < length; i++) {
                  node.contents[position + i] = buffer2[offset + i];
                }
              }
              node.usedBytes = Math.max(node.usedBytes, position + length);
              return length;
            }, "write"),
            llseek: /* @__PURE__ */ __name(function(stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  position += stream.node.usedBytes;
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            }, "llseek"),
            allocate: /* @__PURE__ */ __name(function(stream, offset, length) {
              MEMFS.expandFileStorage(stream.node, offset + length);
              stream.node.usedBytes = Math.max(
                stream.node.usedBytes,
                offset + length
              );
            }, "allocate"),
            mmap: /* @__PURE__ */ __name(function(stream, address, length, position, prot, flags) {
              if (address !== 0) {
                throw new FS.ErrnoError(28);
              }
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr;
              var allocated;
              var contents = stream.node.contents;
              if (!(flags & 2) && contents.buffer === buffer) {
                allocated = false;
                ptr = contents.byteOffset;
              } else {
                if (position > 0 || position + length < contents.length) {
                  if (contents.subarray) {
                    contents = contents.subarray(position, position + length);
                  } else {
                    contents = Array.prototype.slice.call(
                      contents,
                      position,
                      position + length
                    );
                  }
                }
                allocated = true;
                ptr = mmapAlloc(length);
                if (!ptr) {
                  throw new FS.ErrnoError(48);
                }
                HEAP8.set(contents, ptr);
              }
              return { ptr, allocated };
            }, "mmap"),
            msync: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, mmapFlags) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (mmapFlags & 2) {
                return 0;
              }
              var bytesWritten = MEMFS.stream_ops.write(
                stream,
                buffer2,
                0,
                length,
                offset,
                false
              );
              return 0;
            }, "msync")
          }
        };
        var ERRNO_CODES = {
          EPERM: 63,
          ENOENT: 44,
          ESRCH: 71,
          EINTR: 27,
          EIO: 29,
          ENXIO: 60,
          E2BIG: 1,
          ENOEXEC: 45,
          EBADF: 8,
          ECHILD: 12,
          EAGAIN: 6,
          EWOULDBLOCK: 6,
          ENOMEM: 48,
          EACCES: 2,
          EFAULT: 21,
          ENOTBLK: 105,
          EBUSY: 10,
          EEXIST: 20,
          EXDEV: 75,
          ENODEV: 43,
          ENOTDIR: 54,
          EISDIR: 31,
          EINVAL: 28,
          ENFILE: 41,
          EMFILE: 33,
          ENOTTY: 59,
          ETXTBSY: 74,
          EFBIG: 22,
          ENOSPC: 51,
          ESPIPE: 70,
          EROFS: 69,
          EMLINK: 34,
          EPIPE: 64,
          EDOM: 18,
          ERANGE: 68,
          ENOMSG: 49,
          EIDRM: 24,
          ECHRNG: 106,
          EL2NSYNC: 156,
          EL3HLT: 107,
          EL3RST: 108,
          ELNRNG: 109,
          EUNATCH: 110,
          ENOCSI: 111,
          EL2HLT: 112,
          EDEADLK: 16,
          ENOLCK: 46,
          EBADE: 113,
          EBADR: 114,
          EXFULL: 115,
          ENOANO: 104,
          EBADRQC: 103,
          EBADSLT: 102,
          EDEADLOCK: 16,
          EBFONT: 101,
          ENOSTR: 100,
          ENODATA: 116,
          ETIME: 117,
          ENOSR: 118,
          ENONET: 119,
          ENOPKG: 120,
          EREMOTE: 121,
          ENOLINK: 47,
          EADV: 122,
          ESRMNT: 123,
          ECOMM: 124,
          EPROTO: 65,
          EMULTIHOP: 36,
          EDOTDOT: 125,
          EBADMSG: 9,
          ENOTUNIQ: 126,
          EBADFD: 127,
          EREMCHG: 128,
          ELIBACC: 129,
          ELIBBAD: 130,
          ELIBSCN: 131,
          ELIBMAX: 132,
          ELIBEXEC: 133,
          ENOSYS: 52,
          ENOTEMPTY: 55,
          ENAMETOOLONG: 37,
          ELOOP: 32,
          EOPNOTSUPP: 138,
          EPFNOSUPPORT: 139,
          ECONNRESET: 15,
          ENOBUFS: 42,
          EAFNOSUPPORT: 5,
          EPROTOTYPE: 67,
          ENOTSOCK: 57,
          ENOPROTOOPT: 50,
          ESHUTDOWN: 140,
          ECONNREFUSED: 14,
          EADDRINUSE: 3,
          ECONNABORTED: 13,
          ENETUNREACH: 40,
          ENETDOWN: 38,
          ETIMEDOUT: 73,
          EHOSTDOWN: 142,
          EHOSTUNREACH: 23,
          EINPROGRESS: 26,
          EALREADY: 7,
          EDESTADDRREQ: 17,
          EMSGSIZE: 35,
          EPROTONOSUPPORT: 66,
          ESOCKTNOSUPPORT: 137,
          EADDRNOTAVAIL: 4,
          ENETRESET: 39,
          EISCONN: 30,
          ENOTCONN: 53,
          ETOOMANYREFS: 141,
          EUSERS: 136,
          EDQUOT: 19,
          ESTALE: 72,
          ENOTSUP: 138,
          ENOMEDIUM: 148,
          EILSEQ: 25,
          EOVERFLOW: 61,
          ECANCELED: 11,
          ENOTRECOVERABLE: 56,
          EOWNERDEAD: 62,
          ESTRPIPE: 135
        };
        var NODEFS = {
          isWindows: false,
          staticInit: /* @__PURE__ */ __name(function() {
            NODEFS.isWindows = !!process.platform.match(/^win/);
            var flags = { fs: fs.constants };
            if (flags["fs"]) {
              flags = flags["fs"];
            }
            NODEFS.flagsForNodeMap = {
              1024: flags["O_APPEND"],
              64: flags["O_CREAT"],
              128: flags["O_EXCL"],
              256: flags["O_NOCTTY"],
              0: flags["O_RDONLY"],
              2: flags["O_RDWR"],
              4096: flags["O_SYNC"],
              512: flags["O_TRUNC"],
              1: flags["O_WRONLY"]
            };
          }, "staticInit"),
          bufferFrom: /* @__PURE__ */ __name(function(arrayBuffer) {
            return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
          }, "bufferFrom"),
          convertNodeCode: /* @__PURE__ */ __name(function(e) {
            var code = e.code;
            return ERRNO_CODES[code];
          }, "convertNodeCode"),
          mount: /* @__PURE__ */ __name(function(mount) {
            return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
          }, "mount"),
          createNode: /* @__PURE__ */ __name(function(parent, name, mode, dev) {
            if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
              throw new FS.ErrnoError(28);
            }
            var node = FS.createNode(parent, name, mode);
            node.node_ops = NODEFS.node_ops;
            node.stream_ops = NODEFS.stream_ops;
            return node;
          }, "createNode"),
          getMode: /* @__PURE__ */ __name(function(path) {
            var stat;
            try {
              stat = fs.lstatSync(path);
              if (NODEFS.isWindows) {
                stat.mode = stat.mode | (stat.mode & 292) >> 2;
              }
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
            return stat.mode;
          }, "getMode"),
          realPath: /* @__PURE__ */ __name(function(node) {
            var parts = [];
            while (node.parent !== node) {
              parts.push(node.name);
              node = node.parent;
            }
            parts.push(node.mount.opts.root);
            parts.reverse();
            return PATH.join.apply(null, parts);
          }, "realPath"),
          flagsForNode: /* @__PURE__ */ __name(function(flags) {
            flags &= ~2097152;
            flags &= ~2048;
            flags &= ~32768;
            flags &= ~524288;
            var newFlags = 0;
            for (var k in NODEFS.flagsForNodeMap) {
              if (flags & k) {
                newFlags |= NODEFS.flagsForNodeMap[k];
                flags ^= k;
              }
            }
            if (!flags) {
              return newFlags;
            } else {
              throw new FS.ErrnoError(28);
            }
          }, "flagsForNode"),
          node_ops: {
            getattr: /* @__PURE__ */ __name(function(node) {
              var path = NODEFS.realPath(node);
              var stat;
              try {
                stat = fs.lstatSync(path);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
              if (NODEFS.isWindows && !stat.blksize) {
                stat.blksize = 4096;
              }
              if (NODEFS.isWindows && !stat.blocks) {
                stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
              }
              return {
                dev: stat.dev,
                ino: stat.ino,
                mode: stat.mode,
                nlink: stat.nlink,
                uid: stat.uid,
                gid: stat.gid,
                rdev: stat.rdev,
                size: stat.size,
                atime: stat.atime,
                mtime: stat.mtime,
                ctime: stat.ctime,
                blksize: stat.blksize,
                blocks: stat.blocks
              };
            }, "getattr"),
            setattr: /* @__PURE__ */ __name(function(node, attr) {
              var path = NODEFS.realPath(node);
              try {
                if (attr.mode !== void 0) {
                  fs.chmodSync(path, attr.mode);
                  node.mode = attr.mode;
                }
                if (attr.timestamp !== void 0) {
                  var date = new Date(attr.timestamp);
                  fs.utimesSync(path, date, date);
                }
                if (attr.size !== void 0) {
                  fs.truncateSync(path, attr.size);
                }
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "setattr"),
            lookup: /* @__PURE__ */ __name(function(parent, name) {
              var path = PATH.join2(NODEFS.realPath(parent), name);
              var mode = NODEFS.getMode(path);
              return NODEFS.createNode(parent, name, mode);
            }, "lookup"),
            mknod: /* @__PURE__ */ __name(function(parent, name, mode, dev) {
              var node = NODEFS.createNode(parent, name, mode, dev);
              var path = NODEFS.realPath(node);
              try {
                if (FS.isDir(node.mode)) {
                  fs.mkdirSync(path, node.mode);
                } else {
                  fs.writeFileSync(path, "", { mode: node.mode });
                }
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
              return node;
            }, "mknod"),
            rename: /* @__PURE__ */ __name(function(oldNode, newDir, newName) {
              var oldPath = NODEFS.realPath(oldNode);
              var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
              try {
                fs.renameSync(oldPath, newPath);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
              oldNode.name = newName;
            }, "rename"),
            unlink: /* @__PURE__ */ __name(function(parent, name) {
              var path = PATH.join2(NODEFS.realPath(parent), name);
              try {
                fs.unlinkSync(path);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "unlink"),
            rmdir: /* @__PURE__ */ __name(function(parent, name) {
              var path = PATH.join2(NODEFS.realPath(parent), name);
              try {
                fs.rmdirSync(path);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "rmdir"),
            readdir: /* @__PURE__ */ __name(function(node) {
              var path = NODEFS.realPath(node);
              try {
                return fs.readdirSync(path);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "readdir"),
            symlink: /* @__PURE__ */ __name(function(parent, newName, oldPath) {
              var newPath = PATH.join2(NODEFS.realPath(parent), newName);
              try {
                fs.symlinkSync(oldPath, newPath);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "symlink"),
            readlink: /* @__PURE__ */ __name(function(node) {
              var path = NODEFS.realPath(node);
              try {
                path = fs.readlinkSync(path);
                path = NODEJS_PATH.relative(
                  NODEJS_PATH.resolve(node.mount.opts.root),
                  path
                );
                return path;
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "readlink")
          },
          stream_ops: {
            open: /* @__PURE__ */ __name(function(stream) {
              var path = NODEFS.realPath(stream.node);
              try {
                if (FS.isFile(stream.node.mode)) {
                  stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
                }
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "open"),
            close: /* @__PURE__ */ __name(function(stream) {
              try {
                if (FS.isFile(stream.node.mode) && stream.nfd) {
                  fs.closeSync(stream.nfd);
                }
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "close"),
            read: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position) {
              if (length === 0) return 0;
              try {
                return fs.readSync(
                  stream.nfd,
                  NODEFS.bufferFrom(buffer2.buffer),
                  offset,
                  length,
                  position
                );
              } catch (e) {
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "read"),
            write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position) {
              try {
                return fs.writeSync(
                  stream.nfd,
                  NODEFS.bufferFrom(buffer2.buffer),
                  offset,
                  length,
                  position
                );
              } catch (e) {
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }, "write"),
            llseek: /* @__PURE__ */ __name(function(stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  try {
                    var stat = fs.fstatSync(stream.nfd);
                    position += stat.size;
                  } catch (e) {
                    throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
                  }
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            }, "llseek"),
            mmap: /* @__PURE__ */ __name(function(stream, address, length, position, prot, flags) {
              if (address !== 0) {
                throw new FS.ErrnoError(28);
              }
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr = mmapAlloc(length);
              NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
              return { ptr, allocated: true };
            }, "mmap"),
            msync: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, mmapFlags) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (mmapFlags & 2) {
                return 0;
              }
              var bytesWritten = NODEFS.stream_ops.write(
                stream,
                buffer2,
                0,
                length,
                offset,
                false
              );
              return 0;
            }, "msync")
          }
        };
        var NODERAWFS = {
          lookupPath: /* @__PURE__ */ __name(function(path) {
            return { path, node: { mode: NODEFS.getMode(path) } };
          }, "lookupPath"),
          createStandardStreams: /* @__PURE__ */ __name(function() {
            FS.streams[0] = {
              fd: 0,
              nfd: 0,
              position: 0,
              path: "",
              flags: 0,
              tty: true,
              seekable: false
            };
            for (var i = 1; i < 3; i++) {
              FS.streams[i] = {
                fd: i,
                nfd: i,
                position: 0,
                path: "",
                flags: 577,
                tty: true,
                seekable: false
              };
            }
          }, "createStandardStreams"),
          cwd: /* @__PURE__ */ __name(function() {
            return process.cwd();
          }, "cwd"),
          chdir: /* @__PURE__ */ __name(function() {
            process.chdir.apply(void 0, arguments);
          }, "chdir"),
          mknod: /* @__PURE__ */ __name(function(path, mode) {
            if (FS.isDir(path)) {
              fs.mkdirSync(path, mode);
            } else {
              fs.writeFileSync(path, "", { mode });
            }
          }, "mknod"),
          mkdir: /* @__PURE__ */ __name(function() {
            fs.mkdirSync.apply(void 0, arguments);
          }, "mkdir"),
          symlink: /* @__PURE__ */ __name(function() {
            fs.symlinkSync.apply(void 0, arguments);
          }, "symlink"),
          rename: /* @__PURE__ */ __name(function() {
            fs.renameSync.apply(void 0, arguments);
          }, "rename"),
          rmdir: /* @__PURE__ */ __name(function() {
            fs.rmdirSync.apply(void 0, arguments);
          }, "rmdir"),
          readdir: /* @__PURE__ */ __name(function() {
            fs.readdirSync.apply(void 0, arguments);
          }, "readdir"),
          unlink: /* @__PURE__ */ __name(function() {
            fs.unlinkSync.apply(void 0, arguments);
          }, "unlink"),
          readlink: /* @__PURE__ */ __name(function() {
            return fs.readlinkSync.apply(void 0, arguments);
          }, "readlink"),
          stat: /* @__PURE__ */ __name(function() {
            return fs.statSync.apply(void 0, arguments);
          }, "stat"),
          lstat: /* @__PURE__ */ __name(function() {
            return fs.lstatSync.apply(void 0, arguments);
          }, "lstat"),
          chmod: /* @__PURE__ */ __name(function() {
            fs.chmodSync.apply(void 0, arguments);
          }, "chmod"),
          fchmod: /* @__PURE__ */ __name(function() {
            fs.fchmodSync.apply(void 0, arguments);
          }, "fchmod"),
          chown: /* @__PURE__ */ __name(function() {
            fs.chownSync.apply(void 0, arguments);
          }, "chown"),
          fchown: /* @__PURE__ */ __name(function() {
            fs.fchownSync.apply(void 0, arguments);
          }, "fchown"),
          truncate: /* @__PURE__ */ __name(function() {
            fs.truncateSync.apply(void 0, arguments);
          }, "truncate"),
          ftruncate: /* @__PURE__ */ __name(function(fd, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            fs.ftruncateSync.apply(void 0, arguments);
          }, "ftruncate"),
          utime: /* @__PURE__ */ __name(function() {
            fs.utimesSync.apply(void 0, arguments);
          }, "utime"),
          open: /* @__PURE__ */ __name(function(path, flags, mode, suggestFD) {
            if (typeof flags === "string") {
              flags = VFS.modeStringToFlags(flags);
            }
            var nfd = fs.openSync(path, NODEFS.flagsForNode(flags), mode);
            var fd = suggestFD != null ? suggestFD : FS.nextfd(nfd);
            var stream = {
              fd,
              nfd,
              position: 0,
              path,
              flags,
              seekable: true
            };
            FS.streams[fd] = stream;
            return stream;
          }, "open"),
          close: /* @__PURE__ */ __name(function(stream) {
            if (!stream.stream_ops) {
              fs.closeSync(stream.nfd);
            }
            FS.closeStream(stream.fd);
          }, "close"),
          llseek: /* @__PURE__ */ __name(function(stream, offset, whence) {
            if (stream.stream_ops) {
              return VFS.llseek(stream, offset, whence);
            }
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              position += fs.fstatSync(stream.nfd).size;
            } else if (whence !== 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
            }
            if (position < 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
            }
            stream.position = position;
            return position;
          }, "llseek"),
          read: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position) {
            if (stream.stream_ops) {
              return VFS.read(stream, buffer2, offset, length, position);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking && stream.seekable) position = stream.position;
            var bytesRead = fs.readSync(
              stream.nfd,
              NODEFS.bufferFrom(buffer2.buffer),
              offset,
              length,
              position
            );
            if (!seeking) stream.position += bytesRead;
            return bytesRead;
          }, "read"),
          write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position) {
            if (stream.stream_ops) {
              return VFS.write(stream, buffer2, offset, length, position);
            }
            if (stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking && stream.seekable) position = stream.position;
            var bytesWritten = fs.writeSync(
              stream.nfd,
              NODEFS.bufferFrom(buffer2.buffer),
              offset,
              length,
              position
            );
            if (!seeking) stream.position += bytesWritten;
            return bytesWritten;
          }, "write"),
          allocate: /* @__PURE__ */ __name(function() {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }, "allocate"),
          mmap: /* @__PURE__ */ __name(function(stream, address, length, position, prot, flags) {
            if (stream.stream_ops) {
              return VFS.mmap(stream, address, length, position, prot, flags);
            }
            if (address !== 0) {
              throw new FS.ErrnoError(28);
            }
            var ptr = mmapAlloc(length);
            FS.read(stream, HEAP8, ptr, length, position);
            return { ptr, allocated: true };
          }, "mmap"),
          msync: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, mmapFlags) {
            if (stream.stream_ops) {
              return VFS.msync(stream, buffer2, offset, length, mmapFlags);
            }
            if (mmapFlags & 2) {
              return 0;
            }
            FS.write(stream, buffer2, 0, length, offset);
            return 0;
          }, "msync"),
          munmap: /* @__PURE__ */ __name(function() {
            return 0;
          }, "munmap"),
          ioctl: /* @__PURE__ */ __name(function() {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
          }, "ioctl")
        };
        var FS = {
          root: null,
          mounts: [],
          devices: {},
          streams: [],
          nextInode: 1,
          nameTable: null,
          currentPath: "/",
          initialized: false,
          ignorePermissions: true,
          trackingDelegate: {},
          tracking: { openFlags: { READ: 1, WRITE: 2 } },
          ErrnoError: null,
          genericErrors: {},
          filesystems: null,
          syncFSRequests: 0,
          lookupPath: /* @__PURE__ */ __name(function(path, opts) {
            path = PATH_FS.resolve(FS.cwd(), path);
            opts = opts || {};
            if (!path) return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            for (var key2 in defaults) {
              if (opts[key2] === void 0) {
                opts[key2] = defaults[key2];
              }
            }
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = PATH.normalizeArray(
              path.split("/").filter(function(p) {
                return !!p;
              }),
              false
            );
            var current = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, {
                    recurse_count: opts.recurse_count
                  });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, "lookupPath"),
          getPath: /* @__PURE__ */ __name(function(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path) return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
              }
              path = path ? node.name + "/" + path : node.name;
              node = node.parent;
            }
          }, "getPath"),
          hashName: /* @__PURE__ */ __name(function(parentid, name) {
            var hash = 0;
            for (var i = 0; i < name.length; i++) {
              hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, "hashName"),
          hashAddNode: /* @__PURE__ */ __name(function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, "hashAddNode"),
          hashRemoveNode: /* @__PURE__ */ __name(function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, "hashRemoveNode"),
          lookupNode: /* @__PURE__ */ __name(function(parent, name) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name) {
                return node;
              }
            }
            return FS.lookup(parent, name);
          }, "lookupNode"),
          createNode: /* @__PURE__ */ __name(function(parent, name, mode, rdev) {
            var node = new FS.FSNode(parent, name, mode, rdev);
            FS.hashAddNode(node);
            return node;
          }, "createNode"),
          destroyNode: /* @__PURE__ */ __name(function(node) {
            FS.hashRemoveNode(node);
          }, "destroyNode"),
          isRoot: /* @__PURE__ */ __name(function(node) {
            return node === node.parent;
          }, "isRoot"),
          isMountpoint: /* @__PURE__ */ __name(function(node) {
            return !!node.mounted;
          }, "isMountpoint"),
          isFile: /* @__PURE__ */ __name(function(mode) {
            return (mode & 61440) === 32768;
          }, "isFile"),
          isDir: /* @__PURE__ */ __name(function(mode) {
            return (mode & 61440) === 16384;
          }, "isDir"),
          isLink: /* @__PURE__ */ __name(function(mode) {
            return (mode & 61440) === 40960;
          }, "isLink"),
          isChrdev: /* @__PURE__ */ __name(function(mode) {
            return (mode & 61440) === 8192;
          }, "isChrdev"),
          isBlkdev: /* @__PURE__ */ __name(function(mode) {
            return (mode & 61440) === 24576;
          }, "isBlkdev"),
          isFIFO: /* @__PURE__ */ __name(function(mode) {
            return (mode & 61440) === 4096;
          }, "isFIFO"),
          isSocket: /* @__PURE__ */ __name(function(mode) {
            return (mode & 49152) === 49152;
          }, "isSocket"),
          flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 },
          modeStringToFlags: /* @__PURE__ */ __name(function(str) {
            var flags = FS.flagModes[str];
            if (typeof flags === "undefined") {
              throw new Error("Unknown file open mode: " + str);
            }
            return flags;
          }, "modeStringToFlags"),
          flagsToPermissionString: /* @__PURE__ */ __name(function(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, "flagsToPermissionString"),
          nodePermissions: /* @__PURE__ */ __name(function(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          }, "nodePermissions"),
          mayLookup: /* @__PURE__ */ __name(function(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode) return errCode;
            if (!dir.node_ops.lookup) return 2;
            return 0;
          }, "mayLookup"),
          mayCreate: /* @__PURE__ */ __name(function(dir, name) {
            try {
              var node = FS.lookupNode(dir, name);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, "mayCreate"),
          mayDelete: /* @__PURE__ */ __name(function(dir, name, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          }, "mayDelete"),
          mayOpen: /* @__PURE__ */ __name(function(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, "mayOpen"),
          MAX_OPEN_FDS: 4096,
          nextfd: /* @__PURE__ */ __name(function(fd_start, fd_end) {
            fd_start = fd_start || 0;
            fd_end = fd_end || FS.MAX_OPEN_FDS;
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          }, "nextfd"),
          getStream: /* @__PURE__ */ __name(function(fd) {
            return FS.streams[fd];
          }, "getStream"),
          createStream: /* @__PURE__ */ __name(function(stream, fd_start, fd_end) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
              };
              FS.FSStream.prototype = {
                object: {
                  get: /* @__PURE__ */ __name(function() {
                    return this.node;
                  }, "get"),
                  set: /* @__PURE__ */ __name(function(val) {
                    this.node = val;
                  }, "set")
                },
                isRead: {
                  get: /* @__PURE__ */ __name(function() {
                    return (this.flags & 2097155) !== 1;
                  }, "get")
                },
                isWrite: {
                  get: /* @__PURE__ */ __name(function() {
                    return (this.flags & 2097155) !== 0;
                  }, "get")
                },
                isAppend: {
                  get: /* @__PURE__ */ __name(function() {
                    return this.flags & 1024;
                  }, "get")
                }
              };
            }
            var newStream = new FS.FSStream();
            for (var p in stream) {
              newStream[p] = stream[p];
            }
            stream = newStream;
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          }, "createStream"),
          closeStream: /* @__PURE__ */ __name(function(fd) {
            FS.streams[fd] = null;
          }, "closeStream"),
          chrdev_stream_ops: {
            open: /* @__PURE__ */ __name(function(stream) {
              var device = FS.getDevice(stream.node.rdev);
              stream.stream_ops = device.stream_ops;
              if (stream.stream_ops.open) {
                stream.stream_ops.open(stream);
              }
            }, "open"),
            llseek: /* @__PURE__ */ __name(function() {
              throw new FS.ErrnoError(70);
            }, "llseek")
          },
          major: /* @__PURE__ */ __name(function(dev) {
            return dev >> 8;
          }, "major"),
          minor: /* @__PURE__ */ __name(function(dev) {
            return dev & 255;
          }, "minor"),
          makedev: /* @__PURE__ */ __name(function(ma, mi) {
            return ma << 8 | mi;
          }, "makedev"),
          registerDevice: /* @__PURE__ */ __name(function(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, "registerDevice"),
          getDevice: /* @__PURE__ */ __name(function(dev) {
            return FS.devices[dev];
          }, "getDevice"),
          getMounts: /* @__PURE__ */ __name(function(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          }, "getMounts"),
          syncfs: /* @__PURE__ */ __name(function(populate, callback) {
            if (typeof populate === "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err(
                "warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work"
              );
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            __name(doCallback, "doCallback");
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            __name(done, "done");
            mounts.forEach(function(mount) {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, "syncfs"),
          mount: /* @__PURE__ */ __name(function(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = {
              type,
              opts,
              mountpoint,
              mounts: []
            };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, "mount"),
          unmount: /* @__PURE__ */ __name(function(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach(function(hash) {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, "unmount"),
          lookup: /* @__PURE__ */ __name(function(parent, name) {
            return parent.node_ops.lookup(parent, name);
          }, "lookup"),
          mknod: /* @__PURE__ */ __name(function(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            if (!name || name === "." || name === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name, mode, dev);
          }, "mknod"),
          create: /* @__PURE__ */ __name(function(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          }, "create"),
          mkdir: /* @__PURE__ */ __name(function(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          }, "mkdir"),
          mkdirTree: /* @__PURE__ */ __name(function(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i]) continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20) throw e;
              }
            }
          }, "mkdirTree"),
          mkdev: /* @__PURE__ */ __name(function(path, mode, dev) {
            if (typeof dev === "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          }, "mkdev"),
          symlink: /* @__PURE__ */ __name(function(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, "symlink"),
          rename: /* @__PURE__ */ __name(function(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative5 = PATH_FS.relative(old_path, new_dirname);
            if (relative5.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative5 = PATH_FS.relative(new_path, old_dirname);
            if (relative5.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            try {
              if (FS.trackingDelegate["willMovePath"]) {
                FS.trackingDelegate["willMovePath"](old_path, new_path);
              }
            } catch (e) {
              err(
                "FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message
              );
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
            try {
              if (FS.trackingDelegate["onMovePath"])
                FS.trackingDelegate["onMovePath"](old_path, new_path);
            } catch (e) {
              err(
                "FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message
              );
            }
          }, "rename"),
          rmdir: /* @__PURE__ */ __name(function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var errCode = FS.mayDelete(parent, name, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err(
                "FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message
              );
            }
            parent.node_ops.rmdir(parent, name);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err(
                "FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message
              );
            }
          }, "rmdir"),
          readdir: /* @__PURE__ */ __name(function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          }, "readdir"),
          unlink: /* @__PURE__ */ __name(function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var errCode = FS.mayDelete(parent, name, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err(
                "FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message
              );
            }
            parent.node_ops.unlink(parent, name);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err(
                "FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message
              );
            }
          }, "unlink"),
          readlink: /* @__PURE__ */ __name(function(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(
              FS.getPath(link.parent),
              link.node_ops.readlink(link)
            );
          }, "readlink"),
          stat: /* @__PURE__ */ __name(function(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          }, "stat"),
          lstat: /* @__PURE__ */ __name(function(path) {
            return FS.stat(path, true);
          }, "lstat"),
          chmod: /* @__PURE__ */ __name(function(path, mode, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              mode: mode & 4095 | node.mode & ~4095,
              timestamp: Date.now()
            });
          }, "chmod"),
          lchmod: /* @__PURE__ */ __name(function(path, mode) {
            FS.chmod(path, mode, true);
          }, "lchmod"),
          fchmod: /* @__PURE__ */ __name(function(fd, mode) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chmod(stream.node, mode);
          }, "fchmod"),
          chown: /* @__PURE__ */ __name(function(path, uid, gid, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, "chown"),
          lchown: /* @__PURE__ */ __name(function(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, "lchown"),
          fchown: /* @__PURE__ */ __name(function(fd, uid, gid) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chown(stream.node, uid, gid);
          }, "fchown"),
          truncate: /* @__PURE__ */ __name(function(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, "truncate"),
          ftruncate: /* @__PURE__ */ __name(function(fd, len) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          }, "ftruncate"),
          utime: /* @__PURE__ */ __name(function(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, "utime"),
          open: /* @__PURE__ */ __name(function(path, flags, mode, fd_start, fd_end) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode === "undefined" ? 438 : mode;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path === "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512) {
              FS.truncate(node, 0);
            }
            flags &= ~(128 | 512 | 131072);
            var stream = FS.createStream(
              {
                node,
                path: FS.getPath(node),
                flags,
                seekable: true,
                position: 0,
                stream_ops: node.stream_ops,
                ungotten: [],
                error: false
              },
              fd_start,
              fd_end
            );
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles) FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                err("FS.trackingDelegate error on read file: " + path);
              }
            }
            try {
              if (FS.trackingDelegate["onOpenFile"]) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                  trackingFlags |= FS.tracking.openFlags.READ;
                }
                if ((flags & 2097155) !== 0) {
                  trackingFlags |= FS.tracking.openFlags.WRITE;
                }
                FS.trackingDelegate["onOpenFile"](path, trackingFlags);
              }
            } catch (e) {
              err(
                "FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message
              );
            }
            return stream;
          }, "open"),
          close: /* @__PURE__ */ __name(function(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents) stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, "close"),
          isClosed: /* @__PURE__ */ __name(function(stream) {
            return stream.fd === null;
          }, "isClosed"),
          llseek: /* @__PURE__ */ __name(function(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, "llseek"),
          read: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(
              stream,
              buffer2,
              offset,
              length,
              position
            );
            if (!seeking) stream.position += bytesRead;
            return bytesRead;
          }, "read"),
          write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, position, canOwn) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(
              stream,
              buffer2,
              offset,
              length,
              position,
              canOwn
            );
            if (!seeking) stream.position += bytesWritten;
            try {
              if (stream.path && FS.trackingDelegate["onWriteToFile"])
                FS.trackingDelegate["onWriteToFile"](stream.path);
            } catch (e) {
              err(
                "FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message
              );
            }
            return bytesWritten;
          }, "write"),
          allocate: /* @__PURE__ */ __name(function(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, "allocate"),
          mmap: /* @__PURE__ */ __name(function(stream, address, length, position, prot, flags) {
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(
              stream,
              address,
              length,
              position,
              prot,
              flags
            );
          }, "mmap"),
          msync: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, mmapFlags) {
            if (!stream || !stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(
              stream,
              buffer2,
              offset,
              length,
              mmapFlags
            );
          }, "msync"),
          munmap: /* @__PURE__ */ __name(function(stream) {
            return 0;
          }, "munmap"),
          ioctl: /* @__PURE__ */ __name(function(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, "ioctl"),
          readFile: /* @__PURE__ */ __name(function(path, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, "readFile"),
          writeFile: /* @__PURE__ */ __name(function(path, data, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data === "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, "writeFile"),
          cwd: /* @__PURE__ */ __name(function() {
            return FS.currentPath;
          }, "cwd"),
          chdir: /* @__PURE__ */ __name(function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          }, "chdir"),
          createDefaultDirectories: /* @__PURE__ */ __name(function() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, "createDefaultDirectories"),
          createDefaultDevices: /* @__PURE__ */ __name(function() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), {
              read: /* @__PURE__ */ __name(function() {
                return 0;
              }, "read"),
              write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, pos) {
                return length;
              }, "write")
            });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var random_device = getRandomDevice();
            FS.createDevice("/dev", "random", random_device);
            FS.createDevice("/dev", "urandom", random_device);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, "createDefaultDevices"),
          createSpecialDirectories: /* @__PURE__ */ __name(function() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount(
              {
                mount: /* @__PURE__ */ __name(function() {
                  var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
                  node.node_ops = {
                    lookup: /* @__PURE__ */ __name(function(parent, name) {
                      var fd = +name;
                      var stream = FS.getStream(fd);
                      if (!stream) throw new FS.ErrnoError(8);
                      var ret = {
                        parent: null,
                        mount: { mountpoint: "fake" },
                        node_ops: {
                          readlink: /* @__PURE__ */ __name(function() {
                            return stream.path;
                          }, "readlink")
                        }
                      };
                      ret.parent = ret;
                      return ret;
                    }, "lookup")
                  };
                  return node;
                }, "mount")
              },
              {},
              "/proc/self/fd"
            );
          }, "createSpecialDirectories"),
          createStandardStreams: /* @__PURE__ */ __name(function() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", 0);
            var stdout = FS.open("/dev/stdout", 1);
            var stderr = FS.open("/dev/stderr", 1);
          }, "createStandardStreams"),
          ensureErrnoError: /* @__PURE__ */ __name(function() {
            if (FS.ErrnoError) return;
            FS.ErrnoError = /* @__PURE__ */ __name(function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            }, "ErrnoError");
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach(function(code) {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          }, "ensureErrnoError"),
          staticInit: /* @__PURE__ */ __name(function() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { MEMFS, NODEFS };
          }, "staticInit"),
          init: /* @__PURE__ */ __name(function(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          }, "init"),
          quit: /* @__PURE__ */ __name(function() {
            FS.init.initialized = false;
            var fflush = Module["_fflush"];
            if (fflush) fflush(0);
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, "quit"),
          getMode: /* @__PURE__ */ __name(function(canRead, canWrite) {
            var mode = 0;
            if (canRead) mode |= 292 | 73;
            if (canWrite) mode |= 146;
            return mode;
          }, "getMode"),
          findObject: /* @__PURE__ */ __name(function(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (ret.exists) {
              return ret.object;
            } else {
              return null;
            }
          }, "findObject"),
          analyzePath: /* @__PURE__ */ __name(function(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = {
              isRoot: false,
              exists: false,
              error: 0,
              name: null,
              path: null,
              object: null,
              parentExists: false,
              parentPath: null,
              parentObject: null
            };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, "analyzePath"),
          createPath: /* @__PURE__ */ __name(function(parent, path, canRead, canWrite) {
            parent = typeof parent === "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part) continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, "createPath"),
          createFile: /* @__PURE__ */ __name(function(parent, name, properties, canRead, canWrite) {
            var path = PATH.join2(
              typeof parent === "string" ? parent : FS.getPath(parent),
              name
            );
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          }, "createFile"),
          createDataFile: /* @__PURE__ */ __name(function(parent, name, data, canRead, canWrite, canOwn) {
            var path = name ? PATH.join2(
              typeof parent === "string" ? parent : FS.getPath(parent),
              name
            ) : parent;
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          }, "createDataFile"),
          createDevice: /* @__PURE__ */ __name(function(parent, name, input, output) {
            var path = PATH.join2(
              typeof parent === "string" ? parent : FS.getPath(parent),
              name
            );
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major) FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, {
              open: /* @__PURE__ */ __name(function(stream) {
                stream.seekable = false;
              }, "open"),
              close: /* @__PURE__ */ __name(function(stream) {
                if (output && output.buffer && output.buffer.length) {
                  output(10);
                }
              }, "close"),
              read: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, pos) {
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                  var result;
                  try {
                    result = input();
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === void 0) break;
                  bytesRead++;
                  buffer2[offset + i] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              }, "read"),
              write: /* @__PURE__ */ __name(function(stream, buffer2, offset, length, pos) {
                for (var i = 0; i < length; i++) {
                  try {
                    output(buffer2[offset + i]);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i;
              }, "write")
            });
            return FS.mkdev(path, mode, dev);
          }, "createDevice"),
          forceLoadFile: /* @__PURE__ */ __name(function(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest !== "undefined") {
              throw new Error(
                "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
              );
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          }, "forceLoadFile"),
          createLazyFile: /* @__PURE__ */ __name(function(parent, name, url, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            __name(LazyUint8Array, "LazyUint8Array");
            LazyUint8Array.prototype.get = /* @__PURE__ */ __name(function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            }, "LazyUint8Array_get");
            LazyUint8Array.prototype.setDataGetter = /* @__PURE__ */ __name(function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            }, "LazyUint8Array_setDataGetter");
            LazyUint8Array.prototype.cacheLength = /* @__PURE__ */ __name(function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing) chunkSize = datalength;
              var doXHR = /* @__PURE__ */ __name(function(from2, to) {
                if (from2 > to)
                  throw new Error(
                    "invalid range (" + from2 + ", " + to + ") or no bytes requested!"
                  );
                if (to > datalength - 1)
                  throw new Error(
                    "only " + datalength + " bytes available! programmer error!"
                  );
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from2 + "-" + to);
                if (typeof Uint8Array != "undefined")
                  xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error(
                    "Couldn't load " + url + ". Status: " + xhr2.status
                  );
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                } else {
                  return intArrayFromString(xhr2.responseText || "", true);
                }
              }, "doXHR");
              var lazyArray2 = this;
              lazyArray2.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out(
                  "LazyFiles on gzip forces download of the whole file when length is accessed"
                );
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            }, "LazyUint8Array_cacheLength");
            if (typeof XMLHttpRequest !== "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, {
                length: {
                  get: /* @__PURE__ */ __name(function() {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._length;
                  }, "get")
                },
                chunkSize: {
                  get: /* @__PURE__ */ __name(function() {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._chunkSize;
                  }, "get")
                }
              });
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, {
              usedBytes: {
                get: /* @__PURE__ */ __name(function() {
                  return this.contents.length;
                }, "get")
              }
            });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach(function(key2) {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = /* @__PURE__ */ __name(function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              }, "forceLoadLazyFile");
            });
            stream_ops.read = /* @__PURE__ */ __name(function stream_ops_read(stream, buffer2, offset, length, position) {
              FS.forceLoadFile(node);
              var contents = stream.node.contents;
              if (position >= contents.length) return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents.get(position + i);
                }
              }
              return size;
            }, "stream_ops_read");
            node.stream_ops = stream_ops;
            return node;
          }, "createLazyFile"),
          createPreloadedFile: /* @__PURE__ */ __name(function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
            Browser.init();
            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
            var dep = getUniqueRunDependency("cp " + fullname);
            function processData(byteArray) {
              function finish(byteArray2) {
                if (preFinish) preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(
                    parent,
                    name,
                    byteArray2,
                    canRead,
                    canWrite,
                    canOwn
                  );
                }
                if (onload) onload();
                removeRunDependency(dep);
              }
              __name(finish, "finish");
              var handled = false;
              Module["preloadPlugins"].forEach(function(plugin) {
                if (handled) return;
                if (plugin["canHandle"](fullname)) {
                  plugin["handle"](byteArray, fullname, finish, function() {
                    if (onerror) onerror();
                    removeRunDependency(dep);
                  });
                  handled = true;
                }
              });
              if (!handled) finish(byteArray);
            }
            __name(processData, "processData");
            addRunDependency(dep);
            if (typeof url == "string") {
              Browser.asyncLoad(
                url,
                function(byteArray) {
                  processData(byteArray);
                },
                onerror
              );
            } else {
              processData(url);
            }
          }, "createPreloadedFile"),
          indexedDB: /* @__PURE__ */ __name(function() {
            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
          }, "indexedDB"),
          DB_NAME: /* @__PURE__ */ __name(function() {
            return "EM_FS_" + window.location.pathname;
          }, "DB_NAME"),
          DB_VERSION: 20,
          DB_STORE_NAME: "FILE_DATA",
          saveFilesToDB: /* @__PURE__ */ __name(function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = /* @__PURE__ */ __name(function openRequest_onupgradeneeded() {
              out("creating db");
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            }, "openRequest_onupgradeneeded");
            openRequest.onsuccess = /* @__PURE__ */ __name(function openRequest_onsuccess() {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok2 = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0) onload();
                else onerror();
              }
              __name(finish, "finish");
              paths.forEach(function(path) {
                var putRequest = files.put(
                  FS.analyzePath(path).object.contents,
                  path
                );
                putRequest.onsuccess = /* @__PURE__ */ __name(function putRequest_onsuccess() {
                  ok2++;
                  if (ok2 + fail == total) finish();
                }, "putRequest_onsuccess");
                putRequest.onerror = /* @__PURE__ */ __name(function putRequest_onerror() {
                  fail++;
                  if (ok2 + fail == total) finish();
                }, "putRequest_onerror");
              });
              transaction.onerror = onerror;
            }, "openRequest_onsuccess");
            openRequest.onerror = onerror;
          }, "saveFilesToDB"),
          loadFilesFromDB: /* @__PURE__ */ __name(function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = /* @__PURE__ */ __name(function openRequest_onsuccess() {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok2 = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0) onload();
                else onerror();
              }
              __name(finish, "finish");
              paths.forEach(function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = /* @__PURE__ */ __name(function getRequest_onsuccess() {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(
                    PATH.dirname(path),
                    PATH.basename(path),
                    getRequest.result,
                    true,
                    true,
                    true
                  );
                  ok2++;
                  if (ok2 + fail == total) finish();
                }, "getRequest_onsuccess");
                getRequest.onerror = /* @__PURE__ */ __name(function getRequest_onerror() {
                  fail++;
                  if (ok2 + fail == total) finish();
                }, "getRequest_onerror");
              });
              transaction.onerror = onerror;
            }, "openRequest_onsuccess");
            openRequest.onerror = onerror;
          }, "loadFilesFromDB")
        };
        var SYSCALLS = {
          mappings: {},
          DEFAULT_POLLMASK: 5,
          umask: 511,
          calculateAt: /* @__PURE__ */ __name(function(dirfd, path, allowEmpty) {
            if (path[0] === "/") {
              return path;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = FS.getStream(dirfd);
              if (!dirstream) throw new FS.ErrnoError(8);
              dir = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path);
          }, "calculateAt"),
          doStat: /* @__PURE__ */ __name(function(func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            HEAP32[buf >> 2] = stat.dev;
            HEAP32[buf + 4 >> 2] = 0;
            HEAP32[buf + 8 >> 2] = stat.ino;
            HEAP32[buf + 12 >> 2] = stat.mode;
            HEAP32[buf + 16 >> 2] = stat.nlink;
            HEAP32[buf + 20 >> 2] = stat.uid;
            HEAP32[buf + 24 >> 2] = stat.gid;
            HEAP32[buf + 28 >> 2] = stat.rdev;
            HEAP32[buf + 32 >> 2] = 0;
            tempI64 = [
              stat.size >>> 0,
              (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil(
                (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
              ) >>> 0 : 0)
            ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
            HEAP32[buf + 48 >> 2] = 4096;
            HEAP32[buf + 52 >> 2] = stat.blocks;
            HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
            HEAP32[buf + 60 >> 2] = 0;
            HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
            HEAP32[buf + 68 >> 2] = 0;
            HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
            HEAP32[buf + 76 >> 2] = 0;
            tempI64 = [
              stat.ino >>> 0,
              (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil(
                (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
              ) >>> 0 : 0)
            ], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
            return 0;
          }, "doStat"),
          doMsync: /* @__PURE__ */ __name(function(addr, stream, len, flags, offset) {
            var buffer2 = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer2, offset, len, flags);
          }, "doMsync"),
          doMkdir: /* @__PURE__ */ __name(function(path, mode) {
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/")
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          }, "doMkdir"),
          doMknod: /* @__PURE__ */ __name(function(path, mode, dev) {
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path, mode, dev);
            return 0;
          }, "doMknod"),
          doReadlink: /* @__PURE__ */ __name(function(path, buf, bufsize) {
            if (bufsize <= 0) return -28;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len] = endChar;
            return len;
          }, "doReadlink"),
          doAccess: /* @__PURE__ */ __name(function(path, amode) {
            if (amode & ~7) {
              return -28;
            }
            var node;
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4) perms += "r";
            if (amode & 2) perms += "w";
            if (amode & 1) perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          }, "doAccess"),
          doDup: /* @__PURE__ */ __name(function(path, flags, suggestFD) {
            var suggest = FS.getStream(suggestFD);
            if (suggest) FS.close(suggest);
            return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
          }, "doDup"),
          doReadv: /* @__PURE__ */ __name(function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAP32[iov + i * 8 >> 2];
              var len = HEAP32[iov + (i * 8 + 4) >> 2];
              var curr = FS.read(stream, HEAP8, ptr, len, offset);
              if (curr < 0) return -1;
              ret += curr;
              if (curr < len) break;
            }
            return ret;
          }, "doReadv"),
          doWritev: /* @__PURE__ */ __name(function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAP32[iov + i * 8 >> 2];
              var len = HEAP32[iov + (i * 8 + 4) >> 2];
              var curr = FS.write(stream, HEAP8, ptr, len, offset);
              if (curr < 0) return -1;
              ret += curr;
            }
            return ret;
          }, "doWritev"),
          varargs: void 0,
          get: /* @__PURE__ */ __name(function() {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
            return ret;
          }, "get"),
          getStr: /* @__PURE__ */ __name(function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }, "getStr"),
          getStreamFromFD: /* @__PURE__ */ __name(function(fd) {
            var stream = FS.getStream(fd);
            if (!stream) throw new FS.ErrnoError(8);
            return stream;
          }, "getStreamFromFD"),
          get64: /* @__PURE__ */ __name(function(low, high) {
            return low;
          }, "get64")
        };
        function ___sys_chmod(path, mode) {
          try {
            path = SYSCALLS.getStr(path);
            FS.chmod(path, mode);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_chmod, "___sys_chmod");
        function setErrNo(value) {
          HEAP32[___errno_location() >> 2] = value;
          return value;
        }
        __name(setErrNo, "setErrNo");
        function ___sys_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                HEAP16[arg + offset >> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_fcntl64, "___sys_fcntl64");
        function ___sys_fstat64(fd, buf) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return SYSCALLS.doStat(FS.stat, stream.path, buf);
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_fstat64, "___sys_fstat64");
        function ___sys_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty) return -59;
                var argp = SYSCALLS.get();
                HEAP32[argp >> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty) return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty) return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_ioctl, "___sys_ioctl");
        function ___sys_open(path, flags, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_open, "___sys_open");
        function ___sys_rename(old_path, new_path) {
          try {
            old_path = SYSCALLS.getStr(old_path);
            new_path = SYSCALLS.getStr(new_path);
            FS.rename(old_path, new_path);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_rename, "___sys_rename");
        function ___sys_rmdir(path) {
          try {
            path = SYSCALLS.getStr(path);
            FS.rmdir(path);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_rmdir, "___sys_rmdir");
        function ___sys_stat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.doStat(FS.stat, path, buf);
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_stat64, "___sys_stat64");
        function ___sys_unlink(path) {
          try {
            path = SYSCALLS.getStr(path);
            FS.unlink(path);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_unlink, "___sys_unlink");
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.copyWithin(dest, src, src + num);
        }
        __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = HEAPU8.length;
          requestedSize = requestedSize >>> 0;
          var maxHeapSize = 2147483648;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(
              overGrownHeapSize,
              requestedSize + 100663296
            );
            var newSize = Math.min(
              maxHeapSize,
              alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
            );
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        __name(_emscripten_resize_heap, "_emscripten_resize_heap");
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_close, "_fd_close");
        function _fd_fdstat_get(fd, pbuf) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
            HEAP8[pbuf >> 0] = type;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_fdstat_get, "_fd_fdstat_get");
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            HEAP32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_read, "_fd_read");
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [
              stream.position >>> 0,
              (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil(
                (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
              ) >>> 0 : 0)
            ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_seek, "_fd_seek");
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            HEAP32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_write, "_fd_write");
        function _setTempRet0(val) {
          setTempRet0(val);
        }
        __name(_setTempRet0, "_setTempRet0");
        function _time(ptr) {
          var ret = Date.now() / 1e3 | 0;
          if (ptr) {
            HEAP32[ptr >> 2] = ret;
          }
          return ret;
        }
        __name(_time, "_time");
        function _tzset() {
          if (_tzset.called) return;
          _tzset.called = true;
          var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
          var winter = new Date(currentYear, 0, 1);
          var summer = new Date(currentYear, 6, 1);
          var winterOffset = winter.getTimezoneOffset();
          var summerOffset = summer.getTimezoneOffset();
          var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
          HEAP32[__get_timezone() >> 2] = stdTimezoneOffset * 60;
          HEAP32[__get_daylight() >> 2] = Number(winterOffset != summerOffset);
          function extractZone(date) {
            var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
            return match ? match[1] : "GMT";
          }
          __name(extractZone, "extractZone");
          var winterName = extractZone(winter);
          var summerName = extractZone(summer);
          var winterNamePtr = allocateUTF8(winterName);
          var summerNamePtr = allocateUTF8(summerName);
          if (summerOffset < winterOffset) {
            HEAP32[__get_tzname() >> 2] = winterNamePtr;
            HEAP32[__get_tzname() + 4 >> 2] = summerNamePtr;
          } else {
            HEAP32[__get_tzname() >> 2] = summerNamePtr;
            HEAP32[__get_tzname() + 4 >> 2] = winterNamePtr;
          }
        }
        __name(_tzset, "_tzset");
        function _timegm(tmPtr) {
          _tzset();
          var time = Date.UTC(
            HEAP32[tmPtr + 20 >> 2] + 1900,
            HEAP32[tmPtr + 16 >> 2],
            HEAP32[tmPtr + 12 >> 2],
            HEAP32[tmPtr + 8 >> 2],
            HEAP32[tmPtr + 4 >> 2],
            HEAP32[tmPtr >> 2],
            0
          );
          var date = new Date(time);
          HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
          var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
          var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
          HEAP32[tmPtr + 28 >> 2] = yday;
          return date.getTime() / 1e3 | 0;
        }
        __name(_timegm, "_timegm");
        var FSNode = /* @__PURE__ */ __name(function(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        }, "FSNode");
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, {
          read: {
            get: /* @__PURE__ */ __name(function() {
              return (this.mode & readMode) === readMode;
            }, "get"),
            set: /* @__PURE__ */ __name(function(val) {
              val ? this.mode |= readMode : this.mode &= ~readMode;
            }, "set")
          },
          write: {
            get: /* @__PURE__ */ __name(function() {
              return (this.mode & writeMode) === writeMode;
            }, "get"),
            set: /* @__PURE__ */ __name(function(val) {
              val ? this.mode |= writeMode : this.mode &= ~writeMode;
            }, "set")
          },
          isFolder: {
            get: /* @__PURE__ */ __name(function() {
              return FS.isDir(this.mode);
            }, "get")
          },
          isDevice: {
            get: /* @__PURE__ */ __name(function() {
              return FS.isChrdev(this.mode);
            }, "get")
          }
        });
        FS.FSNode = FSNode;
        FS.staticInit();
        if (ENVIRONMENT_IS_NODE) {
          var fs = frozenFs;
          var NODEJS_PATH = __require("path");
          NODEFS.staticInit();
        }
        if (ENVIRONMENT_IS_NODE) {
          var _wrapNodeError = /* @__PURE__ */ __name(function(func) {
            return function() {
              try {
                return func.apply(this, arguments);
              } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            };
          }, "_wrapNodeError");
          var VFS = Object.assign({}, FS);
          for (var _key in NODERAWFS) FS[_key] = _wrapNodeError(NODERAWFS[_key]);
        } else {
          throw new Error(
            "NODERAWFS is currently only supported on Node.js environment."
          );
        }
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(
            stringy,
            u8array,
            0,
            u8array.length
          );
          if (dontAddNull) u8array.length = numBytesWritten;
          return u8array;
        }
        __name(intArrayFromString, "intArrayFromString");
        var decodeBase64 = typeof atob === "function" ? atob : function(input) {
          var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          do {
            enc1 = keyStr.indexOf(input.charAt(i++));
            enc2 = keyStr.indexOf(input.charAt(i++));
            enc3 = keyStr.indexOf(input.charAt(i++));
            enc4 = keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
              output = output + String.fromCharCode(chr3);
            }
          } while (i < input.length);
          return output;
        };
        function intArrayFromBase64(s) {
          if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
            var buf;
            try {
              buf = Buffer.from(s, "base64");
            } catch (_) {
              buf = new Buffer(s, "base64");
            }
            return new Uint8Array(
              buf["buffer"],
              buf["byteOffset"],
              buf["byteLength"]
            );
          }
          try {
            var decoded = decodeBase64(s);
            var bytes = new Uint8Array(decoded.length);
            for (var i = 0; i < decoded.length; ++i) {
              bytes[i] = decoded.charCodeAt(i);
            }
            return bytes;
          } catch (_) {
            throw new Error("Converting base64 string to bytes failed.");
          }
        }
        __name(intArrayFromBase64, "intArrayFromBase64");
        function tryParseAsDataURI(filename) {
          if (!isDataURI(filename)) {
            return;
          }
          return intArrayFromBase64(filename.slice(dataURIPrefix.length));
        }
        __name(tryParseAsDataURI, "tryParseAsDataURI");
        var asmLibraryArg = {
          s: ___gmtime_r,
          p: ___sys_chmod,
          e: ___sys_fcntl64,
          k: ___sys_fstat64,
          o: ___sys_ioctl,
          q: ___sys_open,
          i: ___sys_rename,
          r: ___sys_rmdir,
          c: ___sys_stat64,
          h: ___sys_unlink,
          l: _emscripten_memcpy_big,
          m: _emscripten_resize_heap,
          f: _fd_close,
          j: _fd_fdstat_get,
          g: _fd_read,
          n: _fd_seek,
          d: _fd_write,
          a: _setTempRet0,
          b: _time,
          t: _timegm
        };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = asm["v"];
        var _zip_ext_count_symlinks = Module["_zip_ext_count_symlinks"] = asm["w"];
        var _zip_file_get_external_attributes = Module["_zip_file_get_external_attributes"] = asm["x"];
        var _zipstruct_stat = Module["_zipstruct_stat"] = asm["y"];
        var _zipstruct_statS = Module["_zipstruct_statS"] = asm["z"];
        var _zipstruct_stat_name = Module["_zipstruct_stat_name"] = asm["A"];
        var _zipstruct_stat_index = Module["_zipstruct_stat_index"] = asm["B"];
        var _zipstruct_stat_size = Module["_zipstruct_stat_size"] = asm["C"];
        var _zipstruct_stat_mtime = Module["_zipstruct_stat_mtime"] = asm["D"];
        var _zipstruct_stat_crc = Module["_zipstruct_stat_crc"] = asm["E"];
        var _zipstruct_error = Module["_zipstruct_error"] = asm["F"];
        var _zipstruct_errorS = Module["_zipstruct_errorS"] = asm["G"];
        var _zipstruct_error_code_zip = Module["_zipstruct_error_code_zip"] = asm["H"];
        var _zipstruct_stat_comp_size = Module["_zipstruct_stat_comp_size"] = asm["I"];
        var _zipstruct_stat_comp_method = Module["_zipstruct_stat_comp_method"] = asm["J"];
        var _zip_close = Module["_zip_close"] = asm["K"];
        var _zip_delete = Module["_zip_delete"] = asm["L"];
        var _zip_dir_add = Module["_zip_dir_add"] = asm["M"];
        var _zip_discard = Module["_zip_discard"] = asm["N"];
        var _zip_error_init_with_code = Module["_zip_error_init_with_code"] = asm["O"];
        var _zip_get_error = Module["_zip_get_error"] = asm["P"];
        var _zip_file_get_error = Module["_zip_file_get_error"] = asm["Q"];
        var _zip_error_strerror = Module["_zip_error_strerror"] = asm["R"];
        var _zip_fclose = Module["_zip_fclose"] = asm["S"];
        var _zip_file_add = Module["_zip_file_add"] = asm["T"];
        var _free = Module["_free"] = asm["U"];
        var _malloc = Module["_malloc"] = asm["V"];
        var ___errno_location = Module["___errno_location"] = asm["W"];
        var _zip_source_error = Module["_zip_source_error"] = asm["X"];
        var _zip_source_seek = Module["_zip_source_seek"] = asm["Y"];
        var _zip_file_set_external_attributes = Module["_zip_file_set_external_attributes"] = asm["Z"];
        var _zip_file_set_mtime = Module["_zip_file_set_mtime"] = asm["_"];
        var _zip_fopen = Module["_zip_fopen"] = asm["$"];
        var _zip_fopen_index = Module["_zip_fopen_index"] = asm["aa"];
        var _zip_fread = Module["_zip_fread"] = asm["ba"];
        var _zip_get_name = Module["_zip_get_name"] = asm["ca"];
        var _zip_get_num_entries = Module["_zip_get_num_entries"] = asm["da"];
        var _zip_source_read = Module["_zip_source_read"] = asm["ea"];
        var _zip_name_locate = Module["_zip_name_locate"] = asm["fa"];
        var _zip_open = Module["_zip_open"] = asm["ga"];
        var _zip_open_from_source = Module["_zip_open_from_source"] = asm["ha"];
        var _zip_set_file_compression = Module["_zip_set_file_compression"] = asm["ia"];
        var _zip_source_buffer = Module["_zip_source_buffer"] = asm["ja"];
        var _zip_source_buffer_create = Module["_zip_source_buffer_create"] = asm["ka"];
        var _zip_source_close = Module["_zip_source_close"] = asm["la"];
        var _zip_source_free = Module["_zip_source_free"] = asm["ma"];
        var _zip_source_keep = Module["_zip_source_keep"] = asm["na"];
        var _zip_source_open = Module["_zip_source_open"] = asm["oa"];
        var _zip_source_set_mtime = Module["_zip_source_set_mtime"] = asm["qa"];
        var _zip_source_tell = Module["_zip_source_tell"] = asm["ra"];
        var _zip_stat = Module["_zip_stat"] = asm["sa"];
        var _zip_stat_index = Module["_zip_stat_index"] = asm["ta"];
        var __get_tzname = Module["__get_tzname"] = asm["ua"];
        var __get_daylight = Module["__get_daylight"] = asm["va"];
        var __get_timezone = Module["__get_timezone"] = asm["wa"];
        var stackSave = Module["stackSave"] = asm["xa"];
        var stackRestore = Module["stackRestore"] = asm["ya"];
        var stackAlloc = Module["stackAlloc"] = asm["za"];
        Module["cwrap"] = cwrap;
        Module["getValue"] = getValue;
        var calledRun;
        dependenciesFulfilled = /* @__PURE__ */ __name(function runCaller() {
          if (!calledRun) run();
          if (!calledRun) dependenciesFulfilled = runCaller;
        }, "runCaller");
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun) return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT) return;
            initRuntime();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
            postRun();
          }
          __name(doRun, "doRun");
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        __name(run, "run");
        Module["run"] = run;
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        run();
        return createModule2;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = createModule;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return createModule;
      });
    else if (typeof exports === "object") exports["createModule"] = createModule;
  }
});

// ../node_modules/@yarnpkg/libzip/lib/makeInterface.js
var require_makeInterface = __commonJS({
  "../node_modules/@yarnpkg/libzip/lib/makeInterface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeInterface = exports.Errors = void 0;
    var number64 = [
      `number`,
      `number`
      // high
    ];
    var Errors;
    (function(Errors2) {
      Errors2[Errors2["ZIP_ER_OK"] = 0] = "ZIP_ER_OK";
      Errors2[Errors2["ZIP_ER_MULTIDISK"] = 1] = "ZIP_ER_MULTIDISK";
      Errors2[Errors2["ZIP_ER_RENAME"] = 2] = "ZIP_ER_RENAME";
      Errors2[Errors2["ZIP_ER_CLOSE"] = 3] = "ZIP_ER_CLOSE";
      Errors2[Errors2["ZIP_ER_SEEK"] = 4] = "ZIP_ER_SEEK";
      Errors2[Errors2["ZIP_ER_READ"] = 5] = "ZIP_ER_READ";
      Errors2[Errors2["ZIP_ER_WRITE"] = 6] = "ZIP_ER_WRITE";
      Errors2[Errors2["ZIP_ER_CRC"] = 7] = "ZIP_ER_CRC";
      Errors2[Errors2["ZIP_ER_ZIPCLOSED"] = 8] = "ZIP_ER_ZIPCLOSED";
      Errors2[Errors2["ZIP_ER_NOENT"] = 9] = "ZIP_ER_NOENT";
      Errors2[Errors2["ZIP_ER_EXISTS"] = 10] = "ZIP_ER_EXISTS";
      Errors2[Errors2["ZIP_ER_OPEN"] = 11] = "ZIP_ER_OPEN";
      Errors2[Errors2["ZIP_ER_TMPOPEN"] = 12] = "ZIP_ER_TMPOPEN";
      Errors2[Errors2["ZIP_ER_ZLIB"] = 13] = "ZIP_ER_ZLIB";
      Errors2[Errors2["ZIP_ER_MEMORY"] = 14] = "ZIP_ER_MEMORY";
      Errors2[Errors2["ZIP_ER_CHANGED"] = 15] = "ZIP_ER_CHANGED";
      Errors2[Errors2["ZIP_ER_COMPNOTSUPP"] = 16] = "ZIP_ER_COMPNOTSUPP";
      Errors2[Errors2["ZIP_ER_EOF"] = 17] = "ZIP_ER_EOF";
      Errors2[Errors2["ZIP_ER_INVAL"] = 18] = "ZIP_ER_INVAL";
      Errors2[Errors2["ZIP_ER_NOZIP"] = 19] = "ZIP_ER_NOZIP";
      Errors2[Errors2["ZIP_ER_INTERNAL"] = 20] = "ZIP_ER_INTERNAL";
      Errors2[Errors2["ZIP_ER_INCONS"] = 21] = "ZIP_ER_INCONS";
      Errors2[Errors2["ZIP_ER_REMOVE"] = 22] = "ZIP_ER_REMOVE";
      Errors2[Errors2["ZIP_ER_DELETED"] = 23] = "ZIP_ER_DELETED";
      Errors2[Errors2["ZIP_ER_ENCRNOTSUPP"] = 24] = "ZIP_ER_ENCRNOTSUPP";
      Errors2[Errors2["ZIP_ER_RDONLY"] = 25] = "ZIP_ER_RDONLY";
      Errors2[Errors2["ZIP_ER_NOPASSWD"] = 26] = "ZIP_ER_NOPASSWD";
      Errors2[Errors2["ZIP_ER_WRONGPASSWD"] = 27] = "ZIP_ER_WRONGPASSWD";
      Errors2[Errors2["ZIP_ER_OPNOTSUPP"] = 28] = "ZIP_ER_OPNOTSUPP";
      Errors2[Errors2["ZIP_ER_INUSE"] = 29] = "ZIP_ER_INUSE";
      Errors2[Errors2["ZIP_ER_TELL"] = 30] = "ZIP_ER_TELL";
      Errors2[Errors2["ZIP_ER_COMPRESSED_DATA"] = 31] = "ZIP_ER_COMPRESSED_DATA";
    })(Errors = exports.Errors || (exports.Errors = {}));
    var makeInterface = /* @__PURE__ */ __name((libzip) => ({
      // Those are getters because they can change after memory growth
      get HEAP8() {
        return libzip.HEAP8;
      },
      get HEAPU8() {
        return libzip.HEAPU8;
      },
      errors: Errors,
      SEEK_SET: 0,
      SEEK_CUR: 1,
      SEEK_END: 2,
      ZIP_CHECKCONS: 4,
      ZIP_CREATE: 1,
      ZIP_EXCL: 2,
      ZIP_TRUNCATE: 8,
      ZIP_RDONLY: 16,
      ZIP_FL_OVERWRITE: 8192,
      ZIP_FL_COMPRESSED: 4,
      ZIP_OPSYS_DOS: 0,
      ZIP_OPSYS_AMIGA: 1,
      ZIP_OPSYS_OPENVMS: 2,
      ZIP_OPSYS_UNIX: 3,
      ZIP_OPSYS_VM_CMS: 4,
      ZIP_OPSYS_ATARI_ST: 5,
      ZIP_OPSYS_OS_2: 6,
      ZIP_OPSYS_MACINTOSH: 7,
      ZIP_OPSYS_Z_SYSTEM: 8,
      ZIP_OPSYS_CPM: 9,
      ZIP_OPSYS_WINDOWS_NTFS: 10,
      ZIP_OPSYS_MVS: 11,
      ZIP_OPSYS_VSE: 12,
      ZIP_OPSYS_ACORN_RISC: 13,
      ZIP_OPSYS_VFAT: 14,
      ZIP_OPSYS_ALTERNATE_MVS: 15,
      ZIP_OPSYS_BEOS: 16,
      ZIP_OPSYS_TANDEM: 17,
      ZIP_OPSYS_OS_400: 18,
      ZIP_OPSYS_OS_X: 19,
      ZIP_CM_DEFAULT: -1,
      ZIP_CM_STORE: 0,
      ZIP_CM_DEFLATE: 8,
      uint08S: libzip._malloc(1),
      uint16S: libzip._malloc(2),
      uint32S: libzip._malloc(4),
      uint64S: libzip._malloc(8),
      malloc: libzip._malloc,
      free: libzip._free,
      getValue: libzip.getValue,
      open: libzip.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
      openFromSource: libzip.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
      close: libzip.cwrap(`zip_close`, `number`, [`number`]),
      discard: libzip.cwrap(`zip_discard`, null, [`number`]),
      getError: libzip.cwrap(`zip_get_error`, `number`, [`number`]),
      getName: libzip.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
      getNumEntries: libzip.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
      delete: libzip.cwrap(`zip_delete`, `number`, [`number`, `number`]),
      stat: libzip.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
      statIndex: libzip.cwrap(`zip_stat_index`, `number`, [`number`, ...number64, `number`, `number`]),
      fopen: libzip.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
      fopenIndex: libzip.cwrap(`zip_fopen_index`, `number`, [`number`, ...number64, `number`]),
      fread: libzip.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
      fclose: libzip.cwrap(`zip_fclose`, `number`, [`number`]),
      dir: {
        add: libzip.cwrap(`zip_dir_add`, `number`, [`number`, `string`])
      },
      file: {
        add: libzip.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
        getError: libzip.cwrap(`zip_file_get_error`, `number`, [`number`]),
        getExternalAttributes: libzip.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
        setExternalAttributes: libzip.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
        setMtime: libzip.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...number64, `number`, `number`]),
        setCompression: libzip.cwrap(`zip_set_file_compression`, `number`, [`number`, ...number64, `number`, `number`])
      },
      ext: {
        countSymlinks: libzip.cwrap(`zip_ext_count_symlinks`, `number`, [`number`])
      },
      error: {
        initWithCode: libzip.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
        strerror: libzip.cwrap(`zip_error_strerror`, `string`, [`number`])
      },
      name: {
        locate: libzip.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`])
      },
      source: {
        fromUnattachedBuffer: libzip.cwrap(`zip_source_buffer_create`, `number`, [`number`, ...number64, `number`, `number`]),
        fromBuffer: libzip.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...number64, `number`]),
        free: libzip.cwrap(`zip_source_free`, null, [`number`]),
        keep: libzip.cwrap(`zip_source_keep`, null, [`number`]),
        open: libzip.cwrap(`zip_source_open`, `number`, [`number`]),
        close: libzip.cwrap(`zip_source_close`, `number`, [`number`]),
        seek: libzip.cwrap(`zip_source_seek`, `number`, [`number`, ...number64, `number`]),
        tell: libzip.cwrap(`zip_source_tell`, `number`, [`number`]),
        read: libzip.cwrap(`zip_source_read`, `number`, [`number`, `number`, `number`]),
        error: libzip.cwrap(`zip_source_error`, `number`, [`number`]),
        setMtime: libzip.cwrap(`zip_source_set_mtime`, `number`, [`number`, `number`])
      },
      struct: {
        stat: libzip.cwrap(`zipstruct_stat`, `number`, []),
        statS: libzip.cwrap(`zipstruct_statS`, `number`, []),
        statName: libzip.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
        statIndex: libzip.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
        statSize: libzip.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
        statCompSize: libzip.cwrap(`zipstruct_stat_comp_size`, `number`, [`number`]),
        statCompMethod: libzip.cwrap(`zipstruct_stat_comp_method`, `number`, [`number`]),
        statMtime: libzip.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
        statCrc: libzip.cwrap(`zipstruct_stat_crc`, `number`, [`number`]),
        error: libzip.cwrap(`zipstruct_error`, `number`, []),
        errorS: libzip.cwrap(`zipstruct_errorS`, `number`, []),
        errorCodeZip: libzip.cwrap(`zipstruct_error_code_zip`, `number`, [`number`])
      }
    }), "makeInterface");
    exports.makeInterface = makeInterface;
  }
});

// ../node_modules/@yarnpkg/libzip/lib/sync.js
var require_sync = __commonJS({
  "../node_modules/@yarnpkg/libzip/lib/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLibzipPromise = exports.getLibzipSync = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var libzipSync_1 = tslib_1.__importDefault(require_libzipSync());
    var makeInterface_1 = require_makeInterface();
    var mod = null;
    function getLibzipSync2() {
      if (mod === null)
        mod = (0, makeInterface_1.makeInterface)((0, libzipSync_1.default)());
      return mod;
    }
    __name(getLibzipSync2, "getLibzipSync");
    exports.getLibzipSync = getLibzipSync2;
    async function getLibzipPromise() {
      return getLibzipSync2();
    }
    __name(getLibzipPromise, "getLibzipPromise");
    exports.getLibzipPromise = getLibzipPromise;
  }
});

// src/common/presets.ts
import { logger } from "storybook/internal/node-logger";
import { CriticalPresetLoadError } from "storybook/internal/server-errors";
var import_ts_dedent2 = __toESM(require_dist(), 1);

// src/common/utils/interpret-files.ts
import { existsSync } from "node:fs";
var supportedExtensions = [
  ".js",
  ".mjs",
  ".cjs",
  ".jsx",
  ".ts",
  ".mts",
  ".cts",
  ".tsx"
];
function getInterpretedFile(pathToFile) {
  return supportedExtensions.map((ext) => pathToFile.endsWith(ext) ? pathToFile : `${pathToFile}${ext}`).find((candidate) => existsSync(candidate));
}
__name(getInterpretedFile, "getInterpretedFile");

// src/common/utils/strip-abs-node-modules-path.ts
import { posix, sep } from "node:path";
function normalizePath(id) {
  return posix.normalize(slash(id));
}
__name(normalizePath, "normalizePath");
function stripAbsNodeModulesPath(absPath) {
  const splits = absPath.split(`node_modules${sep}`);
  return normalizePath(splits[splits.length - 1]);
}
__name(stripAbsNodeModulesPath, "stripAbsNodeModulesPath");

// src/common/utils/validate-configuration-files.ts
import { resolve as resolve2 } from "node:path";
import { once } from "storybook/internal/node-logger";
import { MainFileMissingError } from "storybook/internal/server-errors";
var import_ts_dedent = __toESM(require_dist(), 1);
async function validateConfigurationFiles(configDir, cwd) {
  const extensionsPattern = `{${Array.from(supportedExtensions).join(",")}}`;
  const mainConfigMatches = await glob(slash(resolve2(configDir, `main${extensionsPattern}`)), {
    cwd: cwd ?? process.cwd()
  });
  const [mainConfigPath] = mainConfigMatches;
  if (mainConfigMatches.length > 1) {
    once.warn(import_ts_dedent.dedent`
      Multiple main files found in your configDir (${resolve2(configDir)}).
      Storybook will use the first one found and ignore the others. Please remove the extra files.
    `);
  }
  if (!mainConfigPath) {
    throw new MainFileMissingError({ location: configDir });
  }
}
__name(validateConfigurationFiles, "validateConfigurationFiles");

// src/common/presets.ts
var isObject = /* @__PURE__ */ __name((val) => val != null && typeof val === "object" && Array.isArray(val) === false, "isObject");
var isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
function filterPresetsConfig(presetsConfig) {
  return presetsConfig.filter((preset) => {
    const presetName = typeof preset === "string" ? preset : preset.name;
    return !/@storybook[\\\\/]preset-typescript/.test(presetName);
  });
}
__name(filterPresetsConfig, "filterPresetsConfig");
function resolvePresetFunction(input, presetOptions, storybookOptions) {
  if (isFunction(input)) {
    return [...input({ ...storybookOptions, ...presetOptions })];
  }
  if (Array.isArray(input)) {
    return [...input];
  }
  return [];
}
__name(resolvePresetFunction, "resolvePresetFunction");
var resolveAddonName = /* @__PURE__ */ __name((configDir, name, options) => {
  const resolved = safeResolveModule({ specifier: name, parent: configDir });
  if (resolved && parse(name).name === "preset") {
    return {
      type: "presets",
      name: resolved
    };
  }
  const presetFile = safeResolveModule({ specifier: join(name, "preset"), parent: configDir });
  const managerFile = safeResolveModule({ specifier: join(name, "manager"), parent: configDir });
  const previewFile = safeResolveModule({ specifier: join(name, "preview"), parent: configDir });
  if (managerFile || previewFile || presetFile) {
    const previewAnnotations = [];
    if (previewFile) {
      const parsedPreviewFile = stripAbsNodeModulesPath(previewFile);
      if (parsedPreviewFile !== previewFile) {
        previewAnnotations.push({
          bare: parsedPreviewFile,
          absolute: previewFile
        });
      } else {
        previewAnnotations.push(previewFile);
      }
    }
    return {
      type: "virtual",
      name,
      presets: presetFile ? [{ name: presetFile, options }] : [],
      managerEntries: managerFile ? [managerFile] : [],
      previewAnnotations
    };
  }
  if (resolved) {
    return {
      type: "presets",
      name: resolved
    };
  }
  return void 0;
}, "resolveAddonName");
var map = /* @__PURE__ */ __name(({ configDir }) => (item) => {
  const options = isObject(item) ? item["options"] || void 0 : void 0;
  const name = isObject(item) ? item["name"] : item;
  let resolved;
  try {
    resolved = resolveAddonName(configDir, name, options);
  } catch (err) {
    logger.error(
      `Addon value should end in /manager or /preview or /register OR it should be a valid preset https://storybook.js.org/docs/addons/writing-presets/
${item}`
    );
    return void 0;
  }
  if (!resolved) {
    logger.warn(`Could not resolve addon "${name}", skipping. Is it installed?`);
    return void 0;
  }
  return {
    ...options ? { options } : {},
    ...resolved
  };
}, "map");
async function getContent(input) {
  if (input.type === "virtual") {
    const { type, name: name2, ...rest } = input;
    return rest;
  }
  const name = input.name ? input.name : input;
  return importModule(name);
}
__name(getContent, "getContent");
async function loadPreset(input, level, storybookOptions) {
  const presetName = input.name ? input.name : input;
  try {
    const presetOptions = input.options ? input.options : {};
    let contents = await getContent(input);
    if (typeof contents === "function") {
      contents = contents(storybookOptions, presetOptions);
    }
    if (Array.isArray(contents)) {
      const subPresets = contents;
      return await loadPresets(subPresets, level + 1, storybookOptions);
    }
    if (isObject(contents)) {
      const { addons: addonsInput = [], presets: presetsInput = [], ...rest } = contents;
      let filter = /* @__PURE__ */ __name((i) => {
        return true;
      }, "filter");
      if (storybookOptions.isCritical !== true && (storybookOptions.build?.test?.disabledAddons?.length || 0) > 0) {
        filter = /* @__PURE__ */ __name((i) => {
          const name = i.name ? i.name : i;
          return !storybookOptions.build?.test?.disabledAddons?.find((n) => name.includes(n));
        }, "filter");
      }
      const subPresets = resolvePresetFunction(
        presetsInput,
        presetOptions,
        storybookOptions
      ).filter(filter);
      const subAddons = resolvePresetFunction(addonsInput, presetOptions, storybookOptions).filter(
        filter
      );
      return [
        ...await loadPresets([...subPresets], level + 1, storybookOptions),
        ...await loadPresets(
          [...subAddons.map(map(storybookOptions))].filter(Boolean),
          level + 1,
          storybookOptions
        ),
        {
          name: presetName,
          preset: rest,
          options: presetOptions
        }
      ];
    }
    throw new Error(import_ts_dedent2.dedent`
      ${input} is not a valid preset
    `);
  } catch (error) {
    if (storybookOptions?.isCritical) {
      throw new CriticalPresetLoadError({
        error,
        presetName
      });
    }
    const warning = level > 0 ? `  Failed to load preset: ${JSON.stringify(input)} on level ${level}` : `  Failed to load preset: ${JSON.stringify(input)}`;
    logger.warn(warning);
    logger.error(error);
    return [];
  }
}
__name(loadPreset, "loadPreset");
async function loadPresets(presets, level, storybookOptions) {
  if (!presets || !Array.isArray(presets) || !presets.length) {
    return [];
  }
  return (await Promise.all(
    presets.map(async (preset) => {
      return loadPreset(preset, level, storybookOptions);
    })
  )).reduce((acc, loaded) => {
    return acc.concat(loaded);
  }, []);
}
__name(loadPresets, "loadPresets");
function applyPresets(presets, extension, config, args, storybookOptions) {
  const presetResult = new Promise((res) => res(config));
  if (!presets.length) {
    return presetResult;
  }
  return presets.reduce((accumulationPromise, { preset, options }) => {
    const change = preset[extension];
    if (!change) {
      return accumulationPromise;
    }
    if (typeof change === "function") {
      const extensionFn = change;
      const context = {
        preset,
        combinedOptions: {
          ...storybookOptions,
          ...args,
          ...options,
          presetsList: presets,
          presets: {
            apply: /* @__PURE__ */ __name(async (ext, c, a = {}) => applyPresets(presets, ext, c, a, storybookOptions), "apply")
          }
        }
      };
      return accumulationPromise.then(
        (newConfig) => extensionFn.call(context.preset, newConfig, context.combinedOptions)
      );
    }
    return accumulationPromise.then((newConfig) => {
      if (Array.isArray(newConfig) && Array.isArray(change)) {
        return [...newConfig, ...change];
      }
      if (isObject(newConfig) && isObject(change)) {
        return { ...newConfig, ...change };
      }
      return change;
    });
  }, presetResult);
}
__name(applyPresets, "applyPresets");
async function getPresets(presets, storybookOptions) {
  const loadedPresets = await loadPresets(presets, 0, storybookOptions);
  return {
    apply: /* @__PURE__ */ __name(async (extension, config, args = {}) => applyPresets(loadedPresets, extension, config, args, storybookOptions), "apply")
  };
}
__name(getPresets, "getPresets");
async function loadAllPresets(options) {
  const { corePresets = [], overridePresets = [], ...restOptions } = options;
  validateConfigurationFiles(options.configDir);
  const mainUrl = getInterpretedFile(resolve(options.configDir, "main"));
  const presetsConfig = [...corePresets, mainUrl, ...overridePresets];
  const filteredPresetConfig = filterPresetsConfig(presetsConfig);
  if (filteredPresetConfig.length < presetsConfig.length) {
    logger.warn(
      "Storybook now supports TypeScript natively. You can safely remove `@storybook/preset-typescript`."
    );
  }
  return getPresets(filteredPresetConfig, restOptions);
}
__name(loadAllPresets, "loadAllPresets");

// src/common/utils/file-cache.ts
import { createHash, randomBytes } from "node:crypto";
import { mkdirSync, readFileSync, readdirSync, rmSync, writeFileSync } from "node:fs";
import { readFile, readdir, rm, writeFile } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join as join2 } from "node:path";
var FileSystemCache = class {
  static {
    __name(this, "FileSystemCache");
  }
  constructor(options = {}) {
    this.prefix = (options.ns || options.prefix || "") + "-";
    this.hash_alg = options.hash_alg || "sha256";
    this.cache_dir = options.basePath || join2(tmpdir(), randomBytes(15).toString("base64").replace(/\//g, "-"));
    this.ttl = options.ttl || 0;
    createHash(this.hash_alg);
    mkdirSync(this.cache_dir, { recursive: true });
  }
  generateHash(name) {
    return join2(this.cache_dir, this.prefix + createHash(this.hash_alg).update(name).digest("hex"));
  }
  isExpired(parsed, now) {
    return parsed.ttl != null && now > parsed.ttl;
  }
  parseCacheData(data, fallback) {
    const parsed = JSON.parse(data);
    return this.isExpired(parsed, Date.now()) ? fallback : parsed.content;
  }
  parseSetData(key, data, opts = {}) {
    const ttl = opts.ttl ?? this.ttl;
    return JSON.stringify({ key, content: data, ...ttl && { ttl: Date.now() + ttl * 1e3 } });
  }
  async get(name, fallback) {
    try {
      const data = await readFile(this.generateHash(name), "utf8");
      return this.parseCacheData(data, fallback);
    } catch {
      return fallback;
    }
  }
  getSync(name, fallback) {
    try {
      const data = readFileSync(this.generateHash(name), "utf8");
      return this.parseCacheData(data, fallback);
    } catch {
      return fallback;
    }
  }
  async set(name, data, orgOpts = {}) {
    const opts = typeof orgOpts === "number" ? { ttl: orgOpts } : orgOpts;
    mkdirSync(this.cache_dir, { recursive: true });
    await writeFile(this.generateHash(name), this.parseSetData(name, data, opts), {
      encoding: opts.encoding || "utf8"
    });
  }
  setSync(name, data, orgOpts = {}) {
    const opts = typeof orgOpts === "number" ? { ttl: orgOpts } : orgOpts;
    mkdirSync(this.cache_dir, { recursive: true });
    writeFileSync(this.generateHash(name), this.parseSetData(name, data, opts), {
      encoding: opts.encoding || "utf8"
    });
  }
  async setMany(items, options) {
    await Promise.all(items.map((item) => this.set(item.key, item.content ?? item.value, options)));
  }
  setManySync(items, options) {
    items.forEach((item) => this.setSync(item.key, item.content ?? item.value, options));
  }
  async remove(name) {
    await rm(this.generateHash(name), { force: true });
  }
  removeSync(name) {
    rmSync(this.generateHash(name), { force: true });
  }
  async clear() {
    const files = await readdir(this.cache_dir);
    await Promise.all(
      files.filter((f) => f.startsWith(this.prefix)).map((f) => rm(join2(this.cache_dir, f), { force: true }))
    );
  }
  clearSync() {
    readdirSync(this.cache_dir).filter((f) => f.startsWith(this.prefix)).forEach((f) => rmSync(join2(this.cache_dir, f), { force: true }));
  }
  async getAll() {
    const now = Date.now();
    const files = await readdir(this.cache_dir);
    const items = await Promise.all(
      files.filter((f) => f.startsWith(this.prefix)).map((f) => readFile(join2(this.cache_dir, f), "utf8"))
    );
    return items.map((data) => JSON.parse(data)).filter((entry) => entry.content && !this.isExpired(entry, now));
  }
  async load() {
    const res = await this.getAll();
    return {
      files: res.map((entry) => ({
        path: this.generateHash(entry.key),
        value: entry.content,
        key: entry.key
      }))
    };
  }
};
function createFileSystemCache(options) {
  return new FileSystemCache(options);
}
__name(createFileSystemCache, "createFileSystemCache");

// src/common/utils/resolve-path-in-sb-cache.ts
import { join as join4 } from "node:path";

// ../node_modules/empathic/package.mjs
import { env } from "node:process";
import { dirname, join as join3 } from "node:path";
import { existsSync as existsSync2, mkdirSync as mkdirSync2 } from "node:fs";

// ../node_modules/empathic/access.mjs
import { accessSync, constants } from "node:fs";
function ok(path, mode) {
  try {
    accessSync(path, mode);
    return true;
  } catch {
    return false;
  }
}
__name(ok, "ok");
function writable(path) {
  return ok(path, constants.W_OK);
}
__name(writable, "writable");

// ../node_modules/empathic/package.mjs
function up2(options) {
  return up("package.json", options);
}
__name(up2, "up");
function cache(name, options) {
  options = options || {};
  let dir = env.CACHE_DIR;
  if (!dir || /^(1|0|true|false)$/.test(dir)) {
    let pkg = up2(options);
    if (dir = pkg && dirname(pkg)) {
      let mods = join3(dir, "node_modules");
      let exists = existsSync2(mods);
      if (!writable(exists ? mods : dir)) return;
      dir = join3(mods, ".cache");
    }
  }
  if (dir) {
    dir = join3(dir, name);
    if (options.create && !existsSync2(dir)) {
      mkdirSync2(dir, { recursive: true });
    }
    return dir;
  }
}
__name(cache, "cache");

// src/common/utils/resolve-path-in-sb-cache.ts
function resolvePathInStorybookCache(fileOrDirectoryName, sub = "default") {
  let cacheDirectory = cache("storybook");
  cacheDirectory ||= join4(process.cwd(), "node_modules", ".cache", "storybook");
  return join4(cacheDirectory, sub, fileOrDirectoryName);
}
__name(resolvePathInStorybookCache, "resolvePathInStorybookCache");

// src/common/utils/cache.ts
var cache2 = createFileSystemCache({
  basePath: resolvePathInStorybookCache("dev-server"),
  ns: "storybook"
  // Optional. A grouping namespace for items.
});

// src/common/utils/cli.ts
import { createWriteStream, mkdirSync as mkdirSync3 } from "node:fs";
import { copyFile, readFile as readFile2, realpath, rm as rm2, writeFile as writeFile2 } from "node:fs/promises";
import os from "node:os";
import { join as join7 } from "node:path";

// ../node_modules/crypto-random-string/index.js
import { promisify } from "util";
import crypto2 from "crypto";
var randomBytesAsync = promisify(crypto2.randomBytes);
var urlSafeCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~".split("");
var numericCharacters = "0123456789".split("");
var distinguishableCharacters = "CDEHKMPRTUWXY012458".split("");
var asciiPrintableCharacters = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~".split("");
var alphanumericCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
var generateForCustomCharacters = /* @__PURE__ */ __name((length, characters) => {
  const characterCount = characters.length;
  const maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1;
  const entropyLength = 2 * Math.ceil(1.1 * length);
  let string = "";
  let stringLength = 0;
  while (stringLength < length) {
    const entropy = crypto2.randomBytes(entropyLength);
    let entropyPosition = 0;
    while (entropyPosition < entropyLength && stringLength < length) {
      const entropyValue = entropy.readUInt16LE(entropyPosition);
      entropyPosition += 2;
      if (entropyValue > maxValidSelector) {
        continue;
      }
      string += characters[entropyValue % characterCount];
      stringLength++;
    }
  }
  return string;
}, "generateForCustomCharacters");
var generateForCustomCharactersAsync = /* @__PURE__ */ __name(async (length, characters) => {
  const characterCount = characters.length;
  const maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1;
  const entropyLength = 2 * Math.ceil(1.1 * length);
  let string = "";
  let stringLength = 0;
  while (stringLength < length) {
    const entropy = await randomBytesAsync(entropyLength);
    let entropyPosition = 0;
    while (entropyPosition < entropyLength && stringLength < length) {
      const entropyValue = entropy.readUInt16LE(entropyPosition);
      entropyPosition += 2;
      if (entropyValue > maxValidSelector) {
        continue;
      }
      string += characters[entropyValue % characterCount];
      stringLength++;
    }
  }
  return string;
}, "generateForCustomCharactersAsync");
var generateRandomBytes = /* @__PURE__ */ __name((byteLength, type, length) => crypto2.randomBytes(byteLength).toString(type).slice(0, length), "generateRandomBytes");
var generateRandomBytesAsync = /* @__PURE__ */ __name(async (byteLength, type, length) => {
  const buffer = await randomBytesAsync(byteLength);
  return buffer.toString(type).slice(0, length);
}, "generateRandomBytesAsync");
var allowedTypes = /* @__PURE__ */ new Set([
  void 0,
  "hex",
  "base64",
  "url-safe",
  "numeric",
  "distinguishable",
  "ascii-printable",
  "alphanumeric"
]);
var createGenerator = /* @__PURE__ */ __name((generateForCustomCharacters2, generateRandomBytes2) => ({ length, type, characters }) => {
  if (!(length >= 0 && Number.isFinite(length))) {
    throw new TypeError("Expected a `length` to be a non-negative finite number");
  }
  if (type !== void 0 && characters !== void 0) {
    throw new TypeError("Expected either `type` or `characters`");
  }
  if (characters !== void 0 && typeof characters !== "string") {
    throw new TypeError("Expected `characters` to be string");
  }
  if (!allowedTypes.has(type)) {
    throw new TypeError(`Unknown type: ${type}`);
  }
  if (type === void 0 && characters === void 0) {
    type = "hex";
  }
  if (type === "hex" || type === void 0 && characters === void 0) {
    return generateRandomBytes2(Math.ceil(length * 0.5), "hex", length);
  }
  if (type === "base64") {
    return generateRandomBytes2(Math.ceil(length * 0.75), "base64", length);
  }
  if (type === "url-safe") {
    return generateForCustomCharacters2(length, urlSafeCharacters);
  }
  if (type === "numeric") {
    return generateForCustomCharacters2(length, numericCharacters);
  }
  if (type === "distinguishable") {
    return generateForCustomCharacters2(length, distinguishableCharacters);
  }
  if (type === "ascii-printable") {
    return generateForCustomCharacters2(length, asciiPrintableCharacters);
  }
  if (type === "alphanumeric") {
    return generateForCustomCharacters2(length, alphanumericCharacters);
  }
  if (characters.length === 0) {
    throw new TypeError("Expected `characters` string length to be greater than or equal to 1");
  }
  if (characters.length > 65536) {
    throw new TypeError("Expected `characters` string length to be less or equal to 65536");
  }
  return generateForCustomCharacters2(length, characters.split(""));
}, "createGenerator");
var cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);
cryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);
var crypto_random_string_default = cryptoRandomString;

// ../node_modules/unique-string/index.js
function uniqueString() {
  return crypto_random_string_default({ length: 32 });
}
__name(uniqueString, "uniqueString");

// src/common/satellite-addons.ts
var satellite_addons_default = [
  "@storybook/test-runner",
  "@chromatic-com/storybook",
  "@storybook/addon-designs",
  "@storybook/addon-svelte-csf",
  "@storybook/addon-coverage",
  "@storybook/addon-webpack5-compiler-babel",
  "@storybook/addon-webpack5-compiler-swc",
  // Storybook for React Native related packages
  // TODO: For Storybook 10, we should check about possible automigrations
  "@storybook/addon-ondevice-actions",
  "@storybook/addon-ondevice-backgrounds",
  "@storybook/addon-ondevice-controls",
  "@storybook/addon-ondevice-notes",
  "@storybook/react-native"
];

// src/common/utils/get-storybook-info.ts
import { existsSync as existsSync3, readFileSync as readFileSync3 } from "node:fs";
import { dirname as dirname3, join as join6 } from "node:path";

// src/common/js-package-manager/JsPackageManager.ts
import { readFileSync as readFileSync2, writeFileSync as writeFileSync2 } from "node:fs";
import { dirname as dirname2, isAbsolute, join as join5, resolve as resolve3 } from "node:path";
import { logger as logger2, prompt } from "storybook/internal/node-logger";
var import_picocolors = __toESM(require_picocolors(), 1);
import { gt, satisfies } from "semver";

// src/common/utils/HandledError.ts
var HandledError = class extends Error {
  constructor(error) {
    super(String(error));
    this.handled = true;
    if (typeof error !== "string") {
      this.cause = error;
    }
  }
  static {
    __name(this, "HandledError");
  }
};

// src/common/js-package-manager/JsPackageManager.ts
var COMMON_ENV_VARS = {
  COREPACK_ENABLE_STRICT: "0",
  COREPACK_ENABLE_AUTO_PIN: "0",
  NO_UPDATE_NOTIFIER: "true"
};
function getPackageDetails(pkg) {
  const idx = pkg.lastIndexOf("@");
  if (idx <= 0) {
    return [pkg, void 0];
  }
  const packageName = pkg.slice(0, idx);
  const packageVersion = pkg.slice(idx + 1);
  return [packageName, packageVersion];
}
__name(getPackageDetails, "getPackageDetails");
var JsPackageManager = class _JsPackageManager {
  static {
    __name(this, "JsPackageManager");
  }
  static {
    /** Cache for latest version results to avoid repeated network calls. */
    this.latestVersionCache = /* @__PURE__ */ new Map();
  }
  static {
    /** Cache for installed version results to avoid repeated file system calls. */
    this.installedVersionCache = /* @__PURE__ */ new Map();
  }
  constructor(options) {
    this.cwd = options?.cwd || process.cwd();
    this.instanceDir = options?.configDir ? isAbsolute(options?.configDir) ? dirname2(options?.configDir) : dirname2(join5(this.cwd, options?.configDir)) : this.cwd;
    this.packageJsonPaths = _JsPackageManager.listAllPackageJsonPaths(
      this.instanceDir,
      options?.storiesPaths
    );
    this.primaryPackageJson = this.#getPrimaryPackageJson();
  }
  isStorybookInMonorepo() {
    const turboJsonPath = up(`turbo.json`, { last: getProjectRoot() });
    const rushJsonPath = up(`rush.json`, { last: getProjectRoot() });
    const nxJsonPath = up(`nx.json`, { last: getProjectRoot() });
    if (turboJsonPath || rushJsonPath || nxJsonPath) {
      return true;
    }
    const packageJsonPaths = findFilesUp(["package.json"]);
    if (packageJsonPaths.length === 0) {
      return false;
    }
    for (const packageJsonPath of packageJsonPaths) {
      const packageJsonFile = readFileSync2(packageJsonPath, "utf8");
      const packageJson = JSON.parse(packageJsonFile);
      if (packageJson.workspaces) {
        return true;
      }
    }
    return false;
  }
  async installDependencies(options) {
    await prompt.executeTask(() => this.runInstall(options), {
      id: "install-dependencies",
      intro: "Installing dependencies...",
      error: "An error occurred while installing dependencies.",
      success: "Dependencies installed"
    });
    this.clearInstalledVersionCache();
  }
  async dedupeDependencies(options) {
    await prompt.executeTask(
      () => this.runInternalCommand("dedupe", [...options?.force ? ["--force"] : []], this.cwd),
      {
        id: "dedupe-dependencies",
        intro: "Deduplicating dependencies...",
        error: "An error occurred while deduplicating dependencies.",
        success: "Dependencies deduplicated"
      }
    );
    this.clearInstalledVersionCache();
  }
  /** Read the `package.json` file available in the provided directory */
  static getPackageJson(packageJsonPath) {
    const jsonContent = readFileSync2(packageJsonPath, "utf8");
    const packageJSON = JSON.parse(jsonContent);
    return {
      ...packageJSON,
      dependencies: { ...packageJSON.dependencies },
      devDependencies: { ...packageJSON.devDependencies },
      peerDependencies: { ...packageJSON.peerDependencies }
    };
  }
  writePackageJson(packageJson, directory = this.cwd) {
    const packageJsonToWrite = { ...packageJson };
    const dependencyTypes = ["dependencies", "devDependencies", "peerDependencies"];
    dependencyTypes.forEach((type) => {
      if (packageJsonToWrite[type] && Object.keys(packageJsonToWrite[type]).length === 0) {
        delete packageJsonToWrite[type];
      }
    });
    const content = `${JSON.stringify(packageJsonToWrite, null, 2)}
`;
    writeFileSync2(resolve3(directory, "package.json"), content, "utf8");
  }
  getAllDependencies() {
    const allDependencies = {};
    for (const packageJsonPath of this.packageJsonPaths) {
      const packageJson = _JsPackageManager.getPackageJson(packageJsonPath);
      const { dependencies, devDependencies, peerDependencies } = packageJson;
      Object.assign(allDependencies, dependencies, devDependencies, peerDependencies);
    }
    return allDependencies;
  }
  isDependencyInstalled(dependency) {
    return Object.keys(this.getAllDependencies()).includes(dependency);
  }
  /**
   * Add dependencies to a project using `yarn add` or `npm install`.
   *
   * @example
   *
   * ```ts
   * addDependencies(options, [
   *   `@storybook/react@${storybookVersion}`,
   *   `@storybook/addon-links@${linksVersion}`,
   * ]);
   * ```
   *
   * @param {Object} options Contains `skipInstall`, `packageJson` and `installAsDevDependencies`
   *   which we use to determine how we install packages.
   * @param {Array} dependencies Contains a list of packages to add.
   */
  async addDependencies(options, dependencies) {
    const {
      skipInstall,
      writeOutputToFile = true,
      packageJsonInfo = this.primaryPackageJson
    } = options;
    if (skipInstall) {
      const { operationDir, packageJson } = packageJsonInfo;
      const dependenciesMap = {};
      for (const dep of dependencies) {
        const [packageName, packageVersion] = getPackageDetails(dep);
        const latestVersion = await this.getVersion(packageName);
        dependenciesMap[packageName] = packageVersion ?? latestVersion;
      }
      const targetDeps = packageJson[options.type];
      Object.assign(targetDeps, dependenciesMap);
      this.writePackageJson(packageJson, operationDir);
    } else {
      try {
        const result = this.runAddDeps(
          dependencies,
          Boolean(options.type === "devDependencies"),
          writeOutputToFile
        );
        this.clearInstalledVersionCache();
        return result;
      } catch (e) {
        logger2.error("\nAn error occurred while installing dependencies:");
        logger2.log(e.message);
        throw new HandledError(e);
      }
    }
  }
  /**
   * Removing dependencies from the package.json file, which is found first starting from the
   * instance root. The method does not run a package manager install like `npm install`.
   *
   * @example
   *
   * ```ts
   * removeDependencies([`@storybook/react`]);
   * ```
   *
   * @param dependencies Contains a list of packages to remove.
   */
  async removeDependencies(dependencies) {
    for (const pjPath of this.packageJsonPaths) {
      try {
        const packageJson = _JsPackageManager.getPackageJson(pjPath);
        let modified = false;
        dependencies.forEach((dep) => {
          if (packageJson.dependencies && packageJson.dependencies[dep]) {
            delete packageJson.dependencies[dep];
            modified = true;
          }
          if (packageJson.devDependencies && packageJson.devDependencies[dep]) {
            delete packageJson.devDependencies[dep];
            modified = true;
          }
          if (packageJson.peerDependencies && packageJson.peerDependencies[dep]) {
            delete packageJson.peerDependencies[dep];
            modified = true;
          }
        });
        if (modified) {
          this.writePackageJson(packageJson, dirname2(pjPath));
          break;
        }
      } catch (e) {
        logger2.warn(`Could not process ${pjPath} for dependency removal: ${String(e)}`);
      }
    }
  }
  /**
   * Return an array of strings matching following format: `<package_name>@<package_latest_version>`
   *
   * For packages in the storybook monorepo, when the latest version is equal to the version of the
   * current CLI the version is not added to the string.
   *
   * When a package is in the monorepo, and the version is not equal to the CLI version, the version
   * is taken from the versions.ts file and added to the string.
   *
   * @param packages
   */
  getVersionedPackages(packages) {
    return Promise.all(
      packages.map(async (pkg) => {
        const [packageName, packageVersion] = getPackageDetails(pkg);
        if (packageVersion && !(packageName in versions_default)) {
          return pkg;
        }
        const latestInRange = await this.latestVersion(packageName, packageVersion);
        const k = packageName;
        const currentVersion = versions_default[k];
        const isLatestStableRelease = currentVersion === latestInRange;
        if (isLatestStableRelease || !currentVersion) {
          return `${packageName}@^${latestInRange}`;
        }
        return `${packageName}@${currentVersion}`;
      })
    );
  }
  /**
   * Return an array of string standing for the latest version of the input packages. To be able to
   * identify which version goes with which package the order of the input array is keep.
   *
   * @param packageNames
   */
  getVersions(...packageNames) {
    return Promise.all(
      packageNames.map((packageName) => {
        return this.getVersion(packageName);
      })
    );
  }
  /**
   * Return the latest version of the input package available on npmjs registry. If constraint are
   * provided it return the latest version matching the constraints.
   *
   * For `@storybook/*` packages the latest version is retrieved from `cli/src/versions.json` file
   * directly
   *
   * @param packageName The name of the package
   * @param constraint A valid semver constraint, example: '1.x || >=2.5.0 || 5.0.0 - 7.2.3'
   */
  async getVersion(packageName, constraint) {
    let current;
    if (packageName in versions_default) {
      current = versions_default[packageName];
    }
    let latest;
    try {
      latest = await this.latestVersion(packageName, constraint);
      if (!latest) {
        throw new Error(`No version found for ${packageName}`);
      }
    } catch (e) {
      if (current) {
        logger2.warn(`
     ${import_picocolors.default.yellow(String(e))}`);
        return current;
      }
      logger2.error(`
     ${import_picocolors.default.red(String(e))}`);
      throw new HandledError(e);
    }
    const versionToUse = current && (!constraint || satisfies(current, constraint)) && gt(current, latest) ? current : latest;
    return `^${versionToUse}`;
  }
  /**
   * Get the latest version of the package available on npmjs.com. If constraint is set then it
   * returns a version satisfying it, otherwise the latest version available is returned.
   *
   * @param packageName Name of the package
   * @param constraint Version range to use to constraint the returned version
   */
  async latestVersion(packageName, constraint) {
    const cacheKey = constraint ? `${packageName}@${constraint}` : packageName;
    const cachedVersion = _JsPackageManager.latestVersionCache.get(cacheKey);
    if (cachedVersion) {
      logger2.debug(`Using cached version for ${packageName}...`);
      return cachedVersion;
    }
    let result;
    logger2.debug(`Getting CLI versions from NPM for ${packageName}...`);
    try {
      if (!constraint) {
        result = await this.runGetVersions(packageName, false);
      } else {
        const versions = await this.runGetVersions(packageName, true);
        const latestVersionSatisfyingTheConstraint = versions.reverse().find((version) => satisfies(version, constraint));
        invariant(
          latestVersionSatisfyingTheConstraint != null,
          `No version satisfying the constraint: ${packageName}${constraint}`
        );
        result = latestVersionSatisfyingTheConstraint;
      }
      _JsPackageManager.latestVersionCache.set(cacheKey, result);
      return result;
    } catch (e) {
      _JsPackageManager.latestVersionCache.set(cacheKey, null);
      return null;
    }
  }
  /**
   * Clear the latest version cache. Useful for testing or when you want to refresh version
   * information.
   *
   * @param packageName Optional package name to clear only specific entries. If not provided,
   *   clears all cache.
   */
  static clearLatestVersionCache(packageName) {
    if (packageName) {
      const keysToDelete = Array.from(_JsPackageManager.latestVersionCache.keys()).filter(
        (key) => key === packageName || key.startsWith(`${packageName}@`)
      );
      keysToDelete.forEach((key) => _JsPackageManager.latestVersionCache.delete(key));
    } else {
      _JsPackageManager.latestVersionCache.clear();
    }
  }
  /**
   * Clear the installed version cache for a specific package or all packages.
   *
   * @param packageName Optional package name to clear from cache. If not provided, clears all.
   */
  clearInstalledVersionCache(packageName) {
    if (packageName) {
      const keysToDelete = Array.from(_JsPackageManager.installedVersionCache.keys()).filter(
        (key) => key.endsWith(`::${packageName}`)
      );
      keysToDelete.forEach((key) => _JsPackageManager.installedVersionCache.delete(key));
    } else {
      _JsPackageManager.installedVersionCache.clear();
    }
  }
  /**
   * Clear both the latest version cache and installed version cache. This should be called after
   * any operation that modifies dependencies.
   */
  clearAllVersionCaches() {
    _JsPackageManager.clearLatestVersionCache();
    this.clearInstalledVersionCache();
  }
  addStorybookCommandInScripts(options) {
    const sbPort = options?.port ?? 6006;
    const storybookCmd = `storybook dev -p ${sbPort}`;
    const buildStorybookCmd = `storybook build`;
    const preCommand = options?.preCommand ? this.getRunCommand(options.preCommand) : void 0;
    this.addScripts({
      storybook: [preCommand, storybookCmd].filter(Boolean).join(" && "),
      "build-storybook": [preCommand, buildStorybookCmd].filter(Boolean).join(" && ")
    });
  }
  addScripts(scripts) {
    const { operationDir, packageJson } = this.#getPrimaryPackageJson();
    this.writePackageJson(
      {
        ...packageJson,
        scripts: {
          ...packageJson.scripts,
          ...scripts
        }
      },
      operationDir
    );
  }
  addPackageResolutions(versions) {
    const { operationDir, packageJson } = this.#getPrimaryPackageJson();
    const resolutions = this.getResolutions(packageJson, versions);
    this.writePackageJson({ ...packageJson, ...resolutions }, operationDir);
  }
  executeCommandSync({
    command,
    args = [],
    stdio,
    cwd,
    ignoreError = false,
    env: env2,
    ...execaOptions
  }) {
    try {
      const commandResult = execaCommandSync([command, ...args].join(" "), {
        cwd: cwd ?? this.cwd,
        stdio: stdio ?? "pipe",
        shell: true,
        cleanup: true,
        env: {
          ...COMMON_ENV_VARS,
          ...env2
        },
        ...execaOptions
      });
      return commandResult.stdout ?? "";
    } catch (err) {
      if (ignoreError !== true) {
        throw err;
      }
      return "";
    }
  }
  /**
   * Execute a command asynchronously and return the execa process. This allows you to hook into
   * stdout/stderr streams and monitor the process.
   *
   * @example Const process = packageManager.executeCommand({ command: 'npm', args: ['install'] });
   * process.stdout?.on('data', (data) => console.log(data.toString())); const result = await
   * process;
   */
  executeCommand({
    command,
    args = [],
    stdio,
    cwd,
    ignoreError = false,
    env: env2,
    ...execaOptions
  }) {
    const execaProcess = execa([command, ...args].join(" "), {
      cwd: cwd ?? this.cwd,
      stdio: stdio ?? "pipe",
      encoding: "utf8",
      shell: true,
      cleanup: true,
      env: {
        ...COMMON_ENV_VARS,
        ...env2
      },
      ...execaOptions
    });
    if (ignoreError) {
      execaProcess.catch((err) => {
      });
    }
    return execaProcess;
  }
  // TODO: Remove pnp compatibility code in SB11
  /** Returns the installed (within node_modules or pnp zip) version of a specified package */
  async getInstalledVersion(packageName) {
    const cacheKey = packageName;
    try {
      const cachedVersion = _JsPackageManager.installedVersionCache.get(cacheKey);
      if (cachedVersion !== void 0) {
        logger2.debug(`Using cached installed version for ${packageName}...`);
        return cachedVersion;
      }
      logger2.debug(`Getting installed version for ${packageName}...`);
      const installations = await this.findInstallations([packageName]);
      if (!installations) {
        _JsPackageManager.installedVersionCache.set(cacheKey, null);
        return null;
      }
      const version = Object.entries(installations.dependencies)[0]?.[1]?.[0].version || null;
      _JsPackageManager.installedVersionCache.set(cacheKey, version);
      return version;
    } catch (e) {
      _JsPackageManager.installedVersionCache.set(cacheKey, null);
      return null;
    }
  }
  async isPackageInstalled(packageName) {
    const version = await this.getInstalledVersion(packageName);
    return version !== null;
  }
  /**
   * Searches for a dependency/devDependency in all package.json files and returns the version of
   * the dependency.
   */
  getDependencyVersion(dependency) {
    const dependencyVersion = this.packageJsonPaths.map((path) => {
      const packageJson = _JsPackageManager.getPackageJson(path);
      return packageJson.dependencies?.[dependency] ?? packageJson.devDependencies?.[dependency];
    }).filter(Boolean);
    return dependencyVersion[0] ?? null;
  }
  // Helper to read and check a package.json for storybook dependency
  static hasStorybookDependency(packageJsonPath) {
    try {
      const content = readFileSync2(packageJsonPath, "utf-8");
      const packageJson = JSON.parse(content);
      return !!(packageJson.dependencies && packageJson.dependencies.storybook || packageJson.devDependencies && packageJson.devDependencies.storybook);
    } catch (error) {
      return false;
    }
  }
  // Helper to read and check a package.json for storybook dependency
  static hasAnyStorybookDependency(packageJsonPath) {
    try {
      const content = readFileSync2(packageJsonPath, "utf-8");
      const packageJson = JSON.parse(content);
      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      };
      return Object.keys(allDeps).some((dep) => dep.includes("storybook"));
    } catch (error) {
      return false;
    }
  }
  /**
   * Find the primary package.json file in the project root. The primary package.json file is the
   * one that contains the `storybook` dependency. If no primary package.json file is found, the
   * function will return the package.json file in the project root.
   */
  #findPrimaryPackageJsonPath() {
    for (const packageJsonPath of this.packageJsonPaths) {
      const hasStorybook = _JsPackageManager.hasStorybookDependency(packageJsonPath);
      if (hasStorybook) {
        return packageJsonPath;
      }
    }
    return this.packageJsonPaths[0] ?? resolve3(this.cwd, "package.json");
  }
  /** List all package.json files starting from the given directory and stopping at the project root. */
  static listAllPackageJsonPaths(instanceDir, storiesPaths) {
    const packageJsonPaths = findFilesUp(["package.json"], instanceDir);
    if (!storiesPaths) {
      return packageJsonPaths;
    }
    const projectRoot = getProjectRoot();
    const allPackageJsonFiles = globSync("**/package.json", {
      cwd: projectRoot,
      absolute: true,
      ignore: ["**/node_modules/**", "**/dist/**"]
    });
    const relevantPackageJsons = allPackageJsonFiles.filter((packageJsonPath) => {
      const packageDir = dirname2(packageJsonPath);
      return storiesPaths.some((storyPath) => storyPath.startsWith(packageDir));
    });
    return Array.from(/* @__PURE__ */ new Set([...packageJsonPaths, ...relevantPackageJsons]));
  }
  /**
   * Get the primary package.json file and its operation directory. The primary package.json file is
   * the one that contains the storybook dependency. If the primary package.json file is not found,
   * the function returns information about thepackage.json file in the current working directory.
   */
  #getPrimaryPackageJson() {
    const finalTargetPackageJsonPath = this.#findPrimaryPackageJsonPath();
    return _JsPackageManager.getPackageJsonInfo(finalTargetPackageJsonPath);
  }
  static getPackageJsonInfo(packageJsonPath) {
    const operationDir = dirname2(packageJsonPath);
    return {
      packageJsonPath,
      operationDir,
      get packageJson() {
        return _JsPackageManager.getPackageJson(packageJsonPath);
      }
    };
  }
};

// src/common/utils/get-storybook-configuration.ts
function getStorybookConfiguration(storybookScript, shortName, longName) {
  if (!storybookScript) {
    return null;
  }
  const parts = storybookScript.split(/[\s='"]+/);
  let index = parts.indexOf(longName);
  if (index === -1) {
    index = parts.indexOf(shortName);
  }
  if (index === -1) {
    return null;
  }
  return parts[index + 1];
}
__name(getStorybookConfiguration, "getStorybookConfiguration");

// src/common/utils/get-storybook-info.ts
var rendererPackages = {
  "@storybook/react": "react",
  "@storybook/vue3": "vue3",
  "@storybook/angular": "angular",
  "@storybook/html": "html",
  "@storybook/web-components": "web-components",
  "@storybook/polymer": "polymer",
  "@storybook/ember": "ember",
  "@storybook/svelte": "svelte",
  "@storybook/preact": "preact",
  "@storybook/server": "server",
  // community (outside of monorepo)
  "storybook-framework-qwik": "qwik",
  "storybook-solidjs-vite": "solid",
  /** @deprecated This is deprecated. */
  "@storybook/vue": "vue"
};
var frameworkPackages = {
  "@storybook/angular": "angular",
  "@storybook/ember": "ember",
  "@storybook/html-vite": "html-vite",
  "@storybook/nextjs": "nextjs",
  "@storybook/preact-vite": "preact-vite",
  "@storybook/react-vite": "react-vite",
  "@storybook/react-webpack5": "react-webpack5",
  "@storybook/server-webpack5": "server-webpack5",
  "@storybook/svelte-vite": "svelte-vite",
  "@storybook/sveltekit": "sveltekit",
  "@storybook/vue3-vite": "vue3-vite",
  "@storybook/nextjs-vite": "nextjs-vite",
  "@storybook/react-native-web-vite": "react-native-web-vite",
  "@storybook/web-components-vite": "web-components-vite",
  // community (outside of monorepo)
  "storybook-framework-qwik": "qwik",
  "storybook-solidjs-vite": "solid",
  "storybook-react-rsbuild": "react-rsbuild",
  "storybook-vue3-rsbuild": "vue3-rsbuild"
};
var builderPackages = ["@storybook/builder-webpack5", "@storybook/builder-vite"];
var findDependency = /* @__PURE__ */ __name(({ dependencies, devDependencies, peerDependencies }, predicate) => [
  Object.entries(dependencies || {}).find(predicate),
  Object.entries(devDependencies || {}).find(predicate),
  Object.entries(peerDependencies || {}).find(predicate)
], "findDependency");
var getRendererInfo = /* @__PURE__ */ __name((configDir) => {
  const packageJsonPaths = JsPackageManager.listAllPackageJsonPaths(dirname3(configDir));
  for (const packageJsonPath of packageJsonPaths) {
    const packageJson = JSON.parse(readFileSync3(packageJsonPath, "utf-8"));
    const [dep, devDep, peerDep] = findDependency(packageJson, ([key]) => rendererPackages[key]);
    const [pkg, version] = dep || devDep || peerDep || [];
    if (pkg && version) {
      return {
        version,
        frameworkPackage: pkg
      };
    }
  }
  return {
    version: void 0,
    frameworkPackage: void 0
  };
}, "getRendererInfo");
var validConfigExtensions = ["ts", "js", "tsx", "jsx", "mjs", "cjs"];
var findConfigFile = /* @__PURE__ */ __name((prefix, configDir) => {
  const filePrefix = join6(configDir, prefix);
  const extension = validConfigExtensions.find((ext) => existsSync3(`${filePrefix}.${ext}`));
  return extension ? `${filePrefix}.${extension}` : null;
}, "findConfigFile");
var getConfigInfo = /* @__PURE__ */ __name((configDir) => {
  let storybookConfigDir = configDir ?? ".storybook";
  if (!existsSync3(storybookConfigDir)) {
    const packageJsonPaths = JsPackageManager.listAllPackageJsonPaths(storybookConfigDir);
    for (const packageJsonPath of packageJsonPaths) {
      const packageJson = JSON.parse(readFileSync3(packageJsonPath, "utf-8"));
      const storybookScript = packageJson.scripts?.storybook;
      if (storybookScript && !configDir) {
        const configParam = getStorybookConfiguration(storybookScript, "-c", "--config-dir");
        if (configParam) {
          storybookConfigDir = configParam;
          break;
        }
      }
    }
  }
  return {
    configDir: storybookConfigDir,
    mainConfigPath: findConfigFile("main", storybookConfigDir),
    previewConfigPath: findConfigFile("preview", storybookConfigDir),
    managerConfigPath: findConfigFile("manager", storybookConfigDir)
  };
}, "getConfigInfo");
var getStorybookInfo = /* @__PURE__ */ __name((configDir = ".storybook") => {
  const rendererInfo = getRendererInfo(configDir);
  const configInfo = getConfigInfo(configDir);
  return {
    ...rendererInfo,
    ...configInfo
  };
}, "getStorybookInfo");

// src/common/utils/cli.ts
var tempDir = /* @__PURE__ */ __name(() => realpath(os.tmpdir()), "tempDir");
var getPath = /* @__PURE__ */ __name(async (prefix = "") => join7(await tempDir(), prefix + uniqueString()), "getPath");
async function temporaryDirectory({ prefix = "" } = {}) {
  const directory = await getPath(prefix);
  mkdirSync3(directory);
  return directory;
}
__name(temporaryDirectory, "temporaryDirectory");
async function temporaryFile({ name, extension } = {}) {
  if (name) {
    if (extension !== void 0 && extension !== null) {
      throw new Error("The `name` and `extension` options are mutually exclusive");
    }
    return join7(await temporaryDirectory(), name);
  }
  return await getPath() + (extension === void 0 || extension === null ? "" : "." + extension.replace(/^\./, ""));
}
__name(temporaryFile, "temporaryFile");
function parseList(str) {
  return str.split(",").map((item) => item.trim()).filter((item) => item.length > 0);
}
__name(parseList, "parseList");
async function getCoercedStorybookVersion(packageManager) {
  const packages = (await Promise.all(
    Object.keys(rendererPackages).map(async (pkg) => ({
      name: pkg,
      version: (await packageManager.getModulePackageJSON(pkg))?.version ?? null
    }))
  )).filter(({ version }) => !!version);
  return packages[0]?.version || versions_default.storybook;
}
__name(getCoercedStorybookVersion, "getCoercedStorybookVersion");
function getEnvConfig(program, configEnv) {
  Object.keys(configEnv).forEach((fieldName) => {
    const envVarName = configEnv[fieldName];
    const envVarValue = process.env[envVarName];
    if (envVarValue) {
      program[fieldName] = envVarValue;
    }
  });
}
__name(getEnvConfig, "getEnvConfig");
var createLogStream = /* @__PURE__ */ __name(async (logFileName = "storybook.log") => {
  const finalLogPath = join7(process.cwd(), logFileName);
  const temporaryLogPath = await temporaryFile({ name: logFileName });
  const logStream = createWriteStream(temporaryLogPath, { encoding: "utf8" });
  return new Promise((resolve8, reject) => {
    logStream.once("open", () => {
      const clearLogFile = /* @__PURE__ */ __name(async () => writeFile2(temporaryLogPath, ""), "clearLogFile");
      const removeLogFile = /* @__PURE__ */ __name(async () => rm2(temporaryLogPath, { recursive: true, force: true }), "removeLogFile");
      const readLogFile = /* @__PURE__ */ __name(async () => readFile2(temporaryLogPath, { encoding: "utf8" }), "readLogFile");
      const moveLogFile = /* @__PURE__ */ __name(async () => copyFile(temporaryLogPath, finalLogPath).then(removeLogFile), "moveLogFile");
      resolve8({ logStream, moveLogFile, clearLogFile, removeLogFile, readLogFile });
    });
    logStream.once("error", reject);
  });
}, "createLogStream");
var isCorePackage = /* @__PURE__ */ __name((pkg) => !!versions_default[pkg], "isCorePackage");
var isSatelliteAddon = /* @__PURE__ */ __name((pkg) => satellite_addons_default.includes(pkg), "isSatelliteAddon");

// src/common/utils/check-addon-order.ts
import { logger as logger3 } from "storybook/internal/node-logger";
var predicateFor = /* @__PURE__ */ __name((addon) => (entry) => {
  const name = entry.name || entry;
  return name && name.replaceAll(/(\\){1,2}/g, "/").includes(addon);
}, "predicateFor");
var isCorrectOrder = /* @__PURE__ */ __name((addons, before, after) => {
  const essentialsIndex = addons.findIndex(predicateFor("@storybook/addon-essentials"));
  let beforeIndex = addons.findIndex(predicateFor(before.name));
  let afterIndex = addons.findIndex(predicateFor(after.name));
  if (beforeIndex === -1 && before.inEssentials) {
    beforeIndex = essentialsIndex;
  }
  if (afterIndex === -1 && after.inEssentials) {
    afterIndex = essentialsIndex;
  }
  return beforeIndex !== -1 && afterIndex !== -1 && beforeIndex <= afterIndex;
}, "isCorrectOrder");
var checkAddonOrder = /* @__PURE__ */ __name(async ({ before, after, configFile, getConfig }) => {
  try {
    const config = await getConfig(configFile);
    if (!config?.addons) {
      logger3.warn(`Unable to find 'addons' config in main Storybook config`);
      return;
    }
    if (!isCorrectOrder(config.addons, before, after)) {
      const orEssentials = " (or '@storybook/addon-essentials')";
      const beforeText = `'${before.name}'${before.inEssentials ? orEssentials : ""}`;
      const afterText = `'${after.name}'${after.inEssentials ? orEssentials : ""}`;
      logger3.warn(
        `Expected ${beforeText} to be listed before ${afterText} in main Storybook config.`
      );
    }
  } catch (e) {
    logger3.warn(`Unable to load config file: ${configFile}`);
  }
}, "checkAddonOrder");

// src/common/utils/common-glob-options.ts
var NODE_MODULES_RE = /node_modules/;
var commonGlobOptions = /* @__PURE__ */ __name((glob2) => NODE_MODULES_RE.test(glob2) ? {} : { ignore: ["**/node_modules/**"] }, "commonGlobOptions");

// src/common/utils/framework-to-renderer.ts
var frameworkToRenderer = {
  // frameworks
  angular: "angular",
  ember: "ember",
  "html-vite": "html",
  nextjs: "react",
  "nextjs-vite": "react",
  "preact-vite": "preact",
  qwik: "qwik",
  "react-vite": "react",
  "react-webpack5": "react",
  "server-webpack5": "server",
  solid: "solid",
  "svelte-vite": "svelte",
  sveltekit: "svelte",
  "vue3-vite": "vue3",
  nuxt: "vue3",
  "web-components-vite": "web-components",
  "react-rsbuild": "react",
  "vue3-rsbuild": "vue3",
  // renderers
  html: "html",
  preact: "preact",
  "react-native": "react-native",
  "react-native-web-vite": "react",
  react: "react",
  server: "server",
  svelte: "svelte",
  vue3: "vue3",
  "web-components": "web-components"
};

// src/common/utils/get-builder-options.ts
async function getBuilderOptions(options) {
  const framework = await options.presets.apply("framework", {}, options);
  if (typeof framework !== "string" && framework?.options?.builder) {
    return framework.options.builder;
  }
  const { builder } = await options.presets.apply("core", {}, options);
  if (typeof builder !== "string" && builder?.options) {
    return builder.options;
  }
  return {};
}
__name(getBuilderOptions, "getBuilderOptions");

// src/common/utils/get-framework-name.ts
var import_ts_dedent3 = __toESM(require_dist(), 1);

// src/common/utils/normalize-path.ts
import { posix as posix2 } from "node:path";
function normalizePath2(p) {
  return posix2.normalize(p.replace(/\\/g, "/"));
}
__name(normalizePath2, "normalizePath");

// src/common/utils/get-framework-name.ts
async function getFrameworkName(options) {
  const framework = await options.presets.apply("framework", "", options);
  if (!framework) {
    throw new Error(import_ts_dedent3.dedent`
      You must specify a framework in '.storybook/main.js' config.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#framework-field-mandatory
    `);
  }
  return typeof framework === "object" ? framework.name : framework;
}
__name(getFrameworkName, "getFrameworkName");
var extractProperFrameworkName = /* @__PURE__ */ __name((framework) => {
  const normalizedPath = normalizePath2(framework);
  const frameworkName = Object.keys(frameworkPackages).find((pkg) => normalizedPath.endsWith(pkg));
  return frameworkName ?? framework;
}, "extractProperFrameworkName");

// src/common/utils/get-renderer-name.ts
async function getRendererName(options) {
  const core = await options.presets.apply("core", {}, options);
  if (!core || !core.renderer) {
    return getFrameworkName(options);
  }
  return core.renderer;
}
__name(getRendererName, "getRendererName");
async function extractProperRendererNameFromFramework(frameworkName) {
  const extractedFrameworkName = extractProperFrameworkName(frameworkName);
  const framework = frameworkPackages[extractedFrameworkName];
  if (!framework) {
    return null;
  }
  return frameworkToRenderer[framework];
}
__name(extractProperRendererNameFromFramework, "extractProperRendererNameFromFramework");

// src/common/utils/get-storybook-refs.ts
import { readFile as readFile3 } from "node:fs/promises";
import { dirname as dirname4, join as join8 } from "node:path";
import { logger as logger4 } from "storybook/internal/node-logger";
var getAutoRefs = /* @__PURE__ */ __name(async (options) => {
  const location = up2({ cwd: options.configDir, last: getProjectRoot() });
  if (!location) {
    return {};
  }
  const directory = dirname4(location);
  const { dependencies = [], devDependencies = [] } = JSON.parse(await readFile3(location, { encoding: "utf8" })) || {};
  const deps = Object.keys({ ...dependencies, ...devDependencies });
  const list = await Promise.all(
    deps.map(async (d) => {
      try {
        const l = from(directory, join8(d, "package.json"));
        const { storybook, name, version } = JSON.parse(await readFile3(l, { encoding: "utf8" })) || {};
        if (storybook?.url) {
          return { id: name, ...storybook, version };
        }
      } catch (error) {
        if (error.code === "ERR_PACKAGE_PATH_NOT_EXPORTED") {
          return void 0;
        }
        logger4.warn(`unable to find package.json for ${d}`);
        return void 0;
      }
      return void 0;
    })
  );
  return list.filter(Boolean).reduce(
    (acc, cur) => ({
      ...acc,
      [cur.id]: {
        id: cur.id.toLowerCase(),
        url: stripTrailingSlash(cur.url),
        title: cur.title,
        version: cur.version
      }
    }),
    {}
  );
}, "getAutoRefs");
var checkRef = /* @__PURE__ */ __name((url) => fetch(`${url}/iframe.html`).then(
  async ({ ok: ok2, status }) => {
    if (ok2) {
      if (status !== 200) {
        return false;
      }
      const data = await fetch(`${url}/iframe.html`, {
        headers: { Accept: "application/json" }
      });
      if (data.ok && (await data.json().catch(() => ({}))).loginUrl) {
        return false;
      }
    }
    return ok2;
  },
  () => false
), "checkRef");
var stripTrailingSlash = /* @__PURE__ */ __name((url) => url.replace(/\/$/, ""), "stripTrailingSlash");
var toTitle = /* @__PURE__ */ __name((input) => {
  const result = input.replace(/[A-Z]/g, (f) => ` ${f}`).replace(/[-_][A-Z]/gi, (f) => ` ${f.toUpperCase()}`).replace(/-/g, " ").replace(/_/g, " ");
  return `${result.substring(0, 1).toUpperCase()}${result.substring(1)}`.trim();
}, "toTitle");
async function getRefs(options) {
  if (options.test) {
    return {};
  }
  const refs = await options.presets.apply("refs", await getAutoRefs(options));
  Object.entries(refs).forEach(([key, value]) => {
    if (value.disable) {
      delete refs[key];
      return;
    }
    refs[key.toLowerCase()] = {
      ...value,
      id: key.toLowerCase(),
      title: value.title || toTitle(value.id || key),
      url: stripTrailingSlash(value.url)
    };
  });
  await Promise.all(
    Object.entries(refs).map(async ([k, value]) => {
      const ok2 = await checkRef(value.url);
      refs[k] = { ...value, type: ok2 ? "server-checked" : "unknown" };
    })
  );
  return refs;
}
__name(getRefs, "getRefs");

// src/common/utils/glob-to-regexp.ts
var pico = __toESM(require_picomatch(), 1);
function globToRegexp(glob2) {
  const regex = pico.makeRe(glob2, {
    fastpaths: false,
    noglobstar: false,
    bash: false
  });
  if (!regex.source.startsWith("^")) {
    throw new Error(`Invalid glob: >> ${glob2} >> ${regex}`);
  }
  if (!glob2.startsWith("./")) {
    return regex;
  }
  return new RegExp(
    ["^\\.", glob2.startsWith("./**") ? "" : "[\\\\/]", regex.source.substring(1)].join("")
  );
}
__name(globToRegexp, "globToRegexp");

// src/common/utils/interpolate.ts
var interpolate = /* @__PURE__ */ __name((template, bindings) => {
  return Object.entries(bindings).reduce((acc, [k, v]) => {
    const escapedString = v.replace(/\\/g, "/").replace(/\$/g, "$$$");
    return acc.replace(new RegExp(`{{${k}}}`, "g"), escapedString);
  }, template);
}, "interpolate");

// src/common/utils/interpret-require.ts
function getCandidate(paths) {
  for (let i = 0; i < paths.length; i += 1) {
    const candidate = getInterpretedFile(paths[i]);
    if (candidate) {
      return candidate;
    }
  }
  return void 0;
}
__name(getCandidate, "getCandidate");
function serverRequire(filePath) {
  const paths = Array.isArray(filePath) ? filePath : [filePath];
  const candidatePath = getCandidate(paths);
  if (!candidatePath) {
    return null;
  }
  return importModule(candidatePath);
}
__name(serverRequire, "serverRequire");

// src/common/utils/load-main-config.ts
var import_ts_dedent4 = __toESM(require_dist(), 1);
import { readFile as readFile4, rm as rm3, writeFile as writeFile3 } from "node:fs/promises";
import { join as join9, parse as parse2, relative, resolve as resolve4 } from "node:path";
import { logger as logger5 } from "storybook/internal/node-logger";
import { MainFileEvaluationError } from "storybook/internal/server-errors";
async function loadMainConfig({
  configDir = ".storybook",
  cwd,
  skipCache
}) {
  await validateConfigurationFiles(configDir, cwd);
  const mainPath = getInterpretedFile(resolve4(configDir, "main"));
  try {
    const out = await importModule(mainPath, { skipCache });
    return out;
  } catch (e) {
    if (!(e instanceof Error)) {
      throw e;
    }
    if (e.message.includes("not defined in ES module scope")) {
      logger5.info(
        "Loading main config failed as the file does not seem to be valid ESM. Trying a temporary fix, please ensure the main config is valid ESM."
      );
      const comment = "// end of Storybook 10 migration assistant header, you can delete the above code";
      const content = await readFile4(mainPath, "utf-8");
      if (!content.includes(comment)) {
        const header = import_ts_dedent4.dedent`
          import { createRequire } from "node:module";
          import { dirname } from "node:path";
          import { fileURLToPath } from "node:url";
    
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = dirname(__filename);
          const require = createRequire(import.meta.url);
        `;
        const { ext, name, dir } = parse2(mainPath);
        const modifiedMainPath = join9(dir, `${name}.tmp.${ext}`);
        await writeFile3(modifiedMainPath, [header, comment, content].join("\n\n"));
        let out;
        try {
          out = await importModule(modifiedMainPath);
        } finally {
          await rm3(modifiedMainPath);
        }
        return out;
      }
    }
    throw new MainFileEvaluationError({
      location: relative(process.cwd(), mainPath),
      error: e
    });
  }
}
__name(loadMainConfig, "loadMainConfig");

// src/common/utils/load-manager-or-addons-file.ts
var import_ts_dedent5 = __toESM(require_dist(), 1);
import { resolve as resolve5 } from "node:path";
import { logger as logger6 } from "storybook/internal/node-logger";
function loadManagerOrAddonsFile({ configDir }) {
  const storybookCustomAddonsPath = getInterpretedFile(resolve5(configDir, "addons"));
  const storybookCustomManagerPath = getInterpretedFile(resolve5(configDir, "manager"));
  if (storybookCustomAddonsPath || storybookCustomManagerPath) {
    logger6.info("=> Loading custom manager config");
  }
  if (storybookCustomAddonsPath && storybookCustomManagerPath) {
    throw new Error(import_ts_dedent5.dedent`
      You have both a "addons.js" and a "manager.js", remove the "addons.js" file from your configDir (${resolve5(
      configDir,
      "addons"
    )})`);
  }
  return storybookCustomManagerPath || storybookCustomAddonsPath;
}
__name(loadManagerOrAddonsFile, "loadManagerOrAddonsFile");

// src/common/utils/load-preview-or-config-file.ts
var import_ts_dedent6 = __toESM(require_dist(), 1);
import { resolve as resolve6 } from "node:path";
function loadPreviewOrConfigFile({ configDir }) {
  const storybookConfigPath = getInterpretedFile(resolve6(configDir, "config"));
  const storybookPreviewPath = getInterpretedFile(resolve6(configDir, "preview"));
  if (storybookConfigPath && storybookPreviewPath) {
    throw new Error(import_ts_dedent6.dedent`
      You have both a "config.js" and a "preview.js", remove the "config.js" file from your configDir (${resolve6(
      configDir,
      "config"
    )})`);
  }
  return storybookPreviewPath || storybookConfigPath;
}
__name(loadPreviewOrConfigFile, "loadPreviewOrConfigFile");

// src/common/utils/log.ts
var import_picocolors2 = __toESM(require_picocolors(), 1);
import { logger as logger7 } from "storybook/internal/node-logger";
var commandLog = /* @__PURE__ */ __name((message) => {
  process.stdout.write(import_picocolors2.default.cyan(" \u2022 ") + message);
  return (errorMessage, errorInfo) => {
    if (errorMessage) {
      process.stdout.write(`. ${import_picocolors2.default.red("\u2716")}
`);
      logger7.error(`
     ${import_picocolors2.default.red(errorMessage)}`);
      if (!errorInfo) {
        return;
      }
      const newErrorInfo = errorInfo.split("\n").map((line) => `     ${import_picocolors2.default.dim(line)}`).join("\n");
      logger7.error(`${newErrorInfo}
`);
      return;
    }
    process.stdout.write(`. ${import_picocolors2.default.green("\u2713")}
`);
  };
}, "commandLog");
function paddedLog(message) {
  const newMessage = message.split("\n").map((line) => `    ${line}`).join("\n");
  logger7.log(newMessage);
}
__name(paddedLog, "paddedLog");
function getChars(char, amount) {
  let line = "";
  for (let lc = 0; lc < amount; lc += 1) {
    line += char;
  }
  return line;
}
__name(getChars, "getChars");
function codeLog(codeLines, leftPadAmount) {
  let maxLength = 0;
  const newLines = codeLines.map((line) => {
    maxLength = line.length > maxLength ? line.length : maxLength;
    return line;
  });
  const finalResult = newLines.map((line) => {
    const rightPadAmount = maxLength - line.length;
    let newLine = line + getChars(" ", rightPadAmount);
    newLine = getChars(" ", leftPadAmount || 2) + import_picocolors2.default.inverse(` ${newLine} `);
    return newLine;
  }).join("\n");
  logger7.log(finalResult);
}
__name(codeLog, "codeLog");

// src/common/utils/log-config.ts
var import_picocolors3 = __toESM(require_picocolors(), 1);
function logConfig(caption, config) {
  console.log(import_picocolors3.default.cyan(String(caption)));
  console.dir(config, { depth: null });
}
__name(logConfig, "logConfig");

// src/common/utils/normalize-stories.ts
var pico2 = __toESM(require_picomatch(), 1);
import { lstatSync } from "node:fs";
import { basename, dirname as dirname5, relative as relative2, resolve as resolve7 } from "node:path";
import { InvalidStoriesEntryError } from "storybook/internal/server-errors";
var DEFAULT_TITLE_PREFIX = "";
var DEFAULT_FILES_PATTERN = "**/*.@(mdx|stories.@(js|jsx|mjs|ts|tsx))";
var isDirectory = /* @__PURE__ */ __name((configDir, entry) => {
  try {
    return lstatSync(resolve7(configDir, entry)).isDirectory();
  } catch (err) {
    return false;
  }
}, "isDirectory");
var getDirectoryFromWorkingDir = /* @__PURE__ */ __name(({
  configDir,
  workingDir,
  directory
}) => {
  const directoryFromConfig = resolve7(configDir, directory);
  const directoryFromWorking = relative2(workingDir, directoryFromConfig);
  return normalizeStoryPath(directoryFromWorking);
}, "getDirectoryFromWorkingDir");
var normalizeStoriesEntry = /* @__PURE__ */ __name((entry, { configDir, workingDir, defaultFilesPattern = DEFAULT_FILES_PATTERN }) => {
  let specifierWithoutMatcher;
  if (typeof entry === "string") {
    const globResult = pico2.scan(entry);
    if (globResult.isGlob) {
      const directory2 = globResult.prefix + globResult.base;
      const files2 = globResult.glob;
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: directory2,
        files: files2
      };
    } else if (isDirectory(configDir, entry)) {
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: entry,
        files: defaultFilesPattern
      };
    } else {
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: dirname5(entry),
        files: basename(entry)
      };
    }
  } else {
    specifierWithoutMatcher = {
      titlePrefix: DEFAULT_TITLE_PREFIX,
      files: defaultFilesPattern,
      ...entry
    };
  }
  const files = slash(specifierWithoutMatcher.files);
  const { directory: directoryRelativeToConfig } = specifierWithoutMatcher;
  const directory = slash(
    getDirectoryFromWorkingDir({
      configDir,
      workingDir,
      directory: directoryRelativeToConfig
    })
  ).replace(/\/$/, "");
  const importPathMatcher = globToRegexp(`${directory}/${files}`);
  return {
    ...specifierWithoutMatcher,
    directory,
    importPathMatcher
  };
}, "normalizeStoriesEntry");
var normalizeStories = /* @__PURE__ */ __name((entries, options) => {
  if (!entries || Array.isArray(entries) && entries.length === 0) {
    throw new InvalidStoriesEntryError();
  }
  return entries.map((entry) => normalizeStoriesEntry(entry, options));
}, "normalizeStories");

// src/common/utils/readTemplate.ts
import { readFile as readFile5 } from "node:fs/promises";
async function readTemplate(filename) {
  return readFile5(filename, {
    encoding: "utf8"
  });
}
__name(readTemplate, "readTemplate");

// src/common/utils/remove.ts
var import_ts_dedent7 = __toESM(require_dist(), 1);
import { readConfig, writeConfig } from "storybook/internal/csf-tools";
import { logger as logger8 } from "storybook/internal/node-logger";
async function removeAddon(addon, options) {
  const { packageManager, skipInstall } = options;
  const { mainConfigPath, configDir } = getConfigInfo(options.configDir);
  if (typeof configDir === "undefined") {
    throw new Error(import_ts_dedent7.dedent`
      Unable to find storybook config directory
    `);
  }
  if (!mainConfigPath) {
    logger8.error("Unable to find storybook main.js config");
    return;
  }
  const main = await readConfig(mainConfigPath);
  logger8.debug(`Uninstalling ${addon}`);
  await packageManager.removeDependencies([addon]);
  if (!skipInstall) {
    await packageManager.installDependencies();
  }
  const currentAddons = main.getNamesFromPath(["addons"]) ?? [];
  if (currentAddons.includes(addon)) {
    logger8.debug(`Removing '${addon}' from main.js addons field.`);
    try {
      main.removeEntryFromArray(["addons"], addon);
      await writeConfig(main);
    } catch (err) {
      logger8.warn(`Failed to remove '${addon}' from main.js addons field. ${String(err)}`);
    }
  }
}
__name(removeAddon, "removeAddon");

// src/common/utils/symlinks.ts
function isPreservingSymlinks() {
  const { NODE_OPTIONS, NODE_PRESERVE_SYMLINKS } = process.env;
  return !!NODE_PRESERVE_SYMLINKS || NODE_OPTIONS?.includes("--preserve-symlinks");
}
__name(isPreservingSymlinks, "isPreservingSymlinks");

// src/common/utils/template.ts
import { existsSync as existsSync4, readFileSync as readFileSync4 } from "node:fs";
var interpolate2 = /* @__PURE__ */ __name((string, data = {}) => Object.entries(data).reduce((acc, [k, v]) => acc.replace(new RegExp(`%${k}%`, "g"), v), string), "interpolate");
function getPreviewBodyTemplate(configDirPath, interpolations) {
  const base = readFileSync4(
    join(resolvePackageDir("storybook"), "assets/server/base-preview-body.html"),
    "utf8"
  );
  const bodyHtmlPath = resolve(configDirPath, "preview-body.html");
  let result = base;
  if (existsSync4(bodyHtmlPath)) {
    result = readFileSync4(bodyHtmlPath, "utf8") + result;
  }
  return interpolate2(result, interpolations);
}
__name(getPreviewBodyTemplate, "getPreviewBodyTemplate");
function getPreviewHeadTemplate(configDirPath, interpolations) {
  const base = readFileSync4(
    join(resolvePackageDir("storybook"), "assets/server/base-preview-head.html"),
    "utf8"
  );
  const headHtmlPath = resolve(configDirPath, "preview-head.html");
  let result = base;
  if (existsSync4(headHtmlPath)) {
    result += readFileSync4(headHtmlPath, "utf8");
  }
  return interpolate2(result, interpolations);
}
__name(getPreviewHeadTemplate, "getPreviewHeadTemplate");

// src/common/utils/validate-config.ts
import {
  CouldNotEvaluateFrameworkError,
  InvalidFrameworkNameError,
  MissingFrameworkFieldError
} from "storybook/internal/server-errors";
var renderers = ["html", "preact", "react", "server", "svelte", "vue", "vue3", "web-components"];
var rendererNames = [...renderers, ...renderers.map((renderer) => `@storybook/${renderer}`)];
function validateFrameworkName(frameworkName) {
  if (!frameworkName) {
    throw new MissingFrameworkFieldError();
  }
  if (rendererNames.includes(frameworkName)) {
    throw new InvalidFrameworkNameError({ frameworkName });
  }
  if (Object.keys(frameworkPackages).includes(frameworkName)) {
    return;
  }
  try {
    resolveModulePath(`${frameworkName}/preset`, {
      extensions: [".mjs", ".js", ".cjs"],
      conditions: ["node", "import", "require"]
    });
  } catch (err) {
    throw new CouldNotEvaluateFrameworkError({ frameworkName });
  }
}
__name(validateFrameworkName, "validateFrameworkName");

// src/common/utils/satisfies.ts
function satisfies2() {
  return (x) => x;
}
__name(satisfies2, "satisfies");

// src/common/utils/formatter.ts
async function getPrettier() {
  return import("prettier").catch((e) => ({
    resolveConfig: /* @__PURE__ */ __name(async () => null, "resolveConfig"),
    format: /* @__PURE__ */ __name((content) => content, "format")
  }));
}
__name(getPrettier, "getPrettier");
async function formatFileContent(filePath, content) {
  try {
    const { resolveConfig, format } = await getPrettier();
    const config = await resolveConfig(filePath);
    if (!config || Object.keys(config).length === 0) {
      return await formatWithEditorConfig(filePath, content);
    }
    const result = await format(content, {
      ...config,
      filepath: filePath
    });
    return result;
  } catch (error) {
    return content;
  }
}
__name(formatFileContent, "formatFileContent");
async function formatWithEditorConfig(filePath, content) {
  const { resolveConfig, format } = await getPrettier();
  const config = await resolveConfig(filePath, { editorconfig: true });
  if (!config || Object.keys(config).length === 0) {
    return content;
  }
  return format(content, {
    ...config,
    filepath: filePath
  });
}
__name(formatWithEditorConfig, "formatWithEditorConfig");

// src/common/utils/get-story-id.ts
var import_ts_dedent9 = __toESM(require_dist(), 1);
import { relative as relative3 } from "node:path";
import { normalizeStories as normalizeStories2, normalizeStoryPath as normalizeStoryPath2 } from "storybook/internal/common";
import { sanitize as sanitize2, storyNameFromExport, toId } from "storybook/internal/csf";

// src/preview-api/modules/store/autoTitle.ts
import { once as once2 } from "storybook/internal/client-logger";
var import_ts_dedent8 = __toESM(require_dist(), 1);
var sanitize = /* @__PURE__ */ __name((parts) => {
  if (parts.length === 0) {
    return parts;
  }
  const last = parts[parts.length - 1];
  const lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (parts.length === 1) {
    return [lastStripped];
  }
  const nextToLast = parts[parts.length - 2];
  if (lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase()) {
    return [...parts.slice(0, -2), lastStripped];
  }
  return lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
}, "sanitize");
function pathJoin(paths) {
  return paths.flatMap((p) => p.split("/")).filter(Boolean).join("/");
}
__name(pathJoin, "pathJoin");
var userOrAutoTitleFromSpecifier = /* @__PURE__ */ __name((fileName, entry, userTitle) => {
  const { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  if (typeof fileName === "number") {
    once2.warn(import_ts_dedent8.dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  }
  const normalizedFileName = slash(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      const suffix = normalizedFileName.replace(directory, "");
      let parts = pathJoin([titlePrefix, suffix]).split("/");
      parts = sanitize(parts);
      return parts.join("/");
    }
    if (!titlePrefix) {
      return userTitle;
    }
    return pathJoin([titlePrefix, userTitle]);
  }
  return void 0;
}, "userOrAutoTitleFromSpecifier");

// src/common/utils/posix.ts
import { posix as posixPath, sep as sep2 } from "node:path";
var posix3 = /* @__PURE__ */ __name((localPath, seperator = sep2) => localPath.split(seperator).filter(Boolean).join(posixPath.sep), "posix");

// src/common/utils/get-story-id.ts
async function getStoryId(data, options) {
  const stories = await options.presets.apply("stories", [], options);
  const autoTitle = getStoryTitle({
    ...data,
    stories,
    configDir: options.configDir
  });
  if (autoTitle === void 0) {
    throw new Error(import_ts_dedent9.dedent`
    The new story file was successfully generated, but we are unable to index it. Please ensure that the new Story file is matched by the 'stories' glob pattern in your Storybook configuration.
    `);
  }
  const storyName = storyNameFromExport(data.exportedStoryName);
  const storyId = toId(autoTitle, storyName);
  const kind = sanitize2(autoTitle);
  return { storyId, kind };
}
__name(getStoryId, "getStoryId");
function getStoryTitle({
  storyFilePath,
  configDir,
  stories,
  workingDir = process.cwd(),
  userTitle
}) {
  const normalizedStories = normalizeStories2(stories, {
    configDir,
    workingDir
  });
  const relativePath = relative3(workingDir, storyFilePath);
  const importPath = posix3(normalizeStoryPath2(relativePath));
  return normalizedStories.map((normalizeStory) => userOrAutoTitleFromSpecifier(importPath, normalizeStory, userTitle)).filter(Boolean)[0];
}
__name(getStoryTitle, "getStoryTitle");

// src/common/utils/get-addon-names.ts
var getAddonNames = /* @__PURE__ */ __name((mainConfig) => {
  const addons = mainConfig.addons || [];
  const addonList = addons.map((addon) => {
    let name = "";
    if (typeof addon === "string") {
      name = addon;
    } else if (typeof addon === "object") {
      name = addon.name;
    }
    if (name.startsWith(".")) {
      return void 0;
    }
    name = normalizePath2(name);
    name = name.replace(/.*node_modules\//, "");
    return name.replace(/\/dist\/.*$/, "").replace(/\.[mc]?[tj]?sx?$/, "").replace(/\/register$/, "").replace(/\/manager$/, "").replace(/\/preset$/, "");
  });
  return addonList.filter((item) => item != null);
}, "getAddonNames");

// src/common/utils/sync-main-preview-addons.ts
var import_picocolors4 = __toESM(require_picocolors(), 1);
import { types as t } from "storybook/internal/babel";
import {
  isCsfFactoryPreview,
  readConfig as readConfig2,
  writeConfig as writeConfig2
} from "storybook/internal/csf-tools";
import { logger as logger9 } from "storybook/internal/node-logger";

// src/common/utils/get-addon-annotations.ts
import { createRequire } from "node:module";
function getAnnotationsName(addonName) {
  const cleanedUpName = addonName.replace(/^@storybook\//, "").split(/[^a-zA-Z0-9]+/).map(
    (word, index) => index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
  ).join("").replace(/^./, (char) => char.toLowerCase());
  return cleanedUpName;
}
__name(getAnnotationsName, "getAnnotationsName");
async function getAddonAnnotations(addon, configDir) {
  const data = {
    // core addons will have a function as default export in index entrypoint
    importPath: addon,
    importName: getAnnotationsName(addon),
    isCoreAddon: isCorePackage(addon)
  };
  if (!data.isCoreAddon) {
    data.importPath = `${addon}/preview`;
  }
  try {
    const require2 = createRequire(import.meta.url);
    require2.resolve(`${addon}/preview`, { paths: [configDir] });
  } catch (err) {
    return null;
  }
  return data;
}
__name(getAddonAnnotations, "getAddonAnnotations");

// src/common/utils/sync-main-preview-addons.ts
async function syncStorybookAddons(mainConfig, previewConfigPath, configDir) {
  const previewConfig = await readConfig2(previewConfigPath);
  const modifiedConfig = await getSyncedStorybookAddons(mainConfig, previewConfig, configDir);
  await writeConfig2(modifiedConfig);
}
__name(syncStorybookAddons, "syncStorybookAddons");
async function getSyncedStorybookAddons(mainConfig, previewConfig, configDir) {
  const isCsfFactory = isCsfFactoryPreview(previewConfig);
  if (!isCsfFactory) {
    return previewConfig;
  }
  const existingAddons = previewConfig.getFieldNode(["addons"]);
  if (!existingAddons) {
    previewConfig.setFieldNode(["addons"], t.arrayExpression([]));
  }
  const addons = getAddonNames(mainConfig);
  if (!addons) {
    return previewConfig;
  }
  const syncedAddons = [];
  for (const addon of addons) {
    const annotations = await getAddonAnnotations(addon, configDir);
    if (annotations) {
      const hasAlreadyImportedAddonAnnotations = previewConfig._ast.program.body.find(
        (node) => t.isImportDeclaration(node) && node.source.value === annotations.importPath
      );
      if (hasAlreadyImportedAddonAnnotations) {
        continue;
      }
      if (!existingAddons || t.isArrayExpression(existingAddons) && !existingAddons.elements.some(
        (element) => t.isIdentifier(element) && element.name === annotations.importName
      )) {
        syncedAddons.push(addon);
        if (annotations.isCoreAddon) {
          previewConfig.setImport(annotations.importName, annotations.importPath);
          previewConfig.appendNodeToArray(
            ["addons"],
            t.callExpression(t.identifier(annotations.importName), [])
          );
        } else {
          previewConfig.setImport({ namespace: annotations.importName }, annotations.importPath);
          previewConfig.appendNodeToArray(["addons"], t.identifier(annotations.importName));
        }
      }
    }
  }
  if (syncedAddons.length > 0) {
    logger9.log(
      `Synchronizing addons from main config in ${import_picocolors4.default.cyan(previewConfig.fileName)}:
${syncedAddons.map(import_picocolors4.default.magenta).join(", ")}`
    );
  }
  return previewConfig;
}
__name(getSyncedStorybookAddons, "getSyncedStorybookAddons");

// src/common/js-package-manager/JsPackageManagerFactory.ts
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import { basename as basename2, parse as parse3, relative as relative4 } from "node:path";

// src/common/js-package-manager/BUNProxy.ts
import { readFileSync as readFileSync5 } from "node:fs";
import { platform } from "node:os";
import { join as join10 } from "node:path";
import { logger as logger10 } from "storybook/internal/node-logger";
import { FindPackageVersionsError } from "storybook/internal/server-errors";
import sort from "semver/functions/sort.js";
var NPM_ERROR_REGEX = /npm ERR! code (\w+)/;
var NPM_ERROR_CODES = {
  E401: "Authentication failed or is required.",
  E403: "Access to the resource is forbidden.",
  E404: "Requested resource not found.",
  EACCES: "Permission issue.",
  EAI_FAIL: "DNS lookup failed.",
  EBADENGINE: "Engine compatibility check failed.",
  EBADPLATFORM: "Platform not supported.",
  ECONNREFUSED: "Connection refused.",
  ECONNRESET: "Connection reset.",
  EEXIST: "File or directory already exists.",
  EINVALIDTYPE: "Invalid type encountered.",
  EISGIT: "Git operation failed or conflicts with an existing file.",
  EJSONPARSE: "Error parsing JSON data.",
  EMISSINGARG: "Required argument missing.",
  ENEEDAUTH: "Authentication needed.",
  ENOAUDIT: "No audit available.",
  ENOENT: "File or directory does not exist.",
  ENOGIT: "Git not found or failed to run.",
  ENOLOCK: "Lockfile missing.",
  ENOSPC: "Insufficient disk space.",
  ENOTFOUND: "Resource not found.",
  EOTP: "One-time password required.",
  EPERM: "Permission error.",
  EPUBLISHCONFLICT: "Conflict during package publishing.",
  ERESOLVE: "Dependency resolution error.",
  EROFS: "File system is read-only.",
  ERR_SOCKET_TIMEOUT: "Socket timed out.",
  ETARGET: "Package target not found.",
  ETIMEDOUT: "Operation timed out.",
  ETOOMANYARGS: "Too many arguments provided.",
  EUNKNOWNTYPE: "Unknown type encountered."
};
var BUNProxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "bun";
  }
  static {
    __name(this, "BUNProxy");
  }
  async initPackageJson() {
    return this.executeCommand({ command: "bun", args: ["init"] });
  }
  getRunStorybookCommand() {
    return "bun run storybook";
  }
  getRunCommand(command) {
    return `bun run ${command}`;
  }
  getRemoteRunCommand(pkg, args, specifier) {
    return `bunx ${pkg}${specifier ? `@${specifier}` : ""} ${args.join(" ")}`;
  }
  async getModulePackageJSON(packageName) {
    const wantedPath = join10("node_modules", packageName, "package.json");
    const packageJsonPath = up(wantedPath, { cwd: this.cwd, last: getProjectRoot() });
    if (!packageJsonPath) {
      return null;
    }
    const packageJson = JSON.parse(readFileSync5(packageJsonPath, "utf-8"));
    return packageJson;
  }
  getInstallArgs() {
    if (!this.installArgs) {
      this.installArgs = [];
    }
    return this.installArgs;
  }
  runPackageCommandSync(command, args, cwd, stdio) {
    return this.executeCommandSync({
      command: "bun",
      args: ["run", command, ...args],
      cwd,
      stdio
    });
  }
  runPackageCommand(command, args, cwd, stdio) {
    return this.executeCommand({
      command: "bun",
      args: ["run", command, ...args],
      cwd,
      stdio
    });
  }
  runInternalCommand(command, args, cwd, stdio) {
    return this.executeCommand({ command: "bun", args: [command, ...args], cwd, stdio });
  }
  async findInstallations(pattern, { depth = 99 } = {}) {
    const exec = /* @__PURE__ */ __name(async ({ packageDepth }) => {
      const pipeToNull = platform() === "win32" ? "2>NUL" : "2>/dev/null";
      return this.executeCommand({
        command: "npm",
        args: ["ls", "--json", `--depth=${packageDepth}`, pipeToNull],
        env: {
          FORCE_COLOR: "false"
        }
      });
    }, "exec");
    try {
      const process3 = await exec({ packageDepth: depth });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = JSON.parse(commandResult);
      return this.mapDependencies(parsedOutput, pattern);
    } catch (e) {
      try {
        const process3 = await exec({ packageDepth: 0 });
        const result = await process3;
        const commandResult = result.stdout ?? "";
        const parsedOutput = JSON.parse(commandResult);
        return this.mapDependencies(parsedOutput, pattern);
      } catch (err) {
        logger10.debug(`An issue occurred while trying to find dependencies metadata using npm.`);
        return void 0;
      }
    }
  }
  getResolutions(packageJson, versions) {
    return {
      overrides: {
        ...packageJson.overrides,
        ...versions
      }
    };
  }
  runInstall(options) {
    return this.executeCommand({
      command: "bun",
      args: ["install", ...this.getInstallArgs(), ...options?.force ? ["--force"] : []],
      stdio: "inherit",
      cwd: this.cwd
    });
  }
  async getRegistryURL() {
    const process3 = this.executeCommand({
      command: "npm",
      // "npm config" commands are not allowed in workspaces per default
      // https://github.com/npm/cli/issues/6099#issuecomment-1847584792
      args: ["config", "get", "registry", "-ws=false", "-iwr"]
    });
    const result = await process3;
    const url = (result.stdout ?? "").trim();
    return url === "undefined" ? void 0 : url;
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    return this.executeCommand({
      command: "bun",
      args: ["add", ...args, ...this.getInstallArgs()],
      stdio: "pipe",
      cwd: this.primaryPackageJson.operationDir
    });
  }
  async runGetVersions(packageName, fetchAllVersions) {
    const args = fetchAllVersions ? ["versions", "--json"] : ["version"];
    try {
      const process3 = this.executeCommand({
        command: "npm",
        args: ["info", packageName, ...args]
      });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = fetchAllVersions ? JSON.parse(commandResult) : commandResult.trim();
      if (parsedOutput.error?.summary) {
        throw parsedOutput.error.summary;
      }
      return parsedOutput;
    } catch (error) {
      throw new FindPackageVersionsError({
        error,
        packageManager: "NPM",
        packageName
      });
    }
  }
  /**
   * @param input The output of `npm ls --json`
   * @param pattern A list of package names to filter the result. * can be used as a placeholder
   */
  mapDependencies(input, pattern) {
    const acc = {};
    const existingVersions = {};
    const duplicatedDependencies = {};
    const recurse = /* @__PURE__ */ __name(([name, packageInfo]) => {
      if (!name || !pattern.some((p) => new RegExp(`^${p.replace(/\*/g, ".*")}$`).test(name))) {
        return;
      }
      const value = {
        version: packageInfo.version,
        location: ""
      };
      if (!existingVersions[name]?.includes(value.version)) {
        if (acc[name]) {
          acc[name].push(value);
        } else {
          acc[name] = [value];
        }
        existingVersions[name] = sort([...existingVersions[name] || [], value.version]);
        if (existingVersions[name].length > 1) {
          duplicatedDependencies[name] = existingVersions[name];
        }
      }
      if (packageInfo.dependencies) {
        Object.entries(packageInfo.dependencies).forEach(recurse);
      }
    }, "recurse");
    Object.entries(input.dependencies).forEach(recurse);
    return {
      dependencies: acc,
      duplicatedDependencies,
      infoCommand: "npm ls --depth=1",
      dedupeCommand: "npm dedupe"
    };
  }
  parseErrorFromLogs(logs) {
    let finalMessage = "NPM error";
    const match = logs.match(NPM_ERROR_REGEX);
    if (match) {
      const errorCode = match[1];
      if (errorCode) {
        finalMessage = `${finalMessage} ${errorCode}`;
      }
      const errorMessage = NPM_ERROR_CODES[errorCode];
      if (errorMessage) {
        finalMessage = `${finalMessage} - ${errorMessage}`;
      }
    }
    return finalMessage.trim();
  }
};

// src/common/js-package-manager/NPMProxy.ts
import { readFileSync as readFileSync6 } from "node:fs";
import { platform as platform2 } from "node:os";
import { join as join11 } from "node:path";
import { logger as logger11, prompt as prompt2 } from "storybook/internal/node-logger";
import { FindPackageVersionsError as FindPackageVersionsError2 } from "storybook/internal/server-errors";
import sort2 from "semver/functions/sort.js";
var NPM_ERROR_REGEX2 = /npm (ERR!|error) (code|errno) (\w+)/i;
var NPM_ERROR_CODES2 = {
  E401: "Authentication failed or is required.",
  E403: "Access to the resource is forbidden.",
  E404: "Requested resource not found.",
  EACCES: "Permission issue.",
  EAI_FAIL: "DNS lookup failed.",
  EBADENGINE: "Engine compatibility check failed.",
  EBADPLATFORM: "Platform not supported.",
  ECONNREFUSED: "Connection refused.",
  ECONNRESET: "Connection reset.",
  EEXIST: "File or directory already exists.",
  EINVALIDTYPE: "Invalid type encountered.",
  EISGIT: "Git operation failed or conflicts with an existing file.",
  EJSONPARSE: "Error parsing JSON data.",
  EMISSINGARG: "Required argument missing.",
  ENEEDAUTH: "Authentication needed.",
  ENOAUDIT: "No audit available.",
  ENOENT: "File or directory does not exist.",
  ENOGIT: "Git not found or failed to run.",
  ENOLOCK: "Lockfile missing.",
  ENOSPC: "Insufficient disk space.",
  ENOTFOUND: "Resource not found.",
  EOTP: "One-time password required.",
  EPERM: "Permission error.",
  EPUBLISHCONFLICT: "Conflict during package publishing.",
  ERESOLVE: "Dependency resolution error.",
  EROFS: "File system is read-only.",
  ERR_SOCKET_TIMEOUT: "Socket timed out.",
  ETARGET: "Package target not found.",
  ETIMEDOUT: "Operation timed out.",
  ETOOMANYARGS: "Too many arguments provided.",
  EUNKNOWNTYPE: "Unknown type encountered."
};
var NPMProxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "npm";
  }
  static {
    __name(this, "NPMProxy");
  }
  getRunCommand(command) {
    return `npm run ${command}`;
  }
  getRemoteRunCommand(pkg, args, specifier) {
    return `npx ${pkg}${specifier ? `@${specifier}` : ""} ${args.join(" ")}`;
  }
  async getModulePackageJSON(packageName) {
    const wantedPath = join11("node_modules", packageName, "package.json");
    const packageJsonPath = up(wantedPath, { cwd: this.cwd, last: getProjectRoot() });
    if (!packageJsonPath) {
      return null;
    }
    const packageJson = JSON.parse(readFileSync6(packageJsonPath, "utf-8"));
    return packageJson;
  }
  getInstallArgs() {
    if (!this.installArgs) {
      this.installArgs = [];
    }
    return this.installArgs;
  }
  runPackageCommandSync(command, args, cwd, stdio) {
    return this.executeCommandSync({
      command: "npm",
      args: ["exec", "--", command, ...args],
      cwd,
      stdio
    });
  }
  runPackageCommand(command, args, cwd, stdio) {
    return this.executeCommand({
      command: "npm",
      args: ["exec", "--", command, ...args],
      cwd,
      stdio
    });
  }
  runInternalCommand(command, args, cwd, stdio) {
    return this.executeCommand({
      command: "npm",
      args: [command, ...args],
      cwd,
      stdio
    });
  }
  async findInstallations(pattern, { depth = 99 } = {}) {
    const exec = /* @__PURE__ */ __name(({ packageDepth }) => {
      const pipeToNull = platform2() === "win32" ? "2>NUL" : "2>/dev/null";
      return this.executeCommand({
        command: "npm",
        args: ["ls", "--json", `--depth=${packageDepth}`, pipeToNull],
        env: {
          FORCE_COLOR: "false"
        },
        cwd: this.instanceDir
      });
    }, "exec");
    try {
      const childProcess = await exec({ packageDepth: depth });
      const commandResult = childProcess.stdout ?? "";
      const parsedOutput = JSON.parse(commandResult);
      return this.mapDependencies(parsedOutput, pattern);
    } catch (e) {
      try {
        const childProcess = await exec({ packageDepth: 0 });
        const commandResult = childProcess.stdout ?? "";
        const parsedOutput = JSON.parse(commandResult);
        return this.mapDependencies(parsedOutput, pattern);
      } catch (err) {
        logger11.debug(`An issue occurred while trying to find dependencies metadata using npm.`);
        return void 0;
      }
    }
  }
  getResolutions(packageJson, versions) {
    return {
      overrides: {
        ...packageJson.overrides,
        ...versions
      }
    };
  }
  runInstall(options) {
    return this.executeCommand({
      command: "npm",
      args: ["install", ...this.getInstallArgs(), ...options?.force ? ["--force"] : []],
      cwd: this.cwd,
      stdio: prompt2.getPreferredStdio()
    });
  }
  async getRegistryURL() {
    const process3 = this.executeCommand({
      command: "npm",
      // "npm config" commands are not allowed in workspaces per default
      // https://github.com/npm/cli/issues/6099#issuecomment-1847584792
      args: ["config", "get", "registry", "-ws=false", "-iwr"]
    });
    const result = await process3;
    const url = (result.stdout ?? "").trim();
    return url === "undefined" ? void 0 : url;
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    return this.executeCommand({
      command: "npm",
      args: ["install", ...args, ...this.getInstallArgs()],
      stdio: prompt2.getPreferredStdio(),
      cwd: this.primaryPackageJson.operationDir
    });
  }
  async runGetVersions(packageName, fetchAllVersions) {
    const args = fetchAllVersions ? ["versions", "--json"] : ["version"];
    try {
      const process3 = this.executeCommand({
        command: "npm",
        args: ["info", packageName, ...args]
      });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = fetchAllVersions ? JSON.parse(commandResult) : commandResult.trim();
      if (parsedOutput.error?.summary) {
        throw parsedOutput.error.summary;
      }
      return parsedOutput;
    } catch (error) {
      throw new FindPackageVersionsError2({
        error,
        packageManager: "NPM",
        packageName
      });
    }
  }
  /**
   * @param input The output of `npm ls --json`
   * @param pattern A list of package names to filter the result. * can be used as a placeholder
   */
  mapDependencies(input, pattern) {
    const acc = {};
    const existingVersions = {};
    const duplicatedDependencies = {};
    const recurse = /* @__PURE__ */ __name(([name, packageInfo]) => {
      if (!name || !pattern.some((p) => new RegExp(`^${p.replace(/\*/g, ".*")}$`).test(name))) {
        return;
      }
      const value = {
        version: packageInfo.version,
        location: ""
      };
      if (!existingVersions[name]?.includes(value.version)) {
        if (acc[name]) {
          acc[name].push(value);
        } else {
          acc[name] = [value];
        }
        existingVersions[name] = sort2([...existingVersions[name] || [], value.version]);
        if (existingVersions[name].length > 1) {
          duplicatedDependencies[name] = existingVersions[name];
        }
      }
      if (packageInfo.dependencies) {
        Object.entries(packageInfo.dependencies).forEach(recurse);
      }
    }, "recurse");
    Object.entries(input.dependencies).forEach(recurse);
    return {
      dependencies: acc,
      duplicatedDependencies,
      infoCommand: "npm ls --depth=1",
      dedupeCommand: "npm dedupe"
    };
  }
  parseErrorFromLogs(logs) {
    let finalMessage = "NPM error";
    const match = logs.match(NPM_ERROR_REGEX2);
    if (match) {
      const errorCode = match[3];
      if (errorCode) {
        finalMessage = `${finalMessage} ${errorCode}`;
      }
      const errorMessage = NPM_ERROR_CODES2[errorCode];
      if (errorMessage) {
        finalMessage = `${finalMessage} - ${errorMessage}`;
      }
    }
    return finalMessage.trim();
  }
};

// src/common/js-package-manager/PNPMProxy.ts
import { existsSync as existsSync6, readFileSync as readFileSync7 } from "node:fs";
import { join as join12 } from "node:path";
import { pathToFileURL } from "node:url";
import { prompt as prompt3 } from "storybook/internal/node-logger";
import { FindPackageVersionsError as FindPackageVersionsError3 } from "storybook/internal/server-errors";
var PNPM_ERROR_REGEX = /(ELIFECYCLE|ERR_PNPM_[A-Z_]+)\s+(.*)/i;
var PNPMProxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "pnpm";
  }
  static {
    __name(this, "PNPMProxy");
  }
  detectWorkspaceRoot() {
    const CWD = process.cwd();
    const pnpmWorkspaceYaml = `${CWD}/pnpm-workspace.yaml`;
    return existsSync6(pnpmWorkspaceYaml);
  }
  getRunCommand(command) {
    return `pnpm run ${command}`;
  }
  getRemoteRunCommand(pkg, args, specifier) {
    return `pnpm dlx ${pkg}${specifier ? `@${specifier}` : ""} ${args.join(" ")}`;
  }
  async getPnpmVersion() {
    const result = await this.executeCommand({
      command: "pnpm",
      args: ["--version"]
    });
    return result.stdout ?? null;
  }
  getInstallArgs() {
    if (!this.installArgs) {
      this.installArgs = [];
      if (this.detectWorkspaceRoot()) {
        this.installArgs.push("-w");
      }
    }
    return this.installArgs;
  }
  runPackageCommandSync(command, args, cwd, stdio) {
    return this.executeCommandSync({
      command: "pnpm",
      args: ["exec", command, ...args],
      cwd,
      stdio
    });
  }
  runPackageCommand(command, args, cwd, stdio) {
    return this.executeCommand({
      command: "pnpm",
      args: ["exec", command, ...args],
      cwd,
      stdio
    });
  }
  runInternalCommand(command, args, cwd, stdio) {
    return this.executeCommand({
      command: "pnpm",
      args: [command, ...args],
      cwd,
      stdio
    });
  }
  async getRegistryURL() {
    const childProcess = await this.executeCommand({
      command: "pnpm",
      args: ["config", "get", "registry"]
    });
    const url = (childProcess.stdout ?? "").trim();
    return url === "undefined" ? void 0 : url;
  }
  async findInstallations(pattern, { depth = 99 } = {}) {
    try {
      const childProcess = await this.executeCommand({
        command: "pnpm",
        args: ["list", pattern.map((p) => `"${p}"`).join(" "), "--json", `--depth=${depth}`],
        env: {
          FORCE_COLOR: "false"
        },
        cwd: this.instanceDir
      });
      const commandResult = childProcess.stdout ?? "";
      const parsedOutput = JSON.parse(commandResult);
      return this.mapDependencies(parsedOutput, pattern);
    } catch (e) {
      return void 0;
    }
  }
  // TODO: Remove pnp compatibility code in SB11
  async getModulePackageJSON(packageName) {
    const pnpapiPath = any([".pnp.js", ".pnp.cjs"], {
      cwd: this.primaryPackageJson.operationDir,
      last: getProjectRoot()
    });
    if (pnpapiPath) {
      try {
        const pnpApi = await import(pathToFileURL(pnpapiPath).href);
        const resolvedPath = pnpApi.resolveToUnqualified(packageName, this.cwd, {
          considerBuiltins: false
        });
        const pkgLocator = pnpApi.findPackageLocator(resolvedPath);
        const pkg = pnpApi.getPackageInformation(pkgLocator);
        const packageJSON = JSON.parse(
          readFileSync7(join12(pkg.packageLocation, "package.json"), "utf-8")
        );
        return packageJSON;
      } catch (error) {
        if (error.code !== "MODULE_NOT_FOUND") {
          console.error("Error while fetching package version in PNPM PnP mode:", error);
        }
        return null;
      }
    }
    const wantedPath = join12("node_modules", packageName, "package.json");
    const packageJsonPath = up(wantedPath, { cwd: this.cwd, last: getProjectRoot() });
    if (!packageJsonPath) {
      return null;
    }
    return JSON.parse(readFileSync7(packageJsonPath, "utf-8"));
  }
  getResolutions(packageJson, versions) {
    return {
      overrides: {
        ...packageJson.overrides,
        ...versions
      }
    };
  }
  runInstall(options) {
    return this.executeCommand({
      command: "pnpm",
      args: ["install", ...this.getInstallArgs(), ...options?.force ? ["--force"] : []],
      stdio: prompt3.getPreferredStdio(),
      cwd: this.cwd
    });
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    const commandArgs = ["add", ...args, ...this.getInstallArgs()];
    return this.executeCommand({
      command: "pnpm",
      args: commandArgs,
      stdio: prompt3.getPreferredStdio(),
      cwd: this.primaryPackageJson.operationDir
    });
  }
  async runGetVersions(packageName, fetchAllVersions) {
    const args = fetchAllVersions ? ["versions", "--json"] : ["version"];
    try {
      const process3 = this.executeCommand({
        command: "pnpm",
        args: ["info", packageName, ...args]
      });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = fetchAllVersions ? JSON.parse(commandResult) : commandResult.trim();
      if (parsedOutput.error?.summary) {
        throw parsedOutput.error.summary;
      }
      return parsedOutput;
    } catch (error) {
      throw new FindPackageVersionsError3({
        error,
        packageManager: "PNPM",
        packageName
      });
    }
  }
  mapDependencies(input, pattern) {
    const acc = {};
    const existingVersions = {};
    const duplicatedDependencies = {};
    const items = input.reduce((curr, item) => {
      const { devDependencies, dependencies, peerDependencies } = item;
      const allDependencies = { ...devDependencies, ...dependencies, ...peerDependencies };
      return Object.assign(curr, allDependencies);
    }, {});
    const recurse = /* @__PURE__ */ __name(([name, packageInfo]) => {
      if (!name || !pattern.some((p) => new RegExp(`^${p.replace(/\*/g, ".*")}$`).test(name))) {
        return;
      }
      const value = {
        version: packageInfo.version,
        location: ""
      };
      if (!existingVersions[name]?.includes(value.version)) {
        if (acc[name]) {
          acc[name].push(value);
        } else {
          acc[name] = [value];
        }
        existingVersions[name] = [...existingVersions[name] || [], value.version];
        if (existingVersions[name].length > 1) {
          duplicatedDependencies[name] = existingVersions[name];
        }
      }
      if (packageInfo.dependencies) {
        Object.entries(packageInfo.dependencies).forEach(recurse);
      }
    }, "recurse");
    Object.entries(items).forEach(recurse);
    return {
      dependencies: acc,
      duplicatedDependencies,
      infoCommand: "pnpm list --depth=1",
      dedupeCommand: "pnpm dedupe"
    };
  }
  parseErrorFromLogs(logs) {
    let finalMessage = "PNPM error";
    const match = logs.match(PNPM_ERROR_REGEX);
    if (match) {
      const [errorCode] = match;
      if (errorCode) {
        finalMessage = `${finalMessage} ${errorCode}`;
      }
    }
    return finalMessage.trim();
  }
};

// src/common/js-package-manager/Yarn1Proxy.ts
import { readFileSync as readFileSync8 } from "node:fs";
import { join as join13 } from "node:path";
import process2 from "node:process";
import { prompt as prompt4 } from "storybook/internal/node-logger";
import { FindPackageVersionsError as FindPackageVersionsError4 } from "storybook/internal/server-errors";

// src/common/js-package-manager/util.ts
var parsePackageData = /* @__PURE__ */ __name((packageName = "") => {
  const [first, second, third] = packageName.replace(/[└─├]+/g, "").trim().split("@");
  const version = (third || second).replace("npm:", "");
  const name = third ? `@${second}` : first;
  const value = { version, location: "" };
  return { name, value };
}, "parsePackageData");

// src/common/js-package-manager/Yarn1Proxy.ts
var YARN1_ERROR_REGEX = /^error\s(.*)$/gm;
var Yarn1Proxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "yarn1";
  }
  static {
    __name(this, "Yarn1Proxy");
  }
  getInstallArgs() {
    if (!this.installArgs) {
      this.installArgs = process2.env.CI ? [] : ["--ignore-workspace-root-check"];
    }
    return this.installArgs;
  }
  getRunCommand(command) {
    return `yarn ${command}`;
  }
  getRemoteRunCommand(pkg, args, specifier) {
    return `npx ${pkg}${specifier ? `@${specifier}` : ""} ${args.join(" ")}`;
  }
  runPackageCommandSync(command, args, cwd, stdio) {
    return this.executeCommandSync({
      command: `yarn`,
      args: ["exec", command, ...args],
      cwd,
      stdio
    });
  }
  runPackageCommand(command, args, cwd, stdio) {
    return this.executeCommand({ command: `yarn`, args: ["exec", command, ...args], cwd, stdio });
  }
  runInternalCommand(command, args, cwd, stdio) {
    return this.executeCommand({ command: `yarn`, args: [command, ...args], cwd, stdio });
  }
  async getModulePackageJSON(packageName) {
    const wantedPath = join13("node_modules", packageName, "package.json");
    const packageJsonPath = up(wantedPath, { cwd: this.cwd, last: getProjectRoot() });
    if (!packageJsonPath) {
      return null;
    }
    return JSON.parse(readFileSync8(packageJsonPath, "utf-8"));
  }
  async getRegistryURL() {
    const childProcess = await this.executeCommand({
      command: "yarn",
      args: ["config", "get", "registry"]
    });
    const url = (childProcess.stdout ?? "").trim();
    return url === "undefined" ? void 0 : url;
  }
  async findInstallations(pattern, { depth = 99 } = {}) {
    const yarnArgs = ["list", "--pattern", pattern.map((p) => `"${p}"`).join(" "), "--json"];
    if (depth !== 0) {
      yarnArgs.push("--recursive");
    }
    try {
      const process3 = this.executeCommand({
        command: "yarn",
        args: yarnArgs.concat(pattern),
        env: {
          FORCE_COLOR: "false"
        },
        cwd: this.instanceDir
      });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = JSON.parse(commandResult);
      return this.mapDependencies(parsedOutput, pattern);
    } catch (e) {
      return void 0;
    }
  }
  getResolutions(packageJson, versions) {
    return {
      resolutions: {
        ...packageJson.resolutions,
        ...versions
      }
    };
  }
  runInstall(options) {
    return this.executeCommand({
      command: "yarn",
      args: ["install", ...this.getInstallArgs(), ...options?.force ? ["--force"] : []],
      stdio: prompt4.getPreferredStdio(),
      cwd: this.cwd
    });
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    return this.executeCommand({
      command: "yarn",
      args: ["add", ...this.getInstallArgs(), ...args],
      stdio: prompt4.getPreferredStdio(),
      cwd: this.primaryPackageJson.operationDir
    });
  }
  async runGetVersions(packageName, fetchAllVersions) {
    const args = [fetchAllVersions ? "versions" : "version", "--json"];
    try {
      const process3 = this.executeCommand({
        command: "yarn",
        args: ["info", packageName, ...args]
      });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = JSON.parse(commandResult);
      if (parsedOutput.type === "inspect") {
        return parsedOutput.data;
      }
      throw new Error(`Yarn did not provide an output with type 'inspect'.`);
    } catch (error) {
      throw new FindPackageVersionsError4({
        error,
        packageManager: "Yarn 1",
        packageName
      });
    }
  }
  mapDependencies(input, pattern) {
    if (input.type === "tree") {
      const { trees } = input.data;
      const acc = {};
      const existingVersions = {};
      const duplicatedDependencies = {};
      const recurse = /* @__PURE__ */ __name((tree) => {
        const { children } = tree;
        const { name, value } = parsePackageData(tree.name);
        if (!name || !pattern.some((p) => new RegExp(`^${p.replace(/\*/g, ".*")}$`).test(name))) {
          return;
        }
        if (!existingVersions[name]?.includes(value.version)) {
          if (acc[name]) {
            acc[name].push(value);
          } else {
            acc[name] = [value];
          }
          existingVersions[name] = [...existingVersions[name] || [], value.version];
          if (existingVersions[name].length > 1) {
            duplicatedDependencies[name] = existingVersions[name];
          }
        }
        children.forEach(recurse);
      }, "recurse");
      trees.forEach(recurse);
      return {
        dependencies: acc,
        duplicatedDependencies,
        infoCommand: "yarn why",
        dedupeCommand: "yarn dedupe"
      };
    }
    throw new Error("Something went wrong while parsing yarn output");
  }
  parseErrorFromLogs(logs) {
    let finalMessage = "YARN1 error";
    const match = logs.match(YARN1_ERROR_REGEX);
    if (match) {
      const errorMessage = match[0]?.replace(/^error\s(.*)$/, "$1");
      if (errorMessage) {
        finalMessage = `${finalMessage}: ${errorMessage}`;
      }
    }
    return finalMessage.trim();
  }
};

// src/common/js-package-manager/Yarn2Proxy.ts
var import_fslib = __toESM(require_lib(), 1);
var import_libzip = __toESM(require_sync(), 1);
import { readFileSync as readFileSync9 } from "node:fs";
import { join as join14 } from "node:path";
import { pathToFileURL as pathToFileURL2 } from "node:url";
import { prompt as prompt5 } from "storybook/internal/node-logger";
import { FindPackageVersionsError as FindPackageVersionsError5 } from "storybook/internal/server-errors";
var CRITICAL_YARN2_ERROR_CODES = {
  YN0001: "EXCEPTION",
  YN0002: "MISSING_PEER_DEPENDENCY",
  YN0003: "CYCLIC_DEPENDENCIES",
  YN0004: "DISABLED_BUILD_SCRIPTS",
  YN0005: "BUILD_DISABLED",
  YN0006: "SOFT_LINK_BUILD",
  YN0007: "MUST_BUILD",
  YN0008: "MUST_REBUILD",
  YN0009: "BUILD_FAILED",
  YN0010: "RESOLVER_NOT_FOUND",
  YN0011: "FETCHER_NOT_FOUND",
  YN0012: "LINKER_NOT_FOUND",
  YN0013: "FETCH_NOT_CACHED",
  YN0014: "YARN_IMPORT_FAILED",
  YN0015: "REMOTE_INVALID",
  YN0016: "REMOTE_NOT_FOUND",
  YN0018: "CACHE_CHECKSUM_MISMATCH",
  YN0019: "UNUSED_CACHE_ENTRY",
  YN0020: "MISSING_LOCKFILE_ENTRY",
  YN0022: "TOO_MANY_MATCHING_WORKSPACES",
  YN0023: "CONSTRAINTS_MISSING_DEPENDENCY",
  YN0024: "CONSTRAINTS_INCOMPATIBLE_DEPENDENCY",
  YN0025: "CONSTRAINTS_EXTRANEOUS_DEPENDENCY",
  YN0026: "CONSTRAINTS_INVALID_DEPENDENCY",
  YN0027: "CANT_SUGGEST_RESOLUTIONS",
  YN0028: "FROZEN_LOCKFILE_EXCEPTION",
  YN0029: "CROSS_DRIVE_VIRTUAL_LOCAL",
  YN0030: "FETCH_FAILED",
  YN0031: "DANGEROUS_NODE_MODULES",
  YN0035: "NETWORK_ERROR",
  YN0046: "AUTOMERGE_FAILED_TO_PARSE",
  YN0047: "AUTOMERGE_IMMUTABLE",
  YN0048: "AUTOMERGE_SUCCESS",
  YN0049: "AUTOMERGE_REQUIRED",
  YN0050: "DEPRECATED_CLI_SETTINGS",
  YN0059: "INVALID_RANGE_PEER_DEPENDENCY",
  YN0060: "INCOMPATIBLE_PEER_DEPENDENCY",
  YN0062: "INCOMPATIBLE_OS",
  YN0063: "INCOMPATIBLE_CPU",
  YN0069: "REDUNDANT_PACKAGE_EXTENSION",
  YN0071: "NM_CANT_INSTALL_EXTERNAL_SOFT_LINK",
  YN0072: "NM_PRESERVE_SYMLINKS_REQUIRED",
  YN0074: "NM_HARDLINKS_MODE_DOWNGRADED",
  YN0075: "PROLOG_INSTANTIATION_ERROR",
  YN0076: "INCOMPATIBLE_ARCHITECTURE",
  YN0077: "GHOST_ARCHITECTURE",
  YN0078: "RESOLUTION_MISMATCH",
  YN0080: "NETWORK_DISABLED",
  YN0081: "NETWORK_UNSAFE_HTTP",
  YN0082: "RESOLUTION_FAILED",
  YN0083: "AUTOMERGE_GIT_ERROR",
  YN0086: "EXPLAIN_PEER_DEPENDENCIES_CTA",
  YN0090: "OFFLINE_MODE_ENABLED"
};
var Yarn2Proxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "yarn2";
  }
  static {
    __name(this, "Yarn2Proxy");
  }
  getInstallArgs() {
    if (!this.installArgs) {
      this.installArgs = [];
    }
    return this.installArgs;
  }
  getRunCommand(command) {
    return `yarn ${command}`;
  }
  getRemoteRunCommand(pkg, args, specifier) {
    return `yarn dlx ${pkg}${specifier ? `@${specifier}` : ""} ${args.join(" ")}`;
  }
  runPackageCommandSync(command, args, cwd, stdio) {
    return this.executeCommandSync({
      command: "yarn",
      args: ["exec", command, ...args],
      cwd,
      stdio
    });
  }
  runPackageCommand(command, args, cwd, stdio) {
    return this.executeCommand({ command: "yarn", args: ["exec", command, ...args], cwd, stdio });
  }
  runInternalCommand(command, args, cwd, stdio) {
    return this.executeCommand({ command: "yarn", args: [command, ...args], cwd, stdio });
  }
  async findInstallations(pattern, { depth = 99 } = {}) {
    const yarnArgs = ["info", "--name-only"];
    if (depth !== 0) {
      yarnArgs.push("--recursive");
    }
    try {
      const childProcess = await this.executeCommand({
        command: "yarn",
        args: yarnArgs.concat(pattern),
        env: {
          FORCE_COLOR: "false"
        },
        cwd: this.instanceDir
      });
      const commandResult = childProcess.stdout ?? "";
      return this.mapDependencies(commandResult, pattern);
    } catch (e) {
      return void 0;
    }
  }
  // TODO: Remove pnp compatibility code in SB11
  async getModulePackageJSON(packageName) {
    const pnpapiPath = any([".pnp.js", ".pnp.cjs"], {
      cwd: this.cwd,
      last: getProjectRoot()
    });
    if (pnpapiPath) {
      try {
        const { default: pnpApi } = await import(pathToFileURL2(pnpapiPath).href);
        const resolvedPath = pnpApi.resolveToUnqualified(
          packageName,
          this.primaryPackageJson.operationDir,
          {
            considerBuiltins: false
          }
        );
        const pkgLocator = pnpApi.findPackageLocator(resolvedPath);
        const pkg = pnpApi.getPackageInformation(pkgLocator);
        const zipOpenFs = new import_fslib.ZipOpenFS({
          libzip: (0, import_libzip.getLibzipSync)()
        });
        const virtualFs = new import_fslib.VirtualFS({ baseFs: zipOpenFs });
        const crossFs = new import_fslib.PosixFS(virtualFs);
        const virtualPath = join14(pkg.packageLocation, "package.json");
        return crossFs.readJsonSync(virtualPath);
      } catch (error) {
        if (error.code !== "ERR_MODULE_NOT_FOUND") {
          console.error("Error while fetching package version in Yarn PnP mode:", error);
        }
        return null;
      }
    }
    const wantedPath = join14("node_modules", packageName, "package.json");
    const packageJsonPath = up(wantedPath, {
      cwd: this.primaryPackageJson.operationDir,
      last: getProjectRoot()
    });
    if (!packageJsonPath) {
      return null;
    }
    const packageJson = JSON.parse(readFileSync9(packageJsonPath, "utf-8"));
    return packageJson;
  }
  getResolutions(packageJson, versions) {
    return {
      resolutions: {
        ...packageJson.resolutions,
        ...versions
      }
    };
  }
  runInstall() {
    return this.executeCommand({
      command: "yarn",
      args: ["install", ...this.getInstallArgs()],
      cwd: this.cwd
    });
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    return this.executeCommand({
      command: "yarn",
      args: ["add", ...this.getInstallArgs(), ...args],
      stdio: prompt5.getPreferredStdio(),
      cwd: this.primaryPackageJson.operationDir
    });
  }
  async getRegistryURL() {
    const process3 = this.executeCommand({
      command: "yarn",
      args: ["config", "get", "npmRegistryServer"]
    });
    const result = await process3;
    const url = (result.stdout ?? "").trim();
    return url === "undefined" ? void 0 : url;
  }
  async runGetVersions(packageName, fetchAllVersions) {
    const field = fetchAllVersions ? "versions" : "version";
    const args = ["--fields", field, "--json"];
    try {
      const process3 = this.executeCommand({
        command: "yarn",
        args: ["npm", "info", packageName, ...args]
      });
      const result = await process3;
      const commandResult = result.stdout ?? "";
      const parsedOutput = JSON.parse(commandResult);
      return parsedOutput[field];
    } catch (error) {
      throw new FindPackageVersionsError5({
        error,
        packageManager: "Yarn Berry",
        packageName
      });
    }
  }
  mapDependencies(input, pattern) {
    const lines = input.split("\n");
    const acc = {};
    const existingVersions = {};
    const duplicatedDependencies = {};
    lines.forEach((packageName) => {
      if (!packageName || !pattern.some((p) => new RegExp(`${p.replace(/\*/g, ".*")}`).test(packageName))) {
        return;
      }
      const { name, value } = parsePackageData(packageName.replaceAll(`"`, ""));
      if (!existingVersions[name]?.includes(value.version)) {
        if (acc[name]) {
          acc[name].push(value);
        } else {
          acc[name] = [value];
        }
        existingVersions[name] = [...existingVersions[name] || [], value.version];
        if (existingVersions[name].length > 1) {
          duplicatedDependencies[name] = existingVersions[name];
        }
      }
    });
    return {
      dependencies: acc,
      duplicatedDependencies,
      infoCommand: "yarn why",
      dedupeCommand: "yarn dedupe"
    };
  }
  parseErrorFromLogs(logs) {
    const finalMessage = "YARN2 error";
    const errorCodesWithMessages = [];
    const regex = /(YN\d{4}): (.+)/g;
    let match;
    while ((match = regex.exec(logs)) !== null) {
      const code = match[1];
      const message = match[2].replace(/[┌│└]/g, "").trim();
      if (code in CRITICAL_YARN2_ERROR_CODES) {
        errorCodesWithMessages.push({
          code,
          message: `${CRITICAL_YARN2_ERROR_CODES[code]}
-> ${message}
`
        });
      }
    }
    return [
      finalMessage,
      errorCodesWithMessages.map(({ code, message }) => `${code}: ${message}`).join("\n")
    ].join("\n");
  }
};

// src/common/js-package-manager/JsPackageManagerFactory.ts
var JsPackageManagerFactory = class {
  static {
    __name(this, "JsPackageManagerFactory");
  }
  static {
    /** Cache for package manager instances */
    this.cache = /* @__PURE__ */ new Map();
  }
  /** Generate a cache key based on the parameters */
  static getCacheKey(force, configDir = ".storybook", cwd = process.cwd(), storiesPaths) {
    return JSON.stringify({ force: force || null, configDir, cwd, storiesPaths });
  }
  /** Clear the package manager cache */
  static clearCache() {
    this.cache.clear();
  }
  /**
   * Determine which package manager type to use based on lockfiles, commands, and environment
   *
   * @param cwd - Current working directory
   * @returns Package manager type as string: 'npm', 'pnpm', 'bun', 'yarn1', or 'yarn2'
   * @throws Error if no usable package manager is found
   */
  static getPackageManagerType(cwd = process.cwd()) {
    const root = getProjectRoot();
    const lockFiles = [
      up(YARN_LOCKFILE, { cwd, last: root }),
      up(PNPM_LOCKFILE, { cwd, last: root }),
      up(NPM_LOCKFILE, { cwd, last: root }),
      up(BUN_LOCKFILE, { cwd, last: root }),
      up(BUN_LOCKFILE_BINARY, { cwd, last: root })
    ].filter(Boolean).sort((a, b) => {
      const dirA = parse3(a).dir;
      const dirB = parse3(b).dir;
      const compare = relative4(dirA, dirB);
      if (dirA === dirB) {
        return 0;
      }
      if (compare.startsWith("..")) {
        return -1;
      }
      return 1;
    });
    const closestLockfilePath = lockFiles[0];
    const closestLockfile = closestLockfilePath && basename2(closestLockfilePath);
    const yarnVersion = getYarnVersion(cwd);
    if (yarnVersion && closestLockfile === YARN_LOCKFILE) {
      return yarnVersion === 1 ? "yarn1" : "yarn2";
    }
    if (hasPNPM(cwd) && closestLockfile === PNPM_LOCKFILE) {
      return "pnpm";
    }
    const isNPMCommandOk = hasNPM(cwd);
    if (isNPMCommandOk && closestLockfile === NPM_LOCKFILE) {
      return "npm";
    }
    if (hasBun(cwd) && (closestLockfile === BUN_LOCKFILE || closestLockfile === BUN_LOCKFILE_BINARY)) {
      return "bun";
    }
    const inferredPackageManager = this.inferPackageManagerFromUserAgent();
    if (inferredPackageManager && inferredPackageManager in this.PROXY_MAP) {
      return inferredPackageManager;
    }
    if (isNPMCommandOk) {
      return "npm";
    }
    throw new Error("Unable to find a usable package manager within NPM, PNPM, Yarn and Yarn 2");
  }
  static getPackageManager({
    force,
    configDir = ".storybook",
    storiesPaths,
    ignoreCache = false
  } = {}, cwd = process.cwd()) {
    const cacheKey = this.getCacheKey(force, configDir, cwd, storiesPaths);
    const cached = this.cache.get(cacheKey);
    if (cached && !ignoreCache) {
      return cached;
    }
    if (force && force in this.PROXY_MAP) {
      const packageManager2 = new this.PROXY_MAP[force]({ cwd, configDir, storiesPaths });
      this.cache.set(cacheKey, packageManager2);
      return packageManager2;
    }
    const packageManagerType = this.getPackageManagerType(cwd);
    const packageManager = new this.PROXY_MAP[packageManagerType]({ cwd, configDir, storiesPaths });
    this.cache.set(cacheKey, packageManager);
    return packageManager;
  }
  static {
    /** Look up map of package manager proxies by name */
    this.PROXY_MAP = {
      npm: NPMProxy,
      pnpm: PNPMProxy,
      yarn1: Yarn1Proxy,
      yarn2: Yarn2Proxy,
      bun: BUNProxy
    };
  }
  /**
   * Infer the package manager based on the command the user is running. Each package manager sets
   * the `npm_config_user_agent` environment variable with its name and version e.g. "npm/7.24.0"
   * Which is really useful when invoking commands via npx/pnpx/yarn create/etc.
   */
  static inferPackageManagerFromUserAgent() {
    const userAgent = process.env.npm_config_user_agent;
    if (userAgent) {
      const packageSpec = userAgent.split(" ")[0];
      const [pkgMgrName, pkgMgrVersion] = packageSpec.split("/");
      if (pkgMgrName === "pnpm") {
        return "pnpm";
      }
      if (pkgMgrName === "npm") {
        return "npm";
      }
      if (pkgMgrName === "yarn") {
        return `yarn${pkgMgrVersion?.startsWith("1.") ? "1" : "2"}`;
      }
    }
    return void 0;
  }
};
function hasNPM(cwd) {
  const npmVersionCommand = (0, import_cross_spawn.sync)("npm --version", {
    cwd,
    shell: true,
    env: {
      ...process.env,
      ...COMMON_ENV_VARS
    }
  });
  return npmVersionCommand.status === 0;
}
__name(hasNPM, "hasNPM");
function hasBun(cwd) {
  const pnpmVersionCommand = (0, import_cross_spawn.sync)("bun --version", {
    cwd,
    shell: true,
    env: {
      ...process.env,
      ...COMMON_ENV_VARS
    }
  });
  return pnpmVersionCommand.status === 0;
}
__name(hasBun, "hasBun");
function hasPNPM(cwd) {
  const pnpmVersionCommand = (0, import_cross_spawn.sync)("pnpm --version", {
    cwd,
    shell: true,
    env: {
      ...process.env,
      ...COMMON_ENV_VARS
    }
  });
  return pnpmVersionCommand.status === 0;
}
__name(hasPNPM, "hasPNPM");
function getYarnVersion(cwd) {
  const yarnVersionCommand = (0, import_cross_spawn.sync)("yarn --version", {
    cwd,
    shell: true,
    env: {
      ...process.env,
      ...COMMON_ENV_VARS
    }
  });
  if (yarnVersionCommand.status !== 0) {
    return void 0;
  }
  const yarnVersion = yarnVersionCommand.output.toString().replace(/,/g, "").replace(/"/g, "");
  return /^1\.+/.test(yarnVersion) ? 1 : 2;
}
__name(getYarnVersion, "getYarnVersion");

// src/common/utils/scan-and-transform-files.ts
var import_prompts = __toESM(require_prompts(), 1);
async function scanAndTransformFiles({
  promptMessage = "Enter a custom glob pattern to scan (or press enter to use default):",
  defaultGlob = "**/*.{mjs,cjs,js,jsx,ts,tsx,mdx}",
  dryRun = false,
  force = false,
  transformFn,
  transformOptions
}) {
  const { glob: glob2 } = force ? { glob: defaultGlob } : await (0, import_prompts.default)({
    type: "text",
    name: "glob",
    message: promptMessage,
    initial: defaultGlob
  });
  console.log("Scanning for affected files...");
  const globby = (await import("./globby-MTM72QV7.js")).globby;
  const sourceFiles = await globby([glob2], {
    ...commonGlobOptions(""),
    ignore: ["**/node_modules/**"],
    dot: true,
    cwd: getProjectRoot(),
    absolute: true
  });
  console.log(`Scanning ${sourceFiles.length} files...`);
  return transformFn(sourceFiles, transformOptions, dryRun);
}
__name(scanAndTransformFiles, "scanAndTransformFiles");

// src/common/utils/transform-imports.ts
import { readFile as readFile6, writeFile as writeFile4 } from "node:fs/promises";
function transformImports(source, renamedImports) {
  let hasChanges = false;
  let transformed = source;
  for (const [from2, to] of Object.entries(renamedImports)) {
    const regex = new RegExp(`(['"])${from2}(/.*)?\\1`, "g");
    if (regex.test(transformed)) {
      transformed = transformed.replace(regex, `$1${to}$2$1`);
      hasChanges = true;
    }
  }
  return hasChanges ? transformed : null;
}
__name(transformImports, "transformImports");
var transformImportFiles = /* @__PURE__ */ __name(async (files, renamedImports, dryRun) => {
  const errors = [];
  const { default: pLimit } = await import("./p-limit-DHY3P6KR.js");
  const limit = pLimit(10);
  await Promise.all(
    files.map(
      (file) => limit(async () => {
        try {
          const contents = await readFile6(file, "utf-8");
          const transformed = transformImports(contents, renamedImports);
          if (!dryRun && transformed) {
            await writeFile4(file, transformed);
          }
        } catch (error) {
          errors.push({ file, error });
        }
      })
    )
  );
  return errors;
}, "transformImportFiles");

export {
  userOrAutoTitleFromSpecifier,
  up2 as up,
  supportedExtensions,
  getInterpretedFile,
  validateConfigurationFiles,
  filterPresetsConfig,
  resolveAddonName,
  loadPreset,
  getPresets,
  loadAllPresets,
  FileSystemCache,
  createFileSystemCache,
  resolvePathInStorybookCache,
  cache2 as cache,
  HandledError,
  COMMON_ENV_VARS,
  getPackageDetails,
  JsPackageManager,
  getStorybookConfiguration,
  rendererPackages,
  frameworkPackages,
  builderPackages,
  findConfigFile,
  getConfigInfo,
  getStorybookInfo,
  temporaryDirectory,
  temporaryFile,
  parseList,
  getCoercedStorybookVersion,
  getEnvConfig,
  createLogStream,
  isCorePackage,
  isSatelliteAddon,
  checkAddonOrder,
  commonGlobOptions,
  frameworkToRenderer,
  getBuilderOptions,
  getFrameworkName,
  extractProperFrameworkName,
  getRendererName,
  extractProperRendererNameFromFramework,
  getAutoRefs,
  getRefs,
  globToRegexp,
  interpolate,
  serverRequire,
  loadMainConfig,
  loadManagerOrAddonsFile,
  loadPreviewOrConfigFile,
  commandLog,
  paddedLog,
  getChars,
  codeLog,
  logConfig,
  DEFAULT_FILES_PATTERN,
  getDirectoryFromWorkingDir,
  normalizeStoriesEntry,
  normalizeStories,
  readTemplate,
  removeAddon,
  isPreservingSymlinks,
  getPreviewBodyTemplate,
  getPreviewHeadTemplate,
  validateFrameworkName,
  satisfies2 as satisfies,
  formatFileContent,
  posix3 as posix,
  getStoryId,
  getStoryTitle,
  getAddonNames,
  syncStorybookAddons,
  getSyncedStorybookAddons,
  JsPackageManagerFactory,
  scanAndTransformFiles,
  transformImportFiles
};
