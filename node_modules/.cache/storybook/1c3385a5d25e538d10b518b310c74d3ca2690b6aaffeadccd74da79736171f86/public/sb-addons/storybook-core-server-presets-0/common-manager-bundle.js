try{
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x3) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x3, {
    get: (a3, b3) => (typeof require < "u" ? require : a3)[b3]
  }) : x3)(function(x3) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __esm = (fn3, res) => function() {
    return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
  };
  var __commonJS = (cb, mod) => function() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function")
      for (let key of __getOwnPropNames(from))
        !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
    mod
  )), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

  // <define:module>
  var init_define_module = __esm({
    "<define:module>"() {
    }
  });

  // <define:process.env>
  var init_define_process_env = __esm({
    "<define:process.env>"() {
    }
  });

  // <define:process.env.NODE_PATH>
  var init_define_process_env_NODE_PATH = __esm({
    "<define:process.env.NODE_PATH>"() {
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-MM7DTO55.js
  var __create2, __defProp2, __getOwnPropDesc2, __getOwnPropNames2, __getProtoOf2, __hasOwnProp2, __name, __require2, __commonJS2, __export2, __copyProps2, __toESM2, init_chunk_MM7DTO55 = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-MM7DTO55.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      __create2 = Object.create, __defProp2 = Object.defineProperty, __getOwnPropDesc2 = Object.getOwnPropertyDescriptor, __getOwnPropNames2 = Object.getOwnPropertyNames, __getProtoOf2 = Object.getPrototypeOf, __hasOwnProp2 = Object.prototype.hasOwnProperty, __name = (target, value2) => __defProp2(target, "name", { value: value2, configurable: !0 }), __require2 = ((x3) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(x3, {
        get: (a3, b3) => (typeof __require < "u" ? __require : a3)[b3]
      }) : x3)(function(x3) {
        if (typeof __require < "u") return __require.apply(this, arguments);
        throw Error('Dynamic require of "' + x3 + '" is not supported');
      }), __commonJS2 = (cb, mod) => function() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      }, __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames2(from))
            !__hasOwnProp2.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        return to;
      }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target,
        mod
      ));
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-VAMFPZY3.js
  function _objectWithoutPropertiesLoose(r2, e) {
    if (r2 == null) return {};
    var t = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (e.indexOf(n2) !== -1) continue;
      t[n2] = r2[n2];
    }
    return t;
  }
  var init_chunk_VAMFPZY3 = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-VAMFPZY3.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      __name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-L2D73C6Z.js
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
      return typeof o22;
    } : function(o22) {
      return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
    }, _typeof(o2);
  }
  function toPrimitive(t, r2) {
    if (_typeof(t) != "object" || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (e !== void 0) {
      var i3 = e.call(t, r2 || "default");
      if (_typeof(i3) != "object") return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r2 === "string" ? String : Number)(t);
  }
  function toPropertyKey(t) {
    var i3 = toPrimitive(t, "string");
    return _typeof(i3) == "symbol" ? i3 : i3 + "";
  }
  function _defineProperty(e, r2, t) {
    return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r2] = t, e;
  }
  function _objectWithoutProperties(e, t) {
    if (e == null) return {};
    var o2, r2, i3 = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], t.indexOf(o2) === -1 && {}.propertyIsEnumerable.call(e, o2) && (i3[o2] = e[o2]);
    }
    return i3;
  }
  var init_chunk_L2D73C6Z = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-L2D73C6Z.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_VAMFPZY3();
      init_chunk_MM7DTO55();
      __name(_typeof, "_typeof");
      __name(toPrimitive, "toPrimitive");
      __name(toPropertyKey, "toPropertyKey");
      __name(_defineProperty, "_defineProperty");
      __name(_objectWithoutProperties, "_objectWithoutProperties");
    }
  });

  // global-externals:react
  var react_exports = {};
  __export(react_exports, {
    Children: () => Children,
    Component: () => Component,
    Fragment: () => Fragment,
    Profiler: () => Profiler,
    PureComponent: () => PureComponent,
    StrictMode: () => StrictMode,
    Suspense: () => Suspense,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    act: () => act,
    cloneElement: () => cloneElement,
    createContext: () => createContext,
    createElement: () => createElement,
    createFactory: () => createFactory,
    createRef: () => createRef,
    default: () => react_default,
    forwardRef: () => forwardRef,
    isValidElement: () => isValidElement,
    lazy: () => lazy,
    memo: () => memo,
    startTransition: () => startTransition,
    unstable_act: () => unstable_act,
    useCallback: () => useCallback,
    useContext: () => useContext,
    useDebugValue: () => useDebugValue,
    useDeferredValue: () => useDeferredValue,
    useEffect: () => useEffect,
    useId: () => useId,
    useImperativeHandle: () => useImperativeHandle,
    useInsertionEffect: () => useInsertionEffect,
    useLayoutEffect: () => useLayoutEffect,
    useMemo: () => useMemo,
    useReducer: () => useReducer,
    useRef: () => useRef,
    useState: () => useState,
    useSyncExternalStore: () => useSyncExternalStore,
    useTransition: () => useTransition,
    version: () => version
  });
  var react_default, Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, act, cloneElement, createContext, createElement, createFactory, createRef, forwardRef, isValidElement, lazy, memo, startTransition, unstable_act, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, useSyncExternalStore, useTransition, version, init_react = __esm({
    "global-externals:react"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      react_default = __REACT__, { Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, act, cloneElement, createContext, createElement, createFactory, createRef, forwardRef, isValidElement, lazy, memo, startTransition, unstable_act, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, useSyncExternalStore, useTransition, version } = __REACT__;
    }
  });

  // global-externals:storybook/theming
  var theming_default, CacheProvider, ClassNames, Global, ThemeProvider, background, color, convert, create, createCache, createGlobal, createReset, css, darken, ensure, ignoreSsrWarning, isPropValid, jsx, keyframes, lighten, styled, themes, typography, useTheme, withTheme, init_theming = __esm({
    "global-externals:storybook/theming"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      theming_default = __STORYBOOK_THEMING__, { CacheProvider, ClassNames, Global, ThemeProvider, background, color, convert, create, createCache, createGlobal, createReset, css, darken, ensure, ignoreSsrWarning, isPropValid, jsx, keyframes, lighten, styled, themes, typography, useTheme, withTheme } = __STORYBOOK_THEMING__;
    }
  });

  // global-externals:react-dom
  var react_dom_default, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED2, createPortal, createRoot, findDOMNode, flushSync, hydrate, hydrateRoot, render, unmountComponentAtNode, unstable_batchedUpdates, unstable_renderSubtreeIntoContainer, version2, init_react_dom = __esm({
    "global-externals:react-dom"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      react_dom_default = __REACT_DOM__, { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED2, createPortal, createRoot, findDOMNode, flushSync, hydrate, hydrateRoot, render, unmountComponentAtNode, unstable_batchedUpdates, unstable_renderSubtreeIntoContainer, version: version2 } = __REACT_DOM__;
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      (function() {
        function getComponentNameFromType(type) {
          if (type == null) return null;
          if (typeof type == "function")
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if (typeof type == "string") return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if (typeof type == "object")
            switch (typeof type.tag == "number" && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                return type = type.displayName, type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef"), type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload, type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch {
                }
            }
          return null;
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkKeyStringCoercion(value2) {
          try {
            testStringCoercion(value2);
            var JSCompiler_inline_result = !1;
          } catch {
            JSCompiler_inline_result = !0;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error, JSCompiler_inline_result$jscomp$0 = typeof Symbol == "function" && Symbol.toStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            ), testStringCoercion(value2);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if (typeof type == "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return dispatcher === null ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config2) {
          if (hasOwnProperty2.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return !1;
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          return didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          )), componentName = this.props.ref, componentName !== void 0 ? componentName : null;
        }
        function ReactElement3(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          return type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          }, (refProp !== void 0 ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: !1, value: null }), type._store = {}, Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
          }), Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
          }), Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
          }), Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
          }), Object.freeze && (Object.freeze(type.props), Object.freeze(type)), type;
        }
        function jsxDEVImpl(type, config2, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config2.children;
          if (children !== void 0)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty2.call(config2, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config2).filter(function(k3) {
              return k3 !== "key";
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}", didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = !0);
          }
          if (children = null, maybeKey !== void 0 && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), children = "" + config2.key), "key" in config2) {
            maybeKey = {};
            for (var propName in config2)
              propName !== "key" && (maybeKey[propName] = config2[propName]);
          } else maybeKey = config2;
          return children && defineKeyPropWarningGetter(
            maybeKey,
            typeof type == "function" ? type.displayName || type.name || "Unknown" : type
          ), ReactElement3(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement2(node) ? node._store && (node._store.validated = 1) : typeof node == "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement2(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement2(object2) {
          return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React = (init_react(), __toCommonJS(react_exports)), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty2 = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutElementRef = {}, unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
          React,
          UnknownOwner
        )(), unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner)), didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE, exports.jsx = function(type, config2, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config2,
            maybeKey,
            !1,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        }, exports.jsxs = function(type, config2, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config2,
            maybeKey,
            !0,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      module.exports = require_react_jsx_runtime_development();
    }
  });

  // node_modules/@storybook/global/dist/index.mjs
  var scope, init_dist = __esm({
    "node_modules/@storybook/global/dist/index.mjs"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      scope = (() => {
        let win;
        return typeof window < "u" ? win = window : typeof globalThis < "u" ? win = globalThis : typeof window < "u" ? win = window : typeof self < "u" ? win = self : win = {}, win;
      })();
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-RNE2IUTB.js
  function setRef(ref, value2) {
    typeof ref == "function" ? ref(value2) : ref != null && (ref.current = value2);
  }
  function composeRefs(...refs) {
    return (node) => refs.forEach((ref) => setRef(ref, node));
  }
  function useComposedRefs(...refs) {
    return useCallback(composeRefs(...refs), refs);
  }
  function isSlottable(child) {
    return isValidElement(child) && child.type === Slottable;
  }
  function mergeProps(slotProps, childProps) {
    let overrideProps = { ...childProps };
    for (let propName in childProps) {
      let slotPropValue = slotProps[propName], childPropValue = childProps[propName];
      /^on[A-Z]/.test(propName) ? slotPropValue && childPropValue ? overrideProps[propName] = (...args) => {
        childPropValue(...args), slotPropValue(...args);
      } : slotPropValue && (overrideProps[propName] = slotPropValue) : propName === "style" ? overrideProps[propName] = { ...slotPropValue, ...childPropValue } : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    return mayWarn ? element.ref : (getter = Object.getOwnPropertyDescriptor(element, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
  }
  function useStateMachine(initialState, machine) {
    return useReducer((state3, event) => machine[state3][event] ?? state3, initialState);
  }
  function usePresence(present) {
    let [node, setNode] = useState(), stylesRef = useRef({}), prevPresentRef = useRef(present), prevAnimationNameRef = useRef("none"), initialState = present ? "mounted" : "unmounted", [state3, send] = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    return useEffect(() => {
      let currentAnimationName = getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state3 === "mounted" ? currentAnimationName : "none";
    }, [state3]), useLayoutEffect2(() => {
      let styles3 = stylesRef.current, wasPresent = prevPresentRef.current;
      if (wasPresent !== present) {
        let prevAnimationName = prevAnimationNameRef.current, currentAnimationName = getAnimationName(styles3);
        present ? send("MOUNT") : currentAnimationName === "none" || styles3?.display === "none" ? send("UNMOUNT") : send(wasPresent && prevAnimationName !== currentAnimationName ? "ANIMATION_OUT" : "UNMOUNT"), prevPresentRef.current = present;
      }
    }, [present, send]), useLayoutEffect2(() => {
      if (node) {
        let handleAnimationEnd = __name((event) => {
          let isCurrentAnimation = getAnimationName(stylesRef.current).includes(event.animationName);
          event.target === node && isCurrentAnimation && flushSync(() => send("ANIMATION_END"));
        }, "handleAnimationEnd"), handleAnimationStart = __name((event) => {
          event.target === node && (prevAnimationNameRef.current = getAnimationName(stylesRef.current));
        }, "handleAnimationStart");
        return node.addEventListener("animationstart", handleAnimationStart), node.addEventListener("animationcancel", handleAnimationEnd), node.addEventListener("animationend", handleAnimationEnd), () => {
          node.removeEventListener("animationstart", handleAnimationStart), node.removeEventListener("animationcancel", handleAnimationEnd), node.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [node, send]), {
      isPresent: ["mounted", "unmountSuspended"].includes(state3),
      ref: useCallback((node2) => {
        node2 && (stylesRef.current = getComputedStyle(node2)), setNode(node2);
      }, [])
    };
  }
  function getAnimationName(styles3) {
    return styles3?.animationName || "none";
  }
  function getElementRef2(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    return mayWarn ? element.ref : (getter = Object.getOwnPropertyDescriptor(element, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
  }
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      let BaseContext = createContext(defaultContext), index3 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      function Provider2(props) {
        let { scope: scope2, children, ...context } = props, Context = scope2?.[scopeName][index3] || BaseContext, value2 = useMemo(() => context, Object.values(context));
        return (0, import_jsx_runtime3.jsx)(Context.Provider, { value: value2, children });
      }
      __name(Provider2, "Provider");
      function useContext22(consumerName, scope2) {
        let Context = scope2?.[scopeName][index3] || BaseContext, context = useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return __name(useContext22, "useContext2"), Provider2.displayName = rootComponentName + "Provider", [Provider2, useContext22];
    }
    __name(createContext3, "createContext3");
    let createScope = __name(() => {
      let scopeContexts = defaultContexts.map((defaultContext) => createContext(defaultContext));
      return __name(function(scope2) {
        let contexts = scope2?.[scopeName] || scopeContexts;
        return useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope2, [scopeName]: contexts } }),
          [scope2, contexts]
        );
      }, "useScope");
    }, "createScope");
    return createScope.scopeName = scopeName, [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    let baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    let createScope = __name(() => {
      let scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return __name(function(overrideScopes) {
        let nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          let currentScope = useScope(overrideScopes)[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      }, "useComposedScopes");
    }, "createScope");
    return createScope.scopeName = baseScope.scopeName, createScope;
  }
  function useCallbackRef(callback) {
    let callbackRef = useRef(callback);
    return useEffect(() => {
      callbackRef.current = callback;
    }), useMemo(() => (...args) => callbackRef.current?.(...args), []);
  }
  function useDirection(localDir) {
    let globalDir = useContext(DirectionContext);
    return localDir || globalDir || "ltr";
  }
  function clamp(value2, [min2, max2]) {
    return Math.min(max2, Math.max(min2, value2));
  }
  function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
    return __name(function(event) {
      if (originalEventHandler?.(event), checkForDefaultPrevented === !1 || !event.defaultPrevented)
        return ourEventHandler?.(event);
    }, "handleEvent");
  }
  function useStateMachine2(initialState, machine) {
    return useReducer((state3, event) => machine[state3][event] ?? state3, initialState);
  }
  function toInt(value2) {
    return value2 ? parseInt(value2, 10) : 0;
  }
  function getThumbRatio(viewportSize, contentSize) {
    let ratio = viewportSize / contentSize;
    return isNaN(ratio) ? 0 : ratio;
  }
  function getThumbSize(sizes2) {
    let ratio = getThumbRatio(sizes2.viewport, sizes2.content), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, thumbSize = (sizes2.scrollbar.size - scrollbarPadding) * ratio;
    return Math.max(thumbSize, 18);
  }
  function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes2, dir = "ltr") {
    let thumbSizePx = getThumbSize(sizes2), thumbCenter = thumbSizePx / 2, offset3 = pointerOffset || thumbCenter, thumbOffsetFromEnd = thumbSizePx - offset3, minPointerPos = sizes2.scrollbar.paddingStart + offset3, maxPointerPos = sizes2.scrollbar.size - sizes2.scrollbar.paddingEnd - thumbOffsetFromEnd, maxScrollPos = sizes2.content - sizes2.viewport, scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
    return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
  }
  function getThumbOffsetFromScroll(scrollPos, sizes2, dir = "ltr") {
    let thumbSizePx = getThumbSize(sizes2), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, scrollbar = sizes2.scrollbar.size - scrollbarPadding, maxScrollPos = sizes2.content - sizes2.viewport, maxThumbPos = scrollbar - thumbSizePx, scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0], scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);
    return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
  }
  function linearScale(input, output) {
    return (value2) => {
      if (input[0] === input[1] || output[0] === output[1]) return output[0];
      let ratio = (output[1] - output[0]) / (input[1] - input[0]);
      return output[0] + ratio * (value2 - input[0]);
    };
  }
  function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
    return scrollPos > 0 && scrollPos < maxScrollPos;
  }
  function useDebounceCallback(callback, delay) {
    let handleCallback = useCallbackRef(callback), debounceTimerRef = useRef(0);
    return useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []), useCallback(() => {
      window.clearTimeout(debounceTimerRef.current), debounceTimerRef.current = window.setTimeout(handleCallback, delay);
    }, [handleCallback, delay]);
  }
  function useResizeObserver(element, onResize) {
    let handleResize = useCallbackRef(onResize);
    useLayoutEffect2(() => {
      let rAF = 0;
      if (element) {
        let resizeObserver = new ResizeObserver(() => {
          cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize);
        });
        return resizeObserver.observe(element), () => {
          window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element);
        };
      }
    }, [element, handleResize]);
  }
  function getSubtree(options2, content) {
    let { asChild, children } = options2;
    if (!asChild) return typeof content == "function" ? content(children) : content;
    let firstChild = Children.only(children);
    return cloneElement(firstChild, {
      children: typeof content == "function" ? content(firstChild.props.children) : content
    });
  }
  async function copyUsingClipboardAPI(text) {
    try {
      await globalWindow.top?.navigator.clipboard.writeText(text);
    } catch {
      await globalWindow.navigator.clipboard.writeText(text);
    }
  }
  async function copyUsingWorkAround(text) {
    let tmp = document2.createElement("TEXTAREA"), focus2 = document2.activeElement;
    tmp.value = text, document2.body.appendChild(tmp), tmp.select(), document2.execCommand("copy"), document2.body.removeChild(tmp), focus2.focus();
  }
  function createCopyToClipboardFunction() {
    return globalWindow.navigator?.clipboard ? copyUsingClipboardAPI : copyUsingWorkAround;
  }
  var import_jsx_runtime, import_jsx_runtime2, import_jsx_runtime3, import_jsx_runtime4, import_jsx_runtime5, Container, ActionButton, ActionBar, Slot, SlotClone, Slottable, NODES, Primitive, useLayoutEffect2, Presence, DirectionContext, SCROLL_AREA_NAME, createScrollAreaContext, createScrollAreaScope, ScrollAreaProvider, useScrollAreaContext, ScrollArea, VIEWPORT_NAME, ScrollAreaViewport, SCROLLBAR_NAME, ScrollAreaScrollbar, ScrollAreaScrollbarHover, ScrollAreaScrollbarScroll, ScrollAreaScrollbarAuto, ScrollAreaScrollbarVisible, ScrollAreaScrollbarX, ScrollAreaScrollbarY, ScrollbarProvider, useScrollbarContext, ScrollAreaScrollbarImpl, THUMB_NAME, ScrollAreaThumb, ScrollAreaThumbImpl, CORNER_NAME, ScrollAreaCorner, ScrollAreaCornerImpl, addUnlinkedScrollListener, Root, Viewport, Scrollbar, Thumb, Corner, ScrollAreaRoot, ScrollAreaViewport2, ScrollAreaScrollbar2, ScrollAreaThumb2, ScrollArea2, document2, globalWindow, init_chunk_RNE2IUTB = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-RNE2IUTB.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      init_react();
      init_theming();
      init_react();
      init_react();
      init_react();
      init_react_dom();
      init_react();
      init_react();
      import_jsx_runtime = __toESM(require_jsx_runtime(), 1), import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
      init_react();
      init_react_dom();
      init_react();
      init_react();
      init_react();
      import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
      init_react();
      init_react();
      import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
      init_react();
      import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
      init_theming();
      init_dist();
      Container = styled.div(({ theme: theme3 }) => ({
        position: "absolute",
        bottom: 0,
        right: 0,
        maxWidth: "100%",
        display: "flex",
        background: theme3.background.content,
        zIndex: 1
      })), ActionButton = styled.button(
        ({ theme: theme3 }) => ({
          margin: 0,
          border: "0 none",
          padding: "4px 10px",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          color: theme3.color.defaultText,
          background: theme3.background.content,
          fontSize: 12,
          lineHeight: "16px",
          fontFamily: theme3.typography.fonts.base,
          fontWeight: theme3.typography.weight.bold,
          borderTop: `1px solid ${theme3.appBorderColor}`,
          borderLeft: `1px solid ${theme3.appBorderColor}`,
          marginLeft: -1,
          borderRadius: "4px 0 0 0",
          "&:not(:last-child)": { borderRight: `1px solid ${theme3.appBorderColor}` },
          "& + *": {
            borderLeft: `1px solid ${theme3.appBorderColor}`,
            borderRadius: 0
          },
          "&:focus": {
            boxShadow: `${theme3.color.secondary} 0 -3px 0 0 inset`,
            outline: "0 none",
            "@media (forced-colors: active)": {
              outline: "1px solid highlight"
            }
          }
        }),
        ({ disabled }) => disabled && {
          cursor: "not-allowed",
          opacity: 0.5
        }
      );
      ActionButton.displayName = "ActionButton";
      ActionBar = __name(({ actionItems, ...props }) => react_default.createElement(Container, { ...props }, actionItems.map(({ title, className, onClick, disabled }, index3) => react_default.createElement(ActionButton, { key: index3, className, onClick, disabled: !!disabled }, title))), "ActionBar");
      __name(setRef, "setRef");
      __name(composeRefs, "composeRefs");
      __name(useComposedRefs, "useComposedRefs");
      Slot = forwardRef((props, forwardedRef) => {
        let { children, ...slotProps } = props, childrenArray = Children.toArray(children), slottable = childrenArray.find(isSlottable);
        if (slottable) {
          let newElement = slottable.props.children, newChildren = childrenArray.map((child) => child === slottable ? Children.count(newElement) > 1 ? Children.only(null) : isValidElement(newElement) ? newElement.props.children : null : child);
          return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: isValidElement(newElement) ? cloneElement(newElement, void 0, newChildren) : null });
        }
        return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
      });
      Slot.displayName = "Slot";
      SlotClone = forwardRef((props, forwardedRef) => {
        let { children, ...slotProps } = props;
        if (isValidElement(children)) {
          let childrenRef = getElementRef(children);
          return cloneElement(children, {
            ...mergeProps(slotProps, children.props),
            // @ts-ignore
            ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
          });
        }
        return Children.count(children) > 1 ? Children.only(null) : null;
      });
      SlotClone.displayName = "SlotClone";
      Slottable = __name(({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }), "Slottable");
      __name(isSlottable, "isSlottable");
      __name(mergeProps, "mergeProps");
      __name(getElementRef, "getElementRef");
      NODES = [
        "a",
        "button",
        "div",
        "form",
        "h2",
        "h3",
        "img",
        "input",
        "label",
        "li",
        "nav",
        "ol",
        "p",
        "span",
        "svg",
        "ul"
      ], Primitive = NODES.reduce((primitive, node) => {
        let Node3 = forwardRef((props, forwardedRef) => {
          let { asChild, ...primitiveProps } = props, Comp2 = asChild ? Slot : node;
          return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), (0, import_jsx_runtime2.jsx)(Comp2, { ...primitiveProps, ref: forwardedRef });
        });
        return Node3.displayName = `Primitive.${node}`, { ...primitive, [node]: Node3 };
      }, {}), useLayoutEffect2 = globalThis?.document ? useLayoutEffect : () => {
      };
      __name(useStateMachine, "useStateMachine");
      Presence = __name((props) => {
        let { present, children } = props, presence = usePresence(present), child = typeof children == "function" ? children({ present: presence.isPresent }) : Children.only(children), ref = useComposedRefs(presence.ref, getElementRef2(child));
        return typeof children == "function" || presence.isPresent ? cloneElement(child, { ref }) : null;
      }, "Presence");
      Presence.displayName = "Presence";
      __name(usePresence, "usePresence");
      __name(getAnimationName, "getAnimationName");
      __name(getElementRef2, "getElementRef");
      __name(createContextScope, "createContextScope");
      __name(composeContextScopes, "composeContextScopes");
      __name(useCallbackRef, "useCallbackRef");
      DirectionContext = createContext(void 0);
      __name(useDirection, "useDirection");
      __name(clamp, "clamp");
      __name(composeEventHandlers, "composeEventHandlers");
      __name(useStateMachine2, "useStateMachine");
      SCROLL_AREA_NAME = "ScrollArea", [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME), [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME), ScrollArea = forwardRef(
        (props, forwardedRef) => {
          let {
            __scopeScrollArea,
            type = "hover",
            dir,
            scrollHideDelay = 600,
            ...scrollAreaProps
          } = props, [scrollArea, setScrollArea] = useState(null), [viewport2, setViewport] = useState(null), [content, setContent] = useState(null), [scrollbarX, setScrollbarX] = useState(null), [scrollbarY, setScrollbarY] = useState(null), [cornerWidth, setCornerWidth] = useState(0), [cornerHeight, setCornerHeight] = useState(0), [scrollbarXEnabled, setScrollbarXEnabled] = useState(!1), [scrollbarYEnabled, setScrollbarYEnabled] = useState(!1), composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node)), direction = useDirection(dir);
          return (0, import_jsx_runtime5.jsx)(
            ScrollAreaProvider,
            {
              scope: __scopeScrollArea,
              type,
              dir: direction,
              scrollHideDelay,
              scrollArea,
              viewport: viewport2,
              onViewportChange: setViewport,
              content,
              onContentChange: setContent,
              scrollbarX,
              onScrollbarXChange: setScrollbarX,
              scrollbarXEnabled,
              onScrollbarXEnabledChange: setScrollbarXEnabled,
              scrollbarY,
              onScrollbarYChange: setScrollbarY,
              scrollbarYEnabled,
              onScrollbarYEnabledChange: setScrollbarYEnabled,
              onCornerWidthChange: setCornerWidth,
              onCornerHeightChange: setCornerHeight,
              children: (0, import_jsx_runtime5.jsx)(
                Primitive.div,
                {
                  dir: direction,
                  ...scrollAreaProps,
                  ref: composedRefs,
                  style: {
                    position: "relative",
                    // Pass corner sizes as CSS vars to reduce re-renders of context consumers
                    "--radix-scroll-area-corner-width": cornerWidth + "px",
                    "--radix-scroll-area-corner-height": cornerHeight + "px",
                    ...props.style
                  }
                }
              )
            }
          );
        }
      );
      ScrollArea.displayName = SCROLL_AREA_NAME;
      VIEWPORT_NAME = "ScrollAreaViewport", ScrollAreaViewport = forwardRef(
        (props, forwardedRef) => {
          let { __scopeScrollArea, children, asChild, nonce, ...viewportProps } = props, context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea), ref = useRef(null), composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
          return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
            (0, import_jsx_runtime5.jsx)(
              "style",
              {
                dangerouslySetInnerHTML: {
                  __html: `
[data-radix-scroll-area-viewport] {
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
}
[data-radix-scroll-area-viewport]::-webkit-scrollbar {
  display: none;
}
:where([data-radix-scroll-area-viewport]) {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
:where([data-radix-scroll-area-content]) {
  flex-grow: 1;
}
`
                },
                nonce
              }
            ),
            (0, import_jsx_runtime5.jsx)(
              Primitive.div,
              {
                "data-radix-scroll-area-viewport": "",
                ...viewportProps,
                asChild,
                ref: composedRefs,
                style: {
                  /**
                   * We don't support `visible` because the intention is to have at least one scrollbar
                   * if this component is used and `visible` will behave like `auto` in that case
                   * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
                   *
                   * We don't handle `auto` because the intention is for the native implementation
                   * to be hidden if using this component. We just want to ensure the node is scrollable
                   * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
                   * the browser from having to work out whether to render native scrollbars or not,
                   * we tell it to with the intention of hiding them in CSS.
                   */
                  overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
                  overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
                  ...props.style
                },
                children: getSubtree({ asChild, children }, (children2) => (0, import_jsx_runtime5.jsx)(
                  "div",
                  {
                    "data-radix-scroll-area-content": "",
                    ref: context.onContentChange,
                    style: { minWidth: context.scrollbarXEnabled ? "fit-content" : void 0 },
                    children: children2
                  }
                ))
              }
            )
          ] });
        }
      );
      ScrollAreaViewport.displayName = VIEWPORT_NAME;
      SCROLLBAR_NAME = "ScrollAreaScrollbar", ScrollAreaScrollbar = forwardRef(
        (props, forwardedRef) => {
          let { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context, isHorizontal = props.orientation === "horizontal";
          return useEffect(() => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
            isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1);
          }), [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]), context.type === "hover" ? (0, import_jsx_runtime5.jsx)(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? (0, import_jsx_runtime5.jsx)(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? (0, import_jsx_runtime5.jsx)(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? (0, import_jsx_runtime5.jsx)(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
        }
      );
      ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
      ScrollAreaScrollbarHover = forwardRef((props, forwardedRef) => {
        let { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), [visible, setVisible] = useState(!1);
        return useEffect(() => {
          let scrollArea = context.scrollArea, hideTimer = 0;
          if (scrollArea) {
            let handlePointerEnter = __name(() => {
              window.clearTimeout(hideTimer), setVisible(!0);
            }, "handlePointerEnter"), handlePointerLeave = __name(() => {
              hideTimer = window.setTimeout(() => setVisible(!1), context.scrollHideDelay);
            }, "handlePointerLeave");
            return scrollArea.addEventListener("pointerenter", handlePointerEnter), scrollArea.addEventListener("pointerleave", handlePointerLeave), () => {
              window.clearTimeout(hideTimer), scrollArea.removeEventListener("pointerenter", handlePointerEnter), scrollArea.removeEventListener("pointerleave", handlePointerLeave);
            };
          }
        }, [context.scrollArea, context.scrollHideDelay]), (0, import_jsx_runtime5.jsx)(Presence, { present: forceMount || visible, children: (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarAuto,
          {
            "data-state": visible ? "visible" : "hidden",
            ...scrollbarProps,
            ref: forwardedRef
          }
        ) });
      }), ScrollAreaScrollbarScroll = forwardRef((props, forwardedRef) => {
        let { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), isHorizontal = props.orientation === "horizontal", debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100), [state3, send] = useStateMachine2("hidden", {
          hidden: {
            SCROLL: "scrolling"
          },
          scrolling: {
            SCROLL_END: "idle",
            POINTER_ENTER: "interacting"
          },
          interacting: {
            SCROLL: "interacting",
            POINTER_LEAVE: "idle"
          },
          idle: {
            HIDE: "hidden",
            SCROLL: "scrolling",
            POINTER_ENTER: "interacting"
          }
        });
        return useEffect(() => {
          if (state3 === "idle") {
            let hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
            return () => window.clearTimeout(hideTimer);
          }
        }, [state3, context.scrollHideDelay, send]), useEffect(() => {
          let viewport2 = context.viewport, scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
          if (viewport2) {
            let prevScrollPos = viewport2[scrollDirection], handleScroll2 = __name(() => {
              let scrollPos = viewport2[scrollDirection];
              prevScrollPos !== scrollPos && (send("SCROLL"), debounceScrollEnd()), prevScrollPos = scrollPos;
            }, "handleScroll");
            return viewport2.addEventListener("scroll", handleScroll2), () => viewport2.removeEventListener("scroll", handleScroll2);
          }
        }, [context.viewport, isHorizontal, send, debounceScrollEnd]), (0, import_jsx_runtime5.jsx)(Presence, { present: forceMount || state3 !== "hidden", children: (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarVisible,
          {
            "data-state": state3 === "hidden" ? "hidden" : "visible",
            ...scrollbarProps,
            ref: forwardedRef,
            onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
            onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
          }
        ) });
      }), ScrollAreaScrollbarAuto = forwardRef((props, forwardedRef) => {
        let context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), { forceMount, ...scrollbarProps } = props, [visible, setVisible] = useState(!1), isHorizontal = props.orientation === "horizontal", handleResize = useDebounceCallback(() => {
          if (context.viewport) {
            let isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth, isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
            setVisible(isHorizontal ? isOverflowX : isOverflowY);
          }
        }, 10);
        return useResizeObserver(context.viewport, handleResize), useResizeObserver(context.content, handleResize), (0, import_jsx_runtime5.jsx)(Presence, { present: forceMount || visible, children: (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarVisible,
          {
            "data-state": visible ? "visible" : "hidden",
            ...scrollbarProps,
            ref: forwardedRef
          }
        ) });
      }), ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {
        let { orientation = "vertical", ...scrollbarProps } = props, context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), thumbRef = useRef(null), pointerOffsetRef = useRef(0), [sizes2, setSizes] = useState({
          content: 0,
          viewport: 0,
          scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
        }), thumbRatio = getThumbRatio(sizes2.viewport, sizes2.content), commonProps = {
          ...scrollbarProps,
          sizes: sizes2,
          onSizesChange: setSizes,
          hasThumb: thumbRatio > 0 && thumbRatio < 1,
          onThumbChange: __name((thumb) => thumbRef.current = thumb, "onThumbChange"),
          onThumbPointerUp: __name(() => pointerOffsetRef.current = 0, "onThumbPointerUp"),
          onThumbPointerDown: __name((pointerPos) => pointerOffsetRef.current = pointerPos, "onThumbPointerDown")
        };
        function getScrollPosition(pointerPos, dir) {
          return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes2, dir);
        }
        return __name(getScrollPosition, "getScrollPosition"), orientation === "horizontal" ? (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarX,
          {
            ...commonProps,
            ref: forwardedRef,
            onThumbPositionChange: __name(() => {
              if (context.viewport && thumbRef.current) {
                let scrollPos = context.viewport.scrollLeft, offset3 = getThumbOffsetFromScroll(scrollPos, sizes2, context.dir);
                thumbRef.current.style.transform = `translate3d(${offset3}px, 0, 0)`;
              }
            }, "onThumbPositionChange"),
            onWheelScroll: __name((scrollPos) => {
              context.viewport && (context.viewport.scrollLeft = scrollPos);
            }, "onWheelScroll"),
            onDragScroll: __name((pointerPos) => {
              context.viewport && (context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir));
            }, "onDragScroll")
          }
        ) : orientation === "vertical" ? (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarY,
          {
            ...commonProps,
            ref: forwardedRef,
            onThumbPositionChange: __name(() => {
              if (context.viewport && thumbRef.current) {
                let scrollPos = context.viewport.scrollTop, offset3 = getThumbOffsetFromScroll(scrollPos, sizes2);
                thumbRef.current.style.transform = `translate3d(0, ${offset3}px, 0)`;
              }
            }, "onThumbPositionChange"),
            onWheelScroll: __name((scrollPos) => {
              context.viewport && (context.viewport.scrollTop = scrollPos);
            }, "onWheelScroll"),
            onDragScroll: __name((pointerPos) => {
              context.viewport && (context.viewport.scrollTop = getScrollPosition(pointerPos));
            }, "onDragScroll")
          }
        ) : null;
      }), ScrollAreaScrollbarX = forwardRef((props, forwardedRef) => {
        let { sizes: sizes2, onSizesChange, ...scrollbarProps } = props, context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs22 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
        return useEffect(() => {
          ref.current && setComputedStyle(getComputedStyle(ref.current));
        }, [ref]), (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarImpl,
          {
            "data-orientation": "horizontal",
            ...scrollbarProps,
            ref: composeRefs22,
            sizes: sizes2,
            style: {
              bottom: 0,
              left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
              right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
              "--radix-scroll-area-thumb-width": getThumbSize(sizes2) + "px",
              ...props.style
            },
            onThumbPointerDown: __name((pointerPos) => props.onThumbPointerDown(pointerPos.x), "onThumbPointerDown"),
            onDragScroll: __name((pointerPos) => props.onDragScroll(pointerPos.x), "onDragScroll"),
            onWheelScroll: __name((event, maxScrollPos) => {
              if (context.viewport) {
                let scrollPos = context.viewport.scrollLeft + event.deltaX;
                props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
              }
            }, "onWheelScroll"),
            onResize: __name(() => {
              ref.current && context.viewport && computedStyle && onSizesChange({
                content: context.viewport.scrollWidth,
                viewport: context.viewport.offsetWidth,
                scrollbar: {
                  size: ref.current.clientWidth,
                  paddingStart: toInt(computedStyle.paddingLeft),
                  paddingEnd: toInt(computedStyle.paddingRight)
                }
              });
            }, "onResize")
          }
        );
      }), ScrollAreaScrollbarY = forwardRef((props, forwardedRef) => {
        let { sizes: sizes2, onSizesChange, ...scrollbarProps } = props, context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs22 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
        return useEffect(() => {
          ref.current && setComputedStyle(getComputedStyle(ref.current));
        }, [ref]), (0, import_jsx_runtime5.jsx)(
          ScrollAreaScrollbarImpl,
          {
            "data-orientation": "vertical",
            ...scrollbarProps,
            ref: composeRefs22,
            sizes: sizes2,
            style: {
              top: 0,
              right: context.dir === "ltr" ? 0 : void 0,
              left: context.dir === "rtl" ? 0 : void 0,
              bottom: "var(--radix-scroll-area-corner-height)",
              "--radix-scroll-area-thumb-height": getThumbSize(sizes2) + "px",
              ...props.style
            },
            onThumbPointerDown: __name((pointerPos) => props.onThumbPointerDown(pointerPos.y), "onThumbPointerDown"),
            onDragScroll: __name((pointerPos) => props.onDragScroll(pointerPos.y), "onDragScroll"),
            onWheelScroll: __name((event, maxScrollPos) => {
              if (context.viewport) {
                let scrollPos = context.viewport.scrollTop + event.deltaY;
                props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
              }
            }, "onWheelScroll"),
            onResize: __name(() => {
              ref.current && context.viewport && computedStyle && onSizesChange({
                content: context.viewport.scrollHeight,
                viewport: context.viewport.offsetHeight,
                scrollbar: {
                  size: ref.current.clientHeight,
                  paddingStart: toInt(computedStyle.paddingTop),
                  paddingEnd: toInt(computedStyle.paddingBottom)
                }
              });
            }, "onResize")
          }
        );
      }), [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME), ScrollAreaScrollbarImpl = forwardRef((props, forwardedRef) => {
        let {
          __scopeScrollArea,
          sizes: sizes2,
          hasThumb,
          onThumbChange,
          onThumbPointerUp,
          onThumbPointerDown,
          onThumbPositionChange,
          onDragScroll,
          onWheelScroll,
          onResize,
          ...scrollbarProps
        } = props, context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea), [scrollbar, setScrollbar] = useState(null), composeRefs22 = useComposedRefs(forwardedRef, (node) => setScrollbar(node)), rectRef = useRef(null), prevWebkitUserSelectRef = useRef(""), viewport2 = context.viewport, maxScrollPos = sizes2.content - sizes2.viewport, handleWheelScroll = useCallbackRef(onWheelScroll), handleThumbPositionChange = useCallbackRef(onThumbPositionChange), handleResize = useDebounceCallback(onResize, 10);
        function handleDragScroll(event) {
          if (rectRef.current) {
            let x3 = event.clientX - rectRef.current.left, y3 = event.clientY - rectRef.current.top;
            onDragScroll({ x: x3, y: y3 });
          }
        }
        return __name(handleDragScroll, "handleDragScroll"), useEffect(() => {
          let handleWheel = __name((event) => {
            let element = event.target;
            scrollbar?.contains(element) && handleWheelScroll(event, maxScrollPos);
          }, "handleWheel");
          return document.addEventListener("wheel", handleWheel, { passive: !1 }), () => document.removeEventListener("wheel", handleWheel, { passive: !1 });
        }, [viewport2, scrollbar, maxScrollPos, handleWheelScroll]), useEffect(handleThumbPositionChange, [sizes2, handleThumbPositionChange]), useResizeObserver(scrollbar, handleResize), useResizeObserver(context.content, handleResize), (0, import_jsx_runtime5.jsx)(
          ScrollbarProvider,
          {
            scope: __scopeScrollArea,
            scrollbar,
            hasThumb,
            onThumbChange: useCallbackRef(onThumbChange),
            onThumbPointerUp: useCallbackRef(onThumbPointerUp),
            onThumbPositionChange: handleThumbPositionChange,
            onThumbPointerDown: useCallbackRef(onThumbPointerDown),
            children: (0, import_jsx_runtime5.jsx)(
              Primitive.div,
              {
                ...scrollbarProps,
                ref: composeRefs22,
                style: { position: "absolute", ...scrollbarProps.style },
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  event.button === 0 && (event.target.setPointerCapture(event.pointerId), rectRef.current = scrollbar.getBoundingClientRect(), prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", context.viewport && (context.viewport.style.scrollBehavior = "auto"), handleDragScroll(event));
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  let element = event.target;
                  element.hasPointerCapture(event.pointerId) && element.releasePointerCapture(event.pointerId), document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current, context.viewport && (context.viewport.style.scrollBehavior = ""), rectRef.current = null;
                })
              }
            )
          }
        );
      }), THUMB_NAME = "ScrollAreaThumb", ScrollAreaThumb = forwardRef(
        (props, forwardedRef) => {
          let { forceMount, ...thumbProps } = props, scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
          return (0, import_jsx_runtime5.jsx)(Presence, { present: forceMount || scrollbarContext.hasThumb, children: (0, import_jsx_runtime5.jsx)(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
        }
      ), ScrollAreaThumbImpl = forwardRef(
        (props, forwardedRef) => {
          let { __scopeScrollArea, style, ...thumbProps } = props, scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea), scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea), { onThumbPositionChange } = scrollbarContext, composedRef = useComposedRefs(
            forwardedRef,
            (node) => scrollbarContext.onThumbChange(node)
          ), removeUnlinkedScrollListenerRef = useRef(), debounceScrollEnd = useDebounceCallback(() => {
            removeUnlinkedScrollListenerRef.current && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0);
          }, 100);
          return useEffect(() => {
            let viewport2 = scrollAreaContext.viewport;
            if (viewport2) {
              let handleScroll2 = __name(() => {
                if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
                  let listener = addUnlinkedScrollListener(viewport2, onThumbPositionChange);
                  removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange();
                }
              }, "handleScroll");
              return onThumbPositionChange(), viewport2.addEventListener("scroll", handleScroll2), () => viewport2.removeEventListener("scroll", handleScroll2);
            }
          }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]), (0, import_jsx_runtime5.jsx)(
            Primitive.div,
            {
              "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
              ...thumbProps,
              ref: composedRef,
              style: {
                width: "var(--radix-scroll-area-thumb-width)",
                height: "var(--radix-scroll-area-thumb-height)",
                ...style
              },
              onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
                let thumbRect = event.target.getBoundingClientRect(), x3 = event.clientX - thumbRect.left, y3 = event.clientY - thumbRect.top;
                scrollbarContext.onThumbPointerDown({ x: x3, y: y3 });
              }),
              onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
            }
          );
        }
      );
      ScrollAreaThumb.displayName = THUMB_NAME;
      CORNER_NAME = "ScrollAreaCorner", ScrollAreaCorner = forwardRef(
        (props, forwardedRef) => {
          let context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea), hasBothScrollbarsVisible = !!(context.scrollbarX && context.scrollbarY);
          return context.type !== "scroll" && hasBothScrollbarsVisible ? (0, import_jsx_runtime5.jsx)(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
        }
      );
      ScrollAreaCorner.displayName = CORNER_NAME;
      ScrollAreaCornerImpl = forwardRef((props, forwardedRef) => {
        let { __scopeScrollArea, ...cornerProps } = props, context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea), [width, setWidth] = useState(0), [height, setHeight] = useState(0), hasSize = !!(width && height);
        return useResizeObserver(context.scrollbarX, () => {
          let height2 = context.scrollbarX?.offsetHeight || 0;
          context.onCornerHeightChange(height2), setHeight(height2);
        }), useResizeObserver(context.scrollbarY, () => {
          let width2 = context.scrollbarY?.offsetWidth || 0;
          context.onCornerWidthChange(width2), setWidth(width2);
        }), hasSize ? (0, import_jsx_runtime5.jsx)(
          Primitive.div,
          {
            ...cornerProps,
            ref: forwardedRef,
            style: {
              width,
              height,
              position: "absolute",
              right: context.dir === "ltr" ? 0 : void 0,
              left: context.dir === "rtl" ? 0 : void 0,
              bottom: 0,
              ...props.style
            }
          }
        ) : null;
      });
      __name(toInt, "toInt");
      __name(getThumbRatio, "getThumbRatio");
      __name(getThumbSize, "getThumbSize");
      __name(getScrollPositionFromPointer, "getScrollPositionFromPointer");
      __name(getThumbOffsetFromScroll, "getThumbOffsetFromScroll");
      __name(linearScale, "linearScale");
      __name(isScrollingWithinScrollbarBounds, "isScrollingWithinScrollbarBounds");
      addUnlinkedScrollListener = __name((node, handler = () => {
      }) => {
        let prevPosition = { left: node.scrollLeft, top: node.scrollTop }, rAF = 0;
        return __name(function loop() {
          let position = { left: node.scrollLeft, top: node.scrollTop }, isHorizontalScroll = prevPosition.left !== position.left, isVerticalScroll = prevPosition.top !== position.top;
          (isHorizontalScroll || isVerticalScroll) && handler(), prevPosition = position, rAF = window.requestAnimationFrame(loop);
        }, "loop")(), () => window.cancelAnimationFrame(rAF);
      }, "addUnlinkedScrollListener");
      __name(useDebounceCallback, "useDebounceCallback");
      __name(useResizeObserver, "useResizeObserver");
      __name(getSubtree, "getSubtree");
      Root = ScrollArea, Viewport = ScrollAreaViewport, Scrollbar = ScrollAreaScrollbar, Thumb = ScrollAreaThumb, Corner = ScrollAreaCorner, ScrollAreaRoot = styled(Root)(
        ({ scrollbarsize, offset: offset3 }) => ({
          width: "100%",
          height: "100%",
          overflow: "hidden",
          "--scrollbar-size": `${scrollbarsize + offset3}px`,
          "--radix-scroll-area-thumb-width": `${scrollbarsize}px`
        })
      ), ScrollAreaViewport2 = styled(Viewport)({
        width: "100%",
        height: "100%"
      }), ScrollAreaScrollbar2 = styled(Scrollbar)(({ offset: offset3, horizontal, vertical }) => ({
        display: "flex",
        userSelect: "none",
        // ensures no selection
        touchAction: "none",
        // disable browser handling of all panning and zooming gestures on touch devices
        background: "transparent",
        transition: "all 0.2s ease-out",
        borderRadius: "var(--scrollbar-size)",
        zIndex: 1,
        '&[data-orientation="vertical"]': {
          width: "var(--scrollbar-size)",
          paddingRight: offset3,
          marginTop: offset3,
          marginBottom: horizontal === "true" && vertical === "true" ? 0 : offset3
        },
        '&[data-orientation="horizontal"]': {
          flexDirection: "column",
          height: "var(--scrollbar-size)",
          paddingBottom: offset3,
          marginLeft: offset3,
          marginRight: horizontal === "true" && vertical === "true" ? 0 : offset3
        }
      })), ScrollAreaThumb2 = styled(Thumb)(({ theme: theme3 }) => ({
        flex: 1,
        background: theme3.textMutedColor,
        opacity: 0.5,
        borderRadius: "var(--scrollbar-size)",
        position: "relative",
        transition: "opacity 0.2s ease-out",
        "&:hover": { opacity: 0.8 },
        /* increase target size for touch devices https://www.w3.org/WAI/WCAG21/Understanding/target-size.html */
        "::before": {
          content: '""',
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%,-50%)",
          width: "100%",
          height: "100%"
        }
      })), ScrollArea2 = forwardRef(
        ({ children, horizontal = !1, vertical = !1, offset: offset3 = 2, scrollbarSize = 6, className }, ref) => react_default.createElement(ScrollAreaRoot, { scrollbarsize: scrollbarSize, offset: offset3, className }, react_default.createElement(ScrollAreaViewport2, { ref }, children), horizontal && react_default.createElement(
          ScrollAreaScrollbar2,
          {
            orientation: "horizontal",
            offset: offset3,
            horizontal: horizontal.toString(),
            vertical: vertical.toString()
          },
          react_default.createElement(ScrollAreaThumb2, null)
        ), vertical && react_default.createElement(
          ScrollAreaScrollbar2,
          {
            orientation: "vertical",
            offset: offset3,
            horizontal: horizontal.toString(),
            vertical: vertical.toString()
          },
          react_default.createElement(ScrollAreaThumb2, null)
        ), horizontal && vertical && react_default.createElement(Corner, null))
      );
      ScrollArea2.displayName = "ScrollArea";
      ({ document: document2, window: globalWindow } = scope);
      __name(copyUsingClipboardAPI, "copyUsingClipboardAPI");
      __name(copyUsingWorkAround, "copyUsingWorkAround");
      __name(createCopyToClipboardFunction, "createCopyToClipboardFunction");
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-MH6AXFXB.js
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n2[r2] = t[r2]);
      }
      return n2;
    }, _extends.apply(null, arguments);
  }
  var init_chunk_MH6AXFXB = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-MH6AXFXB.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      __name(_extends, "_extends");
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-NVV6MIOE.js
  var require_memoizerific, init_chunk_NVV6MIOE = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-NVV6MIOE.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      require_memoizerific = __commonJS2({
        "../node_modules/memoizerific/memoizerific.js"(exports, module) {
          (function(f4) {
            if (typeof exports == "object" && typeof module < "u")
              module.exports = f4();
            else if (typeof define == "function" && define.amd)
              define([], f4);
            else {
              var g3;
              typeof window < "u" || typeof window < "u" ? g3 = window : typeof self < "u" ? g3 = self : g3 = this, g3.memoizerific = f4();
            }
          })(function() {
            var define2, module2, exports2;
            return __name(function e(t, n2, r2) {
              function s4(o22, u3) {
                if (!n2[o22]) {
                  if (!t[o22]) {
                    var a3 = typeof __require2 == "function" && __require2;
                    if (!u3 && a3) return a3(o22, !0);
                    if (i3) return i3(o22, !0);
                    var f4 = new Error("Cannot find module '" + o22 + "'");
                    throw f4.code = "MODULE_NOT_FOUND", f4;
                  }
                  var l2 = n2[o22] = { exports: {} };
                  t[o22][0].call(l2.exports, function(e2) {
                    var n22 = t[o22][1][e2];
                    return s4(n22 || e2);
                  }, l2, l2.exports, e, t, n2, r2);
                }
                return n2[o22].exports;
              }
              __name(s4, "s");
              for (var i3 = typeof __require2 == "function" && __require2, o2 = 0; o2 < r2.length; o2++) s4(r2[o2]);
              return s4;
            }, "e")({ 1: [function(_dereq_, module3, exports3) {
              module3.exports = function(forceSimilar) {
                if (typeof Map != "function" || forceSimilar) {
                  var Similar = _dereq_("./similar");
                  return new Similar();
                } else
                  return /* @__PURE__ */ new Map();
              };
            }, { "./similar": 2 }], 2: [function(_dereq_, module3, exports3) {
              function Similar() {
                return this.list = [], this.lastItem = void 0, this.size = 0, this;
              }
              __name(Similar, "Similar"), Similar.prototype.get = function(key) {
                var index3;
                if (this.lastItem && this.isEqual(this.lastItem.key, key))
                  return this.lastItem.val;
                if (index3 = this.indexOf(key), index3 >= 0)
                  return this.lastItem = this.list[index3], this.list[index3].val;
              }, Similar.prototype.set = function(key, val) {
                var index3;
                return this.lastItem && this.isEqual(this.lastItem.key, key) ? (this.lastItem.val = val, this) : (index3 = this.indexOf(key), index3 >= 0 ? (this.lastItem = this.list[index3], this.list[index3].val = val, this) : (this.lastItem = { key, val }, this.list.push(this.lastItem), this.size++, this));
              }, Similar.prototype.delete = function(key) {
                var index3;
                if (this.lastItem && this.isEqual(this.lastItem.key, key) && (this.lastItem = void 0), index3 = this.indexOf(key), index3 >= 0)
                  return this.size--, this.list.splice(index3, 1)[0];
              }, Similar.prototype.has = function(key) {
                var index3;
                return this.lastItem && this.isEqual(this.lastItem.key, key) ? !0 : (index3 = this.indexOf(key), index3 >= 0 ? (this.lastItem = this.list[index3], !0) : !1);
              }, Similar.prototype.forEach = function(callback, thisArg) {
                var i3;
                for (i3 = 0; i3 < this.size; i3++)
                  callback.call(thisArg || this, this.list[i3].val, this.list[i3].key, this);
              }, Similar.prototype.indexOf = function(key) {
                var i3;
                for (i3 = 0; i3 < this.size; i3++)
                  if (this.isEqual(this.list[i3].key, key))
                    return i3;
                return -1;
              }, Similar.prototype.isEqual = function(val1, val2) {
                return val1 === val2 || val1 !== val1 && val2 !== val2;
              }, module3.exports = Similar;
            }, {}], 3: [function(_dereq_, module3, exports3) {
              var MapOrSimilar = _dereq_("map-or-similar");
              module3.exports = function(limit) {
                var cache = new MapOrSimilar(!1), lru = [];
                return function(fn3) {
                  var memoizerific = __name(function() {
                    var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = !0, i3;
                    if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1)
                      throw new Error("Memoizerific functions should always be called with the same number of arguments");
                    for (i3 = 0; i3 < argsLengthMinusOne; i3++) {
                      if (lruPath[i3] = {
                        cacheItem: currentCache,
                        arg: arguments[i3]
                      }, currentCache.has(arguments[i3])) {
                        currentCache = currentCache.get(arguments[i3]);
                        continue;
                      }
                      isMemoized = !1, newMap = new MapOrSimilar(!1), currentCache.set(arguments[i3], newMap), currentCache = newMap;
                    }
                    return isMemoized && (currentCache.has(arguments[argsLengthMinusOne]) ? fnResult = currentCache.get(arguments[argsLengthMinusOne]) : isMemoized = !1), isMemoized || (fnResult = fn3.apply(null, arguments), currentCache.set(arguments[argsLengthMinusOne], fnResult)), limit > 0 && (lruPath[argsLengthMinusOne] = {
                      cacheItem: currentCache,
                      arg: arguments[argsLengthMinusOne]
                    }, isMemoized ? moveToMostRecentLru(lru, lruPath) : lru.push(lruPath), lru.length > limit && removeCachedResult(lru.shift())), memoizerific.wasMemoized = isMemoized, memoizerific.numArgs = argsLengthMinusOne + 1, fnResult;
                  }, "memoizerific");
                  return memoizerific.limit = limit, memoizerific.wasMemoized = !1, memoizerific.cache = cache, memoizerific.lru = lru, memoizerific;
                };
              };
              function moveToMostRecentLru(lru, lruPath) {
                var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i3, ii;
                for (i3 = 0; i3 < lruLen; i3++) {
                  for (isMatch = !0, ii = 0; ii < lruPathLen; ii++)
                    if (!isEqual2(lru[i3][ii].arg, lruPath[ii].arg)) {
                      isMatch = !1;
                      break;
                    }
                  if (isMatch)
                    break;
                }
                lru.push(lru.splice(i3, 1)[0]);
              }
              __name(moveToMostRecentLru, "moveToMostRecentLru");
              function removeCachedResult(removedLru) {
                var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i3;
                for (currentLru.cacheItem.delete(currentLru.arg), i3 = removedLruLen - 2; i3 >= 0 && (currentLru = removedLru[i3], tmp = currentLru.cacheItem.get(currentLru.arg), !tmp || !tmp.size); i3--)
                  currentLru.cacheItem.delete(currentLru.arg);
              }
              __name(removeCachedResult, "removeCachedResult");
              function isEqual2(val1, val2) {
                return val1 === val2 || val1 !== val1 && val2 !== val2;
              }
              __name(isEqual2, "isEqual");
            }, { "map-or-similar": 1 }] }, {}, [3])(3);
          });
        }
      });
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-BOOOPFZF.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getWindow(node) {
    if (node == null)
      return window;
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument && ownerDocument.defaultView || window;
    }
    return node;
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot > "u")
      return !1;
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  function applyStyles(_ref) {
    var state3 = _ref.state;
    Object.keys(state3.elements).forEach(function(name) {
      var style = state3.styles[name] || {}, attributes = state3.attributes[name] || {}, element = state3.elements[name];
      !isHTMLElement(element) || !getNodeName(element) || (Object.assign(element.style, style), Object.keys(attributes).forEach(function(name2) {
        var value2 = attributes[name2];
        value2 === !1 ? element.removeAttribute(name2) : element.setAttribute(name2, value2 === !0 ? "" : value2);
      }));
    });
  }
  function effect(_ref2) {
    var state3 = _ref2.state, initialStyles = {
      popper: {
        position: state3.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(state3.elements.popper.style, initialStyles.popper), state3.styles = initialStyles, state3.elements.arrow && Object.assign(state3.elements.arrow.style, initialStyles.arrow), function() {
      Object.keys(state3.elements).forEach(function(name) {
        var element = state3.elements[name], attributes = state3.attributes[name] || {}, styleProperties = Object.keys(state3.styles.hasOwnProperty(name) ? state3.styles[name] : initialStyles[name]), style = styleProperties.reduce(function(style2, property) {
          return style2[property] = "", style2;
        }, {});
        !isHTMLElement(element) || !getNodeName(element) || (Object.assign(element.style, style), Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        }));
      });
    };
  }
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  function getUAString() {
    var uaData = navigator.userAgentData;
    return uaData != null && uaData.brands && Array.isArray(uaData.brands) ? uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ") : navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
    var clientRect = element.getBoundingClientRect(), scaleX = 1, scaleY = 1;
    includeScale && isHTMLElement(element) && (scaleX = element.offsetWidth > 0 && round(clientRect.width) / element.offsetWidth || 1, scaleY = element.offsetHeight > 0 && round(clientRect.height) / element.offsetHeight || 1);
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport, addVisualOffsets = !isLayoutViewport() && isFixedStrategy, x3 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX, y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY, width = clientRect.width / scaleX, height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y3,
      right: x3 + width,
      bottom: y3 + height,
      left: x3,
      x: x3,
      y: y3
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element), width = element.offsetWidth, height = element.offsetHeight;
    return Math.abs(clientRect.width - width) <= 1 && (width = clientRect.width), Math.abs(clientRect.height - height) <= 1 && (height = clientRect.height), {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child))
      return !0;
    if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next))
          return !0;
        next = next.parentNode || next.host;
      } while (next);
    }
    return !1;
  }
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  function getParentNode(element) {
    return getNodeName(element) === "html" ? element : (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }
  function getTrueOffsetParent(element) {
    return !isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed" ? null : element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString()), isIE2 = /Trident/i.test(getUAString());
    if (isIE2 && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed")
        return null;
    }
    var currentNode = getParentNode(element);
    for (isShadowRoot(currentNode) && (currentNode = currentNode.host); isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0; ) {
      var css2 = getComputedStyle2(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none")
        return currentNode;
      currentNode = currentNode.parentNode;
    }
    return null;
  }
  function getOffsetParent(element) {
    for (var window2 = getWindow(element), offsetParent = getTrueOffsetParent(element); offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static"; )
      offsetParent = getTrueOffsetParent(offsetParent);
    return offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static") ? window2 : offsetParent || getContainingBlock(element) || window2;
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function within(min2, value2, max2) {
    return max(min2, min(value2, max2));
  }
  function withinMaxClamp(min2, value2, max2) {
    var v3 = within(min2, value2, max2);
    return v3 > max2 ? max2 : v3;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value2, keys) {
    return keys.reduce(function(hashMap, key) {
      return hashMap[key] = value2, hashMap;
    }, {});
  }
  function arrow(_ref) {
    var _state$modifiersData$, state3 = _ref.state, name = _ref.name, options2 = _ref.options, arrowElement = state3.elements.arrow, popperOffsets2 = state3.modifiersData.popperOffsets, basePlacement = getBasePlacement(state3.placement), axis = getMainAxisFromPlacement(basePlacement), isVertical = [left, right].indexOf(basePlacement) >= 0, len = isVertical ? "height" : "width";
    if (!(!arrowElement || !popperOffsets2)) {
      var paddingObject = toPaddingObject(options2.padding, state3), arrowRect = getLayoutRect(arrowElement), minProp = axis === "y" ? top : left, maxProp = axis === "y" ? bottom : right, endDiff = state3.rects.reference[len] + state3.rects.reference[axis] - popperOffsets2[axis] - state3.rects.popper[len], startDiff = popperOffsets2[axis] - state3.rects.reference[axis], arrowOffsetParent = getOffsetParent(arrowElement), clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0, centerToReference = endDiff / 2 - startDiff / 2, min2 = paddingObject[minProp], max2 = clientSize - arrowRect[len] - paddingObject[maxProp], center = clientSize / 2 - arrowRect[len] / 2 + centerToReference, offset22 = within(min2, center, max2), axisProp = axis;
      state3.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset22, _state$modifiersData$.centerOffset = offset22 - center, _state$modifiersData$);
    }
  }
  function effect2(_ref2) {
    var state3 = _ref2.state, options2 = _ref2.options, _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    arrowElement != null && (typeof arrowElement == "string" && (arrowElement = state3.elements.popper.querySelector(arrowElement), !arrowElement) || contains(state3.elements.popper, arrowElement) && (state3.elements.arrow = arrowElement));
  }
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  function roundOffsetsByDPR(_ref, win) {
    var x3 = _ref.x, y3 = _ref.y, dpr = win.devicePixelRatio || 1;
    return {
      x: round(x3 * dpr) / dpr || 0,
      y: round(y3 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2, popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed, _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y, _ref3 = typeof roundOffsets == "function" ? roundOffsets({
      x: x3,
      y: y3
    }) : {
      x: x3,
      y: y3
    };
    x3 = _ref3.x, y3 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x"), hasY = offsets.hasOwnProperty("y"), sideX = left, sideY = top, win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2), heightProp = "clientHeight", widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2) && (offsetParent = getDocumentElement(popper2), getComputedStyle2(offsetParent).position !== "static" && position === "absolute" && (heightProp = "scrollHeight", widthProp = "scrollWidth")), offsetParent = offsetParent, placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y3 -= offsetY - popperRect.height, y3 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x3 -= offsetX - popperRect.width, x3 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides), _ref4 = roundOffsets === !0 ? roundOffsetsByDPR({
      x: x3,
      y: y3
    }, getWindow(popper2)) : {
      x: x3,
      y: y3
    };
    if (x3 = _ref4.x, y3 = _ref4.y, gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y3 + "px)" : "translate3d(" + x3 + "px, " + y3 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state3 = _ref5.state, options2 = _ref5.options, _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? !0 : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? !0 : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? !0 : _options$roundOffsets, commonStyles = {
      placement: getBasePlacement(state3.placement),
      variation: getVariation(state3.placement),
      popper: state3.elements.popper,
      popperRect: state3.rects.popper,
      gpuAcceleration,
      isFixed: state3.options.strategy === "fixed"
    };
    state3.modifiersData.popperOffsets != null && (state3.styles.popper = Object.assign({}, state3.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state3.modifiersData.popperOffsets,
      position: state3.options.strategy,
      adaptive,
      roundOffsets
    })))), state3.modifiersData.arrow != null && (state3.styles.arrow = Object.assign({}, state3.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state3.modifiersData.arrow,
      position: "absolute",
      adaptive: !1,
      roundOffsets
    })))), state3.attributes.popper = Object.assign({}, state3.attributes.popper, {
      "data-popper-placement": state3.placement
    });
  }
  function effect3(_ref) {
    var state3 = _ref.state, instance = _ref.instance, options2 = _ref.options, _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? !0 : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? !0 : _options$resize, window2 = getWindow(state3.elements.popper), scrollParents = [].concat(state3.scrollParents.reference, state3.scrollParents.popper);
    return scroll && scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    }), resize && window2.addEventListener("resize", instance.update, passive), function() {
      scroll && scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      }), resize && window2.removeEventListener("resize", instance.update, passive);
    };
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }
  function getWindowScroll(node) {
    var win = getWindow(node), scrollLeft = win.pageXOffset, scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getViewportRect(element, strategy) {
    var win = getWindow(element), html = getDocumentElement(element), visualViewport = win.visualViewport, width = html.clientWidth, height = html.clientHeight, x3 = 0, y3 = 0;
    if (visualViewport) {
      width = visualViewport.width, height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      (layoutViewport || !layoutViewport && strategy === "fixed") && (x3 = visualViewport.offsetLeft, y3 = visualViewport.offsetTop);
    }
    return {
      width,
      height,
      x: x3 + getWindowScrollBarX(element),
      y: y3
    };
  }
  function getDocumentRect(element) {
    var _element$ownerDocumen, html = getDocumentElement(element), winScroll = getWindowScroll(element), body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body, width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0), height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0), x3 = -winScroll.scrollLeft + getWindowScrollBarX(element), y3 = -winScroll.scrollTop;
    return getComputedStyle2(body || html).direction === "rtl" && (x3 += max(html.clientWidth, body ? body.clientWidth : 0) - width), {
      width,
      height,
      x: x3,
      y: y3
    };
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getScrollParent(node) {
    return ["html", "body", "#document"].indexOf(getNodeName(node)) >= 0 ? node.ownerDocument.body : isHTMLElement(node) && isScrollParent(node) ? node : getScrollParent(getParentNode(node));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    list === void 0 && (list = []);
    var scrollParent = getScrollParent(element), isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body), win = getWindow(scrollParent), target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent, updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, !1, strategy === "fixed");
    return rect.top = rect.top + element.clientTop, rect.left = rect.left + element.clientLeft, rect.bottom = rect.top + element.clientHeight, rect.right = rect.left + element.clientWidth, rect.width = element.clientWidth, rect.height = element.clientHeight, rect.x = rect.left, rect.y = rect.top, rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element)), canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0, clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    return isElement(clipperElement) ? clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    }) : [];
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary), clippingParents2 = [].concat(mainClippingParents, [rootBoundary]), firstClippingParent = clippingParents2[0], clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    return clippingRect.width = clippingRect.right - clippingRect.left, clippingRect.height = clippingRect.bottom - clippingRect.top, clippingRect.x = clippingRect.left, clippingRect.y = clippingRect.top, clippingRect;
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement, basePlacement = placement ? getBasePlacement(placement) : null, variation = placement ? getVariation(placement) : null, commonX = reference2.x + reference2.width / 2 - element.width / 2, commonY = reference2.y + reference2.height / 2 - element.height / 2, offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }
  function detectOverflow(state3, options2) {
    options2 === void 0 && (options2 = {});
    var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state3.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state3.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? !1 : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding, paddingObject = mergePaddingObject(typeof padding != "number" ? padding : expandToHashMap(padding, basePlacements)), altContext = elementContext === popper ? reference : popper, popperRect = state3.rects.popper, element = state3.elements[altBoundary ? altContext : elementContext], clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state3.elements.popper), boundary, rootBoundary, strategy), referenceClientRect = getBoundingClientRect(state3.elements.reference), popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    }), popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2)), elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect, overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    }, offsetData = state3.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset22 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1, axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset22[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  function computeAutoPlacement(state3, options2) {
    options2 === void 0 && (options2 = {});
    var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP, variation = getVariation(placement), placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements, allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    allowedPlacements.length === 0 && (allowedPlacements = placements2);
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      return acc[placement2] = detectOverflow(state3, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)], acc;
    }, {});
    return Object.keys(overflows).sort(function(a3, b3) {
      return overflows[a3] - overflows[b3];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto)
      return [];
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state3 = _ref.state, options2 = _ref.options, name = _ref.name;
    if (!state3.modifiersData[name]._skip) {
      for (var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? !0 : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? !0 : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? !0 : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements, preferredPlacement = state3.options.placement, basePlacement = getBasePlacement(preferredPlacement), isBasePlacement = basePlacement === preferredPlacement, fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement)), placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state3, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []), referenceRect = state3.rects.reference, popperRect = state3.rects.popper, checksMap = /* @__PURE__ */ new Map(), makeFallbackChecks = !0, firstFittingPlacement = placements2[0], i3 = 0; i3 < placements2.length; i3++) {
        var placement = placements2[i3], _basePlacement = getBasePlacement(placement), isStartVariation = getVariation(placement) === start, isVertical = [top, bottom].indexOf(_basePlacement) >= 0, len = isVertical ? "width" : "height", overflow = detectOverflow(state3, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        }), mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        referenceRect[len] > popperRect[len] && (mainVariationSide = getOppositePlacement(mainVariationSide));
        var altVariationSide = getOppositePlacement(mainVariationSide), checks = [];
        if (checkMainAxis && checks.push(overflow[_basePlacement] <= 0), checkAltAxis && checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0), checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement, makeFallbackChecks = !1;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks)
        for (var numberOfChecks = flipVariations ? 3 : 1, _loop = __name(function(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2)
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
          });
          if (fittingPlacement)
            return firstFittingPlacement = fittingPlacement, "break";
        }, "_loop"), _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break") break;
        }
      state3.placement !== firstFittingPlacement && (state3.modifiersData[name]._skip = !0, state3.placement = firstFittingPlacement, state3.reset = !0);
    }
  }
  function getSideOffsets(overflow, rect, preventedOffsets) {
    return preventedOffsets === void 0 && (preventedOffsets = {
      x: 0,
      y: 0
    }), {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state3 = _ref.state, name = _ref.name, referenceRect = state3.rects.reference, popperRect = state3.rects.popper, preventedOffsets = state3.modifiersData.preventOverflow, referenceOverflow = detectOverflow(state3, {
      elementContext: "reference"
    }), popperAltOverflow = detectOverflow(state3, {
      altBoundary: !0
    }), referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect), popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets), isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets), hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state3.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    }, state3.attributes.popper = Object.assign({}, state3.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  function distanceAndSkiddingToXY(placement, rects, offset22) {
    var basePlacement = getBasePlacement(placement), invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1, _ref = typeof offset22 == "function" ? offset22(Object.assign({}, rects, {
      placement
    })) : offset22, skidding = _ref[0], distance = _ref[1];
    return skidding = skidding || 0, distance = (distance || 0) * invertDistance, [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state3 = _ref2.state, options2 = _ref2.options, name = _ref2.name, _options$offset = options2.offset, offset22 = _options$offset === void 0 ? [0, 0] : _options$offset, data = placements.reduce(function(acc, placement) {
      return acc[placement] = distanceAndSkiddingToXY(placement, state3.rects, offset22), acc;
    }, {}), _data$state$placement = data[state3.placement], x3 = _data$state$placement.x, y3 = _data$state$placement.y;
    state3.modifiersData.popperOffsets != null && (state3.modifiersData.popperOffsets.x += x3, state3.modifiersData.popperOffsets.y += y3), state3.modifiersData[name] = data;
  }
  function popperOffsets(_ref) {
    var state3 = _ref.state, name = _ref.name;
    state3.modifiersData[name] = computeOffsets({
      reference: state3.rects.reference,
      element: state3.rects.popper,
      strategy: "absolute",
      placement: state3.placement
    });
  }
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function preventOverflow(_ref) {
    var state3 = _ref.state, options2 = _ref.options, name = _ref.name, _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? !0 : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? !1 : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? !0 : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset, overflow = detectOverflow(state3, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    }), basePlacement = getBasePlacement(state3.placement), variation = getVariation(state3.placement), isBasePlacement = !variation, mainAxis = getMainAxisFromPlacement(basePlacement), altAxis = getAltAxis(mainAxis), popperOffsets2 = state3.modifiersData.popperOffsets, referenceRect = state3.rects.reference, popperRect = state3.rects.popper, tetherOffsetValue = typeof tetherOffset == "function" ? tetherOffset(Object.assign({}, state3.rects, {
      placement: state3.placement
    })) : tetherOffset, normalizedTetherOffsetValue = typeof tetherOffsetValue == "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue), offsetModifierState = state3.modifiersData.offset ? state3.modifiersData.offset[state3.placement] : null, data = {
      x: 0,
      y: 0
    };
    if (popperOffsets2) {
      if (checkMainAxis) {
        var _offsetModifierState$, mainSide = mainAxis === "y" ? top : left, altSide = mainAxis === "y" ? bottom : right, len = mainAxis === "y" ? "height" : "width", offset22 = popperOffsets2[mainAxis], min2 = offset22 + overflow[mainSide], max2 = offset22 - overflow[altSide], additive = tether ? -popperRect[len] / 2 : 0, minLen = variation === start ? referenceRect[len] : popperRect[len], maxLen = variation === start ? -popperRect[len] : -referenceRect[len], arrowElement = state3.elements.arrow, arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        }, arrowPaddingObject = state3.modifiersData["arrow#persistent"] ? state3.modifiersData["arrow#persistent"].padding : getFreshSideObject(), arrowPaddingMin = arrowPaddingObject[mainSide], arrowPaddingMax = arrowPaddingObject[altSide], arrowLen = within(0, referenceRect[len], arrowRect[len]), minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis, maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis, arrowOffsetParent = state3.elements.arrow && getOffsetParent(state3.elements.arrow), clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0, offsetModifierValue = (_offsetModifierState$ = offsetModifierState?.[mainAxis]) != null ? _offsetModifierState$ : 0, tetherMin = offset22 + minOffset - offsetModifierValue - clientOffset, tetherMax = offset22 + maxOffset - offsetModifierValue, preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset22, tether ? max(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset, data[mainAxis] = preventedOffset - offset22;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2, _mainSide = mainAxis === "x" ? top : left, _altSide = mainAxis === "x" ? bottom : right, _offset = popperOffsets2[altAxis], _len = altAxis === "y" ? "height" : "width", _min = _offset + overflow[_mainSide], _max = _offset - overflow[_altSide], isOriginSide = [top, left].indexOf(basePlacement) !== -1, _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState?.[altAxis]) != null ? _offsetModifierState$2 : 0, _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis, _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max, _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset, data[altAxis] = _preventedOffset - _offset;
      }
      state3.modifiersData[name] = data;
    }
  }
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node) {
    return node === getWindow(node) || !isHTMLElement(node) ? getWindowScroll(node) : getHTMLElementScroll(node);
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect(), scaleX = round(rect.width) / element.offsetWidth || 1, scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    isFixed === void 0 && (isFixed = !1);
    var isOffsetParentAnElement = isHTMLElement(offsetParent), offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent), documentElement = getDocumentElement(offsetParent), rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed), scroll = {
      scrollLeft: 0,
      scrollTop: 0
    }, offsets = {
      x: 0,
      y: 0
    };
    return (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent) ? (offsets = getBoundingClientRect(offsetParent, !0), offsets.x += offsetParent.clientLeft, offsets.y += offsetParent.clientTop) : documentElement && (offsets.x = getWindowScrollBarX(documentElement))), {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function order(modifiers) {
    var map2 = /* @__PURE__ */ new Map(), visited = /* @__PURE__ */ new Set(), result = [];
    modifiers.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          depModifier && sort(depModifier);
        }
      }), result.push(modifier);
    }
    return __name(sort, "sort"), modifiers.forEach(function(modifier) {
      visited.has(modifier.name) || sort(modifier);
    }), result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce(fn22) {
    var pending;
    return function() {
      return pending || (pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0, resolve(fn22());
        });
      })), pending;
    };
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      return merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current, merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect == "function");
    });
  }
  function popperGenerator(generatorOptions) {
    generatorOptions === void 0 && (generatorOptions = {});
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return __name(function(reference2, popper2, options2) {
      options2 === void 0 && (options2 = defaultOptions);
      var state3 = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      }, effectCleanupFns = [], isDestroyed = !1, instance = {
        state: state3,
        setOptions: __name(function(setOptionsAction) {
          var options22 = typeof setOptionsAction == "function" ? setOptionsAction(state3.options) : setOptionsAction;
          cleanupModifierEffects(), state3.options = Object.assign({}, defaultOptions, state3.options, options22), state3.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state3.options.modifiers)));
          return state3.orderedModifiers = orderedModifiers.filter(function(m3) {
            return m3.enabled;
          }), runModifierEffects(), instance.update();
        }, "setOptions"),
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: __name(function() {
          if (!isDestroyed) {
            var _state$elements = state3.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (areValidElements(reference3, popper3)) {
              state3.rects = {
                reference: getCompositeRect(reference3, getOffsetParent(popper3), state3.options.strategy === "fixed"),
                popper: getLayoutRect(popper3)
              }, state3.reset = !1, state3.placement = state3.options.placement, state3.orderedModifiers.forEach(function(modifier) {
                return state3.modifiersData[modifier.name] = Object.assign({}, modifier.data);
              });
              for (var index3 = 0; index3 < state3.orderedModifiers.length; index3++) {
                if (state3.reset === !0) {
                  state3.reset = !1, index3 = -1;
                  continue;
                }
                var _state$orderedModifie = state3.orderedModifiers[index3], fn22 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                typeof fn22 == "function" && (state3 = fn22({
                  state: state3,
                  options: _options,
                  name,
                  instance
                }) || state3);
              }
            }
          }
        }, "forceUpdate"),
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate(), resolve(state3);
          });
        }),
        destroy: __name(function() {
          cleanupModifierEffects(), isDestroyed = !0;
        }, "destroy")
      };
      if (!areValidElements(reference2, popper2))
        return instance;
      instance.setOptions(options2).then(function(state22) {
        !isDestroyed && options2.onFirstUpdate && options2.onFirstUpdate(state22);
      });
      function runModifierEffects() {
        state3.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options22 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
          if (typeof effect4 == "function") {
            var cleanupFn = effect4({
              state: state3,
              name,
              instance,
              options: options22
            }), noopFn = __name(function() {
            }, "noopFn");
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      __name(runModifierEffects, "runModifierEffects");
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn22) {
          return fn22();
        }), effectCleanupFns = [];
      }
      return __name(cleanupModifierEffects, "cleanupModifierEffects"), instance;
    }, "createPopper");
  }
  function useGetLatest(val) {
    var ref = useRef(val);
    return ref.current = val, useCallback(function() {
      return ref.current;
    }, []);
  }
  function useControlledState(_ref) {
    var initial = _ref.initial, value2 = _ref.value, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop : _ref$onChange;
    if (initial === void 0 && value2 === void 0)
      throw new TypeError('Either "value" or "initial" variable must be set. Now both are undefined');
    var _React$useState = useState(initial), state3 = _React$useState[0], setState = _React$useState[1], getLatest = useGetLatest(state3), set = useCallback(function(updater) {
      var state22 = getLatest(), updatedState = typeof updater == "function" ? updater(state22) : updater;
      typeof updatedState.persist == "function" && updatedState.persist(), setState(updatedState), typeof onChange == "function" && onChange(updatedState);
    }, [getLatest, onChange]), isControlled = value2 !== void 0;
    return [isControlled ? value2 : state3, isControlled ? onChange : set];
  }
  function generateBoundingClientRect(x3, y3) {
    return x3 === void 0 && (x3 = 0), y3 === void 0 && (y3 = 0), function() {
      return {
        width: 0,
        height: 0,
        top: y3,
        right: x3,
        bottom: y3,
        left: x3,
        x: 0,
        y: 0,
        toJSON: __name(function() {
          return null;
        }, "toJSON")
      };
    };
  }
  function usePopperTooltip(config2, popperOptions) {
    var _popperProps$state, _popperProps$state$mo, _popperProps$state$mo2;
    config2 === void 0 && (config2 = {}), popperOptions === void 0 && (popperOptions = {});
    var finalConfig = Object.keys(defaultConfig).reduce(function(config22, key) {
      var _extends2;
      return _extends({}, config22, (_extends2 = {}, _extends2[key] = config22[key] !== void 0 ? config22[key] : defaultConfig[key], _extends2));
    }, config2), defaultModifiers3 = useMemo(
      function() {
        return [{
          name: "offset",
          options: {
            offset: finalConfig.offset
          }
        }];
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      Array.isArray(finalConfig.offset) ? finalConfig.offset : []
    ), finalPopperOptions = _extends({}, popperOptions, {
      placement: popperOptions.placement || finalConfig.placement,
      modifiers: popperOptions.modifiers || defaultModifiers3
    }), _React$useState = useState(null), triggerRef = _React$useState[0], setTriggerRef = _React$useState[1], _React$useState2 = useState(null), tooltipRef = _React$useState2[0], setTooltipRef = _React$useState2[1], _useControlledState = useControlledState({
      initial: finalConfig.defaultVisible,
      value: finalConfig.visible,
      onChange: finalConfig.onVisibleChange
    }), visible = _useControlledState[0], setVisible = _useControlledState[1], timer = useRef();
    useEffect(function() {
      return function() {
        return clearTimeout(timer.current);
      };
    }, []);
    var _usePopper = usePopper(finalConfig.followCursor ? virtualElement : triggerRef, tooltipRef, finalPopperOptions), styles3 = _usePopper.styles, attributes = _usePopper.attributes, popperProps = _objectWithoutPropertiesLoose(_usePopper, _excluded), update = popperProps.update, getLatest = useGetLatest({
      visible,
      triggerRef,
      tooltipRef,
      finalConfig
    }), isTriggeredBy = useCallback(
      function(trigger) {
        return Array.isArray(finalConfig.trigger) ? finalConfig.trigger.includes(trigger) : finalConfig.trigger === trigger;
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      Array.isArray(finalConfig.trigger) ? finalConfig.trigger : [finalConfig.trigger]
    ), hideTooltip = useCallback(function() {
      clearTimeout(timer.current), timer.current = window.setTimeout(function() {
        return setVisible(!1);
      }, finalConfig.delayHide);
    }, [finalConfig.delayHide, setVisible]), showTooltip = useCallback(function() {
      clearTimeout(timer.current), timer.current = window.setTimeout(function() {
        return setVisible(!0);
      }, finalConfig.delayShow);
    }, [finalConfig.delayShow, setVisible]), toggleTooltip = useCallback(function() {
      getLatest().visible ? hideTooltip() : showTooltip();
    }, [getLatest, hideTooltip, showTooltip]);
    useEffect(function() {
      if (getLatest().finalConfig.closeOnOutsideClick) {
        var handleClickOutside = __name(function(event) {
          var _event$composedPath, _getLatest = getLatest(), tooltipRef2 = _getLatest.tooltipRef, triggerRef2 = _getLatest.triggerRef, target = (event.composedPath == null || (_event$composedPath = event.composedPath()) == null ? void 0 : _event$composedPath[0]) || event.target;
          target instanceof Node && tooltipRef2 != null && triggerRef2 != null && !tooltipRef2.contains(target) && !triggerRef2.contains(target) && hideTooltip();
        }, "handleClickOutside");
        return document.addEventListener("mousedown", handleClickOutside), function() {
          return document.removeEventListener("mousedown", handleClickOutside);
        };
      }
    }, [getLatest, hideTooltip]), useEffect(function() {
      if (!(triggerRef == null || !isTriggeredBy("click")))
        return triggerRef.addEventListener("click", toggleTooltip), function() {
          return triggerRef.removeEventListener("click", toggleTooltip);
        };
    }, [triggerRef, isTriggeredBy, toggleTooltip]), useEffect(function() {
      if (!(triggerRef == null || !isTriggeredBy("double-click")))
        return triggerRef.addEventListener("dblclick", toggleTooltip), function() {
          return triggerRef.removeEventListener("dblclick", toggleTooltip);
        };
    }, [triggerRef, isTriggeredBy, toggleTooltip]), useEffect(function() {
      if (!(triggerRef == null || !isTriggeredBy("right-click"))) {
        var preventDefaultAndToggle = __name(function(event) {
          event.preventDefault(), toggleTooltip();
        }, "preventDefaultAndToggle");
        return triggerRef.addEventListener("contextmenu", preventDefaultAndToggle), function() {
          return triggerRef.removeEventListener("contextmenu", preventDefaultAndToggle);
        };
      }
    }, [triggerRef, isTriggeredBy, toggleTooltip]), useEffect(function() {
      if (!(triggerRef == null || !isTriggeredBy("focus")))
        return triggerRef.addEventListener("focus", showTooltip), triggerRef.addEventListener("blur", hideTooltip), function() {
          triggerRef.removeEventListener("focus", showTooltip), triggerRef.removeEventListener("blur", hideTooltip);
        };
    }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]), useEffect(function() {
      if (!(triggerRef == null || !isTriggeredBy("hover")))
        return triggerRef.addEventListener("mouseenter", showTooltip), triggerRef.addEventListener("mouseleave", hideTooltip), function() {
          triggerRef.removeEventListener("mouseenter", showTooltip), triggerRef.removeEventListener("mouseleave", hideTooltip);
        };
    }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]), useEffect(function() {
      if (!(tooltipRef == null || !isTriggeredBy("hover") || !getLatest().finalConfig.interactive))
        return tooltipRef.addEventListener("mouseenter", showTooltip), tooltipRef.addEventListener("mouseleave", hideTooltip), function() {
          tooltipRef.removeEventListener("mouseenter", showTooltip), tooltipRef.removeEventListener("mouseleave", hideTooltip);
        };
    }, [tooltipRef, isTriggeredBy, showTooltip, hideTooltip, getLatest]);
    var isReferenceHidden = popperProps == null || (_popperProps$state = popperProps.state) == null || (_popperProps$state$mo = _popperProps$state.modifiersData) == null || (_popperProps$state$mo2 = _popperProps$state$mo.hide) == null ? void 0 : _popperProps$state$mo2.isReferenceHidden;
    useEffect(function() {
      finalConfig.closeOnTriggerHidden && isReferenceHidden && hideTooltip();
    }, [finalConfig.closeOnTriggerHidden, hideTooltip, isReferenceHidden]), useEffect(function() {
      if (!finalConfig.followCursor || triggerRef == null) return;
      function setMousePosition(_ref) {
        var clientX = _ref.clientX, clientY = _ref.clientY;
        virtualElement.getBoundingClientRect = generateBoundingClientRect(clientX, clientY), update?.();
      }
      return __name(setMousePosition, "setMousePosition"), triggerRef.addEventListener("mousemove", setMousePosition), function() {
        return triggerRef.removeEventListener("mousemove", setMousePosition);
      };
    }, [finalConfig.followCursor, triggerRef, update]), useEffect(function() {
      if (!(tooltipRef == null || update == null || finalConfig.mutationObserverOptions == null)) {
        var observer = new MutationObserver(update);
        return observer.observe(tooltipRef, finalConfig.mutationObserverOptions), function() {
          return observer.disconnect();
        };
      }
    }, [finalConfig.mutationObserverOptions, tooltipRef, update]);
    var getTooltipProps = __name(function(args) {
      return args === void 0 && (args = {}), _extends({}, args, {
        style: _extends({}, args.style, styles3.popper)
      }, attributes.popper, {
        "data-popper-interactive": finalConfig.interactive
      });
    }, "getTooltipProps"), getArrowProps = __name(function(args) {
      return args === void 0 && (args = {}), _extends({}, args, attributes.arrow, {
        style: _extends({}, args.style, styles3.arrow),
        "data-popper-arrow": !0
      });
    }, "getArrowProps");
    return _extends({
      getArrowProps,
      getTooltipProps,
      setTooltipRef,
      setTriggerRef,
      tooltipRef,
      triggerRef,
      visible
    }, popperProps);
  }
  var require_react_fast_compare, require_warning, ManagerReferenceNodeContext, ManagerReferenceNodeSetterContext, fromEntries, useIsomorphicLayoutEffect, top, bottom, right, left, auto, basePlacements, start, end, clippingParents, viewport, popper, reference, variationPlacements, placements, beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite, modifierPhases, applyStyles_default, max, min, round, toPaddingObject, arrow_default, unsetSides, computeStyles_default, passive, eventListeners_default, hash, hash2, flip_default, hide_default, offset_default, popperOffsets_default, preventOverflow_default, DEFAULT_OPTIONS, createPopper, defaultModifiers, createPopper2, defaultModifiers2, createPopper3, import_react_fast_compare, EMPTY_MODIFIERS, usePopper, import_warning, noop, _excluded, virtualElement, defaultConfig, import_memoizerific, match, ArrowSpacing, Arrow, Wrapper, Tooltip, document22, TargetContainer, TargetSvgContainer, WithTooltipPure, WithToolTipState, init_chunk_BOOOPFZF = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-BOOOPFZF.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_VAMFPZY3();
      init_chunk_MH6AXFXB();
      init_chunk_NVV6MIOE();
      init_chunk_MM7DTO55();
      init_react();
      init_react_dom();
      init_dist();
      init_react();
      init_react();
      init_react();
      init_react();
      init_react();
      init_react_dom();
      init_react();
      init_theming();
      init_react();
      init_theming();
      require_react_fast_compare = __commonJS2({
        "../node_modules/react-fast-compare/index.js"(exports, module) {
          var hasElementType = typeof Element < "u", hasMap = typeof Map == "function", hasSet = typeof Set == "function", hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
          function equal(a3, b3) {
            if (a3 === b3) return !0;
            if (a3 && b3 && typeof a3 == "object" && typeof b3 == "object") {
              if (a3.constructor !== b3.constructor) return !1;
              var length2, i3, keys;
              if (Array.isArray(a3)) {
                if (length2 = a3.length, length2 != b3.length) return !1;
                for (i3 = length2; i3-- !== 0; )
                  if (!equal(a3[i3], b3[i3])) return !1;
                return !0;
              }
              var it;
              if (hasMap && a3 instanceof Map && b3 instanceof Map) {
                if (a3.size !== b3.size) return !1;
                for (it = a3.entries(); !(i3 = it.next()).done; )
                  if (!b3.has(i3.value[0])) return !1;
                for (it = a3.entries(); !(i3 = it.next()).done; )
                  if (!equal(i3.value[1], b3.get(i3.value[0]))) return !1;
                return !0;
              }
              if (hasSet && a3 instanceof Set && b3 instanceof Set) {
                if (a3.size !== b3.size) return !1;
                for (it = a3.entries(); !(i3 = it.next()).done; )
                  if (!b3.has(i3.value[0])) return !1;
                return !0;
              }
              if (hasArrayBuffer && ArrayBuffer.isView(a3) && ArrayBuffer.isView(b3)) {
                if (length2 = a3.length, length2 != b3.length) return !1;
                for (i3 = length2; i3-- !== 0; )
                  if (a3[i3] !== b3[i3]) return !1;
                return !0;
              }
              if (a3.constructor === RegExp) return a3.source === b3.source && a3.flags === b3.flags;
              if (a3.valueOf !== Object.prototype.valueOf && typeof a3.valueOf == "function" && typeof b3.valueOf == "function") return a3.valueOf() === b3.valueOf();
              if (a3.toString !== Object.prototype.toString && typeof a3.toString == "function" && typeof b3.toString == "function") return a3.toString() === b3.toString();
              if (keys = Object.keys(a3), length2 = keys.length, length2 !== Object.keys(b3).length) return !1;
              for (i3 = length2; i3-- !== 0; )
                if (!Object.prototype.hasOwnProperty.call(b3, keys[i3])) return !1;
              if (hasElementType && a3 instanceof Element) return !1;
              for (i3 = length2; i3-- !== 0; )
                if (!((keys[i3] === "_owner" || keys[i3] === "__v" || keys[i3] === "__o") && a3.$$typeof) && !equal(a3[keys[i3]], b3[keys[i3]]))
                  return !1;
              return !0;
            }
            return a3 !== a3 && b3 !== b3;
          }
          __name(equal, "equal"), module.exports = __name(function(a3, b3) {
            try {
              return equal(a3, b3);
            } catch (error) {
              if ((error.message || "").match(/stack|recursion/i))
                return console.warn("react-fast-compare cannot handle circular refs"), !1;
              throw error;
            }
          }, "isEqual");
        }
      }), require_warning = __commonJS2({
        "../node_modules/warning/warning.js"(exports, module) {
          "use strict";
          var __DEV__ = !0, warning2 = __name(function() {
          }, "warning");
          __DEV__ && (printWarning = __name(function(format3, args) {
            var len = arguments.length;
            args = new Array(len > 1 ? len - 1 : 0);
            for (var key = 1; key < len; key++)
              args[key - 1] = arguments[key];
            var argIndex = 0, message = "Warning: " + format3.replace(/%s/g, function() {
              return args[argIndex++];
            });
            typeof console < "u" && console.error(message);
            try {
              throw new Error(message);
            } catch {
            }
          }, "printWarning"), warning2 = __name(function(condition, format3, args) {
            var len = arguments.length;
            args = new Array(len > 2 ? len - 2 : 0);
            for (var key = 2; key < len; key++)
              args[key - 2] = arguments[key];
            if (format3 === void 0)
              throw new Error(
                "`warning(condition, format, ...args)` requires a warning message argument"
              );
            condition || printWarning.apply(null, [format3].concat(args));
          }, "warning"));
          var printWarning;
          module.exports = warning2;
        }
      }), ManagerReferenceNodeContext = createContext(), ManagerReferenceNodeSetterContext = createContext(), fromEntries = __name(function(entries) {
        return entries.reduce(function(acc, _ref) {
          var key = _ref[0], value2 = _ref[1];
          return acc[key] = value2, acc;
        }, {});
      }, "fromEntries"), useIsomorphicLayoutEffect = typeof window < "u" && window.document && window.document.createElement ? useLayoutEffect : useEffect, top = "top", bottom = "bottom", right = "right", left = "left", auto = "auto", basePlacements = [top, bottom, right, left], start = "start", end = "end", clippingParents = "clippingParents", viewport = "viewport", popper = "popper", reference = "reference", variationPlacements = basePlacements.reduce(function(acc, placement) {
        return acc.concat([placement + "-" + start, placement + "-" + end]);
      }, []), placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
        return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
      }, []), beforeRead = "beforeRead", read = "read", afterRead = "afterRead", beforeMain = "beforeMain", main = "main", afterMain = "afterMain", beforeWrite = "beforeWrite", write = "write", afterWrite = "afterWrite", modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
      __name(getNodeName, "getNodeName");
      __name(getWindow, "getWindow");
      __name(isElement, "isElement");
      __name(isHTMLElement, "isHTMLElement");
      __name(isShadowRoot, "isShadowRoot");
      __name(applyStyles, "applyStyles");
      __name(effect, "effect");
      applyStyles_default = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: applyStyles,
        effect,
        requires: ["computeStyles"]
      };
      __name(getBasePlacement, "getBasePlacement");
      max = Math.max, min = Math.min, round = Math.round;
      __name(getUAString, "getUAString");
      __name(isLayoutViewport, "isLayoutViewport");
      __name(getBoundingClientRect, "getBoundingClientRect");
      __name(getLayoutRect, "getLayoutRect");
      __name(contains, "contains");
      __name(getComputedStyle2, "getComputedStyle");
      __name(isTableElement, "isTableElement");
      __name(getDocumentElement, "getDocumentElement");
      __name(getParentNode, "getParentNode");
      __name(getTrueOffsetParent, "getTrueOffsetParent");
      __name(getContainingBlock, "getContainingBlock");
      __name(getOffsetParent, "getOffsetParent");
      __name(getMainAxisFromPlacement, "getMainAxisFromPlacement");
      __name(within, "within");
      __name(withinMaxClamp, "withinMaxClamp");
      __name(getFreshSideObject, "getFreshSideObject");
      __name(mergePaddingObject, "mergePaddingObject");
      __name(expandToHashMap, "expandToHashMap");
      toPaddingObject = __name(function(padding, state3) {
        return padding = typeof padding == "function" ? padding(Object.assign({}, state3.rects, {
          placement: state3.placement
        })) : padding, mergePaddingObject(typeof padding != "number" ? padding : expandToHashMap(padding, basePlacements));
      }, "toPaddingObject");
      __name(arrow, "arrow");
      __name(effect2, "effect");
      arrow_default = {
        name: "arrow",
        enabled: !0,
        phase: "main",
        fn: arrow,
        effect: effect2,
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
      __name(getVariation, "getVariation");
      unsetSides = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      __name(roundOffsetsByDPR, "roundOffsetsByDPR");
      __name(mapToStyles, "mapToStyles");
      __name(computeStyles, "computeStyles");
      computeStyles_default = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: computeStyles,
        data: {}
      }, passive = {
        passive: !0
      };
      __name(effect3, "effect");
      eventListeners_default = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: __name(function() {
        }, "fn"),
        effect: effect3,
        data: {}
      }, hash = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      __name(getOppositePlacement, "getOppositePlacement");
      hash2 = {
        start: "end",
        end: "start"
      };
      __name(getOppositeVariationPlacement, "getOppositeVariationPlacement");
      __name(getWindowScroll, "getWindowScroll");
      __name(getWindowScrollBarX, "getWindowScrollBarX");
      __name(getViewportRect, "getViewportRect");
      __name(getDocumentRect, "getDocumentRect");
      __name(isScrollParent, "isScrollParent");
      __name(getScrollParent, "getScrollParent");
      __name(listScrollParents, "listScrollParents");
      __name(rectToClientRect, "rectToClientRect");
      __name(getInnerBoundingClientRect, "getInnerBoundingClientRect");
      __name(getClientRectFromMixedType, "getClientRectFromMixedType");
      __name(getClippingParents, "getClippingParents");
      __name(getClippingRect, "getClippingRect");
      __name(computeOffsets, "computeOffsets");
      __name(detectOverflow, "detectOverflow");
      __name(computeAutoPlacement, "computeAutoPlacement");
      __name(getExpandedFallbackPlacements, "getExpandedFallbackPlacements");
      __name(flip, "flip");
      flip_default = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: flip,
        requiresIfExists: ["offset"],
        data: {
          _skip: !1
        }
      };
      __name(getSideOffsets, "getSideOffsets");
      __name(isAnySideFullyClipped, "isAnySideFullyClipped");
      __name(hide, "hide");
      hide_default = {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: hide
      };
      __name(distanceAndSkiddingToXY, "distanceAndSkiddingToXY");
      __name(offset, "offset");
      offset_default = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: ["popperOffsets"],
        fn: offset
      };
      __name(popperOffsets, "popperOffsets");
      popperOffsets_default = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: popperOffsets,
        data: {}
      };
      __name(getAltAxis, "getAltAxis");
      __name(preventOverflow, "preventOverflow");
      preventOverflow_default = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: preventOverflow,
        requiresIfExists: ["offset"]
      };
      __name(getHTMLElementScroll, "getHTMLElementScroll");
      __name(getNodeScroll, "getNodeScroll");
      __name(isElementScaled, "isElementScaled");
      __name(getCompositeRect, "getCompositeRect");
      __name(order, "order");
      __name(orderModifiers, "orderModifiers");
      __name(debounce, "debounce");
      __name(mergeByName, "mergeByName");
      DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
      __name(areValidElements, "areValidElements");
      __name(popperGenerator, "popperGenerator");
      createPopper = popperGenerator(), defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default], createPopper2 = popperGenerator({
        defaultModifiers
      }), defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default], createPopper3 = popperGenerator({
        defaultModifiers: defaultModifiers2
      }), import_react_fast_compare = __toESM2(require_react_fast_compare()), EMPTY_MODIFIERS = [], usePopper = __name(function(referenceElement, popperElement, options2) {
        options2 === void 0 && (options2 = {});
        var prevOptions = useRef(null), optionsWithDefaults = {
          onFirstUpdate: options2.onFirstUpdate,
          placement: options2.placement || "bottom",
          strategy: options2.strategy || "absolute",
          modifiers: options2.modifiers || EMPTY_MODIFIERS
        }, _React$useState = useState({
          styles: {
            popper: {
              position: optionsWithDefaults.strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        }), state3 = _React$useState[0], setState = _React$useState[1], updateStateModifier = useMemo(function() {
          return {
            name: "updateState",
            enabled: !0,
            phase: "write",
            fn: __name(function(_ref) {
              var state22 = _ref.state, elements = Object.keys(state22.elements);
              flushSync(function() {
                setState({
                  styles: fromEntries(elements.map(function(element) {
                    return [element, state22.styles[element] || {}];
                  })),
                  attributes: fromEntries(elements.map(function(element) {
                    return [element, state22.attributes[element]];
                  }))
                });
              });
            }, "fn"),
            requires: ["computeStyles"]
          };
        }, []), popperOptions = useMemo(function() {
          var newOptions = {
            onFirstUpdate: optionsWithDefaults.onFirstUpdate,
            placement: optionsWithDefaults.placement,
            strategy: optionsWithDefaults.strategy,
            modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
              name: "applyStyles",
              enabled: !1
            }])
          };
          return (0, import_react_fast_compare.default)(prevOptions.current, newOptions) ? prevOptions.current || newOptions : (prevOptions.current = newOptions, newOptions);
        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]), popperInstanceRef = useRef();
        return useIsomorphicLayoutEffect(function() {
          popperInstanceRef.current && popperInstanceRef.current.setOptions(popperOptions);
        }, [popperOptions]), useIsomorphicLayoutEffect(function() {
          if (!(referenceElement == null || popperElement == null)) {
            var createPopper4 = options2.createPopper || createPopper3, popperInstance = createPopper4(referenceElement, popperElement, popperOptions);
            return popperInstanceRef.current = popperInstance, function() {
              popperInstance.destroy(), popperInstanceRef.current = null;
            };
          }
        }, [referenceElement, popperElement, options2.createPopper]), {
          state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
          styles: state3.styles,
          attributes: state3.attributes,
          update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
          forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
        };
      }, "usePopper"), import_warning = __toESM2(require_warning());
      __name(useGetLatest, "useGetLatest");
      noop = __name(function() {
      }, "noop");
      __name(useControlledState, "useControlledState");
      __name(generateBoundingClientRect, "generateBoundingClientRect");
      _excluded = ["styles", "attributes"], virtualElement = {
        getBoundingClientRect: generateBoundingClientRect()
      }, defaultConfig = {
        closeOnOutsideClick: !0,
        closeOnTriggerHidden: !1,
        defaultVisible: !1,
        delayHide: 0,
        delayShow: 0,
        followCursor: !1,
        interactive: !1,
        mutationObserverOptions: {
          attributes: !0,
          childList: !0,
          subtree: !0
        },
        offset: [0, 6],
        trigger: "hover"
      };
      __name(usePopperTooltip, "usePopperTooltip");
      import_memoizerific = __toESM2(require_memoizerific(), 1), match = (0, import_memoizerific.default)(1e3)(
        (requests, actual, value2, fallback = 0) => actual.split("-")[0] === requests ? value2 : fallback
      ), ArrowSpacing = 8, Arrow = styled.div(
        {
          position: "absolute",
          borderStyle: "solid"
        },
        ({ placement }) => {
          let x3 = 0, y3 = 0;
          switch (!0) {
            case (placement.startsWith("left") || placement.startsWith("right")): {
              y3 = 8;
              break;
            }
            case (placement.startsWith("top") || placement.startsWith("bottom")): {
              x3 = 8;
              break;
            }
            default:
          }
          return { transform: `translate3d(${x3}px, ${y3}px, 0px)` };
        },
        ({ theme: theme3, color: color2, placement }) => ({
          bottom: `${match("top", placement, `${ArrowSpacing * -1}px`, "auto")}`,
          top: `${match("bottom", placement, `${ArrowSpacing * -1}px`, "auto")}`,
          right: `${match("left", placement, `${ArrowSpacing * -1}px`, "auto")}`,
          left: `${match("right", placement, `${ArrowSpacing * -1}px`, "auto")}`,
          borderBottomWidth: `${match("top", placement, "0", ArrowSpacing)}px`,
          borderTopWidth: `${match("bottom", placement, "0", ArrowSpacing)}px`,
          borderRightWidth: `${match("left", placement, "0", ArrowSpacing)}px`,
          borderLeftWidth: `${match("right", placement, "0", ArrowSpacing)}px`,
          borderTopColor: match(
            "top",
            placement,
            theme3.color[color2] || color2 || theme3.base === "light" ? lighten(theme3.background.app) : theme3.background.app,
            "transparent"
          ),
          borderBottomColor: match(
            "bottom",
            placement,
            theme3.color[color2] || color2 || theme3.base === "light" ? lighten(theme3.background.app) : theme3.background.app,
            "transparent"
          ),
          borderLeftColor: match(
            "left",
            placement,
            theme3.color[color2] || color2 || theme3.base === "light" ? lighten(theme3.background.app) : theme3.background.app,
            "transparent"
          ),
          borderRightColor: match(
            "right",
            placement,
            theme3.color[color2] || color2 || theme3.base === "light" ? lighten(theme3.background.app) : theme3.background.app,
            "transparent"
          )
        })
      ), Wrapper = styled.div(
        ({ hidden }) => ({
          display: hidden ? "none" : "inline-block",
          zIndex: 2147483647,
          colorScheme: "light dark"
        }),
        ({ theme: theme3, color: color2, hasChrome }) => hasChrome ? {
          background: color2 && theme3.color[color2] || color2 || theme3.base === "light" ? lighten(theme3.background.app) : theme3.background.app,
          filter: `
            drop-shadow(0px 5px 5px rgba(0,0,0,0.05))
            drop-shadow(0 1px 3px rgba(0,0,0,0.1))
          `,
          borderRadius: theme3.appBorderRadius + 2,
          fontSize: theme3.typography.size.s1
        } : {}
      ), Tooltip = react_default.forwardRef(
        ({
          placement = "top",
          hasChrome = !0,
          children,
          arrowProps = {},
          tooltipRef,
          color: color2,
          withArrows,
          ...props
        }, ref) => react_default.createElement(Wrapper, { "data-testid": "tooltip", hasChrome, ref, ...props, color: color2 }, hasChrome && withArrows && react_default.createElement(Arrow, { placement, ...arrowProps, color: color2 }), children)
      );
      Tooltip.displayName = "Tooltip";
      ({ document: document22 } = scope), TargetContainer = styled.div`
  display: inline-block;
  cursor: ${(props) => props.trigger === "hover" || props.trigger?.includes("hover") ? "default" : "pointer"};
`, TargetSvgContainer = styled.g`
  cursor: ${(props) => props.trigger === "hover" || props.trigger?.includes("hover") ? "default" : "pointer"};
`, WithTooltipPure = __name(({
        svg = !1,
        trigger = "click",
        closeOnOutsideClick = !1,
        placement = "top",
        modifiers = [
          {
            name: "preventOverflow",
            options: {
              padding: 8
            }
          },
          {
            name: "offset",
            options: {
              offset: [8, 8]
            }
          },
          {
            name: "arrow",
            options: {
              padding: 8
            }
          }
        ],
        hasChrome = !0,
        defaultVisible = !1,
        withArrows,
        offset: offset22,
        tooltip,
        children,
        closeOnTriggerHidden,
        mutationObserverOptions,
        delayHide = trigger === "hover" ? 200 : 0,
        visible,
        interactive,
        delayShow = trigger === "hover" ? 400 : 0,
        strategy,
        followCursor,
        onVisibleChange,
        portalContainer,
        ...props
      }) => {
        let Container4 = svg ? TargetSvgContainer : TargetContainer, {
          getArrowProps,
          getTooltipProps,
          setTooltipRef,
          setTriggerRef,
          visible: isVisible,
          state: state3
        } = usePopperTooltip(
          {
            trigger,
            placement,
            defaultVisible,
            delayHide,
            interactive,
            closeOnOutsideClick,
            closeOnTriggerHidden,
            onVisibleChange,
            delayShow,
            followCursor,
            mutationObserverOptions,
            visible,
            offset: offset22
          },
          {
            modifiers,
            strategy
          }
        ), portalTarget = (typeof portalContainer == "string" ? document22.querySelector(portalContainer) : portalContainer) || document22.body, tooltipComponent = isVisible ? react_default.createElement(
          Tooltip,
          {
            placement: state3?.placement,
            ref: setTooltipRef,
            hasChrome,
            arrowProps: getArrowProps(),
            withArrows,
            ...getTooltipProps()
          },
          typeof tooltip == "function" ? tooltip({ onHide: __name(() => onVisibleChange(!1), "onHide") }) : tooltip
        ) : null;
        return react_default.createElement(react_default.Fragment, null, react_default.createElement(Container4, { trigger, ref: setTriggerRef, ...props }, children), isVisible && react_dom_default.createPortal(tooltipComponent, portalTarget));
      }, "WithTooltipPure"), WithToolTipState = __name(({
        startOpen = !1,
        onVisibleChange: onChange,
        ...rest
      }) => {
        let [tooltipShown, setTooltipShown] = useState(startOpen), onVisibilityChange = useCallback(
          (visibility) => {
            onChange && onChange(visibility) === !1 || setTooltipShown(visibility);
          },
          [onChange]
        );
        return useEffect(() => {
          let hide2 = __name(() => onVisibilityChange(!1), "hide"), handleKeyDown = __name((e) => {
            e.key === "Escape" && hide2();
          }, "handleKeyDown");
          document22.addEventListener("keydown", handleKeyDown, !1);
          let iframes = Array.from(document22.getElementsByTagName("iframe")), unbinders = [];
          return iframes.forEach((iframe) => {
            let bind = __name(() => {
              try {
                iframe.contentWindow.document && (iframe.contentWindow.document.addEventListener("click", hide2), unbinders.push(() => {
                  try {
                    iframe.contentWindow.document.removeEventListener("click", hide2);
                  } catch {
                  }
                }));
              } catch {
              }
            }, "bind");
            bind(), iframe.addEventListener("load", bind), unbinders.push(() => {
              iframe.removeEventListener("load", bind);
            });
          }), () => {
            document22.removeEventListener("keydown", handleKeyDown), unbinders.forEach((unbind) => {
              unbind();
            });
          };
        }), react_default.createElement(WithTooltipPure, { ...rest, visible: tooltipShown, onVisibleChange: onVisibilityChange });
      }, "WithToolTipState");
    }
  });

  // global-externals:@storybook/icons
  var icons_default, AccessibilityAltIcon, AccessibilityIcon, AccessibilityIgnoredIcon, AddIcon, AdminIcon, AlertAltIcon, AlertIcon, AlignLeftIcon, AlignRightIcon, AppleIcon, ArrowBottomLeftIcon, ArrowBottomRightIcon, ArrowDownIcon, ArrowLeftIcon, ArrowRightIcon, ArrowSolidDownIcon, ArrowSolidLeftIcon, ArrowSolidRightIcon, ArrowSolidUpIcon, ArrowTopLeftIcon, ArrowTopRightIcon, ArrowUpIcon, AzureDevOpsIcon, BackIcon, BasketIcon, BatchAcceptIcon, BatchDenyIcon, BeakerIcon, BellIcon, BitbucketIcon, BoldIcon, BookIcon, BookmarkHollowIcon, BookmarkIcon, BottomBarIcon, BottomBarToggleIcon, BoxIcon, BranchIcon, BrowserIcon, BugIcon, ButtonIcon, CPUIcon, CalendarIcon, CameraIcon, CameraStabilizeIcon, CategoryIcon, CertificateIcon, ChangedIcon, ChatIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronSmallDownIcon, ChevronSmallLeftIcon, ChevronSmallRightIcon, ChevronSmallUpIcon, ChevronUpIcon, ChromaticIcon, ChromeIcon, CircleHollowIcon, CircleIcon, ClearIcon, CloseAltIcon, CloseIcon, CloudHollowIcon, CloudIcon, CogIcon, CollapseIcon, CommandIcon, CommentAddIcon, CommentIcon, CommentsIcon, CommitIcon, CompassIcon, ComponentDrivenIcon, ComponentIcon, ContrastIcon, ContrastIgnoredIcon, ControlsIcon, CopyIcon, CreditIcon, CrossIcon, DashboardIcon, DatabaseIcon, DeleteIcon, DiamondIcon, DirectionIcon, DiscordIcon, DocChartIcon, DocListIcon, DocumentIcon, DownloadIcon, DragIcon, EditIcon, EditorIcon, EllipsisIcon, EmailIcon, ExpandAltIcon, ExpandIcon, EyeCloseIcon, EyeIcon, FaceHappyIcon, FaceNeutralIcon, FaceSadIcon, FacebookIcon, FailedIcon, FastForwardIcon, FigmaIcon, FilterIcon, FlagIcon, FolderIcon, FormIcon, GDriveIcon, GiftIcon, GithubIcon, GitlabIcon, GlobeIcon, GoogleIcon, GraphBarIcon, GraphLineIcon, GraphqlIcon, GridAltIcon, GridIcon, GrowIcon, HeartHollowIcon, HeartIcon, HomeIcon, HourglassIcon, InfoIcon, ItalicIcon, JumpToIcon, KeyIcon, LightningIcon, LightningOffIcon, LinkBrokenIcon, LinkIcon, LinkedinIcon, LinuxIcon, ListOrderedIcon, ListUnorderedIcon, LocationIcon, LockIcon, MarkdownIcon, MarkupIcon, MediumIcon, MemoryIcon, MenuIcon, MergeIcon, MirrorIcon, MobileIcon, MoonIcon, NutIcon, OutboxIcon, OutlineIcon, PaintBrushAltIcon, PaintBrushIcon, PaperClipIcon, ParagraphIcon, PassedIcon, PhoneIcon, PhotoDragIcon, PhotoIcon, PhotoStabilizeIcon, PinAltIcon, PinIcon, PlayAllHollowIcon, PlayBackIcon, PlayHollowIcon, PlayIcon, PlayNextIcon, PlusIcon, PointerDefaultIcon, PointerHandIcon, PowerIcon, PrintIcon, ProceedIcon, ProfileIcon, PullRequestIcon, QuestionIcon, RSSIcon, RedirectIcon, ReduxIcon, RefreshIcon, ReplyIcon, RepoIcon, RequestChangeIcon, RewindIcon, RulerIcon, SaveIcon, SearchIcon, ShareAltIcon, ShareIcon, ShieldIcon, SideBySideIcon, SidebarAltIcon, SidebarAltToggleIcon, SidebarIcon, SidebarToggleIcon, SortDownIcon, SortUpIcon, SpeakerIcon, StackedIcon, StarHollowIcon, StarIcon, StatusFailIcon, StatusIcon, StatusPassIcon, StatusWarnIcon, StickerIcon, StopAltHollowIcon, StopAltIcon, StopIcon, StorybookIcon, StructureIcon, SubtractIcon, SunIcon, SupportIcon, SweepIcon, SwitchAltIcon, SyncIcon, TabletIcon, ThumbsUpIcon, TimeIcon, TimerIcon, TransferIcon, TrashIcon, TwitterIcon, TypeIcon, UbuntuIcon, UndoIcon, UnfoldIcon, UnlockIcon, UnpinIcon, UploadIcon, UserAddIcon, UserAltIcon, UserIcon, UsersIcon, VSCodeIcon, VerifiedIcon, VideoIcon, WandIcon, WatchIcon, WindowsIcon, WrenchIcon, XIcon, YoutubeIcon, ZoomIcon, ZoomOutIcon, ZoomResetIcon, iconList, init_icons = __esm({
    "global-externals:@storybook/icons"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      icons_default = __STORYBOOK_ICONS__, { AccessibilityAltIcon, AccessibilityIcon, AccessibilityIgnoredIcon, AddIcon, AdminIcon, AlertAltIcon, AlertIcon, AlignLeftIcon, AlignRightIcon, AppleIcon, ArrowBottomLeftIcon, ArrowBottomRightIcon, ArrowDownIcon, ArrowLeftIcon, ArrowRightIcon, ArrowSolidDownIcon, ArrowSolidLeftIcon, ArrowSolidRightIcon, ArrowSolidUpIcon, ArrowTopLeftIcon, ArrowTopRightIcon, ArrowUpIcon, AzureDevOpsIcon, BackIcon, BasketIcon, BatchAcceptIcon, BatchDenyIcon, BeakerIcon, BellIcon, BitbucketIcon, BoldIcon, BookIcon, BookmarkHollowIcon, BookmarkIcon, BottomBarIcon, BottomBarToggleIcon, BoxIcon, BranchIcon, BrowserIcon, BugIcon, ButtonIcon, CPUIcon, CalendarIcon, CameraIcon, CameraStabilizeIcon, CategoryIcon, CertificateIcon, ChangedIcon, ChatIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronSmallDownIcon, ChevronSmallLeftIcon, ChevronSmallRightIcon, ChevronSmallUpIcon, ChevronUpIcon, ChromaticIcon, ChromeIcon, CircleHollowIcon, CircleIcon, ClearIcon, CloseAltIcon, CloseIcon, CloudHollowIcon, CloudIcon, CogIcon, CollapseIcon, CommandIcon, CommentAddIcon, CommentIcon, CommentsIcon, CommitIcon, CompassIcon, ComponentDrivenIcon, ComponentIcon, ContrastIcon, ContrastIgnoredIcon, ControlsIcon, CopyIcon, CreditIcon, CrossIcon, DashboardIcon, DatabaseIcon, DeleteIcon, DiamondIcon, DirectionIcon, DiscordIcon, DocChartIcon, DocListIcon, DocumentIcon, DownloadIcon, DragIcon, EditIcon, EditorIcon, EllipsisIcon, EmailIcon, ExpandAltIcon, ExpandIcon, EyeCloseIcon, EyeIcon, FaceHappyIcon, FaceNeutralIcon, FaceSadIcon, FacebookIcon, FailedIcon, FastForwardIcon, FigmaIcon, FilterIcon, FlagIcon, FolderIcon, FormIcon, GDriveIcon, GiftIcon, GithubIcon, GitlabIcon, GlobeIcon, GoogleIcon, GraphBarIcon, GraphLineIcon, GraphqlIcon, GridAltIcon, GridIcon, GrowIcon, HeartHollowIcon, HeartIcon, HomeIcon, HourglassIcon, InfoIcon, ItalicIcon, JumpToIcon, KeyIcon, LightningIcon, LightningOffIcon, LinkBrokenIcon, LinkIcon, LinkedinIcon, LinuxIcon, ListOrderedIcon, ListUnorderedIcon, LocationIcon, LockIcon, MarkdownIcon, MarkupIcon, MediumIcon, MemoryIcon, MenuIcon, MergeIcon, MirrorIcon, MobileIcon, MoonIcon, NutIcon, OutboxIcon, OutlineIcon, PaintBrushAltIcon, PaintBrushIcon, PaperClipIcon, ParagraphIcon, PassedIcon, PhoneIcon, PhotoDragIcon, PhotoIcon, PhotoStabilizeIcon, PinAltIcon, PinIcon, PlayAllHollowIcon, PlayBackIcon, PlayHollowIcon, PlayIcon, PlayNextIcon, PlusIcon, PointerDefaultIcon, PointerHandIcon, PowerIcon, PrintIcon, ProceedIcon, ProfileIcon, PullRequestIcon, QuestionIcon, RSSIcon, RedirectIcon, ReduxIcon, RefreshIcon, ReplyIcon, RepoIcon, RequestChangeIcon, RewindIcon, RulerIcon, SaveIcon, SearchIcon, ShareAltIcon, ShareIcon, ShieldIcon, SideBySideIcon, SidebarAltIcon, SidebarAltToggleIcon, SidebarIcon, SidebarToggleIcon, SortDownIcon, SortUpIcon, SpeakerIcon, StackedIcon, StarHollowIcon, StarIcon, StatusFailIcon, StatusIcon, StatusPassIcon, StatusWarnIcon, StickerIcon, StopAltHollowIcon, StopAltIcon, StopIcon, StorybookIcon, StructureIcon, SubtractIcon, SunIcon, SupportIcon, SweepIcon, SwitchAltIcon, SyncIcon, TabletIcon, ThumbsUpIcon, TimeIcon, TimerIcon, TransferIcon, TrashIcon, TwitterIcon, TypeIcon, UbuntuIcon, UndoIcon, UnfoldIcon, UnlockIcon, UnpinIcon, UploadIcon, UserAddIcon, UserAltIcon, UserIcon, UsersIcon, VSCodeIcon, VerifiedIcon, VideoIcon, WandIcon, WatchIcon, WindowsIcon, WrenchIcon, XIcon, YoutubeIcon, ZoomIcon, ZoomOutIcon, ZoomResetIcon, iconList } = __STORYBOOK_ICONS__;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-OPCDBBL3.js
  function dedent(templ) {
    for (var values = [], _i = 1; _i < arguments.length; _i++)
      values[_i - 1] = arguments[_i];
    var strings = Array.from(typeof templ == "string" ? [templ] : templ);
    strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var indentLengths = strings.reduce(function(arr, str2) {
      var matches3 = str2.match(/\n([\t ]+|(?!\s).)/g);
      return matches3 ? arr.concat(matches3.map(function(match2) {
        var _a, _b;
        return (_b = (_a = match2.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      })) : arr;
    }, []);
    if (indentLengths.length) {
      var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
      strings = strings.map(function(str2) {
        return str2.replace(pattern_1, `
`);
      });
    }
    strings[0] = strings[0].replace(/^\r?\n/, "");
    var string = strings[0];
    return values.forEach(function(value2, i3) {
      var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value2;
      typeof value2 == "string" && value2.includes(`
`) && (indentedValue = String(value2).split(`
`).map(function(str2, i22) {
        return i22 === 0 ? str2 : "" + endentation + str2;
      }).join(`
`)), string += indentedValue + strings[i3 + 1];
    }), string;
  }
  var init_chunk_OPCDBBL3 = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-OPCDBBL3.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      __name(dedent, "dedent");
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-AB7OOPUX.js
  function noop3() {
  }
  var init_chunk_AB7OOPUX = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-AB7OOPUX.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      __name(noop3, "noop");
    }
  });

  // global-externals:storybook/internal/client-logger
  var client_logger_default, deprecate, logger, once, pretty, init_client_logger = __esm({
    "global-externals:storybook/internal/client-logger"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      client_logger_default = __STORYBOOK_CLIENT_LOGGER__, { deprecate, logger, once, pretty } = __STORYBOOK_CLIENT_LOGGER__;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/syntaxhighlighter-DK2ODWXH.js
  var syntaxhighlighter_DK2ODWXH_exports = {};
  __export(syntaxhighlighter_DK2ODWXH_exports, {
    SyntaxHighlighter: () => SyntaxHighlighter2,
    default: () => syntaxhighlighter_default,
    supportedLanguages: () => supportedLanguages
  });
  function ownKeys(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r2 && (o2 = o2.filter(function(r22) {
        return Object.getOwnPropertyDescriptor(e, r22).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = arguments[r2] != null ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t), !0).forEach(function(r22) {
        _defineProperty(e, r22, t[r22]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r22) {
        Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t, r22));
      });
    }
    return e;
  }
  function powerSetPermutations(arr) {
    var arrLength = arr.length;
    if (arrLength === 0 || arrLength === 1) return arr;
    if (arrLength === 2)
      return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
    if (arrLength === 3)
      return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
    if (arrLength >= 4)
      return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  function getClassNameCombinations(classNames) {
    if (classNames.length === 0 || classNames.length === 1) return classNames;
    var key = classNames.join(".");
    return classNameCombinations[key] || (classNameCombinations[key] = powerSetPermutations(classNames)), classNameCombinations[key];
  }
  function createStyleObject(classNames) {
    var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, stylesheet = arguments.length > 2 ? arguments[2] : void 0, nonTokenClassNames = classNames.filter(function(className) {
      return className !== "token";
    }), classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
    return classNamesCombinations.reduce(function(styleObject, className) {
      return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
    }, elementStyle);
  }
  function createClassNameString(classNames) {
    return classNames.join(" ");
  }
  function createChildren(stylesheet, useInlineStyles) {
    var childrenCount = 0;
    return function(children) {
      return childrenCount += 1, children.map(function(child, i3) {
        return createElement3({
          node: child,
          stylesheet,
          useInlineStyles,
          key: "code-segment-".concat(childrenCount, "-").concat(i3)
        });
      });
    };
  }
  function createElement3(_ref) {
    var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key, properties = node.properties, type = node.type, TagName = node.tagName, value2 = node.value;
    if (type === "text")
      return value2;
    if (TagName) {
      var childrenCreator = createChildren(stylesheet, useInlineStyles), props;
      if (!useInlineStyles)
        props = _objectSpread(_objectSpread({}, properties), {}, {
          className: createClassNameString(properties.className)
        });
      else {
        var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes2, selector) {
          return selector.split(".").forEach(function(className2) {
            classes2.includes(className2) || classes2.push(className2);
          }), classes2;
        }, []), startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [], className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
          return !allStylesheetSelectors.includes(className2);
        }));
        props = _objectSpread(_objectSpread({}, properties), {}, {
          className: createClassNameString(className) || void 0,
          style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
        });
      }
      var children = childrenCreator(node.children);
      return react_default.createElement(TagName, _extends({
        key
      }, props), children);
    }
  }
  function _arrayLikeToArray(r2, a3) {
    (a3 == null || a3 > r2.length) && (a3 = r2.length);
    for (var e = 0, n2 = Array(a3); e < a3; e++) n2[e] = r2[e];
    return n2;
  }
  function _arrayWithoutHoles(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray(r2);
  }
  function _iterableToArray(r2) {
    if (typeof Symbol < "u" && r2[Symbol.iterator] != null || r2["@@iterator"] != null) return Array.from(r2);
  }
  function _unsupportedIterableToArray(r2, a3) {
    if (r2) {
      if (typeof r2 == "string") return _arrayLikeToArray(r2, a3);
      var t = {}.toString.call(r2).slice(8, -1);
      return t === "Object" && r2.constructor && (t = r2.constructor.name), t === "Map" || t === "Set" ? Array.from(r2) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a3) : void 0;
    }
  }
  function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _toConsumableArray(r2) {
    return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
  }
  function ownKeys2(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r2 && (o2 = o2.filter(function(r22) {
        return Object.getOwnPropertyDescriptor(e, r22).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = arguments[r2] != null ? arguments[r2] : {};
      r2 % 2 ? ownKeys2(Object(t), !0).forEach(function(r22) {
        _defineProperty(e, r22, t[r22]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r22) {
        Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t, r22));
      });
    }
    return e;
  }
  function getNewLines(str2) {
    return str2.match(newLineRegex);
  }
  function getAllLineNumbers(_ref) {
    var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
    return lines.map(function(_3, i3) {
      var number = i3 + startingLineNumber;
      return react_default.createElement("span", {
        key: "line-".concat(i3),
        className: "react-syntax-highlighter-line-number",
        style: typeof style == "function" ? style(number) : style
      }, "".concat(number, `
`));
    });
  }
  function AllLineNumbers(_ref2) {
    var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
      float: "left",
      paddingRight: "10px"
    } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
    return react_default.createElement("code", {
      style: Object.assign({}, codeStyle, containerStyle)
    }, getAllLineNumbers({
      lines: codeString.replace(/\n$/, "").split(`
`),
      style: numberStyle,
      startingLineNumber
    }));
  }
  function getEmWidthOfNumber(num) {
    return "".concat(num.toString().length, ".25em");
  }
  function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
    return {
      type: "element",
      tagName: "span",
      properties: {
        key: "line-number--".concat(lineNumber),
        className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
        style: inlineLineNumberStyle
      },
      children: [{
        type: "text",
        value: lineNumber
      }]
    };
  }
  function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
    var defaultLineNumberStyle = {
      display: "inline-block",
      minWidth: getEmWidthOfNumber(largestLineNumber),
      paddingRight: "1em",
      textAlign: "right",
      userSelect: "none"
    }, customLineNumberStyle = typeof lineNumberStyle == "function" ? lineNumberStyle(lineNumber) : lineNumberStyle, assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
    return assembledStyle;
  }
  function createLineElement(_ref3) {
    var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines, _ref3$wrapLines = _ref3.wrapLines, wrapLines = _ref3$wrapLines === void 0 ? !1 : _ref3$wrapLines, properties = wrapLines ? _objectSpread2({}, typeof lineProps == "function" ? lineProps(lineNumber) : lineProps) : {};
    if (properties.className = properties.className ? [].concat(_toConsumableArray(properties.className.trim().split(/\s+/)), _toConsumableArray(className)) : className, lineNumber && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
      children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
    }
    return wrapLongLines & showLineNumbers && (properties.style = _objectSpread2({
      display: "flex"
    }, properties.style)), {
      type: "element",
      tagName: "span",
      properties,
      children
    };
  }
  function flattenCodeTree(tree) {
    for (var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], i3 = 0; i3 < tree.length; i3++) {
      var node = tree[i3];
      if (node.type === "text")
        newTree.push(createLineElement({
          children: [node],
          className: _toConsumableArray(new Set(className))
        }));
      else if (node.children) {
        var classNames = className.concat(node.properties.className);
        flattenCodeTree(node.children, classNames).forEach(function(i22) {
          return newTree.push(i22);
        });
      }
    }
    return newTree;
  }
  function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
    var _ref4, tree = flattenCodeTree(codeTree.value), newTree = [], lastLineBreakIndex = -1, index3 = 0;
    function createWrappedLine(children2, lineNumber2) {
      var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      return createLineElement({
        children: children2,
        lineNumber: lineNumber2,
        lineNumberStyle,
        largestLineNumber,
        showInlineLineNumbers,
        lineProps,
        className,
        showLineNumbers,
        wrapLongLines,
        wrapLines
      });
    }
    __name(createWrappedLine, "createWrappedLine");
    function createUnwrappedLine(children2, lineNumber2) {
      if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
        var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
        children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
      }
      return children2;
    }
    __name(createUnwrappedLine, "createUnwrappedLine");
    function createLine(children2, lineNumber2) {
      var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
    }
    __name(createLine, "createLine");
    for (var _loop = __name(function() {
      var node = tree[index3], value2 = node.children[0].value, newLines = getNewLines(value2);
      if (newLines) {
        var splitValue = value2.split(`
`);
        splitValue.forEach(function(text, i3) {
          var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber, newChild = {
            type: "text",
            value: "".concat(text, `
`)
          };
          if (i3 === 0) {
            var _children = tree.slice(lastLineBreakIndex + 1, index3).concat(createLineElement({
              children: [newChild],
              className: node.properties.className
            })), _line = createLine(_children, lineNumber2);
            newTree.push(_line);
          } else if (i3 === splitValue.length - 1) {
            var stringChild = tree[index3 + 1] && tree[index3 + 1].children && tree[index3 + 1].children[0], lastLineInPreviousSpan = {
              type: "text",
              value: "".concat(text)
            };
            if (stringChild) {
              var newElem = createLineElement({
                children: [lastLineInPreviousSpan],
                className: node.properties.className
              });
              tree.splice(index3 + 1, 0, newElem);
            } else {
              var _children2 = [lastLineInPreviousSpan], _line2 = createLine(_children2, lineNumber2, node.properties.className);
              newTree.push(_line2);
            }
          } else {
            var _children3 = [newChild], _line3 = createLine(_children3, lineNumber2, node.properties.className);
            newTree.push(_line3);
          }
        }), lastLineBreakIndex = index3;
      }
      index3++;
    }, "_loop"); index3 < tree.length; )
      _loop();
    if (lastLineBreakIndex !== tree.length - 1) {
      var children = tree.slice(lastLineBreakIndex + 1, tree.length);
      if (children && children.length) {
        var lineNumber = showLineNumbers && newTree.length + startingLineNumber, line = createLine(children, lineNumber);
        newTree.push(line);
      }
    }
    return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
  }
  function defaultRenderer(_ref5) {
    var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
    return rows.map(function(node, i3) {
      return createElement3({
        node,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(i3)
      });
    });
  }
  function isHighlightJs(astGenerator) {
    return astGenerator && typeof astGenerator.highlightAuto < "u";
  }
  function getCodeTree(_ref6) {
    var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
    if (isHighlightJs(astGenerator)) {
      var hasLanguage = checkForListedLanguage_default(astGenerator, language);
      return language === "text" ? {
        value: defaultCodeValue,
        language: "text"
      } : hasLanguage ? astGenerator.highlight(language, code) : astGenerator.highlightAuto(code);
    }
    try {
      return language && language !== "text" ? {
        value: astGenerator.highlight(code, language)
      } : {
        value: defaultCodeValue
      };
    } catch {
      return {
        value: defaultCodeValue
      };
    }
  }
  function highlight_default(defaultAstGenerator, defaultStyle) {
    return __name(function(_ref7) {
      var _code$match$length, _code$match, language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
        className: language ? "language-".concat(language) : void 0,
        style: _objectSpread2(_objectSpread2({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
      } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? !0 : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? !1 : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? !0 : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? !1 : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties(_ref7, _excluded2);
      astGenerator = astGenerator || defaultAstGenerator;
      var allLineNumbers = showLineNumbers ? react_default.createElement(AllLineNumbers, {
        containerStyle: lineNumberContainerStyle,
        codeStyle: codeTagProps.style || {},
        numberStyle: lineNumberStyle,
        startingLineNumber,
        codeString: code
      }) : null, defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
        backgroundColor: "#fff"
      }, generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs", preProps = useInlineStyles ? Object.assign({}, rest, {
        style: Object.assign({}, defaultPreStyle, customStyle)
      }) : Object.assign({}, rest, {
        className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
        style: Object.assign({}, customStyle)
      });
      if (wrapLongLines ? codeTagProps.style = _objectSpread2({
        whiteSpace: "pre-wrap"
      }, codeTagProps.style) : codeTagProps.style = _objectSpread2({
        whiteSpace: "pre"
      }, codeTagProps.style), !astGenerator)
        return react_default.createElement(PreTag, preProps, allLineNumbers, react_default.createElement(CodeTag, codeTagProps, code));
      (wrapLines === void 0 && renderer || wrapLongLines) && (wrapLines = !0), renderer = renderer || defaultRenderer;
      var defaultCodeValue = [{
        type: "text",
        value: code
      }], codeTree = getCodeTree({
        astGenerator,
        language,
        code,
        defaultCodeValue
      });
      codeTree.language === null && (codeTree.value = defaultCodeValue);
      var lineBreakCount = (_code$match$length = (_code$match = code.match(/\n/g)) === null || _code$match === void 0 ? void 0 : _code$match.length) !== null && _code$match$length !== void 0 ? _code$match$length : 0, largestLineNumber = startingLineNumber + lineBreakCount, rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
      return react_default.createElement(PreTag, preProps, react_default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
        rows,
        stylesheet: style,
        useInlineStyles
      })));
    }, "SyntaxHighlighter");
  }
  var require_bash, require_css, require_graphql, require_js_extras, require_json, require_jsx, require_markdown, require_markup, require_typescript, require_tsx, require_yaml, require_immutable, require_schema, require_merge, require_normalize, require_info, require_types, require_defined_info, require_create, require_xlink, require_xml2, require_case_sensitive_transform, require_case_insensitive_transform, require_xmlns, require_aria, require_html, require_html2, require_find, require_hast_util_parse_selector, require_space_separated_tokens, require_comma_separated_tokens, require_factory, require_html3, require_hastscript, require_character_entities_legacy, require_character_reference_invalid, require_is_decimal, require_is_hexadecimal, require_is_alphabetical, require_is_alphanumerical, require_decode_entity_browser, require_parse_entities, require_prism_core, require_clike, require_javascript, require_core, import_memoizerific4, classNameCombinations, import_bash, bash_default, import_css, css_default, import_graphql, graphql_default, import_js_extras, js_extras_default, import_json, json_default, import_jsx, jsx_default, import_markdown, markdown_default, import_markup, markup_default, import_tsx, tsx_default, import_typescript, typescript_default, import_yaml, yaml_default, checkForListedLanguage_default, _excluded2, newLineRegex, import_core, SyntaxHighlighter, prism_light_default, globalWindow3, supportedLanguages, themedSyntax, copyToClipboard, Wrapper2, UnstyledScroller, Scroller, Pre, Code, processLineNumber, defaultRenderer2, wrapRenderer, SyntaxHighlighter2, syntaxhighlighter_default, init_syntaxhighlighter_DK2ODWXH = __esm({
    "node_modules/storybook/dist/_browser-chunks/syntaxhighlighter-DK2ODWXH.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_L2D73C6Z();
      init_chunk_RNE2IUTB();
      init_chunk_VAMFPZY3();
      init_chunk_MH6AXFXB();
      init_chunk_NVV6MIOE();
      init_chunk_MM7DTO55();
      init_react();
      init_client_logger();
      init_dist();
      init_react();
      init_react();
      init_theming();
      require_bash = __commonJS2({
        "../node_modules/refractor/lang/bash.js"(exports, module) {
          "use strict";
          module.exports = bash2, bash2.displayName = "bash", bash2.aliases = ["shell"];
          function bash2(Prism) {
            (function(Prism2) {
              var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", commandAfterHeredoc = {
                pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
                lookbehind: !0,
                alias: "punctuation",
                // this looks reasonably well in all themes
                inside: null
                // see below
              }, insideString = {
                bash: commandAfterHeredoc,
                environment: {
                  pattern: RegExp("\\$" + envVars),
                  alias: "constant"
                },
                variable: [
                  // [0]: Arithmetic Environment
                  {
                    pattern: /\$?\(\([\s\S]+?\)\)/,
                    greedy: !0,
                    inside: {
                      // If there is a $ sign at the beginning highlight $(( and )) as variable
                      variable: [
                        {
                          pattern: /(^\$\(\([\s\S]+)\)\)/,
                          lookbehind: !0
                        },
                        /^\$\(\(/
                      ],
                      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                      // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                      operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                      // If there is no $ sign at the beginning highlight (( and )) as punctuation
                      punctuation: /\(\(?|\)\)?|,|;/
                    }
                  },
                  // [1]: Command Substitution
                  {
                    pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
                    greedy: !0,
                    inside: {
                      variable: /^\$\(|^`|\)$|`$/
                    }
                  },
                  // [2]: Brace expansion
                  {
                    pattern: /\$\{[^}]+\}/,
                    greedy: !0,
                    inside: {
                      operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                      punctuation: /[\[\]]/,
                      environment: {
                        pattern: RegExp("(\\{)" + envVars),
                        lookbehind: !0,
                        alias: "constant"
                      }
                    }
                  },
                  /\$(?:\w+|[#?*!@$])/
                ],
                // Escape sequences from echo and printf's manuals, and escaped quotes.
                entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
              };
              Prism2.languages.bash = {
                shebang: {
                  pattern: /^#!\s*\/.*/,
                  alias: "important"
                },
                comment: {
                  pattern: /(^|[^"{\\$])#.*/,
                  lookbehind: !0
                },
                "function-name": [
                  // a) function foo {
                  // b) foo() {
                  // c) function foo() {
                  // but not foo {
                  {
                    // a) and c)
                    pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
                    lookbehind: !0,
                    alias: "function"
                  },
                  {
                    // b)
                    pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
                    alias: "function"
                  }
                ],
                // Highlight variable names as variables in for and select beginnings.
                "for-or-select": {
                  pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
                  alias: "variable",
                  lookbehind: !0
                },
                // Highlight variable names as variables in the left-hand part
                // of assignments (= and +=).
                "assign-left": {
                  pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
                  inside: {
                    environment: {
                      pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                      lookbehind: !0,
                      alias: "constant"
                    }
                  },
                  alias: "variable",
                  lookbehind: !0
                },
                string: [
                  // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
                  {
                    pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
                    lookbehind: !0,
                    greedy: !0,
                    inside: insideString
                  },
                  // Here-document with quotes around the tag
                  //  No expansion (so no inside).
                  {
                    pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
                    lookbehind: !0,
                    greedy: !0,
                    inside: {
                      bash: commandAfterHeredoc
                    }
                  },
                  // Normal string
                  {
                    // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                    pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
                    lookbehind: !0,
                    greedy: !0,
                    inside: insideString
                  },
                  {
                    // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
                    pattern: /(^|[^$\\])'[^']*'/,
                    lookbehind: !0,
                    greedy: !0
                  },
                  {
                    // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
                    pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
                    greedy: !0,
                    inside: {
                      entity: insideString.entity
                    }
                  }
                ],
                environment: {
                  pattern: RegExp("\\$?" + envVars),
                  alias: "constant"
                },
                variable: insideString.variable,
                function: {
                  pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
                  lookbehind: !0
                },
                keyword: {
                  pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
                  lookbehind: !0
                },
                // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
                builtin: {
                  pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
                  lookbehind: !0,
                  // Alias added to make those easier to distinguish from strings.
                  alias: "class-name"
                },
                boolean: {
                  pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
                  lookbehind: !0
                },
                "file-descriptor": {
                  pattern: /\B&\d\b/,
                  alias: "important"
                },
                operator: {
                  // Lots of redirections here, but not just that.
                  pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
                  inside: {
                    "file-descriptor": {
                      pattern: /^\d/,
                      alias: "important"
                    }
                  }
                },
                punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
                number: {
                  pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
                  lookbehind: !0
                }
              }, commandAfterHeredoc.inside = Prism2.languages.bash;
              for (var toBeCopied = [
                "comment",
                "function-name",
                "for-or-select",
                "assign-left",
                "string",
                "environment",
                "function",
                "keyword",
                "builtin",
                "boolean",
                "file-descriptor",
                "operator",
                "punctuation",
                "number"
              ], inside = insideString.variable[1].inside, i3 = 0; i3 < toBeCopied.length; i3++)
                inside[toBeCopied[i3]] = Prism2.languages.bash[toBeCopied[i3]];
              Prism2.languages.shell = Prism2.languages.bash;
            })(Prism);
          }
          __name(bash2, "bash");
        }
      }), require_css = __commonJS2({
        "../node_modules/refractor/lang/css.js"(exports, module) {
          "use strict";
          module.exports = css2, css2.displayName = "css", css2.aliases = [];
          function css2(Prism) {
            (function(Prism2) {
              var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
              Prism2.languages.css = {
                comment: /\/\*[\s\S]*?\*\//,
                atrule: {
                  pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
                  inside: {
                    rule: /^@[\w-]+/,
                    "selector-function-argument": {
                      pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                      lookbehind: !0,
                      alias: "selector"
                    },
                    keyword: {
                      pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                      lookbehind: !0
                    }
                    // See rest below
                  }
                },
                url: {
                  // https://drafts.csswg.org/css-values-3/#urls
                  pattern: RegExp(
                    "\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
                    "i"
                  ),
                  greedy: !0,
                  inside: {
                    function: /^url/i,
                    punctuation: /^\(|\)$/,
                    string: {
                      pattern: RegExp("^" + string.source + "$"),
                      alias: "url"
                    }
                  }
                },
                selector: {
                  pattern: RegExp(
                    `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"
                  ),
                  lookbehind: !0
                },
                string: {
                  pattern: string,
                  greedy: !0
                },
                property: {
                  pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
                  lookbehind: !0
                },
                important: /!important\b/i,
                function: {
                  pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
                  lookbehind: !0
                },
                punctuation: /[(){};:,]/
              }, Prism2.languages.css.atrule.inside.rest = Prism2.languages.css;
              var markup2 = Prism2.languages.markup;
              markup2 && (markup2.tag.addInlined("style", "css"), markup2.tag.addAttribute("style", "css"));
            })(Prism);
          }
          __name(css2, "css");
        }
      }), require_graphql = __commonJS2({
        "../node_modules/refractor/lang/graphql.js"(exports, module) {
          "use strict";
          module.exports = graphql2, graphql2.displayName = "graphql", graphql2.aliases = [];
          function graphql2(Prism) {
            Prism.languages.graphql = {
              comment: /#.*/,
              description: {
                pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
                greedy: !0,
                alias: "string",
                inside: {
                  "language-markdown": {
                    pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
                    lookbehind: !0,
                    inside: Prism.languages.markdown
                  }
                }
              },
              string: {
                pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
                greedy: !0
              },
              number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
              boolean: /\b(?:false|true)\b/,
              variable: /\$[a-z_]\w*/i,
              directive: {
                pattern: /@[a-z_]\w*/i,
                alias: "function"
              },
              "attr-name": {
                pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
                greedy: !0
              },
              "atom-input": {
                pattern: /\b[A-Z]\w*Input\b/,
                alias: "class-name"
              },
              scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
              constant: /\b[A-Z][A-Z_\d]*\b/,
              "class-name": {
                pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
                lookbehind: !0
              },
              fragment: {
                pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
                lookbehind: !0,
                alias: "function"
              },
              "definition-mutation": {
                pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
                lookbehind: !0,
                alias: "function"
              },
              "definition-query": {
                pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
                lookbehind: !0,
                alias: "function"
              },
              keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
              operator: /[!=|&]|\.{3}/,
              "property-query": /\w+(?=\s*\()/,
              object: /\w+(?=\s*\{)/,
              punctuation: /[!(){}\[\]:=,]/,
              property: /\w+/
            }, Prism.hooks.add("after-tokenize", __name(function(env) {
              if (env.language !== "graphql")
                return;
              var validTokens = env.tokens.filter(function(token) {
                return typeof token != "string" && token.type !== "comment" && token.type !== "scalar";
              }), currentIndex = 0;
              function getToken(offset3) {
                return validTokens[currentIndex + offset3];
              }
              __name(getToken, "getToken");
              function isTokenType(types2, offset3) {
                offset3 = offset3 || 0;
                for (var i22 = 0; i22 < types2.length; i22++) {
                  var token = getToken(i22 + offset3);
                  if (!token || token.type !== types2[i22])
                    return !1;
                }
                return !0;
              }
              __name(isTokenType, "isTokenType");
              function findClosingBracket(open, close) {
                for (var stackHeight = 1, i22 = currentIndex; i22 < validTokens.length; i22++) {
                  var token = validTokens[i22], content = token.content;
                  if (token.type === "punctuation" && typeof content == "string") {
                    if (open.test(content))
                      stackHeight++;
                    else if (close.test(content) && (stackHeight--, stackHeight === 0))
                      return i22;
                  }
                }
                return -1;
              }
              __name(findClosingBracket, "findClosingBracket");
              function addAlias(token, alias) {
                var aliases = token.alias;
                aliases ? Array.isArray(aliases) || (token.alias = aliases = [aliases]) : token.alias = aliases = [], aliases.push(alias);
              }
              for (__name(addAlias, "addAlias"); currentIndex < validTokens.length; ) {
                var startToken = validTokens[currentIndex++];
                if (startToken.type === "keyword" && startToken.content === "mutation") {
                  var inputVariables = [];
                  if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
                    currentIndex += 2;
                    var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
                    if (definitionEnd === -1)
                      continue;
                    for (; currentIndex < definitionEnd; currentIndex++) {
                      var t = getToken(0);
                      t.type === "variable" && (addAlias(t, "variable-input"), inputVariables.push(t.content));
                    }
                    currentIndex = definitionEnd + 1;
                  }
                  if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{" && (currentIndex++, addAlias(getToken(0), "property-mutation"), inputVariables.length > 0)) {
                    var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
                    if (mutationEnd === -1)
                      continue;
                    for (var i3 = currentIndex; i3 < mutationEnd; i3++) {
                      var varToken = validTokens[i3];
                      varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0 && addAlias(varToken, "variable-input");
                    }
                  }
                }
              }
            }, "afterTokenizeGraphql"));
          }
          __name(graphql2, "graphql");
        }
      }), require_js_extras = __commonJS2({
        "../node_modules/refractor/lang/js-extras.js"(exports, module) {
          "use strict";
          module.exports = jsExtras2, jsExtras2.displayName = "jsExtras", jsExtras2.aliases = [];
          function jsExtras2(Prism) {
            (function(Prism2) {
              Prism2.languages.insertBefore("javascript", "function-variable", {
                "method-variable": {
                  pattern: RegExp(
                    "(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source
                  ),
                  lookbehind: !0,
                  alias: ["function-variable", "method", "function", "property-access"]
                }
              }), Prism2.languages.insertBefore("javascript", "function", {
                method: {
                  pattern: RegExp(
                    "(\\.\\s*)" + Prism2.languages.javascript.function.source
                  ),
                  lookbehind: !0,
                  alias: ["function", "property-access"]
                }
              }), Prism2.languages.insertBefore("javascript", "constant", {
                "known-class-name": [
                  {
                    // standard built-ins
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
                    pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
                    alias: "class-name"
                  },
                  {
                    // errors
                    pattern: /\b(?:[A-Z]\w*)Error\b/,
                    alias: "class-name"
                  }
                ]
              });
              function withId(source, flags) {
                return RegExp(
                  source.replace(/<ID>/g, function() {
                    return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
                  }),
                  flags
                );
              }
              __name(withId, "withId"), Prism2.languages.insertBefore("javascript", "keyword", {
                imports: {
                  // https://tc39.es/ecma262/#sec-imports
                  pattern: withId(
                    /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
                  ),
                  lookbehind: !0,
                  inside: Prism2.languages.javascript
                },
                exports: {
                  // https://tc39.es/ecma262/#sec-exports
                  pattern: withId(
                    /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
                  ),
                  lookbehind: !0,
                  inside: Prism2.languages.javascript
                }
              }), Prism2.languages.javascript.keyword.unshift(
                {
                  pattern: /\b(?:as|default|export|from|import)\b/,
                  alias: "module"
                },
                {
                  pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
                  alias: "control-flow"
                },
                {
                  pattern: /\bnull\b/,
                  alias: ["null", "nil"]
                },
                {
                  pattern: /\bundefined\b/,
                  alias: "nil"
                }
              ), Prism2.languages.insertBefore("javascript", "operator", {
                spread: {
                  pattern: /\.{3}/,
                  alias: "operator"
                },
                arrow: {
                  pattern: /=>/,
                  alias: "operator"
                }
              }), Prism2.languages.insertBefore("javascript", "punctuation", {
                "property-access": {
                  pattern: withId(/(\.\s*)#?<ID>/.source),
                  lookbehind: !0
                },
                "maybe-class-name": {
                  pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
                  lookbehind: !0
                },
                dom: {
                  // this contains only a few commonly used DOM variables
                  pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
                  alias: "variable"
                },
                console: {
                  pattern: /\bconsole(?=\s*\.)/,
                  alias: "class-name"
                }
              });
              for (var maybeClassNameTokens = [
                "function",
                "function-variable",
                "method",
                "method-variable",
                "property-access"
              ], i3 = 0; i3 < maybeClassNameTokens.length; i3++) {
                var token = maybeClassNameTokens[i3], value2 = Prism2.languages.javascript[token];
                Prism2.util.type(value2) === "RegExp" && (value2 = Prism2.languages.javascript[token] = {
                  pattern: value2
                });
                var inside = value2.inside || {};
                value2.inside = inside, inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
              }
            })(Prism);
          }
          __name(jsExtras2, "jsExtras");
        }
      }), require_json = __commonJS2({
        "../node_modules/refractor/lang/json.js"(exports, module) {
          "use strict";
          module.exports = json2, json2.displayName = "json", json2.aliases = ["webmanifest"];
          function json2(Prism) {
            Prism.languages.json = {
              property: {
                pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
                lookbehind: !0,
                greedy: !0
              },
              string: {
                pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
                lookbehind: !0,
                greedy: !0
              },
              comment: {
                pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
                greedy: !0
              },
              number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
              punctuation: /[{}[\],]/,
              operator: /:/,
              boolean: /\b(?:false|true)\b/,
              null: {
                pattern: /\bnull\b/,
                alias: "keyword"
              }
            }, Prism.languages.webmanifest = Prism.languages.json;
          }
          __name(json2, "json");
        }
      }), require_jsx = __commonJS2({
        "../node_modules/refractor/lang/jsx.js"(exports, module) {
          "use strict";
          module.exports = jsx24, jsx24.displayName = "jsx", jsx24.aliases = [];
          function jsx24(Prism) {
            (function(Prism2) {
              var javascript = Prism2.util.clone(Prism2.languages.javascript), space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
              function re3(source, flags) {
                return source = source.replace(/<S>/g, function() {
                  return space;
                }).replace(/<BRACES>/g, function() {
                  return braces;
                }).replace(/<SPREAD>/g, function() {
                  return spread;
                }), RegExp(source, flags);
              }
              __name(re3, "re"), spread = re3(spread).source, Prism2.languages.jsx = Prism2.languages.extend("markup", javascript), Prism2.languages.jsx.tag.pattern = re3(
                /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
              ), Prism2.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, Prism2.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, Prism2.languages.jsx.tag.inside.comment = javascript.comment, Prism2.languages.insertBefore(
                "inside",
                "attr-name",
                {
                  spread: {
                    pattern: re3(/<SPREAD>/.source),
                    inside: Prism2.languages.jsx
                  }
                },
                Prism2.languages.jsx.tag
              ), Prism2.languages.insertBefore(
                "inside",
                "special-attr",
                {
                  script: {
                    // Allow for two levels of nesting
                    pattern: re3(/=<BRACES>/.source),
                    alias: "language-javascript",
                    inside: {
                      "script-punctuation": {
                        pattern: /^=(?=\{)/,
                        alias: "punctuation"
                      },
                      rest: Prism2.languages.jsx
                    }
                  }
                },
                Prism2.languages.jsx.tag
              );
              var stringifyToken = __name(function(token) {
                return token ? typeof token == "string" ? token : typeof token.content == "string" ? token.content : token.content.map(stringifyToken).join("") : "";
              }, "stringifyToken"), walkTokens = __name(function(tokens) {
                for (var openedTags = [], i3 = 0; i3 < tokens.length; i3++) {
                  var token = tokens[i3], notTagNorBrace = !1;
                  if (typeof token != "string" && (token.type === "tag" && token.content[0] && token.content[0].type === "tag" ? token.content[0].content[0].content === "</" ? openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1]) && openedTags.pop() : token.content[token.content.length - 1].content === "/>" || openedTags.push({
                    tagName: stringifyToken(token.content[0].content[1]),
                    openedBraces: 0
                  }) : openedTags.length > 0 && token.type === "punctuation" && token.content === "{" ? openedTags[openedTags.length - 1].openedBraces++ : openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}" ? openedTags[openedTags.length - 1].openedBraces-- : notTagNorBrace = !0), (notTagNorBrace || typeof token == "string") && openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                    var plainText = stringifyToken(token);
                    i3 < tokens.length - 1 && (typeof tokens[i3 + 1] == "string" || tokens[i3 + 1].type === "plain-text") && (plainText += stringifyToken(tokens[i3 + 1]), tokens.splice(i3 + 1, 1)), i3 > 0 && (typeof tokens[i3 - 1] == "string" || tokens[i3 - 1].type === "plain-text") && (plainText = stringifyToken(tokens[i3 - 1]) + plainText, tokens.splice(i3 - 1, 1), i3--), tokens[i3] = new Prism2.Token(
                      "plain-text",
                      plainText,
                      null,
                      plainText
                    );
                  }
                  token.content && typeof token.content != "string" && walkTokens(token.content);
                }
              }, "walkTokens");
              Prism2.hooks.add("after-tokenize", function(env) {
                env.language !== "jsx" && env.language !== "tsx" || walkTokens(env.tokens);
              });
            })(Prism);
          }
          __name(jsx24, "jsx");
        }
      }), require_markdown = __commonJS2({
        "../node_modules/refractor/lang/markdown.js"(exports, module) {
          "use strict";
          module.exports = markdown2, markdown2.displayName = "markdown", markdown2.aliases = ["md"];
          function markdown2(Prism) {
            (function(Prism2) {
              var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
              function createInline(pattern) {
                return pattern = pattern.replace(/<inner>/g, function() {
                  return inner;
                }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
              }
              __name(createInline, "createInline");
              var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
                /__/g,
                function() {
                  return tableCell;
                }
              ), tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
              Prism2.languages.markdown = Prism2.languages.extend("markup", {}), Prism2.languages.insertBefore("markdown", "prolog", {
                "front-matter-block": {
                  pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
                  lookbehind: !0,
                  greedy: !0,
                  inside: {
                    punctuation: /^---|---$/,
                    "front-matter": {
                      pattern: /\S+(?:\s+\S+)*/,
                      alias: ["yaml", "language-yaml"],
                      inside: Prism2.languages.yaml
                    }
                  }
                },
                blockquote: {
                  // > ...
                  pattern: /^>(?:[\t ]*>)*/m,
                  alias: "punctuation"
                },
                table: {
                  pattern: RegExp(
                    "^" + tableRow + tableLine + "(?:" + tableRow + ")*",
                    "m"
                  ),
                  inside: {
                    "table-data-rows": {
                      pattern: RegExp(
                        "^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"
                      ),
                      lookbehind: !0,
                      inside: {
                        "table-data": {
                          pattern: RegExp(tableCell),
                          inside: Prism2.languages.markdown
                        },
                        punctuation: /\|/
                      }
                    },
                    "table-line": {
                      pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
                      lookbehind: !0,
                      inside: {
                        punctuation: /\||:?-{3,}:?/
                      }
                    },
                    "table-header-row": {
                      pattern: RegExp("^" + tableRow + "$"),
                      inside: {
                        "table-header": {
                          pattern: RegExp(tableCell),
                          alias: "important",
                          inside: Prism2.languages.markdown
                        },
                        punctuation: /\|/
                      }
                    }
                  }
                },
                code: [
                  {
                    // Prefixed by 4 spaces or 1 tab and preceded by an empty line
                    pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
                    lookbehind: !0,
                    alias: "keyword"
                  },
                  {
                    // ```optional language
                    // code block
                    // ```
                    pattern: /^```[\s\S]*?^```$/m,
                    greedy: !0,
                    inside: {
                      "code-block": {
                        pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                        lookbehind: !0
                      },
                      "code-language": {
                        pattern: /^(```).+/,
                        lookbehind: !0
                      },
                      punctuation: /```/
                    }
                  }
                ],
                title: [
                  {
                    // title 1
                    // =======
                    // title 2
                    // -------
                    pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
                    alias: "important",
                    inside: {
                      punctuation: /==+$|--+$/
                    }
                  },
                  {
                    // # title 1
                    // ###### title 6
                    pattern: /(^\s*)#.+/m,
                    lookbehind: !0,
                    alias: "important",
                    inside: {
                      punctuation: /^#+|#+$/
                    }
                  }
                ],
                hr: {
                  // ***
                  // ---
                  // * * *
                  // -----------
                  pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
                  lookbehind: !0,
                  alias: "punctuation"
                },
                list: {
                  // * item
                  // + item
                  // - item
                  // 1. item
                  pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
                  lookbehind: !0,
                  alias: "punctuation"
                },
                "url-reference": {
                  // [id]: http://example.com "Optional title"
                  // [id]: http://example.com 'Optional title'
                  // [id]: http://example.com (Optional title)
                  // [id]: <http://example.com> "Optional title"
                  pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
                  inside: {
                    variable: {
                      pattern: /^(!?\[)[^\]]+/,
                      lookbehind: !0
                    },
                    string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
                    punctuation: /^[\[\]!:]|[<>]/
                  },
                  alias: "url"
                },
                bold: {
                  // **strong**
                  // __strong__
                  // allow one nested instance of italic text using the same delimiter
                  pattern: createInline(
                    /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
                  ),
                  lookbehind: !0,
                  greedy: !0,
                  inside: {
                    content: {
                      pattern: /(^..)[\s\S]+(?=..$)/,
                      lookbehind: !0,
                      inside: {}
                      // see below
                    },
                    punctuation: /\*\*|__/
                  }
                },
                italic: {
                  // *em*
                  // _em_
                  // allow one nested instance of bold text using the same delimiter
                  pattern: createInline(
                    /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
                  ),
                  lookbehind: !0,
                  greedy: !0,
                  inside: {
                    content: {
                      pattern: /(^.)[\s\S]+(?=.$)/,
                      lookbehind: !0,
                      inside: {}
                      // see below
                    },
                    punctuation: /[*_]/
                  }
                },
                strike: {
                  // ~~strike through~~
                  // ~strike~
                  // eslint-disable-next-line regexp/strict
                  pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
                  lookbehind: !0,
                  greedy: !0,
                  inside: {
                    content: {
                      pattern: /(^~~?)[\s\S]+(?=\1$)/,
                      lookbehind: !0,
                      inside: {}
                      // see below
                    },
                    punctuation: /~~?/
                  }
                },
                "code-snippet": {
                  // `code`
                  // ``code``
                  pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
                  lookbehind: !0,
                  greedy: !0,
                  alias: ["code", "keyword"]
                },
                url: {
                  // [example](http://example.com "Optional title")
                  // [example][id]
                  // [example] [id]
                  pattern: createInline(
                    /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
                  ),
                  lookbehind: !0,
                  greedy: !0,
                  inside: {
                    operator: /^!/,
                    content: {
                      pattern: /(^\[)[^\]]+(?=\])/,
                      lookbehind: !0,
                      inside: {}
                      // see below
                    },
                    variable: {
                      pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                      lookbehind: !0
                    },
                    url: {
                      pattern: /(^\]\()[^\s)]+/,
                      lookbehind: !0
                    },
                    string: {
                      pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                      lookbehind: !0
                    }
                  }
                }
              }), ["url", "bold", "italic", "strike"].forEach(function(token) {
                ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
                  token !== inside && (Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside]);
                });
              }), Prism2.hooks.add("after-tokenize", function(env) {
                if (env.language !== "markdown" && env.language !== "md")
                  return;
                function walkTokens(tokens) {
                  if (!(!tokens || typeof tokens == "string"))
                    for (var i3 = 0, l2 = tokens.length; i3 < l2; i3++) {
                      var token = tokens[i3];
                      if (token.type !== "code") {
                        walkTokens(token.content);
                        continue;
                      }
                      var codeLang = token.content[1], codeBlock = token.content[3];
                      if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content == "string") {
                        var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                        lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
                        var alias = "language-" + lang;
                        codeBlock.alias ? typeof codeBlock.alias == "string" ? codeBlock.alias = [codeBlock.alias, alias] : codeBlock.alias.push(alias) : codeBlock.alias = [alias];
                      }
                    }
                }
                __name(walkTokens, "walkTokens"), walkTokens(env.tokens);
              }), Prism2.hooks.add("wrap", function(env) {
                if (env.type === "code-block") {
                  for (var codeLang = "", i3 = 0, l2 = env.classes.length; i3 < l2; i3++) {
                    var cls = env.classes[i3], match2 = /language-(.+)/.exec(cls);
                    if (match2) {
                      codeLang = match2[1];
                      break;
                    }
                  }
                  var grammar = Prism2.languages[codeLang];
                  if (grammar)
                    env.content = Prism2.highlight(
                      textContent(env.content.value),
                      grammar,
                      codeLang
                    );
                  else if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
                    var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
                    env.attributes.id = id2, Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
                      var ele = document.getElementById(id2);
                      ele && (ele.innerHTML = Prism2.highlight(
                        ele.textContent,
                        Prism2.languages[codeLang],
                        codeLang
                      ));
                    });
                  }
                }
              });
              var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi"), KNOWN_ENTITY_NAMES = {
                amp: "&",
                lt: "<",
                gt: ">",
                quot: '"'
              }, fromCodePoint = String.fromCodePoint || String.fromCharCode;
              function textContent(html) {
                var text = html.replace(tagPattern, "");
                return text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m3, code) {
                  if (code = code.toLowerCase(), code[0] === "#") {
                    var value2;
                    return code[1] === "x" ? value2 = parseInt(code.slice(2), 16) : value2 = Number(code.slice(1)), fromCodePoint(value2);
                  } else {
                    var known = KNOWN_ENTITY_NAMES[code];
                    return known || m3;
                  }
                }), text;
              }
              __name(textContent, "textContent"), Prism2.languages.md = Prism2.languages.markdown;
            })(Prism);
          }
          __name(markdown2, "markdown");
        }
      }), require_markup = __commonJS2({
        "../node_modules/refractor/lang/markup.js"(exports, module) {
          "use strict";
          module.exports = markup2, markup2.displayName = "markup", markup2.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
          function markup2(Prism) {
            Prism.languages.markup = {
              comment: {
                pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
                greedy: !0
              },
              prolog: {
                pattern: /<\?[\s\S]+?\?>/,
                greedy: !0
              },
              doctype: {
                // https://www.w3.org/TR/xml/#NT-doctypedecl
                pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
                greedy: !0,
                inside: {
                  "internal-subset": {
                    pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                    lookbehind: !0,
                    greedy: !0,
                    inside: null
                    // see below
                  },
                  string: {
                    pattern: /"[^"]*"|'[^']*'/,
                    greedy: !0
                  },
                  punctuation: /^<!|>$|[[\]]/,
                  "doctype-tag": /^DOCTYPE/i,
                  name: /[^\s<>'"]+/
                }
              },
              cdata: {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                greedy: !0
              },
              tag: {
                pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
                greedy: !0,
                inside: {
                  tag: {
                    pattern: /^<\/?[^\s>\/]+/,
                    inside: {
                      punctuation: /^<\/?/,
                      namespace: /^[^\s>\/:]+:/
                    }
                  },
                  "special-attr": [],
                  "attr-value": {
                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                    inside: {
                      punctuation: [
                        {
                          pattern: /^=/,
                          alias: "attr-equals"
                        },
                        /"|'/
                      ]
                    }
                  },
                  punctuation: /\/?>/,
                  "attr-name": {
                    pattern: /[^\s>\/]+/,
                    inside: {
                      namespace: /^[^\s>\/:]+:/
                    }
                  }
                }
              },
              entity: [
                {
                  pattern: /&[\da-z]{1,8};/i,
                  alias: "named-entity"
                },
                /&#x?[\da-f]{1,8};/i
              ]
            }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(env) {
              env.type === "entity" && (env.attributes.title = env.content.value.replace(/&amp;/, "&"));
            }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
              /**
               * Adds an inlined language to markup.
               *
               * An example of an inlined language is CSS with `<style>` tags.
               *
               * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
               * case insensitive.
               * @param {string} lang The language key.
               * @example
               * addInlined('style', 'css');
               */
              value: __name(function(tagName, lang) {
                var includedCdataInside = {};
                includedCdataInside["language-" + lang] = {
                  pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                  lookbehind: !0,
                  inside: Prism.languages[lang]
                }, includedCdataInside.cdata = /^<!\[CDATA\[|\]\]>$/i;
                var inside = {
                  "included-cdata": {
                    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                    inside: includedCdataInside
                  }
                };
                inside["language-" + lang] = {
                  pattern: /[\s\S]+/,
                  inside: Prism.languages[lang]
                };
                var def = {};
                def[tagName] = {
                  pattern: RegExp(
                    /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
                      /__/g,
                      function() {
                        return tagName;
                      }
                    ),
                    "i"
                  ),
                  lookbehind: !0,
                  greedy: !0,
                  inside
                }, Prism.languages.insertBefore("markup", "cdata", def);
              }, "addInlined")
            }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
              /**
               * Adds an pattern to highlight languages embedded in HTML attributes.
               *
               * An example of an inlined language is CSS with `style` attributes.
               *
               * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
               * case insensitive.
               * @param {string} lang The language key.
               * @example
               * addAttribute('style', 'css');
               */
              value: __name(function(attrName, lang) {
                Prism.languages.markup.tag.inside["special-attr"].push({
                  pattern: RegExp(
                    /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
                    "i"
                  ),
                  lookbehind: !0,
                  inside: {
                    "attr-name": /^[^\s=]+/,
                    "attr-value": {
                      pattern: /=[\s\S]+/,
                      inside: {
                        value: {
                          pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                          lookbehind: !0,
                          alias: [lang, "language-" + lang],
                          inside: Prism.languages[lang]
                        },
                        punctuation: [
                          {
                            pattern: /^=/,
                            alias: "attr-equals"
                          },
                          /"|'/
                        ]
                      }
                    }
                  }
                });
              }, "value")
            }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;
          }
          __name(markup2, "markup");
        }
      }), require_typescript = __commonJS2({
        "../node_modules/refractor/lang/typescript.js"(exports, module) {
          "use strict";
          module.exports = typescript2, typescript2.displayName = "typescript", typescript2.aliases = ["ts"];
          function typescript2(Prism) {
            (function(Prism2) {
              Prism2.languages.typescript = Prism2.languages.extend("javascript", {
                "class-name": {
                  pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
                  lookbehind: !0,
                  greedy: !0,
                  inside: null
                  // see below
                },
                builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
              }), Prism2.languages.typescript.keyword.push(
                /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
                // keywords that have to be followed by an identifier
                /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
                // This is for `import type *, {}`
                /\btype\b(?=\s*(?:[\{*]|$))/
              ), delete Prism2.languages.typescript.parameter, delete Prism2.languages.typescript["literal-property"];
              var typeInside = Prism2.languages.extend("typescript", {});
              delete typeInside["class-name"], Prism2.languages.typescript["class-name"].inside = typeInside, Prism2.languages.insertBefore("typescript", "function", {
                decorator: {
                  pattern: /@[$\w\xA0-\uFFFF]+/,
                  inside: {
                    at: {
                      pattern: /^@/,
                      alias: "operator"
                    },
                    function: /^[\s\S]+/
                  }
                },
                "generic-function": {
                  // e.g. foo<T extends "bar" | "baz">( ...
                  pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
                  greedy: !0,
                  inside: {
                    function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
                    generic: {
                      pattern: /<[\s\S]+/,
                      // everything after the first <
                      alias: "class-name",
                      inside: typeInside
                    }
                  }
                }
              }), Prism2.languages.ts = Prism2.languages.typescript;
            })(Prism);
          }
          __name(typescript2, "typescript");
        }
      }), require_tsx = __commonJS2({
        "../node_modules/refractor/lang/tsx.js"(exports, module) {
          "use strict";
          var refractorJsx = require_jsx(), refractorTypescript = require_typescript();
          module.exports = tsx2, tsx2.displayName = "tsx", tsx2.aliases = [];
          function tsx2(Prism) {
            Prism.register(refractorJsx), Prism.register(refractorTypescript), (function(Prism2) {
              var typescript2 = Prism2.util.clone(Prism2.languages.typescript);
              Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript2), delete Prism2.languages.tsx.parameter, delete Prism2.languages.tsx["literal-property"];
              var tag = Prism2.languages.tsx.tag;
              tag.pattern = RegExp(
                /(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")",
                tag.pattern.flags
              ), tag.lookbehind = !0;
            })(Prism);
          }
          __name(tsx2, "tsx");
        }
      }), require_yaml = __commonJS2({
        "../node_modules/refractor/lang/yaml.js"(exports, module) {
          "use strict";
          module.exports = yaml2, yaml2.displayName = "yaml", yaml2.aliases = ["yml"];
          function yaml2(Prism) {
            (function(Prism2) {
              var anchorOrAlias = /[*&][^\s[\]{},]+/, tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)", plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
                /<PLAIN>/g,
                function() {
                  return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
                }
              ), string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
              function createValuePattern(value2, flags) {
                flags = (flags || "").replace(/m/g, "") + "m";
                var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
                  return properties;
                }).replace(/<<value>>/g, function() {
                  return value2;
                });
                return RegExp(pattern, flags);
              }
              __name(createValuePattern, "createValuePattern"), Prism2.languages.yaml = {
                scalar: {
                  pattern: RegExp(
                    /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
                      /<<prop>>/g,
                      function() {
                        return properties;
                      }
                    )
                  ),
                  lookbehind: !0,
                  alias: "string"
                },
                comment: /#.*/,
                key: {
                  pattern: RegExp(
                    /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                      return properties;
                    }).replace(/<<key>>/g, function() {
                      return "(?:" + plainKey + "|" + string + ")";
                    })
                  ),
                  lookbehind: !0,
                  greedy: !0,
                  alias: "atrule"
                },
                directive: {
                  pattern: /(^[ \t]*)%.+/m,
                  lookbehind: !0,
                  alias: "important"
                },
                datetime: {
                  pattern: createValuePattern(
                    /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
                  ),
                  lookbehind: !0,
                  alias: "number"
                },
                boolean: {
                  pattern: createValuePattern(/false|true/.source, "i"),
                  lookbehind: !0,
                  alias: "important"
                },
                null: {
                  pattern: createValuePattern(/null|~/.source, "i"),
                  lookbehind: !0,
                  alias: "important"
                },
                string: {
                  pattern: createValuePattern(string),
                  lookbehind: !0,
                  greedy: !0
                },
                number: {
                  pattern: createValuePattern(
                    /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
                    "i"
                  ),
                  lookbehind: !0
                },
                tag,
                important: anchorOrAlias,
                punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
              }, Prism2.languages.yml = Prism2.languages.yaml;
            })(Prism);
          }
          __name(yaml2, "yaml");
        }
      }), require_immutable = __commonJS2({
        "../node_modules/xtend/immutable.js"(exports, module) {
          module.exports = extend;
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          function extend() {
            for (var target = {}, i3 = 0; i3 < arguments.length; i3++) {
              var source = arguments[i3];
              for (var key in source)
                hasOwnProperty2.call(source, key) && (target[key] = source[key]);
            }
            return target;
          }
          __name(extend, "extend");
        }
      }), require_schema = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/schema.js"(exports, module) {
          "use strict";
          module.exports = Schema;
          var proto = Schema.prototype;
          proto.space = null, proto.normal = {}, proto.property = {};
          function Schema(property, normal, space) {
            this.property = property, this.normal = normal, space && (this.space = space);
          }
          __name(Schema, "Schema");
        }
      }), require_merge = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/merge.js"(exports, module) {
          "use strict";
          var xtend = require_immutable(), Schema = require_schema();
          module.exports = merge3;
          function merge3(definitions) {
            for (var length2 = definitions.length, property = [], normal = [], index3 = -1, info, space; ++index3 < length2; )
              info = definitions[index3], property.push(info.property), normal.push(info.normal), space = info.space;
            return new Schema(
              xtend.apply(null, property),
              xtend.apply(null, normal),
              space
            );
          }
          __name(merge3, "merge");
        }
      }), require_normalize = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/normalize.js"(exports, module) {
          "use strict";
          module.exports = normalize;
          function normalize(value2) {
            return value2.toLowerCase();
          }
          __name(normalize, "normalize");
        }
      }), require_info = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/info.js"(exports, module) {
          "use strict";
          module.exports = Info2;
          var proto = Info2.prototype;
          proto.space = null, proto.attribute = null, proto.property = null, proto.boolean = !1, proto.booleanish = !1, proto.overloadedBoolean = !1, proto.number = !1, proto.commaSeparated = !1, proto.spaceSeparated = !1, proto.commaOrSpaceSeparated = !1, proto.mustUseProperty = !1, proto.defined = !1;
          function Info2(property, attribute) {
            this.property = property, this.attribute = attribute;
          }
          __name(Info2, "Info");
        }
      }), require_types = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/types.js"(exports) {
          "use strict";
          var powers = 0;
          exports.boolean = increment(), exports.booleanish = increment(), exports.overloadedBoolean = increment(), exports.number = increment(), exports.spaceSeparated = increment(), exports.commaSeparated = increment(), exports.commaOrSpaceSeparated = increment();
          function increment() {
            return Math.pow(2, ++powers);
          }
          __name(increment, "increment");
        }
      }), require_defined_info = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/defined-info.js"(exports, module) {
          "use strict";
          var Info2 = require_info(), types2 = require_types();
          module.exports = DefinedInfo, DefinedInfo.prototype = new Info2(), DefinedInfo.prototype.defined = !0;
          var checks = [
            "boolean",
            "booleanish",
            "overloadedBoolean",
            "number",
            "commaSeparated",
            "spaceSeparated",
            "commaOrSpaceSeparated"
          ], checksLength = checks.length;
          function DefinedInfo(property, attribute, mask, space) {
            var index3 = -1, check;
            for (mark(this, "space", space), Info2.call(this, property, attribute); ++index3 < checksLength; )
              check = checks[index3], mark(this, check, (mask & types2[check]) === types2[check]);
          }
          __name(DefinedInfo, "DefinedInfo");
          function mark(values, key, value2) {
            value2 && (values[key] = value2);
          }
          __name(mark, "mark");
        }
      }), require_create = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/create.js"(exports, module) {
          "use strict";
          var normalize = require_normalize(), Schema = require_schema(), DefinedInfo = require_defined_info();
          module.exports = create2;
          function create2(definition) {
            var space = definition.space, mustUseProperty = definition.mustUseProperty || [], attributes = definition.attributes || {}, props = definition.properties, transform = definition.transform, property = {}, normal = {}, prop, info;
            for (prop in props)
              info = new DefinedInfo(
                prop,
                transform(attributes, prop),
                props[prop],
                space
              ), mustUseProperty.indexOf(prop) !== -1 && (info.mustUseProperty = !0), property[prop] = info, normal[normalize(prop)] = prop, normal[normalize(info.attribute)] = prop;
            return new Schema(property, normal, space);
          }
          __name(create2, "create");
        }
      }), require_xlink = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/xlink.js"(exports, module) {
          "use strict";
          var create2 = require_create();
          module.exports = create2({
            space: "xlink",
            transform: xlinkTransform,
            properties: {
              xLinkActuate: null,
              xLinkArcRole: null,
              xLinkHref: null,
              xLinkRole: null,
              xLinkShow: null,
              xLinkTitle: null,
              xLinkType: null
            }
          });
          function xlinkTransform(_3, prop) {
            return "xlink:" + prop.slice(5).toLowerCase();
          }
          __name(xlinkTransform, "xlinkTransform");
        }
      }), require_xml2 = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/xml.js"(exports, module) {
          "use strict";
          var create2 = require_create();
          module.exports = create2({
            space: "xml",
            transform: xmlTransform,
            properties: {
              xmlLang: null,
              xmlBase: null,
              xmlSpace: null
            }
          });
          function xmlTransform(_3, prop) {
            return "xml:" + prop.slice(3).toLowerCase();
          }
          __name(xmlTransform, "xmlTransform");
        }
      }), require_case_sensitive_transform = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/case-sensitive-transform.js"(exports, module) {
          "use strict";
          module.exports = caseSensitiveTransform;
          function caseSensitiveTransform(attributes, attribute) {
            return attribute in attributes ? attributes[attribute] : attribute;
          }
          __name(caseSensitiveTransform, "caseSensitiveTransform");
        }
      }), require_case_insensitive_transform = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/util/case-insensitive-transform.js"(exports, module) {
          "use strict";
          var caseSensitiveTransform = require_case_sensitive_transform();
          module.exports = caseInsensitiveTransform;
          function caseInsensitiveTransform(attributes, property) {
            return caseSensitiveTransform(attributes, property.toLowerCase());
          }
          __name(caseInsensitiveTransform, "caseInsensitiveTransform");
        }
      }), require_xmlns = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/xmlns.js"(exports, module) {
          "use strict";
          var create2 = require_create(), caseInsensitiveTransform = require_case_insensitive_transform();
          module.exports = create2({
            space: "xmlns",
            attributes: {
              xmlnsxlink: "xmlns:xlink"
            },
            transform: caseInsensitiveTransform,
            properties: {
              xmlns: null,
              xmlnsXLink: null
            }
          });
        }
      }), require_aria = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/aria.js"(exports, module) {
          "use strict";
          var types2 = require_types(), create2 = require_create(), booleanish = types2.booleanish, number = types2.number, spaceSeparated = types2.spaceSeparated;
          module.exports = create2({
            transform: ariaTransform,
            properties: {
              ariaActiveDescendant: null,
              ariaAtomic: booleanish,
              ariaAutoComplete: null,
              ariaBusy: booleanish,
              ariaChecked: booleanish,
              ariaColCount: number,
              ariaColIndex: number,
              ariaColSpan: number,
              ariaControls: spaceSeparated,
              ariaCurrent: null,
              ariaDescribedBy: spaceSeparated,
              ariaDetails: null,
              ariaDisabled: booleanish,
              ariaDropEffect: spaceSeparated,
              ariaErrorMessage: null,
              ariaExpanded: booleanish,
              ariaFlowTo: spaceSeparated,
              ariaGrabbed: booleanish,
              ariaHasPopup: null,
              ariaHidden: booleanish,
              ariaInvalid: null,
              ariaKeyShortcuts: null,
              ariaLabel: null,
              ariaLabelledBy: spaceSeparated,
              ariaLevel: number,
              ariaLive: null,
              ariaModal: booleanish,
              ariaMultiLine: booleanish,
              ariaMultiSelectable: booleanish,
              ariaOrientation: null,
              ariaOwns: spaceSeparated,
              ariaPlaceholder: null,
              ariaPosInSet: number,
              ariaPressed: booleanish,
              ariaReadOnly: booleanish,
              ariaRelevant: null,
              ariaRequired: booleanish,
              ariaRoleDescription: spaceSeparated,
              ariaRowCount: number,
              ariaRowIndex: number,
              ariaRowSpan: number,
              ariaSelected: booleanish,
              ariaSetSize: number,
              ariaSort: null,
              ariaValueMax: number,
              ariaValueMin: number,
              ariaValueNow: number,
              ariaValueText: null,
              role: null
            }
          });
          function ariaTransform(_3, prop) {
            return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
          }
          __name(ariaTransform, "ariaTransform");
        }
      }), require_html = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/lib/html.js"(exports, module) {
          "use strict";
          var types2 = require_types(), create2 = require_create(), caseInsensitiveTransform = require_case_insensitive_transform(), boolean = types2.boolean, overloadedBoolean = types2.overloadedBoolean, booleanish = types2.booleanish, number = types2.number, spaceSeparated = types2.spaceSeparated, commaSeparated = types2.commaSeparated;
          module.exports = create2({
            space: "html",
            attributes: {
              acceptcharset: "accept-charset",
              classname: "class",
              htmlfor: "for",
              httpequiv: "http-equiv"
            },
            transform: caseInsensitiveTransform,
            mustUseProperty: ["checked", "multiple", "muted", "selected"],
            properties: {
              // Standard Properties.
              abbr: null,
              accept: commaSeparated,
              acceptCharset: spaceSeparated,
              accessKey: spaceSeparated,
              action: null,
              allow: null,
              allowFullScreen: boolean,
              allowPaymentRequest: boolean,
              allowUserMedia: boolean,
              alt: null,
              as: null,
              async: boolean,
              autoCapitalize: null,
              autoComplete: spaceSeparated,
              autoFocus: boolean,
              autoPlay: boolean,
              capture: boolean,
              charSet: null,
              checked: boolean,
              cite: null,
              className: spaceSeparated,
              cols: number,
              colSpan: null,
              content: null,
              contentEditable: booleanish,
              controls: boolean,
              controlsList: spaceSeparated,
              coords: number | commaSeparated,
              crossOrigin: null,
              data: null,
              dateTime: null,
              decoding: null,
              default: boolean,
              defer: boolean,
              dir: null,
              dirName: null,
              disabled: boolean,
              download: overloadedBoolean,
              draggable: booleanish,
              encType: null,
              enterKeyHint: null,
              form: null,
              formAction: null,
              formEncType: null,
              formMethod: null,
              formNoValidate: boolean,
              formTarget: null,
              headers: spaceSeparated,
              height: number,
              hidden: boolean,
              high: number,
              href: null,
              hrefLang: null,
              htmlFor: spaceSeparated,
              httpEquiv: spaceSeparated,
              id: null,
              imageSizes: null,
              imageSrcSet: commaSeparated,
              inputMode: null,
              integrity: null,
              is: null,
              isMap: boolean,
              itemId: null,
              itemProp: spaceSeparated,
              itemRef: spaceSeparated,
              itemScope: boolean,
              itemType: spaceSeparated,
              kind: null,
              label: null,
              lang: null,
              language: null,
              list: null,
              loading: null,
              loop: boolean,
              low: number,
              manifest: null,
              max: null,
              maxLength: number,
              media: null,
              method: null,
              min: null,
              minLength: number,
              multiple: boolean,
              muted: boolean,
              name: null,
              nonce: null,
              noModule: boolean,
              noValidate: boolean,
              onAbort: null,
              onAfterPrint: null,
              onAuxClick: null,
              onBeforePrint: null,
              onBeforeUnload: null,
              onBlur: null,
              onCancel: null,
              onCanPlay: null,
              onCanPlayThrough: null,
              onChange: null,
              onClick: null,
              onClose: null,
              onContextMenu: null,
              onCopy: null,
              onCueChange: null,
              onCut: null,
              onDblClick: null,
              onDrag: null,
              onDragEnd: null,
              onDragEnter: null,
              onDragExit: null,
              onDragLeave: null,
              onDragOver: null,
              onDragStart: null,
              onDrop: null,
              onDurationChange: null,
              onEmptied: null,
              onEnded: null,
              onError: null,
              onFocus: null,
              onFormData: null,
              onHashChange: null,
              onInput: null,
              onInvalid: null,
              onKeyDown: null,
              onKeyPress: null,
              onKeyUp: null,
              onLanguageChange: null,
              onLoad: null,
              onLoadedData: null,
              onLoadedMetadata: null,
              onLoadEnd: null,
              onLoadStart: null,
              onMessage: null,
              onMessageError: null,
              onMouseDown: null,
              onMouseEnter: null,
              onMouseLeave: null,
              onMouseMove: null,
              onMouseOut: null,
              onMouseOver: null,
              onMouseUp: null,
              onOffline: null,
              onOnline: null,
              onPageHide: null,
              onPageShow: null,
              onPaste: null,
              onPause: null,
              onPlay: null,
              onPlaying: null,
              onPopState: null,
              onProgress: null,
              onRateChange: null,
              onRejectionHandled: null,
              onReset: null,
              onResize: null,
              onScroll: null,
              onSecurityPolicyViolation: null,
              onSeeked: null,
              onSeeking: null,
              onSelect: null,
              onSlotChange: null,
              onStalled: null,
              onStorage: null,
              onSubmit: null,
              onSuspend: null,
              onTimeUpdate: null,
              onToggle: null,
              onUnhandledRejection: null,
              onUnload: null,
              onVolumeChange: null,
              onWaiting: null,
              onWheel: null,
              open: boolean,
              optimum: number,
              pattern: null,
              ping: spaceSeparated,
              placeholder: null,
              playsInline: boolean,
              poster: null,
              preload: null,
              readOnly: boolean,
              referrerPolicy: null,
              rel: spaceSeparated,
              required: boolean,
              reversed: boolean,
              rows: number,
              rowSpan: number,
              sandbox: spaceSeparated,
              scope: null,
              scoped: boolean,
              seamless: boolean,
              selected: boolean,
              shape: null,
              size: number,
              sizes: null,
              slot: null,
              span: number,
              spellCheck: booleanish,
              src: null,
              srcDoc: null,
              srcLang: null,
              srcSet: commaSeparated,
              start: number,
              step: null,
              style: null,
              tabIndex: number,
              target: null,
              title: null,
              translate: null,
              type: null,
              typeMustMatch: boolean,
              useMap: null,
              value: booleanish,
              width: number,
              wrap: null,
              // Legacy.
              // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
              align: null,
              // Several. Use CSS `text-align` instead,
              aLink: null,
              // `<body>`. Use CSS `a:active {color}` instead
              archive: spaceSeparated,
              // `<object>`. List of URIs to archives
              axis: null,
              // `<td>` and `<th>`. Use `scope` on `<th>`
              background: null,
              // `<body>`. Use CSS `background-image` instead
              bgColor: null,
              // `<body>` and table elements. Use CSS `background-color` instead
              border: number,
              // `<table>`. Use CSS `border-width` instead,
              borderColor: null,
              // `<table>`. Use CSS `border-color` instead,
              bottomMargin: number,
              // `<body>`
              cellPadding: null,
              // `<table>`
              cellSpacing: null,
              // `<table>`
              char: null,
              // Several table elements. When `align=char`, sets the character to align on
              charOff: null,
              // Several table elements. When `char`, offsets the alignment
              classId: null,
              // `<object>`
              clear: null,
              // `<br>`. Use CSS `clear` instead
              code: null,
              // `<object>`
              codeBase: null,
              // `<object>`
              codeType: null,
              // `<object>`
              color: null,
              // `<font>` and `<hr>`. Use CSS instead
              compact: boolean,
              // Lists. Use CSS to reduce space between items instead
              declare: boolean,
              // `<object>`
              event: null,
              // `<script>`
              face: null,
              // `<font>`. Use CSS instead
              frame: null,
              // `<table>`
              frameBorder: null,
              // `<iframe>`. Use CSS `border` instead
              hSpace: number,
              // `<img>` and `<object>`
              leftMargin: number,
              // `<body>`
              link: null,
              // `<body>`. Use CSS `a:link {color: *}` instead
              longDesc: null,
              // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
              lowSrc: null,
              // `<img>`. Use a `<picture>`
              marginHeight: number,
              // `<body>`
              marginWidth: number,
              // `<body>`
              noResize: boolean,
              // `<frame>`
              noHref: boolean,
              // `<area>`. Use no href instead of an explicit `nohref`
              noShade: boolean,
              // `<hr>`. Use background-color and height instead of borders
              noWrap: boolean,
              // `<td>` and `<th>`
              object: null,
              // `<applet>`
              profile: null,
              // `<head>`
              prompt: null,
              // `<isindex>`
              rev: null,
              // `<link>`
              rightMargin: number,
              // `<body>`
              rules: null,
              // `<table>`
              scheme: null,
              // `<meta>`
              scrolling: booleanish,
              // `<frame>`. Use overflow in the child context
              standby: null,
              // `<object>`
              summary: null,
              // `<table>`
              text: null,
              // `<body>`. Use CSS `color` instead
              topMargin: number,
              // `<body>`
              valueType: null,
              // `<param>`
              version: null,
              // `<html>`. Use a doctype.
              vAlign: null,
              // Several. Use CSS `vertical-align` instead
              vLink: null,
              // `<body>`. Use CSS `a:visited {color}` instead
              vSpace: number,
              // `<img>` and `<object>`
              // Non-standard Properties.
              allowTransparency: null,
              autoCorrect: null,
              autoSave: null,
              disablePictureInPicture: boolean,
              disableRemotePlayback: boolean,
              prefix: null,
              property: null,
              results: number,
              security: null,
              unselectable: null
            }
          });
        }
      }), require_html2 = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/html.js"(exports, module) {
          "use strict";
          var merge3 = require_merge(), xlink = require_xlink(), xml = require_xml2(), xmlns = require_xmlns(), aria = require_aria(), html = require_html();
          module.exports = merge3([xml, xlink, xmlns, aria, html]);
        }
      }), require_find = __commonJS2({
        "../node_modules/hastscript/node_modules/property-information/find.js"(exports, module) {
          "use strict";
          var normalize = require_normalize(), DefinedInfo = require_defined_info(), Info2 = require_info(), data = "data";
          module.exports = find2;
          var valid = /^data[-\w.:]+$/i, dash = /-[a-z]/g, cap = /[A-Z]/g;
          function find2(schema, value2) {
            var normal = normalize(value2), prop = value2, Type2 = Info2;
            return normal in schema.normal ? schema.property[schema.normal[normal]] : (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value2) && (value2.charAt(4) === "-" ? prop = datasetToProperty(value2) : value2 = datasetToAttribute(value2), Type2 = DefinedInfo), new Type2(prop, value2));
          }
          __name(find2, "find");
          function datasetToProperty(attribute) {
            var value2 = attribute.slice(5).replace(dash, camelcase);
            return data + value2.charAt(0).toUpperCase() + value2.slice(1);
          }
          __name(datasetToProperty, "datasetToProperty");
          function datasetToAttribute(property) {
            var value2 = property.slice(4);
            return dash.test(value2) ? property : (value2 = value2.replace(cap, kebab), value2.charAt(0) !== "-" && (value2 = "-" + value2), data + value2);
          }
          __name(datasetToAttribute, "datasetToAttribute");
          function kebab($0) {
            return "-" + $0.toLowerCase();
          }
          __name(kebab, "kebab");
          function camelcase($0) {
            return $0.charAt(1).toUpperCase();
          }
          __name(camelcase, "camelcase");
        }
      }), require_hast_util_parse_selector = __commonJS2({
        "../node_modules/hast-util-parse-selector/index.js"(exports, module) {
          "use strict";
          module.exports = parse5;
          var search = /[#.]/g;
          function parse5(selector, defaultTagName) {
            for (var value2 = selector || "", name = defaultTagName || "div", props = {}, start2 = 0, subvalue, previous, match2; start2 < value2.length; )
              search.lastIndex = start2, match2 = search.exec(value2), subvalue = value2.slice(start2, match2 ? match2.index : value2.length), subvalue && (previous ? previous === "#" ? props.id = subvalue : props.className ? props.className.push(subvalue) : props.className = [subvalue] : name = subvalue, start2 += subvalue.length), match2 && (previous = match2[0], start2++);
            return { type: "element", tagName: name, properties: props, children: [] };
          }
          __name(parse5, "parse");
        }
      }), require_space_separated_tokens = __commonJS2({
        "../node_modules/hastscript/node_modules/space-separated-tokens/index.js"(exports) {
          "use strict";
          exports.parse = parse5, exports.stringify = stringify4;
          var empty = "", space = " ", whiteSpace = /[ \t\n\r\f]+/g;
          function parse5(value2) {
            var input = String(value2 || empty).trim();
            return input === empty ? [] : input.split(whiteSpace);
          }
          __name(parse5, "parse");
          function stringify4(values) {
            return values.join(space).trim();
          }
          __name(stringify4, "stringify");
        }
      }), require_comma_separated_tokens = __commonJS2({
        "../node_modules/hastscript/node_modules/comma-separated-tokens/index.js"(exports) {
          "use strict";
          exports.parse = parse5, exports.stringify = stringify4;
          var comma = ",", space = " ", empty = "";
          function parse5(value2) {
            for (var values = [], input = String(value2 || empty), index3 = input.indexOf(comma), lastIndex = 0, end2 = !1, val; !end2; )
              index3 === -1 && (index3 = input.length, end2 = !0), val = input.slice(lastIndex, index3).trim(), (val || !end2) && values.push(val), lastIndex = index3 + 1, index3 = input.indexOf(comma, lastIndex);
            return values;
          }
          __name(parse5, "parse");
          function stringify4(values, options2) {
            var settings = options2 || {}, left2 = settings.padLeft === !1 ? empty : space, right2 = settings.padRight ? space : empty;
            return values[values.length - 1] === empty && (values = values.concat(empty)), values.join(right2 + comma + left2).trim();
          }
          __name(stringify4, "stringify");
        }
      }), require_factory = __commonJS2({
        "../node_modules/hastscript/factory.js"(exports, module) {
          "use strict";
          var find2 = require_find(), normalize = require_normalize(), parseSelector = require_hast_util_parse_selector(), spaces = require_space_separated_tokens().parse, commas = require_comma_separated_tokens().parse;
          module.exports = factory;
          var own = {}.hasOwnProperty;
          function factory(schema, defaultTagName, caseSensitive) {
            var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
            return h4;
            function h4(selector, properties) {
              var node = parseSelector(selector, defaultTagName), children = Array.prototype.slice.call(arguments, 2), name = node.tagName.toLowerCase(), property;
              if (node.tagName = adjust && own.call(adjust, name) ? adjust[name] : name, properties && isChildren(properties, node) && (children.unshift(properties), properties = null), properties)
                for (property in properties)
                  addProperty(node.properties, property, properties[property]);
              return addChild(node.children, children), node.tagName === "template" && (node.content = { type: "root", children: node.children }, node.children = []), node;
            }
            function addProperty(properties, key, value2) {
              var info, property, result;
              value2 == null || value2 !== value2 || (info = find2(schema, key), property = info.property, result = value2, typeof result == "string" && (info.spaceSeparated ? result = spaces(result) : info.commaSeparated ? result = commas(result) : info.commaOrSpaceSeparated && (result = spaces(commas(result).join(" ")))), property === "style" && typeof value2 != "string" && (result = style(result)), property === "className" && properties.className && (result = properties.className.concat(result)), properties[property] = parsePrimitives(info, property, result));
            }
          }
          __name(factory, "factory");
          function isChildren(value2, node) {
            return typeof value2 == "string" || "length" in value2 || isNode(node.tagName, value2);
          }
          __name(isChildren, "isChildren");
          function isNode(tagName, value2) {
            var type = value2.type;
            return tagName === "input" || !type || typeof type != "string" ? !1 : typeof value2.children == "object" && "length" in value2.children ? !0 : (type = type.toLowerCase(), tagName === "button" ? type !== "menu" && type !== "submit" && type !== "reset" && type !== "button" : "value" in value2);
          }
          __name(isNode, "isNode");
          function addChild(nodes, value2) {
            var index3, length2;
            if (typeof value2 == "string" || typeof value2 == "number") {
              nodes.push({ type: "text", value: String(value2) });
              return;
            }
            if (typeof value2 == "object" && "length" in value2) {
              for (index3 = -1, length2 = value2.length; ++index3 < length2; )
                addChild(nodes, value2[index3]);
              return;
            }
            if (typeof value2 != "object" || !("type" in value2))
              throw new Error("Expected node, nodes, or string, got `" + value2 + "`");
            nodes.push(value2);
          }
          __name(addChild, "addChild");
          function parsePrimitives(info, name, value2) {
            var index3, length2, result;
            if (typeof value2 != "object" || !("length" in value2))
              return parsePrimitive(info, name, value2);
            for (length2 = value2.length, index3 = -1, result = []; ++index3 < length2; )
              result[index3] = parsePrimitive(info, name, value2[index3]);
            return result;
          }
          __name(parsePrimitives, "parsePrimitives");
          function parsePrimitive(info, name, value2) {
            var result = value2;
            return info.number || info.positiveNumber ? !isNaN(result) && result !== "" && (result = Number(result)) : (info.boolean || info.overloadedBoolean) && typeof result == "string" && (result === "" || normalize(value2) === normalize(name)) && (result = !0), result;
          }
          __name(parsePrimitive, "parsePrimitive");
          function style(value2) {
            var result = [], key;
            for (key in value2)
              result.push([key, value2[key]].join(": "));
            return result.join("; ");
          }
          __name(style, "style");
          function createAdjustMap(values) {
            for (var length2 = values.length, index3 = -1, result = {}, value2; ++index3 < length2; )
              value2 = values[index3], result[value2.toLowerCase()] = value2;
            return result;
          }
          __name(createAdjustMap, "createAdjustMap");
        }
      }), require_html3 = __commonJS2({
        "../node_modules/hastscript/html.js"(exports, module) {
          "use strict";
          var schema = require_html2(), factory = require_factory(), html = factory(schema, "div");
          html.displayName = "html", module.exports = html;
        }
      }), require_hastscript = __commonJS2({
        "../node_modules/hastscript/index.js"(exports, module) {
          "use strict";
          module.exports = require_html3();
        }
      }), require_character_entities_legacy = __commonJS2({
        "../node_modules/refractor/node_modules/character-entities-legacy/index.json"(exports, module) {
          module.exports = {
            AElig: "\xC6",
            AMP: "&",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Agrave: "\xC0",
            Aring: "\xC5",
            Atilde: "\xC3",
            Auml: "\xC4",
            COPY: "\xA9",
            Ccedil: "\xC7",
            ETH: "\xD0",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Egrave: "\xC8",
            Euml: "\xCB",
            GT: ">",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Igrave: "\xCC",
            Iuml: "\xCF",
            LT: "<",
            Ntilde: "\xD1",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Ograve: "\xD2",
            Oslash: "\xD8",
            Otilde: "\xD5",
            Ouml: "\xD6",
            QUOT: '"',
            REG: "\xAE",
            THORN: "\xDE",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Ugrave: "\xD9",
            Uuml: "\xDC",
            Yacute: "\xDD",
            aacute: "\xE1",
            acirc: "\xE2",
            acute: "\xB4",
            aelig: "\xE6",
            agrave: "\xE0",
            amp: "&",
            aring: "\xE5",
            atilde: "\xE3",
            auml: "\xE4",
            brvbar: "\xA6",
            ccedil: "\xE7",
            cedil: "\xB8",
            cent: "\xA2",
            copy: "\xA9",
            curren: "\xA4",
            deg: "\xB0",
            divide: "\xF7",
            eacute: "\xE9",
            ecirc: "\xEA",
            egrave: "\xE8",
            eth: "\xF0",
            euml: "\xEB",
            frac12: "\xBD",
            frac14: "\xBC",
            frac34: "\xBE",
            gt: ">",
            iacute: "\xED",
            icirc: "\xEE",
            iexcl: "\xA1",
            igrave: "\xEC",
            iquest: "\xBF",
            iuml: "\xEF",
            laquo: "\xAB",
            lt: "<",
            macr: "\xAF",
            micro: "\xB5",
            middot: "\xB7",
            nbsp: "\xA0",
            not: "\xAC",
            ntilde: "\xF1",
            oacute: "\xF3",
            ocirc: "\xF4",
            ograve: "\xF2",
            ordf: "\xAA",
            ordm: "\xBA",
            oslash: "\xF8",
            otilde: "\xF5",
            ouml: "\xF6",
            para: "\xB6",
            plusmn: "\xB1",
            pound: "\xA3",
            quot: '"',
            raquo: "\xBB",
            reg: "\xAE",
            sect: "\xA7",
            shy: "\xAD",
            sup1: "\xB9",
            sup2: "\xB2",
            sup3: "\xB3",
            szlig: "\xDF",
            thorn: "\xFE",
            times: "\xD7",
            uacute: "\xFA",
            ucirc: "\xFB",
            ugrave: "\xF9",
            uml: "\xA8",
            uuml: "\xFC",
            yacute: "\xFD",
            yen: "\xA5",
            yuml: "\xFF"
          };
        }
      }), require_character_reference_invalid = __commonJS2({
        "../node_modules/refractor/node_modules/character-reference-invalid/index.json"(exports, module) {
          module.exports = {
            0: "\uFFFD",
            128: "\u20AC",
            130: "\u201A",
            131: "\u0192",
            132: "\u201E",
            133: "\u2026",
            134: "\u2020",
            135: "\u2021",
            136: "\u02C6",
            137: "\u2030",
            138: "\u0160",
            139: "\u2039",
            140: "\u0152",
            142: "\u017D",
            145: "\u2018",
            146: "\u2019",
            147: "\u201C",
            148: "\u201D",
            149: "\u2022",
            150: "\u2013",
            151: "\u2014",
            152: "\u02DC",
            153: "\u2122",
            154: "\u0161",
            155: "\u203A",
            156: "\u0153",
            158: "\u017E",
            159: "\u0178"
          };
        }
      }), require_is_decimal = __commonJS2({
        "../node_modules/refractor/node_modules/is-decimal/index.js"(exports, module) {
          "use strict";
          module.exports = decimal;
          function decimal(character) {
            var code = typeof character == "string" ? character.charCodeAt(0) : character;
            return code >= 48 && code <= 57;
          }
          __name(decimal, "decimal");
        }
      }), require_is_hexadecimal = __commonJS2({
        "../node_modules/refractor/node_modules/is-hexadecimal/index.js"(exports, module) {
          "use strict";
          module.exports = hexadecimal;
          function hexadecimal(character) {
            var code = typeof character == "string" ? character.charCodeAt(0) : character;
            return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
          }
          __name(hexadecimal, "hexadecimal");
        }
      }), require_is_alphabetical = __commonJS2({
        "../node_modules/refractor/node_modules/is-alphabetical/index.js"(exports, module) {
          "use strict";
          module.exports = alphabetical;
          function alphabetical(character) {
            var code = typeof character == "string" ? character.charCodeAt(0) : character;
            return code >= 97 && code <= 122 || code >= 65 && code <= 90;
          }
          __name(alphabetical, "alphabetical");
        }
      }), require_is_alphanumerical = __commonJS2({
        "../node_modules/refractor/node_modules/is-alphanumerical/index.js"(exports, module) {
          "use strict";
          var alphabetical = require_is_alphabetical(), decimal = require_is_decimal();
          module.exports = alphanumerical;
          function alphanumerical(character) {
            return alphabetical(character) || decimal(character);
          }
          __name(alphanumerical, "alphanumerical");
        }
      }), require_decode_entity_browser = __commonJS2({
        "../node_modules/refractor/node_modules/parse-entities/decode-entity.browser.js"(exports, module) {
          "use strict";
          var el, semicolon = 59;
          module.exports = decodeEntity;
          function decodeEntity(characters) {
            var entity = "&" + characters + ";", char;
            return el = el || document.createElement("i"), el.innerHTML = entity, char = el.textContent, char.charCodeAt(char.length - 1) === semicolon && characters !== "semi" || char === entity ? !1 : char;
          }
          __name(decodeEntity, "decodeEntity");
        }
      }), require_parse_entities = __commonJS2({
        "../node_modules/refractor/node_modules/parse-entities/index.js"(exports, module) {
          "use strict";
          var legacy = require_character_entities_legacy(), invalid = require_character_reference_invalid(), decimal = require_is_decimal(), hexadecimal = require_is_hexadecimal(), alphanumerical = require_is_alphanumerical(), decodeEntity = require_decode_entity_browser();
          module.exports = parseEntities;
          var own = {}.hasOwnProperty, fromCharCode = String.fromCharCode, noop6 = Function.prototype, defaults = {
            warning: null,
            reference: null,
            text: null,
            warningContext: null,
            referenceContext: null,
            textContext: null,
            position: {},
            additional: null,
            attribute: !1,
            nonTerminated: !0
          }, tab = 9, lineFeed = 10, formFeed = 12, space = 32, ampersand = 38, semicolon = 59, lessThan = 60, equalsTo = 61, numberSign = 35, uppercaseX = 88, lowercaseX = 120, replacementCharacter = 65533, name = "named", hexa = "hexadecimal", deci = "decimal", bases = {};
          bases[hexa] = 16, bases[deci] = 10;
          var tests = {};
          tests[name] = alphanumerical, tests[deci] = decimal, tests[hexa] = hexadecimal;
          var namedNotTerminated = 1, numericNotTerminated = 2, namedEmpty = 3, numericEmpty = 4, namedUnknown = 5, numericDisallowed = 6, numericProhibited = 7, messages = {};
          messages[namedNotTerminated] = "Named character references must be terminated by a semicolon", messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon", messages[namedEmpty] = "Named character references cannot be empty", messages[numericEmpty] = "Numeric character references cannot be empty", messages[namedUnknown] = "Named character references must be known", messages[numericDisallowed] = "Numeric character references cannot be disallowed", messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
          function parseEntities(value2, options2) {
            var settings = {}, option, key;
            options2 || (options2 = {});
            for (key in defaults)
              option = options2[key], settings[key] = option ?? defaults[key];
            return (settings.position.indent || settings.position.start) && (settings.indent = settings.position.indent || [], settings.position = settings.position.start), parse5(value2, settings);
          }
          __name(parseEntities, "parseEntities");
          function parse5(value2, settings) {
            var additional = settings.additional, nonTerminated = settings.nonTerminated, handleText = settings.text, handleReference = settings.reference, handleWarning = settings.warning, textContext = settings.textContext, referenceContext = settings.referenceContext, warningContext = settings.warningContext, pos = settings.position, indent = settings.indent || [], length2 = value2.length, index3 = 0, lines = -1, column = pos.column || 1, line = pos.line || 1, queue = "", result = [], entityCharacters, namedEntity, terminated, characters, character, reference2, following, warning, reason, output, entity, begin, start2, type, test2, prev, next, diff2, end2;
            for (typeof additional == "string" && (additional = additional.charCodeAt(0)), prev = now(), warning = handleWarning ? parseError : noop6, index3--, length2++; ++index3 < length2; )
              if (character === lineFeed && (column = indent[lines] || 1), character = value2.charCodeAt(index3), character === ampersand) {
                if (following = value2.charCodeAt(index3 + 1), following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
                  queue += fromCharCode(character), column++;
                  continue;
                }
                for (start2 = index3 + 1, begin = start2, end2 = start2, following === numberSign ? (end2 = ++begin, following = value2.charCodeAt(end2), following === uppercaseX || following === lowercaseX ? (type = hexa, end2 = ++begin) : type = deci) : type = name, entityCharacters = "", entity = "", characters = "", test2 = tests[type], end2--; ++end2 < length2 && (following = value2.charCodeAt(end2), !!test2(following)); )
                  characters += fromCharCode(following), type === name && own.call(legacy, characters) && (entityCharacters = characters, entity = legacy[characters]);
                terminated = value2.charCodeAt(end2) === semicolon, terminated && (end2++, namedEntity = type === name ? decodeEntity(characters) : !1, namedEntity && (entityCharacters = characters, entity = namedEntity)), diff2 = 1 + end2 - start2, !terminated && !nonTerminated || (characters ? type === name ? (terminated && !entity ? warning(namedUnknown, 1) : (entityCharacters !== characters && (end2 = begin + entityCharacters.length, diff2 = 1 + end2 - begin, terminated = !1), terminated || (reason = entityCharacters ? namedNotTerminated : namedEmpty, settings.attribute ? (following = value2.charCodeAt(end2), following === equalsTo ? (warning(reason, diff2), entity = null) : alphanumerical(following) ? entity = null : warning(reason, diff2)) : warning(reason, diff2))), reference2 = entity) : (terminated || warning(numericNotTerminated, diff2), reference2 = parseInt(characters, bases[type]), prohibited(reference2) ? (warning(numericProhibited, diff2), reference2 = fromCharCode(replacementCharacter)) : reference2 in invalid ? (warning(numericDisallowed, diff2), reference2 = invalid[reference2]) : (output = "", disallowed(reference2) && warning(numericDisallowed, diff2), reference2 > 65535 && (reference2 -= 65536, output += fromCharCode(reference2 >>> 10 | 55296), reference2 = 56320 | reference2 & 1023), reference2 = output + fromCharCode(reference2))) : type !== name && warning(numericEmpty, diff2)), reference2 ? (flush(), prev = now(), index3 = end2 - 1, column += end2 - start2 + 1, result.push(reference2), next = now(), next.offset++, handleReference && handleReference.call(
                  referenceContext,
                  reference2,
                  { start: prev, end: next },
                  value2.slice(start2 - 1, end2)
                ), prev = next) : (characters = value2.slice(start2 - 1, end2), queue += characters, column += characters.length, index3 = end2 - 1);
              } else
                character === 10 && (line++, lines++, column = 0), character === character ? (queue += fromCharCode(character), column++) : flush();
            return result.join("");
            function now() {
              return {
                line,
                column,
                offset: index3 + (pos.offset || 0)
              };
            }
            function parseError(code, offset3) {
              var position = now();
              position.column += offset3, position.offset += offset3, handleWarning.call(warningContext, messages[code], position, code);
            }
            function flush() {
              queue && (result.push(queue), handleText && handleText.call(textContext, queue, { start: prev, end: now() }), queue = "");
            }
          }
          __name(parse5, "parse");
          function prohibited(code) {
            return code >= 55296 && code <= 57343 || code > 1114111;
          }
          __name(prohibited, "prohibited");
          function disallowed(code) {
            return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
          }
          __name(disallowed, "disallowed");
        }
      }), require_prism_core = __commonJS2({
        "../node_modules/refractor/node_modules/prismjs/components/prism-core.js"(exports, module) {
          var _self = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {}, Prism = (function(_self2) {
            var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, uniqueId = 0, plainTextGrammar = {}, _3 = {
              /**
               * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
               * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
               * additional languages or plugins yourself.
               *
               * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
               *
               * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
               * empty Prism object into the global scope before loading the Prism script like this:
               *
               * ```js
               * window.Prism = window.Prism || {};
               * Prism.manual = true;
               * // add a new <script> to load Prism's script
               * ```
               *
               * @default false
               * @type {boolean}
               * @memberof Prism
               * @public
               */
              manual: _self2.Prism && _self2.Prism.manual,
              /**
               * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
               * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
               * own worker, you don't want it to do this.
               *
               * By setting this value to `true`, Prism will not add its own listeners to the worker.
               *
               * You obviously have to change this value before Prism executes. To do this, you can add an
               * empty Prism object into the global scope before loading the Prism script like this:
               *
               * ```js
               * window.Prism = window.Prism || {};
               * Prism.disableWorkerMessageHandler = true;
               * // Load Prism's script
               * ```
               *
               * @default false
               * @type {boolean}
               * @memberof Prism
               * @public
               */
              disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
              /**
               * A namespace for utility methods.
               *
               * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
               * change or disappear at any time.
               *
               * @namespace
               * @memberof Prism
               */
              util: {
                encode: __name(function encode(tokens) {
                  return tokens instanceof Token ? new Token(tokens.type, encode(tokens.content), tokens.alias) : Array.isArray(tokens) ? tokens.map(encode) : tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
                }, "encode"),
                /**
                 * Returns the name of the type of the given value.
                 *
                 * @param {any} o
                 * @returns {string}
                 * @example
                 * type(null)      === 'Null'
                 * type(undefined) === 'Undefined'
                 * type(123)       === 'Number'
                 * type('foo')     === 'String'
                 * type(true)      === 'Boolean'
                 * type([1, 2])    === 'Array'
                 * type({})        === 'Object'
                 * type(String)    === 'Function'
                 * type(/abc+/)    === 'RegExp'
                 */
                type: __name(function(o2) {
                  return Object.prototype.toString.call(o2).slice(8, -1);
                }, "type"),
                /**
                 * Returns a unique number for the given object. Later calls will still return the same number.
                 *
                 * @param {Object} obj
                 * @returns {number}
                 */
                objId: __name(function(obj) {
                  return obj.__id || Object.defineProperty(obj, "__id", { value: ++uniqueId }), obj.__id;
                }, "objId"),
                /**
                 * Creates a deep clone of the given object.
                 *
                 * The main intended use of this function is to clone language definitions.
                 *
                 * @param {T} o
                 * @param {Record<number, any>} [visited]
                 * @returns {T}
                 * @template T
                 */
                clone: __name(function deepClone2(o2, visited) {
                  visited = visited || {};
                  var clone2, id2;
                  switch (_3.util.type(o2)) {
                    case "Object":
                      if (id2 = _3.util.objId(o2), visited[id2])
                        return visited[id2];
                      clone2 = /** @type {Record<string, any>} */
                      {}, visited[id2] = clone2;
                      for (var key in o2)
                        o2.hasOwnProperty(key) && (clone2[key] = deepClone2(o2[key], visited));
                      return (
                        /** @type {any} */
                        clone2
                      );
                    case "Array":
                      return id2 = _3.util.objId(o2), visited[id2] ? visited[id2] : (clone2 = [], visited[id2] = clone2, o2.forEach(function(v3, i3) {
                        clone2[i3] = deepClone2(v3, visited);
                      }), /** @type {any} */
                      clone2);
                    default:
                      return o2;
                  }
                }, "deepClone"),
                /**
                 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
                 *
                 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
                 *
                 * @param {Element} element
                 * @returns {string}
                 */
                getLanguage: __name(function(element) {
                  for (; element; ) {
                    var m3 = lang.exec(element.className);
                    if (m3)
                      return m3[1].toLowerCase();
                    element = element.parentElement;
                  }
                  return "none";
                }, "getLanguage"),
                /**
                 * Sets the Prism `language-xxxx` class of the given element.
                 *
                 * @param {Element} element
                 * @param {string} language
                 * @returns {void}
                 */
                setLanguage: __name(function(element, language) {
                  element.className = element.className.replace(RegExp(lang, "gi"), ""), element.classList.add("language-" + language);
                }, "setLanguage"),
                /**
                 * Returns the script element that is currently executing.
                 *
                 * This does __not__ work for line script element.
                 *
                 * @returns {HTMLScriptElement | null}
                 */
                currentScript: __name(function() {
                  if (typeof document > "u")
                    return null;
                  if ("currentScript" in document)
                    return (
                      /** @type {any} */
                      document.currentScript
                    );
                  try {
                    throw new Error();
                  } catch (err) {
                    var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                      var scripts = document.getElementsByTagName("script");
                      for (var i3 in scripts)
                        if (scripts[i3].src == src)
                          return scripts[i3];
                    }
                    return null;
                  }
                }, "currentScript"),
                /**
                 * Returns whether a given class is active for `element`.
                 *
                 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
                 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
                 * given class is just the given class with a `no-` prefix.
                 *
                 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
                 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
                 * ancestors have the given class or the negated version of it, then the default activation will be returned.
                 *
                 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
                 * version of it, the class is considered active.
                 *
                 * @param {Element} element
                 * @param {string} className
                 * @param {boolean} [defaultActivation=false]
                 * @returns {boolean}
                 */
                isActive: __name(function(element, className, defaultActivation) {
                  for (var no = "no-" + className; element; ) {
                    var classList = element.classList;
                    if (classList.contains(className))
                      return !0;
                    if (classList.contains(no))
                      return !1;
                    element = element.parentElement;
                  }
                  return !!defaultActivation;
                }, "isActive")
              },
              /**
               * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
               *
               * @namespace
               * @memberof Prism
               * @public
               */
              languages: {
                /**
                 * The grammar for plain, unformatted text.
                 */
                plain: plainTextGrammar,
                plaintext: plainTextGrammar,
                text: plainTextGrammar,
                txt: plainTextGrammar,
                /**
                 * Creates a deep copy of the language with the given id and appends the given tokens.
                 *
                 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
                 * will be overwritten at its original position.
                 *
                 * ## Best practices
                 *
                 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
                 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
                 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
                 *
                 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
                 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
                 *
                 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
                 * @param {Grammar} redef The new tokens to append.
                 * @returns {Grammar} The new language created.
                 * @public
                 * @example
                 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
                 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
                 *     // at its original position
                 *     'comment': { ... },
                 *     // CSS doesn't have a 'color' token, so this token will be appended
                 *     'color': /\b(?:red|green|blue)\b/
                 * });
                 */
                extend: __name(function(id2, redef) {
                  var lang2 = _3.util.clone(_3.languages[id2]);
                  for (var key in redef)
                    lang2[key] = redef[key];
                  return lang2;
                }, "extend"),
                /**
                 * Inserts tokens _before_ another token in a language definition or any other grammar.
                 *
                 * ## Usage
                 *
                 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
                 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
                 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
                 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
                 * this:
                 *
                 * ```js
                 * Prism.languages.markup.style = {
                 *     // token
                 * };
                 * ```
                 *
                 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
                 * before existing tokens. For the CSS example above, you would use it like this:
                 *
                 * ```js
                 * Prism.languages.insertBefore('markup', 'cdata', {
                 *     'style': {
                 *         // token
                 *     }
                 * });
                 * ```
                 *
                 * ## Special cases
                 *
                 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
                 * will be ignored.
                 *
                 * This behavior can be used to insert tokens after `before`:
                 *
                 * ```js
                 * Prism.languages.insertBefore('markup', 'comment', {
                 *     'comment': Prism.languages.markup.comment,
                 *     // tokens after 'comment'
                 * });
                 * ```
                 *
                 * ## Limitations
                 *
                 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
                 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
                 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
                 * deleting properties which is necessary to insert at arbitrary positions.
                 *
                 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
                 * Instead, it will create a new object and replace all references to the target object with the new one. This
                 * can be done without temporarily deleting properties, so the iteration order is well-defined.
                 *
                 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
                 * you hold the target object in a variable, then the value of the variable will not change.
                 *
                 * ```js
                 * var oldMarkup = Prism.languages.markup;
                 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
                 *
                 * assert(oldMarkup !== Prism.languages.markup);
                 * assert(newMarkup === Prism.languages.markup);
                 * ```
                 *
                 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
                 * object to be modified.
                 * @param {string} before The key to insert before.
                 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
                 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
                 * object to be modified.
                 *
                 * Defaults to `Prism.languages`.
                 * @returns {Grammar} The new grammar object.
                 * @public
                 */
                insertBefore: __name(function(inside, before, insert, root) {
                  root = root || /** @type {any} */
                  _3.languages;
                  var grammar = root[inside], ret = {};
                  for (var token in grammar)
                    if (grammar.hasOwnProperty(token)) {
                      if (token == before)
                        for (var newToken in insert)
                          insert.hasOwnProperty(newToken) && (ret[newToken] = insert[newToken]);
                      insert.hasOwnProperty(token) || (ret[token] = grammar[token]);
                    }
                  var old = root[inside];
                  return root[inside] = ret, _3.languages.DFS(_3.languages, function(key, value2) {
                    value2 === old && key != inside && (this[key] = ret);
                  }), ret;
                }, "insertBefore"),
                // Traverse a language definition with Depth First Search
                DFS: __name(function DFS(o2, callback, type, visited) {
                  visited = visited || {};
                  var objId = _3.util.objId;
                  for (var i3 in o2)
                    if (o2.hasOwnProperty(i3)) {
                      callback.call(o2, i3, o2[i3], type || i3);
                      var property = o2[i3], propertyType = _3.util.type(property);
                      propertyType === "Object" && !visited[objId(property)] ? (visited[objId(property)] = !0, DFS(property, callback, null, visited)) : propertyType === "Array" && !visited[objId(property)] && (visited[objId(property)] = !0, DFS(property, callback, i3, visited));
                    }
                }, "DFS")
              },
              plugins: {},
              /**
               * This is the most high-level function in Prisms API.
               * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
               * each one of them.
               *
               * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
               *
               * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
               * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
               * @memberof Prism
               * @public
               */
              highlightAll: __name(function(async, callback) {
                _3.highlightAllUnder(document, async, callback);
              }, "highlightAll"),
              /**
               * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
               * {@link Prism.highlightElement} on each one of them.
               *
               * The following hooks will be run:
               * 1. `before-highlightall`
               * 2. `before-all-elements-highlight`
               * 3. All hooks of {@link Prism.highlightElement} for each element.
               *
               * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
               * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
               * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
               * @memberof Prism
               * @public
               */
              highlightAllUnder: __name(function(container, async, callback) {
                var env = {
                  callback,
                  container,
                  selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                };
                _3.hooks.run("before-highlightall", env), env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector)), _3.hooks.run("before-all-elements-highlight", env);
                for (var i3 = 0, element; element = env.elements[i3++]; )
                  _3.highlightElement(element, async === !0, env.callback);
              }, "highlightAllUnder"),
              /**
               * Highlights the code inside a single element.
               *
               * The following hooks will be run:
               * 1. `before-sanity-check`
               * 2. `before-highlight`
               * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
               * 4. `before-insert`
               * 5. `after-highlight`
               * 6. `complete`
               *
               * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
               * the element's language.
               *
               * @param {Element} element The element containing the code.
               * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
               * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
               * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
               * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
               *
               * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
               * asynchronous highlighting to work. You can build your own bundle on the
               * [Download page](https://prismjs.com/download.html).
               * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
               * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
               * @memberof Prism
               * @public
               */
              highlightElement: __name(function(element, async, callback) {
                var language = _3.util.getLanguage(element), grammar = _3.languages[language];
                _3.util.setLanguage(element, language);
                var parent = element.parentElement;
                parent && parent.nodeName.toLowerCase() === "pre" && _3.util.setLanguage(parent, language);
                var code = element.textContent, env = {
                  element,
                  language,
                  grammar,
                  code
                };
                function insertHighlightedCode(highlightedCode) {
                  env.highlightedCode = highlightedCode, _3.hooks.run("before-insert", env), env.element.innerHTML = env.highlightedCode, _3.hooks.run("after-highlight", env), _3.hooks.run("complete", env), callback && callback.call(env.element);
                }
                if (__name(insertHighlightedCode, "insertHighlightedCode"), _3.hooks.run("before-sanity-check", env), parent = env.element.parentElement, parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex") && parent.setAttribute("tabindex", "0"), !env.code) {
                  _3.hooks.run("complete", env), callback && callback.call(env.element);
                  return;
                }
                if (_3.hooks.run("before-highlight", env), !env.grammar) {
                  insertHighlightedCode(_3.util.encode(env.code));
                  return;
                }
                if (async && _self2.Worker) {
                  var worker = new Worker(_3.filename);
                  worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                  }, worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: !0
                  }));
                } else
                  insertHighlightedCode(_3.highlight(env.code, env.grammar, env.language));
              }, "highlightElement"),
              /**
               * Low-level function, only use if you know what youre doing. It accepts a string of text as input
               * and the language definitions to use, and returns a string with the HTML produced.
               *
               * The following hooks will be run:
               * 1. `before-tokenize`
               * 2. `after-tokenize`
               * 3. `wrap`: On each {@link Token}.
               *
               * @param {string} text A string with the code to be highlighted.
               * @param {Grammar} grammar An object containing the tokens to use.
               *
               * Usually a language definition like `Prism.languages.markup`.
               * @param {string} language The name of the language definition passed to `grammar`.
               * @returns {string} The highlighted HTML.
               * @memberof Prism
               * @public
               * @example
               * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
               */
              highlight: __name(function(text, grammar, language) {
                var env = {
                  code: text,
                  grammar,
                  language
                };
                if (_3.hooks.run("before-tokenize", env), !env.grammar)
                  throw new Error('The language "' + env.language + '" has no grammar.');
                return env.tokens = _3.tokenize(env.code, env.grammar), _3.hooks.run("after-tokenize", env), Token.stringify(_3.util.encode(env.tokens), env.language);
              }, "highlight"),
              /**
               * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
               * and the language definitions to use, and returns an array with the tokenized code.
               *
               * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
               *
               * This method could be useful in other contexts as well, as a very crude parser.
               *
               * @param {string} text A string with the code to be highlighted.
               * @param {Grammar} grammar An object containing the tokens to use.
               *
               * Usually a language definition like `Prism.languages.markup`.
               * @returns {TokenStream} An array of strings and tokens, a token stream.
               * @memberof Prism
               * @public
               * @example
               * let code = `var foo = 0;`;
               * let tokens = Prism.tokenize(code, Prism.languages.javascript);
               * tokens.forEach(token => {
               *     if (token instanceof Prism.Token && token.type === 'number') {
               *         console.log(`Found numeric literal: ${token.content}`);
               *     }
               * });
               */
              tokenize: __name(function(text, grammar) {
                var rest = grammar.rest;
                if (rest) {
                  for (var token in rest)
                    grammar[token] = rest[token];
                  delete grammar.rest;
                }
                var tokenList = new LinkedList();
                return addAfter(tokenList, tokenList.head, text), matchGrammar(text, tokenList, grammar, tokenList.head, 0), toArray(tokenList);
              }, "tokenize"),
              /**
               * @namespace
               * @memberof Prism
               * @public
               */
              hooks: {
                all: {},
                /**
                 * Adds the given callback to the list of callbacks for the given hook.
                 *
                 * The callback will be invoked when the hook it is registered for is run.
                 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
                 *
                 * One callback function can be registered to multiple hooks and the same hook multiple times.
                 *
                 * @param {string} name The name of the hook.
                 * @param {HookCallback} callback The callback function which is given environment variables.
                 * @public
                 */
                add: __name(function(name, callback) {
                  var hooks = _3.hooks.all;
                  hooks[name] = hooks[name] || [], hooks[name].push(callback);
                }, "add"),
                /**
                 * Runs a hook invoking all registered callbacks with the given environment variables.
                 *
                 * Callbacks will be invoked synchronously and in the order in which they were registered.
                 *
                 * @param {string} name The name of the hook.
                 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
                 * @public
                 */
                run: __name(function(name, env) {
                  var callbacks = _3.hooks.all[name];
                  if (!(!callbacks || !callbacks.length))
                    for (var i3 = 0, callback; callback = callbacks[i3++]; )
                      callback(env);
                }, "run")
              },
              Token
            };
            _self2.Prism = _3;
            function Token(type, content, alias, matchedStr) {
              this.type = type, this.content = content, this.alias = alias, this.length = (matchedStr || "").length | 0;
            }
            __name(Token, "Token"), Token.stringify = __name(function stringify4(o2, language) {
              if (typeof o2 == "string")
                return o2;
              if (Array.isArray(o2)) {
                var s4 = "";
                return o2.forEach(function(e) {
                  s4 += stringify4(e, language);
                }), s4;
              }
              var env = {
                type: o2.type,
                content: stringify4(o2.content, language),
                tag: "span",
                classes: ["token", o2.type],
                attributes: {},
                language
              }, aliases = o2.alias;
              aliases && (Array.isArray(aliases) ? Array.prototype.push.apply(env.classes, aliases) : env.classes.push(aliases)), _3.hooks.run("wrap", env);
              var attributes = "";
              for (var name in env.attributes)
                attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
              return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
            }, "stringify");
            function matchPattern(pattern, pos, text, lookbehind) {
              pattern.lastIndex = pos;
              var match2 = pattern.exec(text);
              if (match2 && lookbehind && match2[1]) {
                var lookbehindLength = match2[1].length;
                match2.index += lookbehindLength, match2[0] = match2[0].slice(lookbehindLength);
              }
              return match2;
            }
            __name(matchPattern, "matchPattern");
            function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
              for (var token in grammar)
                if (!(!grammar.hasOwnProperty(token) || !grammar[token])) {
                  var patterns = grammar[token];
                  patterns = Array.isArray(patterns) ? patterns : [patterns];
                  for (var j2 = 0; j2 < patterns.length; ++j2) {
                    if (rematch && rematch.cause == token + "," + j2)
                      return;
                    var patternObj = patterns[j2], inside = patternObj.inside, lookbehind = !!patternObj.lookbehind, greedy = !!patternObj.greedy, alias = patternObj.alias;
                    if (greedy && !patternObj.pattern.global) {
                      var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                      patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                    }
                    for (var pattern = patternObj.pattern || patternObj, currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail && !(rematch && pos >= rematch.reach); pos += currentNode.value.length, currentNode = currentNode.next) {
                      var str2 = currentNode.value;
                      if (tokenList.length > text.length)
                        return;
                      if (!(str2 instanceof Token)) {
                        var removeCount = 1, match2;
                        if (greedy) {
                          if (match2 = matchPattern(pattern, pos, text, lookbehind), !match2 || match2.index >= text.length)
                            break;
                          var from = match2.index, to = match2.index + match2[0].length, p4 = pos;
                          for (p4 += currentNode.value.length; from >= p4; )
                            currentNode = currentNode.next, p4 += currentNode.value.length;
                          if (p4 -= currentNode.value.length, pos = p4, currentNode.value instanceof Token)
                            continue;
                          for (var k3 = currentNode; k3 !== tokenList.tail && (p4 < to || typeof k3.value == "string"); k3 = k3.next)
                            removeCount++, p4 += k3.value.length;
                          removeCount--, str2 = text.slice(pos, p4), match2.index -= pos;
                        } else if (match2 = matchPattern(pattern, 0, str2, lookbehind), !match2)
                          continue;
                        var from = match2.index, matchStr = match2[0], before = str2.slice(0, from), after = str2.slice(from + matchStr.length), reach = pos + str2.length;
                        rematch && reach > rematch.reach && (rematch.reach = reach);
                        var removeFrom = currentNode.prev;
                        before && (removeFrom = addAfter(tokenList, removeFrom, before), pos += before.length), removeRange(tokenList, removeFrom, removeCount);
                        var wrapped = new Token(token, inside ? _3.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                        if (currentNode = addAfter(tokenList, removeFrom, wrapped), after && addAfter(tokenList, currentNode, after), removeCount > 1) {
                          var nestedRematch = {
                            cause: token + "," + j2,
                            reach
                          };
                          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch), rematch && nestedRematch.reach > rematch.reach && (rematch.reach = nestedRematch.reach);
                        }
                      }
                    }
                  }
                }
            }
            __name(matchGrammar, "matchGrammar");
            function LinkedList() {
              var head = { value: null, prev: null, next: null }, tail = { value: null, prev: head, next: null };
              head.next = tail, this.head = head, this.tail = tail, this.length = 0;
            }
            __name(LinkedList, "LinkedList");
            function addAfter(list, node, value2) {
              var next = node.next, newNode = { value: value2, prev: node, next };
              return node.next = newNode, next.prev = newNode, list.length++, newNode;
            }
            __name(addAfter, "addAfter");
            function removeRange(list, node, count3) {
              for (var next = node.next, i3 = 0; i3 < count3 && next !== list.tail; i3++)
                next = next.next;
              node.next = next, next.prev = node, list.length -= i3;
            }
            __name(removeRange, "removeRange");
            function toArray(list) {
              for (var array2 = [], node = list.head.next; node !== list.tail; )
                array2.push(node.value), node = node.next;
              return array2;
            }
            if (__name(toArray, "toArray"), !_self2.document)
              return _self2.addEventListener && (_3.disableWorkerMessageHandler || _self2.addEventListener("message", function(evt) {
                var message = JSON.parse(evt.data), lang2 = message.language, code = message.code, immediateClose = message.immediateClose;
                _self2.postMessage(_3.highlight(code, _3.languages[lang2], lang2)), immediateClose && _self2.close();
              }, !1)), _3;
            var script = _3.util.currentScript();
            script && (_3.filename = script.src, script.hasAttribute("data-manual") && (_3.manual = !0));
            function highlightAutomaticallyCallback() {
              _3.manual || _3.highlightAll();
            }
            if (__name(highlightAutomaticallyCallback, "highlightAutomaticallyCallback"), !_3.manual) {
              var readyState = document.readyState;
              readyState === "loading" || readyState === "interactive" && script && script.defer ? document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback) : window.requestAnimationFrame ? window.requestAnimationFrame(highlightAutomaticallyCallback) : window.setTimeout(highlightAutomaticallyCallback, 16);
            }
            return _3;
          })(_self);
          typeof module < "u" && module.exports && (module.exports = Prism), typeof window < "u" && (window.Prism = Prism);
        }
      }), require_clike = __commonJS2({
        "../node_modules/refractor/lang/clike.js"(exports, module) {
          "use strict";
          module.exports = clike, clike.displayName = "clike", clike.aliases = [];
          function clike(Prism) {
            Prism.languages.clike = {
              comment: [
                {
                  pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                  lookbehind: !0,
                  greedy: !0
                },
                {
                  pattern: /(^|[^\\:])\/\/.*/,
                  lookbehind: !0,
                  greedy: !0
                }
              ],
              string: {
                pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                greedy: !0
              },
              "class-name": {
                pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
                lookbehind: !0,
                inside: {
                  punctuation: /[.\\]/
                }
              },
              keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
              boolean: /\b(?:false|true)\b/,
              function: /\b\w+(?=\()/,
              number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
              operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
              punctuation: /[{}[\];(),.:]/
            };
          }
          __name(clike, "clike");
        }
      }), require_javascript = __commonJS2({
        "../node_modules/refractor/lang/javascript.js"(exports, module) {
          "use strict";
          module.exports = javascript, javascript.displayName = "javascript", javascript.aliases = ["js"];
          function javascript(Prism) {
            Prism.languages.javascript = Prism.languages.extend("clike", {
              "class-name": [
                Prism.languages.clike["class-name"],
                {
                  pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
                  lookbehind: !0
                }
              ],
              keyword: [
                {
                  pattern: /((?:^|\})\s*)catch\b/,
                  lookbehind: !0
                },
                {
                  pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                  lookbehind: !0
                }
              ],
              // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
              function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
              number: {
                pattern: RegExp(
                  /(^|[^\w$])/.source + "(?:" + // constant
                  (/NaN|Infinity/.source + "|" + // binary integer
                  /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
                  /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
                  /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
                  /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
                  /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
                ),
                lookbehind: !0
              },
              operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
            }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
              regex: {
                // eslint-disable-next-line regexp/no-dupe-characters-character-class
                pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
                lookbehind: !0,
                greedy: !0,
                inside: {
                  "regex-source": {
                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                    lookbehind: !0,
                    alias: "language-regex",
                    inside: Prism.languages.regex
                  },
                  "regex-delimiter": /^\/|\/$/,
                  "regex-flags": /^[a-z]+$/
                }
              },
              // This must be declared before keyword because we use "function" inside the look-forward
              "function-variable": {
                pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
                alias: "function"
              },
              parameter: [
                {
                  pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
                  lookbehind: !0,
                  inside: Prism.languages.javascript
                },
                {
                  pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
                  lookbehind: !0,
                  inside: Prism.languages.javascript
                },
                {
                  pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
                  lookbehind: !0,
                  inside: Prism.languages.javascript
                },
                {
                  pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
                  lookbehind: !0,
                  inside: Prism.languages.javascript
                }
              ],
              constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
            }), Prism.languages.insertBefore("javascript", "string", {
              hashbang: {
                pattern: /^#!.*/,
                greedy: !0,
                alias: "comment"
              },
              "template-string": {
                pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
                greedy: !0,
                inside: {
                  "template-punctuation": {
                    pattern: /^`|`$/,
                    alias: "string"
                  },
                  interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                    lookbehind: !0,
                    inside: {
                      "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                      },
                      rest: Prism.languages.javascript
                    }
                  },
                  string: /[\s\S]+/
                }
              },
              "string-property": {
                pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
                lookbehind: !0,
                greedy: !0,
                alias: "property"
              }
            }), Prism.languages.insertBefore("javascript", "operator", {
              "literal-property": {
                pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
                lookbehind: !0,
                alias: "property"
              }
            }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
              /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
              "javascript"
            )), Prism.languages.js = Prism.languages.javascript;
          }
          __name(javascript, "javascript");
        }
      }), require_core = __commonJS2({
        "../node_modules/refractor/core.js"(exports, module) {
          "use strict";
          var ctx = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" || typeof window == "object" ? window : {}, restore = capture();
          ctx.Prism = { manual: !0, disableWorkerMessageHandler: !0 };
          var h4 = require_hastscript(), decode = require_parse_entities(), Prism = require_prism_core(), markup2 = require_markup(), css2 = require_css(), clike = require_clike(), js = require_javascript();
          restore();
          var own = {}.hasOwnProperty;
          function Refractor() {
          }
          __name(Refractor, "Refractor"), Refractor.prototype = Prism;
          var refract = new Refractor();
          module.exports = refract, refract.highlight = highlight2, refract.register = register, refract.alias = alias, refract.registered = registered, refract.listLanguages = listLanguages, register(markup2), register(css2), register(clike), register(js), refract.util.encode = encode, refract.Token.stringify = stringify4;
          function register(grammar) {
            if (typeof grammar != "function" || !grammar.displayName)
              throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
            refract.languages[grammar.displayName] === void 0 && grammar(refract);
          }
          __name(register, "register");
          function alias(name, alias2) {
            var languages2 = refract.languages, map2 = name, key, list, length2, index3;
            alias2 && (map2 = {}, map2[name] = alias2);
            for (key in map2)
              for (list = map2[key], list = typeof list == "string" ? [list] : list, length2 = list.length, index3 = -1; ++index3 < length2; )
                languages2[list[index3]] = languages2[key];
          }
          __name(alias, "alias");
          function highlight2(value2, name) {
            var sup = Prism.highlight, grammar;
            if (typeof value2 != "string")
              throw new Error("Expected `string` for `value`, got `" + value2 + "`");
            if (refract.util.type(name) === "Object")
              grammar = name, name = null;
            else {
              if (typeof name != "string")
                throw new Error("Expected `string` for `name`, got `" + name + "`");
              if (own.call(refract.languages, name))
                grammar = refract.languages[name];
              else
                throw new Error("Unknown language: `" + name + "` is not registered");
            }
            return sup.call(this, value2, grammar, name);
          }
          __name(highlight2, "highlight");
          function registered(language) {
            if (typeof language != "string")
              throw new Error("Expected `string` for `language`, got `" + language + "`");
            return own.call(refract.languages, language);
          }
          __name(registered, "registered");
          function listLanguages() {
            var languages2 = refract.languages, list = [], language;
            for (language in languages2)
              own.call(languages2, language) && typeof languages2[language] == "object" && list.push(language);
            return list;
          }
          __name(listLanguages, "listLanguages");
          function stringify4(value2, language, parent) {
            var env;
            return typeof value2 == "string" ? { type: "text", value: value2 } : refract.util.type(value2) === "Array" ? stringifyAll(value2, language) : (env = {
              type: value2.type,
              content: refract.Token.stringify(value2.content, language, parent),
              tag: "span",
              classes: ["token", value2.type],
              attributes: {},
              language,
              parent
            }, value2.alias && (env.classes = env.classes.concat(value2.alias)), refract.hooks.run("wrap", env), h4(
              env.tag + "." + env.classes.join("."),
              attributes(env.attributes),
              env.content
            ));
          }
          __name(stringify4, "stringify");
          function stringifyAll(values, language) {
            for (var result = [], length2 = values.length, index3 = -1, value2; ++index3 < length2; )
              value2 = values[index3], value2 !== "" && value2 !== null && value2 !== void 0 && result.push(value2);
            for (index3 = -1, length2 = result.length; ++index3 < length2; )
              value2 = result[index3], result[index3] = refract.Token.stringify(value2, language, result);
            return result;
          }
          __name(stringifyAll, "stringifyAll");
          function encode(tokens) {
            return tokens;
          }
          __name(encode, "encode");
          function attributes(attrs) {
            var key;
            for (key in attrs)
              attrs[key] = decode(attrs[key]);
            return attrs;
          }
          __name(attributes, "attributes");
          function capture() {
            var defined = "Prism" in ctx, current = defined ? ctx.Prism : void 0;
            return restore2;
            function restore2() {
              defined ? ctx.Prism = current : delete ctx.Prism, defined = void 0, current = void 0;
            }
          }
          __name(capture, "capture");
        }
      }), import_memoizerific4 = __toESM2(require_memoizerific(), 1);
      __name(ownKeys, "ownKeys");
      __name(_objectSpread, "_objectSpread");
      __name(powerSetPermutations, "powerSetPermutations");
      classNameCombinations = {};
      __name(getClassNameCombinations, "getClassNameCombinations");
      __name(createStyleObject, "createStyleObject");
      __name(createClassNameString, "createClassNameString");
      __name(createChildren, "createChildren");
      __name(createElement3, "createElement");
      import_bash = __toESM2(require_bash()), bash_default = import_bash.default, import_css = __toESM2(require_css()), css_default = import_css.default, import_graphql = __toESM2(require_graphql()), graphql_default = import_graphql.default, import_js_extras = __toESM2(require_js_extras()), js_extras_default = import_js_extras.default, import_json = __toESM2(require_json()), json_default = import_json.default, import_jsx = __toESM2(require_jsx()), jsx_default = import_jsx.default, import_markdown = __toESM2(require_markdown()), markdown_default = import_markdown.default, import_markup = __toESM2(require_markup()), markup_default = import_markup.default, import_tsx = __toESM2(require_tsx()), tsx_default = import_tsx.default, import_typescript = __toESM2(require_typescript()), typescript_default = import_typescript.default, import_yaml = __toESM2(require_yaml()), yaml_default = import_yaml.default;
      __name(_arrayLikeToArray, "_arrayLikeToArray");
      __name(_arrayWithoutHoles, "_arrayWithoutHoles");
      __name(_iterableToArray, "_iterableToArray");
      __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
      __name(_nonIterableSpread, "_nonIterableSpread");
      __name(_toConsumableArray, "_toConsumableArray");
      checkForListedLanguage_default = __name(function(astGenerator, language) {
        var langs = astGenerator.listLanguages();
        return langs.indexOf(language) !== -1;
      }, "default"), _excluded2 = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
      __name(ownKeys2, "ownKeys");
      __name(_objectSpread2, "_objectSpread");
      newLineRegex = /\n/g;
      __name(getNewLines, "getNewLines");
      __name(getAllLineNumbers, "getAllLineNumbers");
      __name(AllLineNumbers, "AllLineNumbers");
      __name(getEmWidthOfNumber, "getEmWidthOfNumber");
      __name(getInlineLineNumber, "getInlineLineNumber");
      __name(assembleLineNumberStyles, "assembleLineNumberStyles");
      __name(createLineElement, "createLineElement");
      __name(flattenCodeTree, "flattenCodeTree");
      __name(processLines, "processLines");
      __name(defaultRenderer, "defaultRenderer");
      __name(isHighlightJs, "isHighlightJs");
      __name(getCodeTree, "getCodeTree");
      __name(highlight_default, "default");
      import_core = __toESM2(require_core()), SyntaxHighlighter = highlight_default(import_core.default, {});
      SyntaxHighlighter.registerLanguage = function(_3, language) {
        return import_core.default.register(language);
      };
      SyntaxHighlighter.alias = function(name, aliases) {
        return import_core.default.alias(name, aliases);
      };
      prism_light_default = SyntaxHighlighter, { window: globalWindow3 } = scope, supportedLanguages = {
        jsextra: js_extras_default,
        jsx: jsx_default,
        json: json_default,
        yml: yaml_default,
        md: markdown_default,
        bash: bash_default,
        css: css_default,
        html: markup_default,
        tsx: tsx_default,
        typescript: typescript_default,
        graphql: graphql_default
      };
      Object.entries(supportedLanguages).forEach(([key, val]) => {
        prism_light_default.registerLanguage(key, val);
      });
      themedSyntax = (0, import_memoizerific4.default)(2)(
        (theme3) => Object.entries(theme3.code || {}).reduce((acc, [key, val]) => ({ ...acc, [`* .${key}`]: val }), {})
      ), copyToClipboard = createCopyToClipboardFunction(), Wrapper2 = styled.div(
        ({ theme: theme3 }) => ({
          position: "relative",
          overflow: "hidden",
          color: theme3.color.defaultText
        }),
        ({ theme: theme3, bordered }) => bordered ? {
          border: `1px solid ${theme3.appBorderColor}`,
          borderRadius: theme3.borderRadius,
          background: theme3.background.content
        } : {},
        ({ showLineNumbers }) => showLineNumbers ? {
          // use the before pseudo element to display line numbers
          ".react-syntax-highlighter-line-number::before": {
            content: "attr(data-line-number)"
          }
        } : {}
      ), UnstyledScroller = __name(({ children, className }) => react_default.createElement(ScrollArea2, { horizontal: !0, vertical: !0, className }, children), "UnstyledScroller"), Scroller = styled(UnstyledScroller)(
        {
          position: "relative"
        },
        ({ theme: theme3 }) => themedSyntax(theme3)
      ), Pre = styled.pre(({ theme: theme3, padded }) => ({
        display: "flex",
        justifyContent: "flex-start",
        margin: 0,
        padding: padded ? theme3.layoutMargin : 0
      })), Code = styled.div(({ theme: theme3 }) => ({
        flex: 1,
        paddingLeft: 2,
        // TODO: To match theming/global.ts for now
        paddingRight: theme3.layoutMargin,
        opacity: 1,
        fontFamily: theme3.typography.fonts.mono
      })), processLineNumber = __name((row) => {
        let children = [...row.children], lineNumberNode = children[0], lineNumber = lineNumberNode.children[0].value, processedLineNumberNode = {
          ...lineNumberNode,
          // empty the line-number element
          children: [],
          properties: {
            ...lineNumberNode.properties,
            // add a data-line-number attribute to line-number element, so we can access the line number with `content: attr(data-line-number)`
            "data-line-number": lineNumber,
            // remove the 'userSelect: none' style, which will produce extra empty lines when copy-pasting in firefox
            style: { ...lineNumberNode.properties.style, userSelect: "auto" }
          }
        };
        return children[0] = processedLineNumberNode, { ...row, children };
      }, "processLineNumber"), defaultRenderer2 = __name(({ rows, stylesheet, useInlineStyles }) => rows.map((node, i3) => createElement3({
        node: processLineNumber(node),
        stylesheet,
        useInlineStyles,
        key: `code-segement${i3}`
      })), "defaultRenderer"), wrapRenderer = __name((renderer, showLineNumbers) => showLineNumbers ? renderer ? ({ rows, ...rest }) => renderer({ rows: rows.map((row) => processLineNumber(row)), ...rest }) : defaultRenderer2 : renderer, "wrapRenderer"), SyntaxHighlighter2 = __name(({
        children,
        language = "jsx",
        copyable = !1,
        bordered = !1,
        padded = !1,
        format: format3 = !0,
        formatter: formatter2 = void 0,
        className = void 0,
        showLineNumbers = !1,
        ...rest
      }) => {
        if (typeof children != "string" || !children.trim())
          return null;
        let [highlightableCode, setHighlightableCode] = useState("");
        useEffect(() => {
          formatter2 ? formatter2(format3, children).then(setHighlightableCode) : setHighlightableCode(children.trim());
        }, [children, format3, formatter2]);
        let [copied, setCopied] = useState(!1), onClick = useCallback(
          (e) => {
            e.preventDefault(), copyToClipboard(highlightableCode).then(() => {
              setCopied(!0), globalWindow3.setTimeout(() => setCopied(!1), 1500);
            }).catch(logger.error);
          },
          [highlightableCode]
        ), renderer = wrapRenderer(rest.renderer, showLineNumbers);
        return react_default.createElement(
          Wrapper2,
          {
            bordered,
            padded,
            showLineNumbers,
            className
          },
          react_default.createElement(Scroller, null, react_default.createElement(
            prism_light_default,
            {
              padded: padded || bordered,
              language,
              showLineNumbers,
              showInlineLineNumbers: showLineNumbers,
              useInlineStyles: !1,
              PreTag: Pre,
              CodeTag: Code,
              lineNumberContainerStyle: {},
              ...rest,
              renderer
            },
            highlightableCode
          )),
          copyable ? react_default.createElement(ActionBar, { actionItems: [{ title: copied ? "Copied" : "Copy", onClick }] }) : null
        );
      }, "SyntaxHighlighter");
      SyntaxHighlighter2.registerLanguage = (...args) => prism_light_default.registerLanguage(...args);
      syntaxhighlighter_default = SyntaxHighlighter2;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/formatter-OMEEQ6HG.js
  var formatter_OMEEQ6HG_exports = {};
  __export(formatter_OMEEQ6HG_exports, {
    formatter: () => formatter
  });
  var import_memoizerific5, formatter, init_formatter_OMEEQ6HG = __esm({
    "node_modules/storybook/dist/_browser-chunks/formatter-OMEEQ6HG.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_NVV6MIOE();
      init_chunk_OPCDBBL3();
      init_chunk_MM7DTO55();
      import_memoizerific5 = __toESM2(require_memoizerific(), 1), formatter = (0, import_memoizerific5.default)(2)(async (type, source) => type === !1 ? source : dedent(source));
    }
  });

  // node_modules/storybook/dist/_browser-chunks/WithTooltip-SK46ZJ2J.js
  var WithTooltip_SK46ZJ2J_exports = {};
  __export(WithTooltip_SK46ZJ2J_exports, {
    WithToolTipState: () => WithToolTipState,
    WithTooltip: () => WithToolTipState,
    WithTooltipPure: () => WithTooltipPure
  });
  var init_WithTooltip_SK46ZJ2J = __esm({
    "node_modules/storybook/dist/_browser-chunks/WithTooltip-SK46ZJ2J.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_BOOOPFZF();
      init_chunk_VAMFPZY3();
      init_chunk_MH6AXFXB();
      init_chunk_NVV6MIOE();
      init_chunk_MM7DTO55();
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-U46RQHA4.js
  var getControlId, getControlSetterButtonId, init_chunk_U46RQHA4 = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-U46RQHA4.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      getControlId = __name((value2) => `control-${value2.replace(/\s+/g, "-")}`, "getControlId"), getControlSetterButtonId = __name((value2) => `set-${value2.replace(/\s+/g, "-")}`, "getControlSetterButtonId");
    }
  });

  // global-externals:storybook/internal/components
  var components_exports = {};
  __export(components_exports, {
    A: () => A3,
    ActionBar: () => ActionBar2,
    AddonPanel: () => AddonPanel2,
    Badge: () => Badge2,
    Bar: () => Bar2,
    Blockquote: () => Blockquote2,
    Button: () => Button2,
    ClipboardCode: () => ClipboardCode2,
    Code: () => Code3,
    DL: () => DL2,
    Div: () => Div2,
    DocumentWrapper: () => DocumentWrapper2,
    EmptyTabContent: () => EmptyTabContent2,
    ErrorFormatter: () => ErrorFormatter2,
    FlexBar: () => FlexBar2,
    Form: () => Form2,
    H1: () => H12,
    H2: () => H22,
    H3: () => H32,
    H4: () => H42,
    H5: () => H52,
    H6: () => H62,
    HR: () => HR2,
    IconButton: () => IconButton2,
    Img: () => Img2,
    LI: () => LI2,
    Link: () => Link3,
    ListItem: () => ListItem2,
    Loader: () => Loader2,
    Modal: () => Modal2,
    OL: () => OL2,
    P: () => P2,
    Placeholder: () => Placeholder2,
    Pre: () => Pre3,
    ProgressSpinner: () => ProgressSpinner2,
    ResetWrapper: () => ResetWrapper2,
    ScrollArea: () => ScrollArea3,
    Separator: () => Separator2,
    Spaced: () => Spaced2,
    Span: () => Span2,
    StorybookIcon: () => StorybookIcon3,
    StorybookLogo: () => StorybookLogo2,
    SyntaxHighlighter: () => SyntaxHighlighter4,
    TT: () => TT2,
    TabBar: () => TabBar2,
    TabButton: () => TabButton2,
    TabWrapper: () => TabWrapper2,
    Table: () => Table2,
    Tabs: () => Tabs2,
    TabsState: () => TabsState,
    TooltipLinkList: () => TooltipLinkList2,
    TooltipMessage: () => TooltipMessage2,
    TooltipNote: () => TooltipNote2,
    UL: () => UL2,
    WithTooltip: () => WithTooltip2,
    WithTooltipPure: () => WithTooltipPure3,
    Zoom: () => Zoom,
    codeCommon: () => codeCommon2,
    components: () => components2,
    createCopyToClipboardFunction: () => createCopyToClipboardFunction2,
    default: () => components_default,
    getStoryHref: () => getStoryHref2,
    interleaveSeparators: () => interleaveSeparators2,
    nameSpaceClassNames: () => nameSpaceClassNames2,
    resetComponents: () => resetComponents2,
    withReset: () => withReset2
  });
  var components_default, A3, ActionBar2, AddonPanel2, Badge2, Bar2, Blockquote2, Button2, ClipboardCode2, Code3, DL2, Div2, DocumentWrapper2, EmptyTabContent2, ErrorFormatter2, FlexBar2, Form2, H12, H22, H32, H42, H52, H62, HR2, IconButton2, Img2, LI2, Link3, ListItem2, Loader2, Modal2, OL2, P2, Placeholder2, Pre3, ProgressSpinner2, ResetWrapper2, ScrollArea3, Separator2, Spaced2, Span2, StorybookIcon3, StorybookLogo2, SyntaxHighlighter4, TT2, TabBar2, TabButton2, TabWrapper2, Table2, Tabs2, TabsState, TooltipLinkList2, TooltipMessage2, TooltipNote2, UL2, WithTooltip2, WithTooltipPure3, Zoom, codeCommon2, components2, createCopyToClipboardFunction2, getStoryHref2, interleaveSeparators2, nameSpaceClassNames2, resetComponents2, withReset2, init_components = __esm({
    "global-externals:storybook/internal/components"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      components_default = __STORYBOOK_COMPONENTS__, { A: A3, ActionBar: ActionBar2, AddonPanel: AddonPanel2, Badge: Badge2, Bar: Bar2, Blockquote: Blockquote2, Button: Button2, ClipboardCode: ClipboardCode2, Code: Code3, DL: DL2, Div: Div2, DocumentWrapper: DocumentWrapper2, EmptyTabContent: EmptyTabContent2, ErrorFormatter: ErrorFormatter2, FlexBar: FlexBar2, Form: Form2, H1: H12, H2: H22, H3: H32, H4: H42, H5: H52, H6: H62, HR: HR2, IconButton: IconButton2, Img: Img2, LI: LI2, Link: Link3, ListItem: ListItem2, Loader: Loader2, Modal: Modal2, OL: OL2, P: P2, Placeholder: Placeholder2, Pre: Pre3, ProgressSpinner: ProgressSpinner2, ResetWrapper: ResetWrapper2, ScrollArea: ScrollArea3, Separator: Separator2, Spaced: Spaced2, Span: Span2, StorybookIcon: StorybookIcon3, StorybookLogo: StorybookLogo2, SyntaxHighlighter: SyntaxHighlighter4, TT: TT2, TabBar: TabBar2, TabButton: TabButton2, TabWrapper: TabWrapper2, Table: Table2, Tabs: Tabs2, TabsState, TooltipLinkList: TooltipLinkList2, TooltipMessage: TooltipMessage2, TooltipNote: TooltipNote2, UL: UL2, WithTooltip: WithTooltip2, WithTooltipPure: WithTooltipPure3, Zoom, codeCommon: codeCommon2, components: components2, createCopyToClipboardFunction: createCopyToClipboardFunction2, getStoryHref: getStoryHref2, interleaveSeparators: interleaveSeparators2, nameSpaceClassNames: nameSpaceClassNames2, resetComponents: resetComponents2, withReset: withReset2 } = __STORYBOOK_COMPONENTS__;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/Color-7ZNS6F6B.js
  var Color_7ZNS6F6B_exports = {};
  __export(Color_7ZNS6F6B_exports, {
    ColorControl: () => ColorControl,
    default: () => Color_default
  });
  function debounce2(func, debounceMs, { signal, edges } = {}) {
    let pendingThis, pendingArgs = null, leading = edges != null && edges.includes("leading"), trailing = edges == null || edges.includes("trailing"), invoke = __name(() => {
      pendingArgs !== null && (func.apply(pendingThis, pendingArgs), pendingThis = void 0, pendingArgs = null);
    }, "invoke"), onTimerEnd = __name(() => {
      trailing && invoke(), cancel();
    }, "onTimerEnd"), timeoutId = null, schedule = __name(() => {
      timeoutId != null && clearTimeout(timeoutId), timeoutId = setTimeout(() => {
        timeoutId = null, onTimerEnd();
      }, debounceMs);
    }, "schedule"), cancelTimer = __name(() => {
      timeoutId !== null && (clearTimeout(timeoutId), timeoutId = null);
    }, "cancelTimer"), cancel = __name(() => {
      cancelTimer(), pendingThis = void 0, pendingArgs = null;
    }, "cancel"), flush = __name(() => {
      invoke();
    }, "flush"), debounced = __name(function(...args) {
      if (signal?.aborted)
        return;
      pendingThis = this, pendingArgs = args;
      let isFirstCall = timeoutId == null;
      schedule(), leading && isFirstCall && invoke();
    }, "debounced");
    return debounced.schedule = schedule, debounced.cancel = cancel, debounced.flush = flush, signal?.addEventListener("abort", cancel, { once: !0 }), debounced;
  }
  function partial(func, ...partialArgs) {
    return partialImpl(func, placeholderSymbol, ...partialArgs);
  }
  function partialImpl(func, placeholder, ...partialArgs) {
    let partialed = __name(function(...providedArgs) {
      let providedArgsIndex = 0, substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg), remainingArgs = providedArgs.slice(providedArgsIndex);
      return func.apply(this, substitutedArgs.concat(remainingArgs));
    }, "partialed");
    return func.prototype && (partialed.prototype = Object.create(func.prototype)), partialed;
  }
  function partialRight(func, ...partialArgs) {
    return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
  }
  function partialRightImpl(func, placeholder, ...partialArgs) {
    let partialedRight = __name(function(...providedArgs) {
      let placeholderLength = partialArgs.filter((arg) => arg === placeholder).length, rangeLength = Math.max(providedArgs.length - placeholderLength, 0), remainingArgs = providedArgs.slice(0, rangeLength), providedArgsIndex = rangeLength, substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
      return func.apply(this, remainingArgs.concat(substitutedArgs));
    }, "partialedRight");
    return func.prototype && (partialedRight.prototype = Object.create(func.prototype)), partialedRight;
  }
  function u() {
    return (u = Object.assign || function(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = arguments[r2];
        for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  function c(e2, r2) {
    if (e2 == null) return {};
    var t2, n2, o2 = {}, a22 = Object.keys(e2);
    for (n2 = 0; n2 < a22.length; n2++) r2.indexOf(t2 = a22[n2]) >= 0 || (o2[t2] = e2[t2]);
    return o2;
  }
  function i(e2) {
    var t2 = useRef(e2), n2 = useRef(function(e3) {
      t2.current && t2.current(e3);
    });
    return t2.current = e2, n2.current;
  }
  function Y(e2, t2, l2) {
    var u22 = i(l2), c22 = useState(function() {
      return e2.toHsva(t2);
    }), s22 = c22[0], f22 = c22[1], v22 = useRef({ color: t2, hsva: s22 });
    useEffect(function() {
      if (!e2.equal(t2, v22.current.color)) {
        var r2 = e2.toHsva(t2);
        v22.current = { hsva: r2, color: t2 }, f22(r2);
      }
    }, [t2, e2]), useEffect(function() {
      var r2;
      F(s22, v22.current.hsva) || e2.equal(r2 = e2.fromHsva(s22), v22.current.color) || (v22.current = { hsva: s22, color: r2 }, u22(r2));
    }, [s22, e2, u22]);
    var d22 = useCallback(function(e3) {
      f22(function(r2) {
        return Object.assign({}, r2, e3);
      });
    }, []);
    return [s22, d22];
  }
  var require_color_name, require_conversions, require_route, require_color_convert, import_color_convert, placeholderSymbol, placeholderSymbol2, DEFAULT_RETRIES, s2, f2, v, d, h2, m, g, p2, b, _, x, C2, E, H, N, w, y, q, k, I, z, D, K, L, S, T, F, P3, X, R, V, $, J, Q, U, W, Z, ee, re, le, ue, Ee, He, Wrapper5, PickerTooltip, TooltipContent, Note2, Swatches, SwatchColor, swatchBackground, Swatch, Input5, ToggleIcon, ColorSpace, COLOR_SPACES, COLOR_REGEXP2, RGB_REGEXP, HSL_REGEXP, HEX_REGEXP2, SHORTHEX_REGEXP, ColorPicker, fallbackColor, stringToArgs, parseRgb, parseHsl, parseHexOrKeyword, parseValue, getRealValue, useColorInput, id, usePresets, ColorControl, Color_default, init_Color_7ZNS6F6B = __esm({
    "node_modules/storybook/dist/_browser-chunks/Color-7ZNS6F6B.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_U46RQHA4();
      init_chunk_AB7OOPUX();
      init_chunk_MM7DTO55();
      init_react();
      init_components();
      init_icons();
      init_react();
      init_theming();
      require_color_name = __commonJS2({
        "../node_modules/color-name/index.js"(exports, module) {
          "use strict";
          module.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
          };
        }
      }), require_conversions = __commonJS2({
        "../node_modules/color-convert/conversions.js"(exports, module) {
          var cssKeywords = require_color_name(), reverseKeywords = {};
          for (let key of Object.keys(cssKeywords))
            reverseKeywords[cssKeywords[key]] = key;
          var convert23 = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          module.exports = convert23;
          for (let model of Object.keys(convert23)) {
            if (!("channels" in convert23[model]))
              throw new Error("missing channels property: " + model);
            if (!("labels" in convert23[model]))
              throw new Error("missing channel labels property: " + model);
            if (convert23[model].labels.length !== convert23[model].channels)
              throw new Error("channel and label counts mismatch: " + model);
            let { channels, labels } = convert23[model];
            delete convert23[model].channels, delete convert23[model].labels, Object.defineProperty(convert23[model], "channels", { value: channels }), Object.defineProperty(convert23[model], "labels", { value: labels });
          }
          convert23.rgb.hsl = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, min2 = Math.min(r2, g22, b22), max2 = Math.max(r2, g22, b22), delta = max2 - min2, h22, s22;
            max2 === min2 ? h22 = 0 : r2 === max2 ? h22 = (g22 - b22) / delta : g22 === max2 ? h22 = 2 + (b22 - r2) / delta : b22 === max2 && (h22 = 4 + (r2 - g22) / delta), h22 = Math.min(h22 * 60, 360), h22 < 0 && (h22 += 360);
            let l2 = (min2 + max2) / 2;
            return max2 === min2 ? s22 = 0 : l2 <= 0.5 ? s22 = delta / (max2 + min2) : s22 = delta / (2 - max2 - min2), [h22, s22 * 100, l2 * 100];
          }, convert23.rgb.hsv = function(rgb2) {
            let rdif, gdif, bdif, h22, s22, r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, v22 = Math.max(r2, g22, b22), diff2 = v22 - Math.min(r2, g22, b22), diffc = __name(function(c22) {
              return (v22 - c22) / 6 / diff2 + 1 / 2;
            }, "diffc");
            return diff2 === 0 ? (h22 = 0, s22 = 0) : (s22 = diff2 / v22, rdif = diffc(r2), gdif = diffc(g22), bdif = diffc(b22), r2 === v22 ? h22 = bdif - gdif : g22 === v22 ? h22 = 1 / 3 + rdif - bdif : b22 === v22 && (h22 = 2 / 3 + gdif - rdif), h22 < 0 ? h22 += 1 : h22 > 1 && (h22 -= 1)), [
              h22 * 360,
              s22 * 100,
              v22 * 100
            ];
          }, convert23.rgb.hwb = function(rgb2) {
            let r2 = rgb2[0], g22 = rgb2[1], b22 = rgb2[2], h22 = convert23.rgb.hsl(rgb2)[0], w22 = 1 / 255 * Math.min(r2, Math.min(g22, b22));
            return b22 = 1 - 1 / 255 * Math.max(r2, Math.max(g22, b22)), [h22, w22 * 100, b22 * 100];
          }, convert23.rgb.cmyk = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, k22 = Math.min(1 - r2, 1 - g22, 1 - b22), c22 = (1 - r2 - k22) / (1 - k22) || 0, m22 = (1 - g22 - k22) / (1 - k22) || 0, y22 = (1 - b22 - k22) / (1 - k22) || 0;
            return [c22 * 100, m22 * 100, y22 * 100, k22 * 100];
          };
          function comparativeDistance(x22, y22) {
            return (x22[0] - y22[0]) ** 2 + (x22[1] - y22[1]) ** 2 + (x22[2] - y22[2]) ** 2;
          }
          __name(comparativeDistance, "comparativeDistance"), convert23.rgb.keyword = function(rgb2) {
            let reversed = reverseKeywords[rgb2];
            if (reversed)
              return reversed;
            let currentClosestDistance = 1 / 0, currentClosestKeyword;
            for (let keyword of Object.keys(cssKeywords)) {
              let value2 = cssKeywords[keyword], distance = comparativeDistance(rgb2, value2);
              distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
            }
            return currentClosestKeyword;
          }, convert23.keyword.rgb = function(keyword) {
            return cssKeywords[keyword];
          }, convert23.rgb.xyz = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255;
            r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92, g22 = g22 > 0.04045 ? ((g22 + 0.055) / 1.055) ** 2.4 : g22 / 12.92, b22 = b22 > 0.04045 ? ((b22 + 0.055) / 1.055) ** 2.4 : b22 / 12.92;
            let x22 = r2 * 0.4124 + g22 * 0.3576 + b22 * 0.1805, y22 = r2 * 0.2126 + g22 * 0.7152 + b22 * 0.0722, z22 = r2 * 0.0193 + g22 * 0.1192 + b22 * 0.9505;
            return [x22 * 100, y22 * 100, z22 * 100];
          }, convert23.rgb.lab = function(rgb2) {
            let xyz = convert23.rgb.xyz(rgb2), x22 = xyz[0], y22 = xyz[1], z22 = xyz[2];
            x22 /= 95.047, y22 /= 100, z22 /= 108.883, x22 = x22 > 8856e-6 ? x22 ** (1 / 3) : 7.787 * x22 + 16 / 116, y22 = y22 > 8856e-6 ? y22 ** (1 / 3) : 7.787 * y22 + 16 / 116, z22 = z22 > 8856e-6 ? z22 ** (1 / 3) : 7.787 * z22 + 16 / 116;
            let l2 = 116 * y22 - 16, a22 = 500 * (x22 - y22), b22 = 200 * (y22 - z22);
            return [l2, a22, b22];
          }, convert23.hsl.rgb = function(hsl2) {
            let h22 = hsl2[0] / 360, s22 = hsl2[1] / 100, l2 = hsl2[2] / 100, t2, t3, val;
            if (s22 === 0)
              return val = l2 * 255, [val, val, val];
            l2 < 0.5 ? t2 = l2 * (1 + s22) : t2 = l2 + s22 - l2 * s22;
            let t1 = 2 * l2 - t2, rgb2 = [0, 0, 0];
            for (let i22 = 0; i22 < 3; i22++)
              t3 = h22 + 1 / 3 * -(i22 - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb2[i22] = val * 255;
            return rgb2;
          }, convert23.hsl.hsv = function(hsl2) {
            let h22 = hsl2[0], s22 = hsl2[1] / 100, l2 = hsl2[2] / 100, smin = s22, lmin = Math.max(l2, 0.01);
            l2 *= 2, s22 *= l2 <= 1 ? l2 : 2 - l2, smin *= lmin <= 1 ? lmin : 2 - lmin;
            let v22 = (l2 + s22) / 2, sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s22 / (l2 + s22);
            return [h22, sv * 100, v22 * 100];
          }, convert23.hsv.rgb = function(hsv) {
            let h22 = hsv[0] / 60, s22 = hsv[1] / 100, v22 = hsv[2] / 100, hi = Math.floor(h22) % 6, f22 = h22 - Math.floor(h22), p22 = 255 * v22 * (1 - s22), q22 = 255 * v22 * (1 - s22 * f22), t2 = 255 * v22 * (1 - s22 * (1 - f22));
            switch (v22 *= 255, hi) {
              case 0:
                return [v22, t2, p22];
              case 1:
                return [q22, v22, p22];
              case 2:
                return [p22, v22, t2];
              case 3:
                return [p22, q22, v22];
              case 4:
                return [t2, p22, v22];
              case 5:
                return [v22, p22, q22];
            }
          }, convert23.hsv.hsl = function(hsv) {
            let h22 = hsv[0], s22 = hsv[1] / 100, v22 = hsv[2] / 100, vmin = Math.max(v22, 0.01), sl, l2;
            l2 = (2 - s22) * v22;
            let lmin = (2 - s22) * vmin;
            return sl = s22 * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l2 /= 2, [h22, sl * 100, l2 * 100];
          }, convert23.hwb.rgb = function(hwb) {
            let h22 = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, f22;
            ratio > 1 && (wh /= ratio, bl /= ratio);
            let i22 = Math.floor(6 * h22), v22 = 1 - bl;
            f22 = 6 * h22 - i22, (i22 & 1) !== 0 && (f22 = 1 - f22);
            let n2 = wh + f22 * (v22 - wh), r2, g22, b22;
            switch (i22) {
              default:
              case 6:
              case 0:
                r2 = v22, g22 = n2, b22 = wh;
                break;
              case 1:
                r2 = n2, g22 = v22, b22 = wh;
                break;
              case 2:
                r2 = wh, g22 = v22, b22 = n2;
                break;
              case 3:
                r2 = wh, g22 = n2, b22 = v22;
                break;
              case 4:
                r2 = n2, g22 = wh, b22 = v22;
                break;
              case 5:
                r2 = v22, g22 = wh, b22 = n2;
                break;
            }
            return [r2 * 255, g22 * 255, b22 * 255];
          }, convert23.cmyk.rgb = function(cmyk) {
            let c22 = cmyk[0] / 100, m22 = cmyk[1] / 100, y22 = cmyk[2] / 100, k22 = cmyk[3] / 100, r2 = 1 - Math.min(1, c22 * (1 - k22) + k22), g22 = 1 - Math.min(1, m22 * (1 - k22) + k22), b22 = 1 - Math.min(1, y22 * (1 - k22) + k22);
            return [r2 * 255, g22 * 255, b22 * 255];
          }, convert23.xyz.rgb = function(xyz) {
            let x22 = xyz[0] / 100, y22 = xyz[1] / 100, z22 = xyz[2] / 100, r2, g22, b22;
            return r2 = x22 * 3.2406 + y22 * -1.5372 + z22 * -0.4986, g22 = x22 * -0.9689 + y22 * 1.8758 + z22 * 0.0415, b22 = x22 * 0.0557 + y22 * -0.204 + z22 * 1.057, r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92, g22 = g22 > 31308e-7 ? 1.055 * g22 ** (1 / 2.4) - 0.055 : g22 * 12.92, b22 = b22 > 31308e-7 ? 1.055 * b22 ** (1 / 2.4) - 0.055 : b22 * 12.92, r2 = Math.min(Math.max(0, r2), 1), g22 = Math.min(Math.max(0, g22), 1), b22 = Math.min(Math.max(0, b22), 1), [r2 * 255, g22 * 255, b22 * 255];
          }, convert23.xyz.lab = function(xyz) {
            let x22 = xyz[0], y22 = xyz[1], z22 = xyz[2];
            x22 /= 95.047, y22 /= 100, z22 /= 108.883, x22 = x22 > 8856e-6 ? x22 ** (1 / 3) : 7.787 * x22 + 16 / 116, y22 = y22 > 8856e-6 ? y22 ** (1 / 3) : 7.787 * y22 + 16 / 116, z22 = z22 > 8856e-6 ? z22 ** (1 / 3) : 7.787 * z22 + 16 / 116;
            let l2 = 116 * y22 - 16, a22 = 500 * (x22 - y22), b22 = 200 * (y22 - z22);
            return [l2, a22, b22];
          }, convert23.lab.xyz = function(lab) {
            let l2 = lab[0], a22 = lab[1], b22 = lab[2], x22, y22, z22;
            y22 = (l2 + 16) / 116, x22 = a22 / 500 + y22, z22 = y22 - b22 / 200;
            let y222 = y22 ** 3, x222 = x22 ** 3, z222 = z22 ** 3;
            return y22 = y222 > 8856e-6 ? y222 : (y22 - 16 / 116) / 7.787, x22 = x222 > 8856e-6 ? x222 : (x22 - 16 / 116) / 7.787, z22 = z222 > 8856e-6 ? z222 : (z22 - 16 / 116) / 7.787, x22 *= 95.047, y22 *= 100, z22 *= 108.883, [x22, y22, z22];
          }, convert23.lab.lch = function(lab) {
            let l2 = lab[0], a22 = lab[1], b22 = lab[2], h22;
            h22 = Math.atan2(b22, a22) * 360 / 2 / Math.PI, h22 < 0 && (h22 += 360);
            let c22 = Math.sqrt(a22 * a22 + b22 * b22);
            return [l2, c22, h22];
          }, convert23.lch.lab = function(lch) {
            let l2 = lch[0], c22 = lch[1], hr = lch[2] / 360 * 2 * Math.PI, a22 = c22 * Math.cos(hr), b22 = c22 * Math.sin(hr);
            return [l2, a22, b22];
          }, convert23.rgb.ansi16 = function(args, saturation = null) {
            let [r2, g22, b22] = args, value2 = saturation === null ? convert23.rgb.hsv(args)[2] : saturation;
            if (value2 = Math.round(value2 / 50), value2 === 0)
              return 30;
            let ansi = 30 + (Math.round(b22 / 255) << 2 | Math.round(g22 / 255) << 1 | Math.round(r2 / 255));
            return value2 === 2 && (ansi += 60), ansi;
          }, convert23.hsv.ansi16 = function(args) {
            return convert23.rgb.ansi16(convert23.hsv.rgb(args), args[2]);
          }, convert23.rgb.ansi256 = function(args) {
            let r2 = args[0], g22 = args[1], b22 = args[2];
            return r2 === g22 && g22 === b22 ? r2 < 8 ? 16 : r2 > 248 ? 231 : Math.round((r2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g22 / 255 * 5) + Math.round(b22 / 255 * 5);
          }, convert23.ansi16.rgb = function(args) {
            let color2 = args % 10;
            if (color2 === 0 || color2 === 7)
              return args > 50 && (color2 += 3.5), color2 = color2 / 10.5 * 255, [color2, color2, color2];
            let mult = (~~(args > 50) + 1) * 0.5, r2 = (color2 & 1) * mult * 255, g22 = (color2 >> 1 & 1) * mult * 255, b22 = (color2 >> 2 & 1) * mult * 255;
            return [r2, g22, b22];
          }, convert23.ansi256.rgb = function(args) {
            if (args >= 232) {
              let c22 = (args - 232) * 10 + 8;
              return [c22, c22, c22];
            }
            args -= 16;
            let rem2, r2 = Math.floor(args / 36) / 5 * 255, g22 = Math.floor((rem2 = args % 36) / 6) / 5 * 255, b22 = rem2 % 6 / 5 * 255;
            return [r2, g22, b22];
          }, convert23.rgb.hex = function(args) {
            let string = (((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255)).toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          }, convert23.hex.rgb = function(args) {
            let match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match2)
              return [0, 0, 0];
            let colorString = match2[0];
            match2[0].length === 3 && (colorString = colorString.split("").map((char) => char + char).join(""));
            let integer = parseInt(colorString, 16), r2 = integer >> 16 & 255, g22 = integer >> 8 & 255, b22 = integer & 255;
            return [r2, g22, b22];
          }, convert23.rgb.hcg = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, max2 = Math.max(Math.max(r2, g22), b22), min2 = Math.min(Math.min(r2, g22), b22), chroma = max2 - min2, grayscale, hue;
            return chroma < 1 ? grayscale = min2 / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max2 === r2 ? hue = (g22 - b22) / chroma % 6 : max2 === g22 ? hue = 2 + (b22 - r2) / chroma : hue = 4 + (r2 - g22) / chroma, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
          }, convert23.hsl.hcg = function(hsl2) {
            let s22 = hsl2[1] / 100, l2 = hsl2[2] / 100, c22 = l2 < 0.5 ? 2 * s22 * l2 : 2 * s22 * (1 - l2), f22 = 0;
            return c22 < 1 && (f22 = (l2 - 0.5 * c22) / (1 - c22)), [hsl2[0], c22 * 100, f22 * 100];
          }, convert23.hsv.hcg = function(hsv) {
            let s22 = hsv[1] / 100, v22 = hsv[2] / 100, c22 = s22 * v22, f22 = 0;
            return c22 < 1 && (f22 = (v22 - c22) / (1 - c22)), [hsv[0], c22 * 100, f22 * 100];
          }, convert23.hcg.rgb = function(hcg) {
            let h22 = hcg[0] / 360, c22 = hcg[1] / 100, g22 = hcg[2] / 100;
            if (c22 === 0)
              return [g22 * 255, g22 * 255, g22 * 255];
            let pure = [0, 0, 0], hi = h22 % 1 * 6, v22 = hi % 1, w22 = 1 - v22, mg = 0;
            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1, pure[1] = v22, pure[2] = 0;
                break;
              case 1:
                pure[0] = w22, pure[1] = 1, pure[2] = 0;
                break;
              case 2:
                pure[0] = 0, pure[1] = 1, pure[2] = v22;
                break;
              case 3:
                pure[0] = 0, pure[1] = w22, pure[2] = 1;
                break;
              case 4:
                pure[0] = v22, pure[1] = 0, pure[2] = 1;
                break;
              default:
                pure[0] = 1, pure[1] = 0, pure[2] = w22;
            }
            return mg = (1 - c22) * g22, [
              (c22 * pure[0] + mg) * 255,
              (c22 * pure[1] + mg) * 255,
              (c22 * pure[2] + mg) * 255
            ];
          }, convert23.hcg.hsv = function(hcg) {
            let c22 = hcg[1] / 100, g22 = hcg[2] / 100, v22 = c22 + g22 * (1 - c22), f22 = 0;
            return v22 > 0 && (f22 = c22 / v22), [hcg[0], f22 * 100, v22 * 100];
          }, convert23.hcg.hsl = function(hcg) {
            let c22 = hcg[1] / 100, l2 = hcg[2] / 100 * (1 - c22) + 0.5 * c22, s22 = 0;
            return l2 > 0 && l2 < 0.5 ? s22 = c22 / (2 * l2) : l2 >= 0.5 && l2 < 1 && (s22 = c22 / (2 * (1 - l2))), [hcg[0], s22 * 100, l2 * 100];
          }, convert23.hcg.hwb = function(hcg) {
            let c22 = hcg[1] / 100, g22 = hcg[2] / 100, v22 = c22 + g22 * (1 - c22);
            return [hcg[0], (v22 - c22) * 100, (1 - v22) * 100];
          }, convert23.hwb.hcg = function(hwb) {
            let w22 = hwb[1] / 100, v22 = 1 - hwb[2] / 100, c22 = v22 - w22, g22 = 0;
            return c22 < 1 && (g22 = (v22 - c22) / (1 - c22)), [hwb[0], c22 * 100, g22 * 100];
          }, convert23.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          }, convert23.rgb.apple = function(rgb2) {
            return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
          }, convert23.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          }, convert23.gray.hsl = function(args) {
            return [0, 0, args[0]];
          }, convert23.gray.hsv = convert23.gray.hsl, convert23.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          }, convert23.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          }, convert23.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          }, convert23.gray.hex = function(gray) {
            let val = Math.round(gray[0] / 100 * 255) & 255, string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          }, convert23.rgb.gray = function(rgb2) {
            return [(rgb2[0] + rgb2[1] + rgb2[2]) / 3 / 255 * 100];
          };
        }
      }), require_route = __commonJS2({
        "../node_modules/color-convert/route.js"(exports, module) {
          var conversions = require_conversions();
          function buildGraph() {
            let graph = {}, models = Object.keys(conversions);
            for (let len = models.length, i22 = 0; i22 < len; i22++)
              graph[models[i22]] = {
                // http://jsperf.com/1-vs-infinity
                // micro-opt, but this is simple.
                distance: -1,
                parent: null
              };
            return graph;
          }
          __name(buildGraph, "buildGraph");
          function deriveBFS(fromModel) {
            let graph = buildGraph(), queue = [fromModel];
            for (graph[fromModel].distance = 0; queue.length; ) {
              let current = queue.pop(), adjacents = Object.keys(conversions[current]);
              for (let len = adjacents.length, i22 = 0; i22 < len; i22++) {
                let adjacent = adjacents[i22], node = graph[adjacent];
                node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
              }
            }
            return graph;
          }
          __name(deriveBFS, "deriveBFS");
          function link(from, to) {
            return function(args) {
              return to(from(args));
            };
          }
          __name(link, "link");
          function wrapConversion(toModel, graph) {
            let path = [graph[toModel].parent, toModel], fn3 = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
            for (; graph[cur].parent; )
              path.unshift(graph[cur].parent), fn3 = link(conversions[graph[cur].parent][cur], fn3), cur = graph[cur].parent;
            return fn3.conversion = path, fn3;
          }
          __name(wrapConversion, "wrapConversion"), module.exports = function(fromModel) {
            let graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
            for (let len = models.length, i22 = 0; i22 < len; i22++) {
              let toModel = models[i22];
              graph[toModel].parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
            }
            return conversion;
          };
        }
      }), require_color_convert = __commonJS2({
        "../node_modules/color-convert/index.js"(exports, module) {
          var conversions = require_conversions(), route = require_route(), convert23 = {}, models = Object.keys(conversions);
          function wrapRaw(fn3) {
            let wrappedFn = __name(function(...args) {
              let arg0 = args[0];
              return arg0 == null ? arg0 : (arg0.length > 1 && (args = arg0), fn3(args));
            }, "wrappedFn");
            return "conversion" in fn3 && (wrappedFn.conversion = fn3.conversion), wrappedFn;
          }
          __name(wrapRaw, "wrapRaw");
          function wrapRounded(fn3) {
            let wrappedFn = __name(function(...args) {
              let arg0 = args[0];
              if (arg0 == null)
                return arg0;
              arg0.length > 1 && (args = arg0);
              let result = fn3(args);
              if (typeof result == "object")
                for (let len = result.length, i22 = 0; i22 < len; i22++)
                  result[i22] = Math.round(result[i22]);
              return result;
            }, "wrappedFn");
            return "conversion" in fn3 && (wrappedFn.conversion = fn3.conversion), wrappedFn;
          }
          __name(wrapRounded, "wrapRounded"), models.forEach((fromModel) => {
            convert23[fromModel] = {}, Object.defineProperty(convert23[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert23[fromModel], "labels", { value: conversions[fromModel].labels });
            let routes = route(fromModel);
            Object.keys(routes).forEach((toModel) => {
              let fn3 = routes[toModel];
              convert23[fromModel][toModel] = wrapRounded(fn3), convert23[fromModel][toModel].raw = wrapRaw(fn3);
            });
          }), module.exports = convert23;
        }
      }), import_color_convert = __toESM2(require_color_convert(), 1);
      __name(debounce2, "debounce");
      __name(partial, "partial");
      __name(partialImpl, "partialImpl");
      placeholderSymbol = Symbol("partial.placeholder");
      partial.placeholder = placeholderSymbol;
      __name(partialRight, "partialRight");
      __name(partialRightImpl, "partialRightImpl");
      placeholderSymbol2 = Symbol("partialRight.placeholder");
      partialRight.placeholder = placeholderSymbol2;
      DEFAULT_RETRIES = Number.POSITIVE_INFINITY;
      __name(u, "u");
      __name(c, "c");
      __name(i, "i");
      s2 = __name(function(e2, r2, t2) {
        return r2 === void 0 && (r2 = 0), t2 === void 0 && (t2 = 1), e2 > t2 ? t2 : e2 < r2 ? r2 : e2;
      }, "s"), f2 = __name(function(e2) {
        return "touches" in e2;
      }, "f"), v = __name(function(e2) {
        return e2 && e2.ownerDocument.defaultView || self;
      }, "v"), d = __name(function(e2, r2, t2) {
        var n2 = e2.getBoundingClientRect(), o2 = f2(r2) ? (function(e3, r3) {
          for (var t3 = 0; t3 < e3.length; t3++) if (e3[t3].identifier === r3) return e3[t3];
          return e3[0];
        })(r2.touches, t2) : r2;
        return { left: s2((o2.pageX - (n2.left + v(e2).pageXOffset)) / n2.width), top: s2((o2.pageY - (n2.top + v(e2).pageYOffset)) / n2.height) };
      }, "d"), h2 = __name(function(e2) {
        !f2(e2) && e2.preventDefault();
      }, "h"), m = react_default.memo(function(o2) {
        var a22 = o2.onMove, l2 = o2.onKey, s22 = c(o2, ["onMove", "onKey"]), m22 = useRef(null), g22 = i(a22), p22 = i(l2), b22 = useRef(null), _22 = useRef(!1), x22 = useMemo(function() {
          var e2 = __name(function(e3) {
            h2(e3), (f2(e3) ? e3.touches.length > 0 : e3.buttons > 0) && m22.current ? g22(d(m22.current, e3, b22.current)) : t2(!1);
          }, "e"), r2 = __name(function() {
            return t2(!1);
          }, "r");
          function t2(t3) {
            var n2 = _22.current, o3 = v(m22.current), a3 = t3 ? o3.addEventListener : o3.removeEventListener;
            a3(n2 ? "touchmove" : "mousemove", e2), a3(n2 ? "touchend" : "mouseup", r2);
          }
          return __name(t2, "t"), [function(e3) {
            var r3 = e3.nativeEvent, n2 = m22.current;
            if (n2 && (h2(r3), !(function(e4, r4) {
              return r4 && !f2(e4);
            })(r3, _22.current) && n2)) {
              if (f2(r3)) {
                _22.current = !0;
                var o3 = r3.changedTouches || [];
                o3.length && (b22.current = o3[0].identifier);
              }
              n2.focus(), g22(d(n2, r3, b22.current)), t2(!0);
            }
          }, function(e3) {
            var r3 = e3.which || e3.keyCode;
            r3 < 37 || r3 > 40 || (e3.preventDefault(), p22({ left: r3 === 39 ? 0.05 : r3 === 37 ? -0.05 : 0, top: r3 === 40 ? 0.05 : r3 === 38 ? -0.05 : 0 }));
          }, t2];
        }, [p22, g22]), C22 = x22[0], E22 = x22[1], H23 = x22[2];
        return useEffect(function() {
          return H23;
        }, [H23]), react_default.createElement("div", u({}, s22, { onTouchStart: C22, onMouseDown: C22, className: "react-colorful__interactive", ref: m22, onKeyDown: E22, tabIndex: 0, role: "slider" }));
      }), g = __name(function(e2) {
        return e2.filter(Boolean).join(" ");
      }, "g"), p2 = __name(function(r2) {
        var t2 = r2.color, n2 = r2.left, o2 = r2.top, a22 = o2 === void 0 ? 0.5 : o2, l2 = g(["react-colorful__pointer", r2.className]);
        return react_default.createElement("div", { className: l2, style: { top: 100 * a22 + "%", left: 100 * n2 + "%" } }, react_default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t2 } }));
      }, "p"), b = __name(function(e2, r2, t2) {
        return r2 === void 0 && (r2 = 0), t2 === void 0 && (t2 = Math.pow(10, r2)), Math.round(t2 * e2) / t2;
      }, "b"), _ = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, x = __name(function(e2) {
        return L(C2(e2));
      }, "x"), C2 = __name(function(e2) {
        return e2[0] === "#" && (e2 = e2.substring(1)), e2.length < 6 ? { r: parseInt(e2[0] + e2[0], 16), g: parseInt(e2[1] + e2[1], 16), b: parseInt(e2[2] + e2[2], 16), a: e2.length === 4 ? b(parseInt(e2[3] + e2[3], 16) / 255, 2) : 1 } : { r: parseInt(e2.substring(0, 2), 16), g: parseInt(e2.substring(2, 4), 16), b: parseInt(e2.substring(4, 6), 16), a: e2.length === 8 ? b(parseInt(e2.substring(6, 8), 16) / 255, 2) : 1 };
      }, "C"), E = __name(function(e2, r2) {
        return r2 === void 0 && (r2 = "deg"), Number(e2) * (_[r2] || 1);
      }, "E"), H = __name(function(e2) {
        var r2 = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e2);
        return r2 ? N({ h: E(r2[1], r2[2]), s: Number(r2[3]), l: Number(r2[4]), a: r2[5] === void 0 ? 1 : Number(r2[5]) / (r2[6] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
      }, "H"), N = __name(function(e2) {
        var r2 = e2.s, t2 = e2.l;
        return { h: e2.h, s: (r2 *= (t2 < 50 ? t2 : 100 - t2) / 100) > 0 ? 2 * r2 / (t2 + r2) * 100 : 0, v: t2 + r2, a: e2.a };
      }, "N"), w = __name(function(e2) {
        return K(I(e2));
      }, "w"), y = __name(function(e2) {
        var r2 = e2.s, t2 = e2.v, n2 = e2.a, o2 = (200 - r2) * t2 / 100;
        return { h: b(e2.h), s: b(o2 > 0 && o2 < 200 ? r2 * t2 / 100 / (o2 <= 100 ? o2 : 200 - o2) * 100 : 0), l: b(o2 / 2), a: b(n2, 2) };
      }, "y"), q = __name(function(e2) {
        var r2 = y(e2);
        return "hsl(" + r2.h + ", " + r2.s + "%, " + r2.l + "%)";
      }, "q"), k = __name(function(e2) {
        var r2 = y(e2);
        return "hsla(" + r2.h + ", " + r2.s + "%, " + r2.l + "%, " + r2.a + ")";
      }, "k"), I = __name(function(e2) {
        var r2 = e2.h, t2 = e2.s, n2 = e2.v, o2 = e2.a;
        r2 = r2 / 360 * 6, t2 /= 100, n2 /= 100;
        var a22 = Math.floor(r2), l2 = n2 * (1 - t2), u22 = n2 * (1 - (r2 - a22) * t2), c22 = n2 * (1 - (1 - r2 + a22) * t2), i22 = a22 % 6;
        return { r: b(255 * [n2, u22, l2, l2, c22, n2][i22]), g: b(255 * [c22, n2, n2, u22, l2, l2][i22]), b: b(255 * [l2, l2, c22, n2, n2, u22][i22]), a: b(o2, 2) };
      }, "I"), z = __name(function(e2) {
        var r2 = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e2);
        return r2 ? L({ r: Number(r2[1]) / (r2[2] ? 100 / 255 : 1), g: Number(r2[3]) / (r2[4] ? 100 / 255 : 1), b: Number(r2[5]) / (r2[6] ? 100 / 255 : 1), a: r2[7] === void 0 ? 1 : Number(r2[7]) / (r2[8] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
      }, "z"), D = __name(function(e2) {
        var r2 = e2.toString(16);
        return r2.length < 2 ? "0" + r2 : r2;
      }, "D"), K = __name(function(e2) {
        var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a22 = o2 < 1 ? D(b(255 * o2)) : "";
        return "#" + D(r2) + D(t2) + D(n2) + a22;
      }, "K"), L = __name(function(e2) {
        var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a22 = Math.max(r2, t2, n2), l2 = a22 - Math.min(r2, t2, n2), u22 = l2 ? a22 === r2 ? (t2 - n2) / l2 : a22 === t2 ? 2 + (n2 - r2) / l2 : 4 + (r2 - t2) / l2 : 0;
        return { h: b(60 * (u22 < 0 ? u22 + 6 : u22)), s: b(a22 ? l2 / a22 * 100 : 0), v: b(a22 / 255 * 100), a: o2 };
      }, "L"), S = react_default.memo(function(r2) {
        var t2 = r2.hue, n2 = r2.onChange, o2 = g(["react-colorful__hue", r2.className]);
        return react_default.createElement("div", { className: o2 }, react_default.createElement(m, { onMove: __name(function(e2) {
          n2({ h: 360 * e2.left });
        }, "onMove"), onKey: __name(function(e2) {
          n2({ h: s2(t2 + 360 * e2.left, 0, 360) });
        }, "onKey"), "aria-label": "Hue", "aria-valuenow": b(t2), "aria-valuemax": "360", "aria-valuemin": "0" }, react_default.createElement(p2, { className: "react-colorful__hue-pointer", left: t2 / 360, color: q({ h: t2, s: 100, v: 100, a: 1 }) })));
      }), T = react_default.memo(function(r2) {
        var t2 = r2.hsva, n2 = r2.onChange, o2 = { backgroundColor: q({ h: t2.h, s: 100, v: 100, a: 1 }) };
        return react_default.createElement("div", { className: "react-colorful__saturation", style: o2 }, react_default.createElement(m, { onMove: __name(function(e2) {
          n2({ s: 100 * e2.left, v: 100 - 100 * e2.top });
        }, "onMove"), onKey: __name(function(e2) {
          n2({ s: s2(t2.s + 100 * e2.left, 0, 100), v: s2(t2.v - 100 * e2.top, 0, 100) });
        }, "onKey"), "aria-label": "Color", "aria-valuetext": "Saturation " + b(t2.s) + "%, Brightness " + b(t2.v) + "%" }, react_default.createElement(p2, { className: "react-colorful__saturation-pointer", top: 1 - t2.v / 100, left: t2.s / 100, color: q(t2) })));
      }), F = __name(function(e2, r2) {
        if (e2 === r2) return !0;
        for (var t2 in e2) if (e2[t2] !== r2[t2]) return !1;
        return !0;
      }, "F"), P3 = __name(function(e2, r2) {
        return e2.replace(/\s/g, "") === r2.replace(/\s/g, "");
      }, "P"), X = __name(function(e2, r2) {
        return e2.toLowerCase() === r2.toLowerCase() || F(C2(e2), C2(r2));
      }, "X");
      __name(Y, "Y");
      V = typeof window < "u" ? useLayoutEffect : useEffect, $ = __name(function() {
        return R || (typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0);
      }, "$"), J = /* @__PURE__ */ new Map(), Q = __name(function(e2) {
        V(function() {
          var r2 = e2.current ? e2.current.ownerDocument : document;
          if (r2 !== void 0 && !J.has(r2)) {
            var t2 = r2.createElement("style");
            t2.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, J.set(r2, t2);
            var n2 = $();
            n2 && t2.setAttribute("nonce", n2), r2.head.appendChild(t2);
          }
        }, []);
      }, "Q"), U = __name(function(t2) {
        var n2 = t2.className, o2 = t2.colorModel, a22 = t2.color, l2 = a22 === void 0 ? o2.defaultColor : a22, i22 = t2.onChange, s22 = c(t2, ["className", "colorModel", "color", "onChange"]), f22 = useRef(null);
        Q(f22);
        var v22 = Y(o2, l2, i22), d22 = v22[0], h22 = v22[1], m22 = g(["react-colorful", n2]);
        return react_default.createElement("div", u({}, s22, { ref: f22, className: m22 }), react_default.createElement(T, { hsva: d22, onChange: h22 }), react_default.createElement(S, { hue: d22.h, onChange: h22, className: "react-colorful__last-control" }));
      }, "U"), W = { defaultColor: "000", toHsva: x, fromHsva: __name(function(e2) {
        return w({ h: e2.h, s: e2.s, v: e2.v, a: 1 });
      }, "fromHsva"), equal: X }, Z = __name(function(r2) {
        return react_default.createElement(U, u({}, r2, { colorModel: W }));
      }, "Z"), ee = __name(function(r2) {
        var t2 = r2.className, n2 = r2.hsva, o2 = r2.onChange, a22 = { backgroundImage: "linear-gradient(90deg, " + k(Object.assign({}, n2, { a: 0 })) + ", " + k(Object.assign({}, n2, { a: 1 })) + ")" }, l2 = g(["react-colorful__alpha", t2]), u22 = b(100 * n2.a);
        return react_default.createElement("div", { className: l2 }, react_default.createElement("div", { className: "react-colorful__alpha-gradient", style: a22 }), react_default.createElement(m, { onMove: __name(function(e2) {
          o2({ a: e2.left });
        }, "onMove"), onKey: __name(function(e2) {
          o2({ a: s2(n2.a + e2.left) });
        }, "onKey"), "aria-label": "Alpha", "aria-valuetext": u22 + "%", "aria-valuenow": u22, "aria-valuemin": "0", "aria-valuemax": "100" }, react_default.createElement(p2, { className: "react-colorful__alpha-pointer", left: n2.a, color: k(n2) })));
      }, "ee"), re = __name(function(t2) {
        var n2 = t2.className, o2 = t2.colorModel, a22 = t2.color, l2 = a22 === void 0 ? o2.defaultColor : a22, i22 = t2.onChange, s22 = c(t2, ["className", "colorModel", "color", "onChange"]), f22 = useRef(null);
        Q(f22);
        var v22 = Y(o2, l2, i22), d22 = v22[0], h22 = v22[1], m22 = g(["react-colorful", n2]);
        return react_default.createElement("div", u({}, s22, { ref: f22, className: m22 }), react_default.createElement(T, { hsva: d22, onChange: h22 }), react_default.createElement(S, { hue: d22.h, onChange: h22 }), react_default.createElement(ee, { hsva: d22, onChange: h22, className: "react-colorful__last-control" }));
      }, "re"), le = { defaultColor: "hsla(0, 0%, 0%, 1)", toHsva: H, fromHsva: k, equal: P3 }, ue = __name(function(r2) {
        return react_default.createElement(re, u({}, r2, { colorModel: le }));
      }, "ue"), Ee = { defaultColor: "rgba(0, 0, 0, 1)", toHsva: z, fromHsva: __name(function(e2) {
        var r2 = I(e2);
        return "rgba(" + r2.r + ", " + r2.g + ", " + r2.b + ", " + r2.a + ")";
      }, "fromHsva"), equal: P3 }, He = __name(function(r2) {
        return react_default.createElement(re, u({}, r2, { colorModel: Ee }));
      }, "He"), Wrapper5 = styled.div({
        position: "relative",
        maxWidth: 250,
        '&[aria-readonly="true"]': {
          opacity: 0.5
        }
      }), PickerTooltip = styled(WithTooltip2)({
        position: "absolute",
        zIndex: 1,
        top: 4,
        left: 4,
        "[aria-readonly=true] &": {
          cursor: "not-allowed"
        }
      }), TooltipContent = styled.div({
        width: 200,
        margin: 5,
        ".react-colorful__saturation": {
          borderRadius: "4px 4px 0 0"
        },
        ".react-colorful__hue": {
          boxShadow: "inset 0 0 0 1px rgb(0 0 0 / 5%)"
        },
        ".react-colorful__last-control": {
          borderRadius: "0 0 4px 4px"
        }
      }), Note2 = styled(TooltipNote2)(({ theme: theme3 }) => ({
        fontFamily: theme3.typography.fonts.base
      })), Swatches = styled.div({
        display: "grid",
        gridTemplateColumns: "repeat(9, 16px)",
        gap: 6,
        padding: 3,
        marginTop: 5,
        width: 200
      }), SwatchColor = styled.div(({ theme: theme3, active }) => ({
        width: 16,
        height: 16,
        boxShadow: active ? `${theme3.appBorderColor} 0 0 0 1px inset, ${theme3.textMutedColor}50 0 0 0 4px` : `${theme3.appBorderColor} 0 0 0 1px inset`,
        borderRadius: theme3.appBorderRadius
      })), swatchBackground = `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`, Swatch = __name(({ value: value2, style, ...props }) => {
        let backgroundImage = `linear-gradient(${value2}, ${value2}), ${swatchBackground}, linear-gradient(#fff, #fff)`;
        return react_default.createElement(SwatchColor, { ...props, style: { ...style, backgroundImage } });
      }, "Swatch"), Input5 = styled(Form2.Input)(({ theme: theme3, readOnly }) => ({
        width: "100%",
        paddingLeft: 30,
        paddingRight: 30,
        boxSizing: "border-box",
        fontFamily: theme3.typography.fonts.base
      })), ToggleIcon = styled(MarkupIcon)(({ theme: theme3 }) => ({
        position: "absolute",
        zIndex: 1,
        top: 6,
        right: 7,
        width: 20,
        height: 20,
        padding: 4,
        boxSizing: "border-box",
        cursor: "pointer",
        color: theme3.input.color
      })), ColorSpace = ((ColorSpace2) => (ColorSpace2.RGB = "rgb", ColorSpace2.HSL = "hsl", ColorSpace2.HEX = "hex", ColorSpace2))(ColorSpace || {}), COLOR_SPACES = Object.values(ColorSpace), COLOR_REGEXP2 = /\(([0-9]+),\s*([0-9]+)%?,\s*([0-9]+)%?,?\s*([0-9.]+)?\)/, RGB_REGEXP = /^\s*rgba?\(([0-9]+),\s*([0-9]+),\s*([0-9]+),?\s*([0-9.]+)?\)\s*$/i, HSL_REGEXP = /^\s*hsla?\(([0-9]+),\s*([0-9]+)%,\s*([0-9]+)%,?\s*([0-9.]+)?\)\s*$/i, HEX_REGEXP2 = /^\s*#?([0-9a-f]{3}|[0-9a-f]{6})\s*$/i, SHORTHEX_REGEXP = /^\s*#?([0-9a-f]{3})\s*$/i, ColorPicker = {
        hex: Z,
        rgb: He,
        hsl: ue
      }, fallbackColor = {
        hex: "transparent",
        rgb: "rgba(0, 0, 0, 0)",
        hsl: "hsla(0, 0%, 0%, 0)"
      }, stringToArgs = __name((value2) => {
        let match2 = value2?.match(COLOR_REGEXP2);
        if (!match2)
          return [0, 0, 0, 1];
        let [, x22, y22, z22, a22 = 1] = match2;
        return [x22, y22, z22, a22].map(Number);
      }, "stringToArgs"), parseRgb = __name((value2) => {
        let [r2, g22, b22, a22] = stringToArgs(value2), [h22, s22, l2] = import_color_convert.default.rgb.hsl([r2, g22, b22]) || [0, 0, 0];
        return {
          valid: !0,
          value: value2,
          keyword: import_color_convert.default.rgb.keyword([r2, g22, b22]),
          colorSpace: "rgb",
          rgb: value2,
          hsl: `hsla(${h22}, ${s22}%, ${l2}%, ${a22})`,
          hex: `#${import_color_convert.default.rgb.hex([r2, g22, b22]).toLowerCase()}`
        };
      }, "parseRgb"), parseHsl = __name((value2) => {
        let [h22, s22, l2, a22] = stringToArgs(value2), [r2, g22, b22] = import_color_convert.default.hsl.rgb([h22, s22, l2]) || [0, 0, 0];
        return {
          valid: !0,
          value: value2,
          keyword: import_color_convert.default.hsl.keyword([h22, s22, l2]),
          colorSpace: "hsl",
          rgb: `rgba(${r2}, ${g22}, ${b22}, ${a22})`,
          hsl: value2,
          hex: `#${import_color_convert.default.hsl.hex([h22, s22, l2]).toLowerCase()}`
        };
      }, "parseHsl"), parseHexOrKeyword = __name((value2) => {
        let plain = value2.replace("#", ""), rgb2 = import_color_convert.default.keyword.rgb(plain) || import_color_convert.default.hex.rgb(plain), hsl2 = import_color_convert.default.rgb.hsl(rgb2), mapped = value2;
        /[^#a-f0-9]/i.test(value2) ? mapped = plain : HEX_REGEXP2.test(value2) && (mapped = `#${plain}`);
        let valid = !0;
        if (mapped.startsWith("#"))
          valid = HEX_REGEXP2.test(mapped);
        else
          try {
            import_color_convert.default.keyword.hex(mapped);
          } catch {
            valid = !1;
          }
        return {
          valid,
          value: mapped,
          keyword: import_color_convert.default.rgb.keyword(rgb2),
          colorSpace: "hex",
          rgb: `rgba(${rgb2[0]}, ${rgb2[1]}, ${rgb2[2]}, 1)`,
          hsl: `hsla(${hsl2[0]}, ${hsl2[1]}%, ${hsl2[2]}%, 1)`,
          hex: mapped
        };
      }, "parseHexOrKeyword"), parseValue = __name((value2) => {
        if (value2)
          return RGB_REGEXP.test(value2) ? parseRgb(value2) : HSL_REGEXP.test(value2) ? parseHsl(value2) : parseHexOrKeyword(value2);
      }, "parseValue"), getRealValue = __name((value2, color2, colorSpace) => {
        if (!value2 || !color2?.valid)
          return fallbackColor[colorSpace];
        if (colorSpace !== "hex")
          return color2?.[colorSpace] || fallbackColor[colorSpace];
        if (!color2.hex.startsWith("#"))
          try {
            return `#${import_color_convert.default.keyword.hex(color2.hex)}`;
          } catch {
            return fallbackColor.hex;
          }
        let short = color2.hex.match(SHORTHEX_REGEXP);
        if (!short)
          return HEX_REGEXP2.test(color2.hex) ? color2.hex : fallbackColor.hex;
        let [r2, g22, b22] = short[1].split("");
        return `#${r2}${r2}${g22}${g22}${b22}${b22}`;
      }, "getRealValue"), useColorInput = __name((initialValue, onChange) => {
        let [value2, setValue] = useState(initialValue || ""), [color2, setColor] = useState(() => parseValue(value2)), [colorSpace, setColorSpace] = useState(
          color2?.colorSpace || "hex"
          /* HEX */
        );
        useEffect(() => {
          let nextValue = initialValue || "", nextColor = parseValue(nextValue);
          setValue(nextValue), setColor(nextColor), setColorSpace(
            nextColor?.colorSpace || "hex"
            /* HEX */
          );
        }, [initialValue]);
        let realValue = useMemo(
          () => getRealValue(value2, color2, colorSpace).toLowerCase(),
          [value2, color2, colorSpace]
        ), updateValue = useCallback(
          (update) => {
            let parsed = parseValue(update), v22 = parsed?.value || update || "";
            setValue(v22), v22 === "" && (setColor(void 0), onChange(void 0)), parsed && (setColor(parsed), setColorSpace(parsed.colorSpace), onChange(parsed.value));
          },
          [onChange]
        ), cycleColorSpace = useCallback(() => {
          let nextIndex = (COLOR_SPACES.indexOf(colorSpace) + 1) % COLOR_SPACES.length, nextSpace = COLOR_SPACES[nextIndex];
          setColorSpace(nextSpace);
          let updatedValue = color2?.[nextSpace] || "";
          setValue(updatedValue), onChange(updatedValue);
        }, [color2, colorSpace, onChange]);
        return { value: value2, realValue, updateValue, color: color2, colorSpace, cycleColorSpace };
      }, "useColorInput"), id = __name((value2) => value2.replace(/\s*/, "").toLowerCase(), "id"), usePresets = __name((presetColors, currentColor, colorSpace) => {
        let [selectedColors, setSelectedColors] = useState(currentColor?.valid ? [currentColor] : []);
        useEffect(() => {
          currentColor === void 0 && setSelectedColors([]);
        }, [currentColor]);
        let presets = useMemo(() => (presetColors || []).map((preset) => typeof preset == "string" ? parseValue(preset) : preset.title ? { ...parseValue(preset.color), keyword: preset.title } : parseValue(preset.color)).concat(selectedColors).filter(Boolean).slice(-27), [presetColors, selectedColors]), addPreset = useCallback(
          (color2) => {
            color2?.valid && (presets.some(
              (preset) => preset && preset[colorSpace] && id(preset[colorSpace] || "") === id(color2[colorSpace] || "")
            ) || setSelectedColors((arr) => arr.concat(color2)));
          },
          [colorSpace, presets]
        );
        return { presets, addPreset };
      }, "usePresets"), ColorControl = __name(({
        name,
        value: initialValue,
        onChange,
        onFocus,
        onBlur,
        presetColors,
        startOpen = !1,
        argType
      }) => {
        let debouncedOnChange = useCallback(debounce2(onChange, 200), [onChange]), { value: value2, realValue, updateValue, color: color2, colorSpace, cycleColorSpace } = useColorInput(
          initialValue,
          debouncedOnChange
        ), { presets, addPreset } = usePresets(presetColors ?? [], color2, colorSpace), Picker = ColorPicker[colorSpace], readonly = !!argType?.table?.readonly;
        return react_default.createElement(Wrapper5, { "aria-readonly": readonly }, react_default.createElement(
          PickerTooltip,
          {
            startOpen,
            trigger: readonly ? null : void 0,
            closeOnOutsideClick: !0,
            onVisibleChange: () => color2 && addPreset(color2),
            tooltip: react_default.createElement(TooltipContent, null, react_default.createElement(
              Picker,
              {
                color: realValue === "transparent" ? "#000000" : realValue,
                onChange: updateValue,
                onFocus,
                onBlur
              }
            ), presets.length > 0 && react_default.createElement(Swatches, null, presets.map((preset, index3) => react_default.createElement(
              WithTooltip2,
              {
                key: `${preset?.value || index3}-${index3}`,
                hasChrome: !1,
                tooltip: react_default.createElement(Note2, { note: preset?.keyword || preset?.value || "" })
              },
              react_default.createElement(
                Swatch,
                {
                  value: preset?.[colorSpace] || "",
                  active: !!(color2 && preset && preset[colorSpace] && id(preset[colorSpace] || "") === id(color2[colorSpace])),
                  onClick: () => preset && updateValue(preset.value || "")
                }
              )
            ))))
          },
          react_default.createElement(Swatch, { value: realValue, style: { margin: 4 } })
        ), react_default.createElement(
          Input5,
          {
            id: getControlId(name),
            value: value2,
            onChange: (e2) => updateValue(e2.target.value),
            onFocus: (e2) => e2.target.select(),
            readOnly: readonly,
            placeholder: "Choose color..."
          }
        ), value2 ? react_default.createElement(ToggleIcon, { onClick: cycleColorSpace }) : null);
      }, "ColorControl"), Color_default = ColorControl;
    }
  });

  // node_modules/.cache/storybook/1c3385a5d25e538d10b518b310c74d3ca2690b6aaffeadccd74da79736171f86/sb-manager/storybook-core-server-presets-0/common-manager-bundle.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_L2D73C6Z();

  // node_modules/storybook/dist/_browser-chunks/chunk-I74EUU5O.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_RNE2IUTB();
  init_chunk_BOOOPFZF();
  init_chunk_VAMFPZY3();

  // node_modules/storybook/dist/_browser-chunks/chunk-OBXWFEPB.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MH6AXFXB();
  init_chunk_MM7DTO55();
  function _assertThisInitialized(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  __name(_assertThisInitialized, "_assertThisInitialized");
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  __name(_setPrototypeOf, "_setPrototypeOf");
  function _inheritsLoose(t, o2) {
    t.prototype = Object.create(o2.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o2);
  }
  __name(_inheritsLoose, "_inheritsLoose");
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  __name(_getPrototypeOf, "_getPrototypeOf");
  function _isNativeFunction(t) {
    try {
      return Function.toString.call(t).indexOf("[native code]") !== -1;
    } catch {
      return typeof t == "function";
    }
  }
  __name(_isNativeFunction, "_isNativeFunction");
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (_isNativeReflectConstruct = __name(function() {
      return !!t;
    }, "_isNativeReflectConstruct"))();
  }
  __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
  function _construct(t, e, r2) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o2 = [null];
    o2.push.apply(o2, e);
    var p4 = new (t.bind.apply(t, o2))();
    return r2 && _setPrototypeOf(p4, r2.prototype), p4;
  }
  __name(_construct, "_construct");
  function _wrapNativeSuper(t) {
    var r2 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return _wrapNativeSuper = __name(function(t2) {
      if (t2 === null || !_isNativeFunction(t2)) return t2;
      if (typeof t2 != "function") throw new TypeError("Super expression must either be null or a function");
      if (r2 !== void 0) {
        if (r2.has(t2)) return r2.get(t2);
        r2.set(t2, Wrapper13);
      }
      function Wrapper13() {
        return _construct(t2, arguments, _getPrototypeOf(this).constructor);
      }
      return __name(Wrapper13, "Wrapper"), Wrapper13.prototype = Object.create(t2.prototype, {
        constructor: {
          value: Wrapper13,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper13, t2);
    }, "_wrapNativeSuper"), _wrapNativeSuper(t);
  }
  __name(_wrapNativeSuper, "_wrapNativeSuper");
  var ERRORS = {
    1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
    2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
    3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
    4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
    5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
    6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
    7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
    8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
    9: `Please provide a number of steps to the modularScale helper.

`,
    10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
    11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
    12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
    13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
    14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
    15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
    16: `You must provide a template to this method.

`,
    17: `You passed an unsupported selector state to this method.

`,
    18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
    19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
    20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
    21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    23: `fontFace expects a name of a font-family.

`,
    24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
    25: `fontFace expects localFonts to be an array.

`,
    26: `fontFace expects fileFormats to be an array.

`,
    27: `radialGradient requries at least 2 color-stops to properly render.

`,
    28: `Please supply a filename to retinaImage() as the first argument.

`,
    29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
    30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
    32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
    33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
    34: `borderRadius expects a radius value as a string or number as the second argument.

`,
    35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
    36: `Property must be a string value.

`,
    37: `Syntax Error at %s.

`,
    38: `Formula contains a function that needs parentheses at %s.

`,
    39: `Formula is missing closing parenthesis at %s.

`,
    40: `Formula has too many closing parentheses at %s.

`,
    41: `All values in a formula must have the same unit or be unitless.

`,
    42: `Please provide a number of steps to the modularScale helper.

`,
    43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
    44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
    45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
    46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
    47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
    48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
    49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
    50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
    51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
    52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
    53: `fontFace expects localFonts to be an array.

`,
    54: `fontFace expects fileFormats to be an array.

`,
    55: `fontFace expects a name of a font-family.

`,
    56: `linearGradient requries at least 2 color-stops to properly render.

`,
    57: `radialGradient requries at least 2 color-stops to properly render.

`,
    58: `Please supply a filename to retinaImage() as the first argument.

`,
    59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
    60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    61: `Property must be a string value.

`,
    62: `borderRadius expects a radius value as a string or number as the second argument.

`,
    63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
    64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
    65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
    66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
    67: `You must provide a template to this method.

`,
    68: `You passed an unsupported selector state to this method.

`,
    69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
    70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
    71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
    72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
    73: `Please provide a valid CSS variable.

`,
    74: `CSS variable not found and no default was provided.

`,
    75: `important requires a valid style object, got a %s instead.

`,
    76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
    77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
    78: `base must be set in "px" or "%" but you set it in "%s".
`
  };
  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    var a3 = args[0], b3 = [], c3;
    for (c3 = 1; c3 < args.length; c3 += 1)
      b3.push(args[c3]);
    return b3.forEach(function(d3) {
      a3 = a3.replace(/%[a-z]/, d3);
    }), a3;
  }
  __name(format, "format");
  var PolishedError = (function(_Error) {
    _inheritsLoose(PolishedError2, _Error);
    function PolishedError2(code) {
      for (var _this, _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
        args[_key2 - 1] = arguments[_key2];
      return _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this, _assertThisInitialized(_this);
    }
    return __name(PolishedError2, "PolishedError"), PolishedError2;
  })(_wrapNativeSuper(Error));
  function endsWith(string, suffix) {
    return string.substr(-suffix.length) === suffix;
  }
  __name(endsWith, "endsWith");
  var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
  function stripUnit(value2) {
    if (typeof value2 != "string") return value2;
    var matchedValue = value2.match(cssRegex$1);
    return matchedValue ? parseFloat(value2) : value2;
  }
  __name(stripUnit, "stripUnit");
  var pxtoFactory = __name(function(to) {
    return function(pxval, base) {
      base === void 0 && (base = "16px");
      var newPxval = pxval, newBase = base;
      if (typeof pxval == "string") {
        if (!endsWith(pxval, "px"))
          throw new PolishedError(69, to, pxval);
        newPxval = stripUnit(pxval);
      }
      if (typeof base == "string") {
        if (!endsWith(base, "px"))
          throw new PolishedError(70, to, base);
        newBase = stripUnit(base);
      }
      if (typeof newPxval == "string")
        throw new PolishedError(71, pxval, to);
      if (typeof newBase == "string")
        throw new PolishedError(72, base, to);
      return "" + newPxval / newBase + to;
    };
  }, "pxtoFactory"), pixelsto = pxtoFactory, em = pixelsto("em"), rem = pixelsto("rem");
  function colorToInt(color2) {
    return Math.round(color2 * 255);
  }
  __name(colorToInt, "colorToInt");
  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }
  __name(convertToInt, "convertToInt");
  function hslToRgb(hue, saturation, lightness, convert5) {
    if (convert5 === void 0 && (convert5 = convertToInt), saturation === 0)
      return convert5(lightness, lightness, lightness);
    var huePrime = (hue % 360 + 360) % 360 / 60, chroma = (1 - Math.abs(2 * lightness - 1)) * saturation, secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1)), red = 0, green = 0, blue = 0;
    huePrime >= 0 && huePrime < 1 ? (red = chroma, green = secondComponent) : huePrime >= 1 && huePrime < 2 ? (red = secondComponent, green = chroma) : huePrime >= 2 && huePrime < 3 ? (green = chroma, blue = secondComponent) : huePrime >= 3 && huePrime < 4 ? (green = secondComponent, blue = chroma) : huePrime >= 4 && huePrime < 5 ? (red = secondComponent, blue = chroma) : huePrime >= 5 && huePrime < 6 && (red = chroma, blue = secondComponent);
    var lightnessModification = lightness - chroma / 2, finalRed = red + lightnessModification, finalGreen = green + lightnessModification, finalBlue = blue + lightnessModification;
    return convert5(finalRed, finalGreen, finalBlue);
  }
  __name(hslToRgb, "hslToRgb");
  var namedColorMap = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "639",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  function nameToHex(color2) {
    if (typeof color2 != "string") return color2;
    var normalizedColorName = color2.toLowerCase();
    return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
  }
  __name(nameToHex, "nameToHex");
  var hexRegex = /^#[a-fA-F0-9]{6}$/, hexRgbaRegex = /^#[a-fA-F0-9]{8}$/, reducedHexRegex = /^#[a-fA-F0-9]{3}$/, reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/, rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
  function parseToRgb(color2) {
    if (typeof color2 != "string")
      throw new PolishedError(3);
    var normalizedColor = nameToHex(color2);
    if (normalizedColor.match(hexRegex))
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
      };
    if (normalizedColor.match(hexRgbaRegex)) {
      var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
        alpha
      };
    }
    if (normalizedColor.match(reducedHexRegex))
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
      };
    if (normalizedColor.match(reducedRgbaHexRegex)) {
      var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
        alpha: _alpha
      };
    }
    var rgbMatched = rgbRegex.exec(normalizedColor);
    if (rgbMatched)
      return {
        red: parseInt("" + rgbMatched[1], 10),
        green: parseInt("" + rgbMatched[2], 10),
        blue: parseInt("" + rgbMatched[3], 10)
      };
    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
    if (rgbaMatched)
      return {
        red: parseInt("" + rgbaMatched[1], 10),
        green: parseInt("" + rgbaMatched[2], 10),
        blue: parseInt("" + rgbaMatched[3], 10),
        alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
      };
    var hslMatched = hslRegex.exec(normalizedColor);
    if (hslMatched) {
      var hue = parseInt("" + hslMatched[1], 10), saturation = parseInt("" + hslMatched[2], 10) / 100, lightness = parseInt("" + hslMatched[3], 10) / 100, rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")", hslRgbMatched = rgbRegex.exec(rgbColorString);
      if (!hslRgbMatched)
        throw new PolishedError(4, normalizedColor, rgbColorString);
      return {
        red: parseInt("" + hslRgbMatched[1], 10),
        green: parseInt("" + hslRgbMatched[2], 10),
        blue: parseInt("" + hslRgbMatched[3], 10)
      };
    }
    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
    if (hslaMatched) {
      var _hue = parseInt("" + hslaMatched[1], 10), _saturation = parseInt("" + hslaMatched[2], 10) / 100, _lightness = parseInt("" + hslaMatched[3], 10) / 100, _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")", _hslRgbMatched = rgbRegex.exec(_rgbColorString);
      if (!_hslRgbMatched)
        throw new PolishedError(4, normalizedColor, _rgbColorString);
      return {
        red: parseInt("" + _hslRgbMatched[1], 10),
        green: parseInt("" + _hslRgbMatched[2], 10),
        blue: parseInt("" + _hslRgbMatched[3], 10),
        alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
      };
    }
    throw new PolishedError(5);
  }
  __name(parseToRgb, "parseToRgb");
  function rgbToHsl(color2) {
    var red = color2.red / 255, green = color2.green / 255, blue = color2.blue / 255, max2 = Math.max(red, green, blue), min2 = Math.min(red, green, blue), lightness = (max2 + min2) / 2;
    if (max2 === min2)
      return color2.alpha !== void 0 ? {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color2.alpha
      } : {
        hue: 0,
        saturation: 0,
        lightness
      };
    var hue, delta = max2 - min2, saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
    switch (max2) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      default:
        hue = (red - green) / delta + 4;
        break;
    }
    return hue *= 60, color2.alpha !== void 0 ? {
      hue,
      saturation,
      lightness,
      alpha: color2.alpha
    } : {
      hue,
      saturation,
      lightness
    };
  }
  __name(rgbToHsl, "rgbToHsl");
  function parseToHsl(color2) {
    return rgbToHsl(parseToRgb(color2));
  }
  __name(parseToHsl, "parseToHsl");
  var reduceHexValue = __name(function(value2) {
    return value2.length === 7 && value2[1] === value2[2] && value2[3] === value2[4] && value2[5] === value2[6] ? "#" + value2[1] + value2[3] + value2[5] : value2;
  }, "reduceHexValue"), reduceHexValue$1 = reduceHexValue;
  function numberToHex(value2) {
    var hex2 = value2.toString(16);
    return hex2.length === 1 ? "0" + hex2 : hex2;
  }
  __name(numberToHex, "numberToHex");
  function colorToHex(color2) {
    return numberToHex(Math.round(color2 * 255));
  }
  __name(colorToHex, "colorToHex");
  function convertToHex(red, green, blue) {
    return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
  }
  __name(convertToHex, "convertToHex");
  function hslToHex(hue, saturation, lightness) {
    return hslToRgb(hue, saturation, lightness, convertToHex);
  }
  __name(hslToHex, "hslToHex");
  function hsl(value2, saturation, lightness) {
    if (typeof value2 == "number" && typeof saturation == "number" && typeof lightness == "number")
      return hslToHex(value2, saturation, lightness);
    if (typeof value2 == "object" && saturation === void 0 && lightness === void 0)
      return hslToHex(value2.hue, value2.saturation, value2.lightness);
    throw new PolishedError(1);
  }
  __name(hsl, "hsl");
  function hsla(value2, saturation, lightness, alpha) {
    if (typeof value2 == "number" && typeof saturation == "number" && typeof lightness == "number" && typeof alpha == "number")
      return alpha >= 1 ? hslToHex(value2, saturation, lightness) : "rgba(" + hslToRgb(value2, saturation, lightness) + "," + alpha + ")";
    if (typeof value2 == "object" && saturation === void 0 && lightness === void 0 && alpha === void 0)
      return value2.alpha >= 1 ? hslToHex(value2.hue, value2.saturation, value2.lightness) : "rgba(" + hslToRgb(value2.hue, value2.saturation, value2.lightness) + "," + value2.alpha + ")";
    throw new PolishedError(2);
  }
  __name(hsla, "hsla");
  function rgb(value2, green, blue) {
    if (typeof value2 == "number" && typeof green == "number" && typeof blue == "number")
      return reduceHexValue$1("#" + numberToHex(value2) + numberToHex(green) + numberToHex(blue));
    if (typeof value2 == "object" && green === void 0 && blue === void 0)
      return reduceHexValue$1("#" + numberToHex(value2.red) + numberToHex(value2.green) + numberToHex(value2.blue));
    throw new PolishedError(6);
  }
  __name(rgb, "rgb");
  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue == "string" && typeof secondValue == "number") {
      var rgbValue = parseToRgb(firstValue);
      return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
    } else {
      if (typeof firstValue == "number" && typeof secondValue == "number" && typeof thirdValue == "number" && typeof fourthValue == "number")
        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
      if (typeof firstValue == "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0)
        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
    }
    throw new PolishedError(7);
  }
  __name(rgba, "rgba");
  var isRgb = __name(function(color2) {
    return typeof color2.red == "number" && typeof color2.green == "number" && typeof color2.blue == "number" && (typeof color2.alpha != "number" || typeof color2.alpha > "u");
  }, "isRgb"), isRgba = __name(function(color2) {
    return typeof color2.red == "number" && typeof color2.green == "number" && typeof color2.blue == "number" && typeof color2.alpha == "number";
  }, "isRgba"), isHsl = __name(function(color2) {
    return typeof color2.hue == "number" && typeof color2.saturation == "number" && typeof color2.lightness == "number" && (typeof color2.alpha != "number" || typeof color2.alpha > "u");
  }, "isHsl"), isHsla = __name(function(color2) {
    return typeof color2.hue == "number" && typeof color2.saturation == "number" && typeof color2.lightness == "number" && typeof color2.alpha == "number";
  }, "isHsla");
  function toColorString(color2) {
    if (typeof color2 != "object") throw new PolishedError(8);
    if (isRgba(color2)) return rgba(color2);
    if (isRgb(color2)) return rgb(color2);
    if (isHsla(color2)) return hsla(color2);
    if (isHsl(color2)) return hsl(color2);
    throw new PolishedError(8);
  }
  __name(toColorString, "toColorString");
  function curried(f4, length2, acc) {
    return __name(function() {
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length2 ? f4.apply(this, combined) : curried(f4, length2, combined);
    }, "fn");
  }
  __name(curried, "curried");
  function curry(f4) {
    return curried(f4, f4.length, []);
  }
  __name(curry, "curry");
  function adjustHue(degree, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      hue: hslColor.hue + parseFloat(degree)
    }));
  }
  __name(adjustHue, "adjustHue");
  var curriedAdjustHue = curry(adjustHue);
  function guard(lowerBoundary, upperBoundary, value2) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value2));
  }
  __name(guard, "guard");
  function darken2(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
    }));
  }
  __name(darken2, "darken");
  var curriedDarken = curry(darken2), curriedDarken$1 = curriedDarken;
  function desaturate(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
    }));
  }
  __name(desaturate, "desaturate");
  var curriedDesaturate = curry(desaturate);
  function lighten2(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
    }));
  }
  __name(lighten2, "lighten");
  var curriedLighten = curry(lighten2), curriedLighten$1 = curriedLighten;
  function mix(weight, color2, otherColor) {
    if (color2 === "transparent") return otherColor;
    if (otherColor === "transparent") return color2;
    if (weight === 0) return otherColor;
    var parsedColor1 = parseToRgb(color2), color1 = _extends({}, parsedColor1, {
      alpha: typeof parsedColor1.alpha == "number" ? parsedColor1.alpha : 1
    }), parsedColor2 = parseToRgb(otherColor), color22 = _extends({}, parsedColor2, {
      alpha: typeof parsedColor2.alpha == "number" ? parsedColor2.alpha : 1
    }), alphaDelta = color1.alpha - color22.alpha, x3 = parseFloat(weight) * 2 - 1, y3 = x3 * alphaDelta === -1 ? x3 : x3 + alphaDelta, z3 = 1 + x3 * alphaDelta, weight1 = (y3 / z3 + 1) / 2, weight2 = 1 - weight1, mixedColor = {
      red: Math.floor(color1.red * weight1 + color22.red * weight2),
      green: Math.floor(color1.green * weight1 + color22.green * weight2),
      blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
      alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
    };
    return rgba(mixedColor);
  }
  __name(mix, "mix");
  var curriedMix = curry(mix), mix$1 = curriedMix;
  function opacify(amount, color2) {
    if (color2 === "transparent") return color2;
    var parsedColor = parseToRgb(color2), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
    });
    return rgba(colorWithAlpha);
  }
  __name(opacify, "opacify");
  var curriedOpacify = curry(opacify), curriedOpacify$1 = curriedOpacify;
  function saturate(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
    }));
  }
  __name(saturate, "saturate");
  var curriedSaturate = curry(saturate);
  function setHue(hue, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      hue: parseFloat(hue)
    }));
  }
  __name(setHue, "setHue");
  var curriedSetHue = curry(setHue);
  function setLightness(lightness, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      lightness: parseFloat(lightness)
    }));
  }
  __name(setLightness, "setLightness");
  var curriedSetLightness = curry(setLightness);
  function setSaturation(saturation, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      saturation: parseFloat(saturation)
    }));
  }
  __name(setSaturation, "setSaturation");
  var curriedSetSaturation = curry(setSaturation);
  function shade(percentage, color2) {
    return color2 === "transparent" ? color2 : mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
  }
  __name(shade, "shade");
  var curriedShade = curry(shade);
  function tint(percentage, color2) {
    return color2 === "transparent" ? color2 : mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
  }
  __name(tint, "tint");
  var curriedTint = curry(tint);
  function transparentize(amount, color2) {
    if (color2 === "transparent") return color2;
    var parsedColor = parseToRgb(color2), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
    });
    return rgba(colorWithAlpha);
  }
  __name(transparentize, "transparentize");
  var curriedTransparentize = curry(transparentize), curriedTransparentize$1 = curriedTransparentize;

  // node_modules/storybook/dist/_browser-chunks/chunk-I74EUU5O.js
  init_chunk_MH6AXFXB();

  // node_modules/storybook/dist/_browser-chunks/chunk-LYCSRYYR.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var ANIMATION_TIMEOUT = 5e3;
  function isTestEnvironment() {
    try {
      return (
        // @ts-expect-error This property exists in Vitest browser mode
        !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
      );
    } catch {
      return !1;
    }
  }
  __name(isTestEnvironment, "isTestEnvironment");
  function pauseAnimations(atEnd = !0) {
    if (!("document" in globalThis && "createElement" in globalThis.document))
      return () => {
      };
    let disableStyle = document.createElement("style");
    disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(disableStyle);
    let pauseStyle = document.createElement("style");
    return pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(pauseStyle), document.body.clientHeight, document.head.removeChild(disableStyle), () => {
      pauseStyle.parentNode?.removeChild(pauseStyle);
    };
  }
  __name(pauseAnimations, "pauseAnimations");
  async function waitForAnimations(signal) {
    if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
      return;
    let timedOut = !1;
    await Promise.race([
      // After 50ms, retrieve any running animations and wait for them to finish
      // If new animations are created while waiting, we'll wait for them too
      new Promise((resolve) => {
        setTimeout(() => {
          let animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)], checkAnimationsFinished = __name(async () => {
            if (timedOut || signal?.aborted)
              return;
            let runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a3) => a3.playState === "running" && !isInfiniteAnimation(a3));
            runningAnimations.length > 0 && (await Promise.all(runningAnimations.map((a3) => a3.finished)), await checkAnimationsFinished());
          }, "checkAnimationsFinished");
          checkAnimationsFinished().then(resolve);
        }, 100);
      }),
      // If animations don't finish within the timeout, continue without waiting
      new Promise(
        (resolve) => setTimeout(() => {
          timedOut = !0, resolve(void 0);
        }, ANIMATION_TIMEOUT)
      )
    ]);
  }
  __name(waitForAnimations, "waitForAnimations");
  function getShadowRoots(doc) {
    return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => ("shadowRoot" in el && el.shadowRoot && acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot)), acc), []);
  }
  __name(getShadowRoots, "getShadowRoots");
  function isInfiniteAnimation(anim) {
    if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
      let style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement), index3 = style.animationName?.split(", ").indexOf(anim.animationName);
      return style.animationIterationCount.split(", ")[index3] === "infinite";
    }
    return !1;
  }
  __name(isInfiniteAnimation, "isInfiniteAnimation");

  // node_modules/storybook/dist/_browser-chunks/chunk-I74EUU5O.js
  init_chunk_NVV6MIOE();
  init_chunk_MM7DTO55();
  init_react();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react_dom();
  init_react();
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1), import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  init_react();
  init_react();
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  init_react();
  var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
  init_react();
  init_react_dom();
  var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_dist();
  init_theming();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();

  // node_modules/storybook/dist/csf/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-CADGRH3P.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID = "storybook/background", PARAM_KEY = "backgrounds", EVENTS = {
    UPDATE: `${ADDON_ID}/update`
  }, ADDON_ID2 = "storybook/measure-addon", TOOL_ID = `${ADDON_ID2}/tool`, PARAM_KEY2 = "measureEnabled", EVENTS2 = {
    RESULT: `${ADDON_ID2}/result`,
    REQUEST: `${ADDON_ID2}/request`,
    CLEAR: `${ADDON_ID2}/clear`
  }, ADDON_ID3 = "storybook/outline", PARAM_KEY3 = "outline", DEFAULT_BACKGROUNDS = {
    light: { name: "light", value: "#F8F8F8" },
    dark: { name: "dark", value: "#333" }
  };

  // node_modules/storybook/dist/_browser-chunks/chunk-W4QKLQSC.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-Y3M7TW6K.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var require_string_util = __commonJS2({
    "../node_modules/picoquery/lib/string-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.encodeString = encodeString;
      var hexTable = Array.from({ length: 256 }, (_3, i3) => "%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase()), noEscape = new Int8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        0
      ]);
      function encodeString(str2) {
        let len = str2.length;
        if (len === 0)
          return "";
        let out = "", lastPos = 0, i3 = 0;
        outer: for (; i3 < len; i3++) {
          let c3 = str2.charCodeAt(i3);
          for (; c3 < 128; ) {
            if (noEscape[c3] !== 1 && (lastPos < i3 && (out += str2.slice(lastPos, i3)), lastPos = i3 + 1, out += hexTable[c3]), ++i3 === len)
              break outer;
            c3 = str2.charCodeAt(i3);
          }
          if (lastPos < i3 && (out += str2.slice(lastPos, i3)), c3 < 2048) {
            lastPos = i3 + 1, out += hexTable[192 | c3 >> 6] + hexTable[128 | c3 & 63];
            continue;
          }
          if (c3 < 55296 || c3 >= 57344) {
            lastPos = i3 + 1, out += hexTable[224 | c3 >> 12] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
            continue;
          }
          if (++i3, i3 >= len)
            throw new Error("URI malformed");
          let c22 = str2.charCodeAt(i3) & 1023;
          lastPos = i3 + 1, c3 = 65536 + ((c3 & 1023) << 10 | c22), out += hexTable[240 | c3 >> 18] + hexTable[128 | c3 >> 12 & 63] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
        }
        return lastPos === 0 ? str2 : lastPos < len ? out + str2.slice(lastPos) : out;
      }
      __name(encodeString, "encodeString");
    }
  }), require_shared = __commonJS2({
    "../node_modules/picoquery/lib/shared.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
      var string_util_js_1 = require_string_util(), defaultValueSerializer = __name((value2) => {
        switch (typeof value2) {
          case "string":
            return (0, string_util_js_1.encodeString)(value2);
          case "bigint":
          case "boolean":
            return "" + value2;
          case "number":
            if (Number.isFinite(value2))
              return value2 < 1e21 ? "" + value2 : (0, string_util_js_1.encodeString)("" + value2);
            break;
        }
        return value2 instanceof Date ? (0, string_util_js_1.encodeString)(value2.toISOString()) : "";
      }, "defaultValueSerializer");
      exports.defaultValueSerializer = defaultValueSerializer;
      var defaultShouldSerializeObject = __name((val) => val instanceof Date, "defaultShouldSerializeObject");
      exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
      var identityFunc = __name((v3) => v3, "identityFunc");
      exports.defaultOptions = {
        nesting: !0,
        nestingSyntax: "dot",
        arrayRepeat: !1,
        arrayRepeatSyntax: "repeat",
        delimiter: 38,
        valueDeserializer: identityFunc,
        valueSerializer: exports.defaultValueSerializer,
        keyDeserializer: identityFunc,
        shouldSerializeObject: exports.defaultShouldSerializeObject
      };
    }
  }), require_object_util = __commonJS2({
    "../node_modules/picoquery/lib/object-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getDeepObject = getDeepObject, exports.stringifyObject = stringifyObject;
      var shared_js_1 = require_shared(), string_util_js_1 = require_string_util();
      function isPrototypeKey(value2) {
        return value2 === "__proto__" || value2 === "constructor" || value2 === "prototype";
      }
      __name(isPrototypeKey, "isPrototypeKey");
      function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
        if (isPrototypeKey(key))
          return obj;
        let currObj = obj[key];
        return typeof currObj == "object" && currObj !== null ? currObj : !forceObject && (forceArray || typeof nextKey == "number" || typeof nextKey == "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1) ? obj[key] = [] : obj[key] = {};
      }
      __name(getDeepObject, "getDeepObject");
      var MAX_DEPTH = 20, strBracketPair = "[]", strBracketLeft = "[", strBracketRight = "]", strDot = ".";
      function stringifyObject(obj, options2, depth = 0, parentKey, isProbableArray) {
        let { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options2, strDelimiter = typeof delimiter == "number" ? String.fromCharCode(delimiter) : delimiter, useArrayRepeatKey = isProbableArray === !0 && arrayRepeat, shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
        if (depth > MAX_DEPTH)
          return "";
        let result = "", firstKey = !0, valueIsProbableArray = !1;
        for (let key in obj) {
          let value2 = obj[key];
          if (value2 === void 0)
            continue;
          let path;
          parentKey ? (path = parentKey, useArrayRepeatKey ? arrayRepeatSyntax === "bracket" && (path += strBracketPair) : shouldUseDot ? (path += strDot, path += key) : (path += strBracketLeft, path += key, path += strBracketRight)) : path = key, firstKey || (result += strDelimiter), typeof value2 == "object" && value2 !== null && !shouldSerializeObject(value2) ? (valueIsProbableArray = value2.pop !== void 0, (nesting || arrayRepeat && valueIsProbableArray) && (result += stringifyObject(value2, options2, depth + 1, path, valueIsProbableArray))) : (result += (0, string_util_js_1.encodeString)(path), result += "=", result += valueSerializer(value2, key)), firstKey && (firstKey = !1);
        }
        return result;
      }
      __name(stringifyObject, "stringifyObject");
    }
  }), require_decode_uri_component = __commonJS2({
    "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeURIComponent = decodeURIComponent2;
      var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [
        // The first part of the table maps bytes to character to a transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // The second part of the table maps a state to a new state when adding a
        // transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // The third part maps the current transition to a mask that needs to apply
        // to the byte.
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ];
      function decodeURIComponent2(uri) {
        let percentPosition = uri.indexOf("%");
        if (percentPosition === -1)
          return uri;
        let length2 = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state3 = UTF8_ACCEPT;
        for (; percentPosition > -1 && percentPosition < length2; ) {
          let high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type = UTF8_DATA[byte];
          if (state3 = UTF8_DATA[256 + state3 + type], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type], state3 === UTF8_ACCEPT)
            decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
          else {
            if (state3 === UTF8_REJECT)
              return null;
            if (percentPosition += 3, percentPosition < length2 && uri.charCodeAt(percentPosition) === 37)
              continue;
            return null;
          }
        }
        return decoded + uri.slice(last);
      }
      __name(decodeURIComponent2, "decodeURIComponent");
      var HEX = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      function hexCodeToInt(c3, shift) {
        let i3 = HEX[c3];
        return i3 === void 0 ? 255 : i3 << shift;
      }
      __name(hexCodeToInt, "hexCodeToInt");
    }
  }), require_parse = __commonJS2({
    "../node_modules/picoquery/lib/parse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0, exports.parse = parse5;
      var object_util_js_1 = require_object_util(), shared_js_1 = require_shared(), decode_uri_component_js_1 = require_decode_uri_component(), numberKeyDeserializer = __name((key) => {
        let asNumber = Number(key);
        return Number.isNaN(asNumber) ? key : asNumber;
      }, "numberKeyDeserializer");
      exports.numberKeyDeserializer = numberKeyDeserializer;
      var numberValueDeserializer = __name((value2) => {
        let asNumber = Number(value2);
        return Number.isNaN(asNumber) ? value2 : asNumber;
      }, "numberValueDeserializer");
      exports.numberValueDeserializer = numberValueDeserializer;
      var regexPlus = /\+/g, Empty3 = __name(function() {
      }, "Empty");
      Empty3.prototype = /* @__PURE__ */ Object.create(null);
      function computeKeySlice(input, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
        let chunk = input.substring(startIndex, endIndex);
        return keyHasPlus && (chunk = chunk.replace(regexPlus, " ")), shouldDecodeKey && (chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk), chunk;
      }
      __name(computeKeySlice, "computeKeySlice");
      function parse5(input, options2) {
        let { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options2 ?? {}, charDelimiter = typeof delimiter == "string" ? delimiter.charCodeAt(0) : delimiter, isJsNestingSyntax = nestingSyntax === "js", result = new Empty3();
        if (typeof input != "string")
          return result;
        let inputLength = input.length, value2 = "", startingIndex = -1, equalityIndex = -1, keySeparatorIndex = -1, currentObj = result, lastKey, currentKey = "", keyChunk = "", shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, hasBothKeyValuePair = !1, c3 = 0, arrayRepeatBracketIndex = -1, prevIndex = -1, prevChar = -1;
        for (let i3 = 0; i3 < inputLength + 1; i3++) {
          if (c3 = i3 !== inputLength ? input.charCodeAt(i3) : charDelimiter, c3 === charDelimiter) {
            if (hasBothKeyValuePair = equalityIndex > startingIndex, hasBothKeyValuePair || (equalityIndex = i3), keySeparatorIndex !== equalityIndex - 1 && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0))), hasBothKeyValuePair || currentKey !== "") {
              hasBothKeyValuePair && (value2 = input.slice(equalityIndex + 1, i3), valueHasPlus && (value2 = value2.replace(regexPlus, " ")), shouldDecodeValue && (value2 = (0, decode_uri_component_js_1.decodeURIComponent)(value2) || value2));
              let newValue = valueDeserializer(value2, currentKey);
              if (arrayRepeat) {
                let currentValue = currentObj[currentKey];
                currentValue === void 0 ? arrayRepeatBracketIndex > -1 ? currentObj[currentKey] = [newValue] : currentObj[currentKey] = newValue : currentValue.pop ? currentValue.push(newValue) : currentObj[currentKey] = [currentValue, newValue];
              } else
                currentObj[currentKey] = newValue;
            }
            value2 = "", startingIndex = i3, equalityIndex = i3, shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, arrayRepeatBracketIndex = -1, keySeparatorIndex = i3, currentObj = result, lastKey = void 0, currentKey = "";
          } else c3 === 93 ? (arrayRepeat && arrayRepeatSyntax === "bracket" && prevChar === 91 && (arrayRepeatBracketIndex = prevIndex), nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keySeparatorIndex = i3, keyIsDot = !1)) : c3 === 46 ? nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keyIsDot = !0, keySeparatorIndex = i3) : c3 === 91 ? nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), isJsNestingSyntax && lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1, keyIsDot = !1), keySeparatorIndex = i3) : c3 === 61 ? equalityIndex <= startingIndex ? equalityIndex = i3 : shouldDecodeValue = !0 : c3 === 43 ? equalityIndex > startingIndex ? valueHasPlus = !0 : keyHasPlus = !0 : c3 === 37 && (equalityIndex > startingIndex ? shouldDecodeValue = !0 : shouldDecodeKey = !0);
          prevIndex = i3, prevChar = c3;
        }
        return result;
      }
      __name(parse5, "parse");
    }
  }), require_stringify = __commonJS2({
    "../node_modules/picoquery/lib/stringify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.stringify = stringify4;
      var object_util_js_1 = require_object_util();
      function stringify4(input, options2) {
        if (input === null || typeof input != "object")
          return "";
        let optionsObj = options2 ?? {};
        return (0, object_util_js_1.stringifyObject)(input, optionsObj);
      }
      __name(stringify4, "stringify");
    }
  }), require_main = __commonJS2({
    "../node_modules/picoquery/lib/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
        k22 === void 0 && (k22 = k3);
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: __name(function() {
          return m3[k3];
        }, "get") }), Object.defineProperty(o2, k22, desc);
      } : function(o2, m3, k3, k22) {
        k22 === void 0 && (k22 = k3), o2[k22] = m3[k3];
      }), __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p4 in m3) p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4) && __createBinding(exports2, m3, p4);
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.stringify = exports.parse = void 0;
      var parse_js_1 = require_parse();
      Object.defineProperty(exports, "parse", { enumerable: !0, get: __name(function() {
        return parse_js_1.parse;
      }, "get") });
      var stringify_js_1 = require_stringify();
      Object.defineProperty(exports, "stringify", { enumerable: !0, get: __name(function() {
        return stringify_js_1.stringify;
      }, "get") }), __exportStar(require_shared(), exports);
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-UTNZYD2N.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-FSBVR7H5.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function isPlainObject(value2) {
    if (!value2 || typeof value2 != "object")
      return !1;
    let proto = Object.getPrototypeOf(value2);
    return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value2) === "[object Object]" : !1;
  }
  __name(isPlainObject, "isPlainObject");
  function isPrimitive(value2) {
    return value2 == null || typeof value2 != "object" && typeof value2 != "function";
  }
  __name(isPrimitive, "isPrimitive");
  function isTypedArray(x3) {
    return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
  }
  __name(isTypedArray, "isTypedArray");
  function getSymbols(object2) {
    return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
  }
  __name(getSymbols, "getSymbols");
  function getTag(value2) {
    return value2 == null ? value2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value2);
  }
  __name(getTag, "getTag");
  var regexpTag = "[object RegExp]", stringTag = "[object String]", numberTag = "[object Number]", booleanTag = "[object Boolean]", argumentsTag = "[object Arguments]", symbolTag = "[object Symbol]", dateTag = "[object Date]", mapTag = "[object Map]", setTag = "[object Set]", arrayTag = "[object Array]", functionTag = "[object Function]", arrayBufferTag = "[object ArrayBuffer]", objectTag = "[object Object]", errorTag = "[object Error]", dataViewTag = "[object DataView]", uint8ArrayTag = "[object Uint8Array]", uint8ClampedArrayTag = "[object Uint8ClampedArray]", uint16ArrayTag = "[object Uint16Array]", uint32ArrayTag = "[object Uint32Array]", bigUint64ArrayTag = "[object BigUint64Array]", int8ArrayTag = "[object Int8Array]", int16ArrayTag = "[object Int16Array]", int32ArrayTag = "[object Int32Array]", bigInt64ArrayTag = "[object BigInt64Array]", float32ArrayTag = "[object Float32Array]", float64ArrayTag = "[object Float64Array]";

  // node_modules/storybook/dist/_browser-chunks/chunk-UTNZYD2N.js
  init_chunk_MM7DTO55();
  function mapValues(object2, getNewValue) {
    let result = {}, keys = Object.keys(object2);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], value2 = object2[key];
      result[key] = getNewValue(value2, key, object2);
    }
    return result;
  }
  __name(mapValues, "mapValues");
  function isUnsafeProperty(key) {
    return key === "__proto__";
  }
  __name(isUnsafeProperty, "isUnsafeProperty");
  function isObjectLike(value2) {
    return typeof value2 == "object" && value2 !== null;
  }
  __name(isObjectLike, "isObjectLike");
  function mergeWith(target, source, merge22) {
    let sourceKeys = Object.keys(source);
    for (let i3 = 0; i3 < sourceKeys.length; i3++) {
      let key = sourceKeys[i3];
      if (isUnsafeProperty(key))
        continue;
      let sourceValue = source[key], targetValue = target[key], merged = merge22(targetValue, sourceValue, key, target, source);
      merged !== void 0 ? target[key] = merged : Array.isArray(sourceValue) ? target[key] = mergeWith(targetValue ?? [], sourceValue, merge22) : isObjectLike(targetValue) && isObjectLike(sourceValue) ? target[key] = mergeWith(targetValue ?? {}, sourceValue, merge22) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);
    }
    return target;
  }
  __name(mergeWith, "mergeWith");
  function pick(obj, keys) {
    let result = {};
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3];
      Object.hasOwn(obj, key) && (result[key] = obj[key]);
    }
    return result;
  }
  __name(pick, "pick");
  function pickBy(obj, shouldPick) {
    let result = {}, keys = Object.keys(obj);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], value2 = obj[key];
      shouldPick(value2, key) && (result[key] = value2);
    }
    return result;
  }
  __name(pickBy, "pickBy");
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    let cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
    if (cloned !== void 0)
      return cloned;
    if (isPrimitive(valueToClone))
      return valueToClone;
    if (stack.has(valueToClone))
      return stack.get(valueToClone);
    if (Array.isArray(valueToClone)) {
      let result = new Array(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i3 = 0; i3 < valueToClone.length; i3++)
        result[i3] = cloneDeepWithImpl(valueToClone[i3], i3, objectToClone, stack, cloneValue);
      return Object.hasOwn(valueToClone, "index") && (result.index = valueToClone.index), Object.hasOwn(valueToClone, "input") && (result.input = valueToClone.input), result;
    }
    if (valueToClone instanceof Date)
      return new Date(valueToClone.getTime());
    if (valueToClone instanceof RegExp) {
      let result = new RegExp(valueToClone.source, valueToClone.flags);
      return result.lastIndex = valueToClone.lastIndex, result;
    }
    if (valueToClone instanceof Map) {
      let result = /* @__PURE__ */ new Map();
      stack.set(valueToClone, result);
      for (let [key, value2] of valueToClone)
        result.set(key, cloneDeepWithImpl(value2, key, objectToClone, stack, cloneValue));
      return result;
    }
    if (valueToClone instanceof Set) {
      let result = /* @__PURE__ */ new Set();
      stack.set(valueToClone, result);
      for (let value2 of valueToClone)
        result.add(cloneDeepWithImpl(value2, void 0, objectToClone, stack, cloneValue));
      return result;
    }
    if (typeof Buffer < "u" && Buffer.isBuffer(valueToClone))
      return valueToClone.subarray();
    if (isTypedArray(valueToClone)) {
      let result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i3 = 0; i3 < valueToClone.length; i3++)
        result[i3] = cloneDeepWithImpl(valueToClone[i3], i3, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && valueToClone instanceof SharedArrayBuffer)
      return valueToClone.slice(0);
    if (valueToClone instanceof DataView) {
      let result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof File < "u" && valueToClone instanceof File) {
      let result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Blob) {
      let result = new Blob([valueToClone], { type: valueToClone.type });
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Error) {
      let result = new valueToClone.constructor();
      return stack.set(valueToClone, result), result.message = valueToClone.message, result.name = valueToClone.name, result.stack = valueToClone.stack, result.cause = valueToClone.cause, copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof valueToClone == "object" && isCloneableObject(valueToClone)) {
      let result = Object.create(Object.getPrototypeOf(valueToClone));
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    return valueToClone;
  }
  __name(cloneDeepWithImpl, "cloneDeepWithImpl");
  function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
    let keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], descriptor = Object.getOwnPropertyDescriptor(target, key);
      (descriptor == null || descriptor.writable) && (target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue));
    }
  }
  __name(copyProperties, "copyProperties");
  function isCloneableObject(object2) {
    switch (getTag(object2)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
        return !0;
      default:
        return !1;
    }
  }
  __name(isCloneableObject, "isCloneableObject");
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  __name(cloneDeep, "cloneDeep");
  function merge(target, source) {
    let sourceKeys = Object.keys(source);
    for (let i3 = 0; i3 < sourceKeys.length; i3++) {
      let key = sourceKeys[i3];
      if (isUnsafeProperty(key))
        continue;
      let sourceValue = source[key], targetValue = target[key];
      Array.isArray(sourceValue) ? Array.isArray(targetValue) ? target[key] = merge(targetValue, sourceValue) : target[key] = merge([], sourceValue) : isPlainObject(sourceValue) ? isPlainObject(targetValue) ? target[key] = merge(targetValue, sourceValue) : target[key] = merge({}, sourceValue) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);
    }
    return target;
  }
  __name(merge, "merge");
  var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  function toMerged(target, source) {
    return merge(cloneDeep(target), source);
  }
  __name(toMerged, "toMerged");

  // node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js
  init_chunk_MM7DTO55();

  // node_modules/storybook/dist/preview-errors.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-FDWKXLBI.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-LASUB7TL.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function parseErrorCode({
    code,
    category
  }) {
    let paddedCode = String(code).padStart(4, "0");
    return `SB_${category}_${paddedCode}`;
  }
  __name(parseErrorCode, "parseErrorCode");
  function appendErrorRef(url) {
    if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url))
      return url;
    try {
      let urlObj = new URL(url);
      return urlObj.searchParams.set("ref", "error"), urlObj.toString();
    } catch {
      return url;
    }
  }
  __name(appendErrorRef, "appendErrorRef");
  var _StorybookError = class _StorybookError2 extends Error {
    constructor(props) {
      super(_StorybookError2.getFullMessage(props)), this.data = {}, this.fromStorybook = !0, this.category = props.category, this.documentation = props.documentation ?? !1, this.code = props.code;
    }
    get fullErrorCode() {
      return parseErrorCode({ code: this.code, category: this.category });
    }
    /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
    get name() {
      let errorName = this.constructor.name;
      return `${this.fullErrorCode} (${errorName})`;
    }
    /** Generates the error message along with additional documentation link (if applicable). */
    static getFullMessage({
      documentation,
      code,
      category,
      message
    }) {
      let page;
      return documentation === !0 ? page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error` : typeof documentation == "string" ? page = appendErrorRef(documentation) : Array.isArray(documentation) && (page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join(`
`)}`), `${message}${page != null ? `

More info: ${page}
` : ""}`;
    }
  };
  __name(_StorybookError, "StorybookError");
  var StorybookError = _StorybookError;

  // node_modules/storybook/dist/_browser-chunks/chunk-FDWKXLBI.js
  init_chunk_OPCDBBL3();
  init_chunk_MM7DTO55();
  var Category = ((Category2) => (Category2.BLOCKS = "BLOCKS", Category2.DOCS_TOOLS = "DOCS-TOOLS", Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", Category2.ADDON_VITEST = "ADDON_VITEST", Category2.ADDON_A11Y = "ADDON_A11Y", Category2))(Category || {}), _MissingStoryAfterHmrError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 1,
        message: dedent`
        Couldn't find story matching id '${data.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${data.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
      }), this.data = data;
    }
  };
  __name(_MissingStoryAfterHmrError, "MissingStoryAfterHmrError");
  var MissingStoryAfterHmrError = _MissingStoryAfterHmrError, _ImplicitActionsDuringRendering = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 2,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
        message: dedent`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
      }), this.data = data;
    }
  };
  __name(_ImplicitActionsDuringRendering, "ImplicitActionsDuringRendering");
  var ImplicitActionsDuringRendering = _ImplicitActionsDuringRendering, _CalledExtractOnStoreError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 3,
        message: dedent`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
      });
    }
  };
  __name(_CalledExtractOnStoreError, "CalledExtractOnStoreError");
  var CalledExtractOnStoreError = _CalledExtractOnStoreError, _MissingRenderToCanvasError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 4,
        message: dedent`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
      });
    }
  };
  __name(_MissingRenderToCanvasError, "MissingRenderToCanvasError");
  var MissingRenderToCanvasError = _MissingRenderToCanvasError, _CalledPreviewMethodBeforeInitializationError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 5,
        message: dedent`
        Called \`Preview.${data.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${data.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
      }), this.data = data;
    }
  };
  __name(_CalledPreviewMethodBeforeInitializationError, "CalledPreviewMethodBeforeInitializationError");
  var CalledPreviewMethodBeforeInitializationError = _CalledPreviewMethodBeforeInitializationError, _StoryIndexFetchError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 6,
        message: dedent`
        Error fetching \`/index.json\`:
        
        ${data.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
      }), this.data = data;
    }
  };
  __name(_StoryIndexFetchError, "StoryIndexFetchError");
  var StoryIndexFetchError = _StoryIndexFetchError, _MdxFileWithNoCsfReferencesError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 7,
        message: dedent`
        Tried to render docs entry ${data.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
      }), this.data = data;
    }
  };
  __name(_MdxFileWithNoCsfReferencesError, "MdxFileWithNoCsfReferencesError");
  var MdxFileWithNoCsfReferencesError = _MdxFileWithNoCsfReferencesError, _EmptyIndexError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 8,
        message: dedent`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
      });
    }
  };
  __name(_EmptyIndexError, "EmptyIndexError");
  var EmptyIndexError = _EmptyIndexError, _NoStoryMatchError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 9,
        message: dedent`
        Couldn't find story matching '${data.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
      }), this.data = data;
    }
  };
  __name(_NoStoryMatchError, "NoStoryMatchError");
  var NoStoryMatchError = _NoStoryMatchError, _MissingStoryFromCsfFileError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 10,
        message: dedent`
        Couldn't find story matching id '${data.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
      }), this.data = data;
    }
  };
  __name(_MissingStoryFromCsfFileError, "MissingStoryFromCsfFileError");
  var MissingStoryFromCsfFileError = _MissingStoryFromCsfFileError, _StoryStoreAccessedBeforeInitializationError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 11,
        message: dedent`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
      });
    }
  };
  __name(_StoryStoreAccessedBeforeInitializationError, "StoryStoreAccessedBeforeInitializationError");
  var StoryStoreAccessedBeforeInitializationError = _StoryStoreAccessedBeforeInitializationError, _MountMustBeDestructuredError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 12,
        message: dedent`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${data.playFunction}`
      }), this.data = data;
    }
  };
  __name(_MountMustBeDestructuredError, "MountMustBeDestructuredError");
  var MountMustBeDestructuredError = _MountMustBeDestructuredError, _NoRenderFunctionError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 14,
        message: dedent`
        No render function available for storyId '${data.id}'
      `
      }), this.data = data;
    }
  };
  __name(_NoRenderFunctionError, "NoRenderFunctionError");
  var NoRenderFunctionError = _NoRenderFunctionError, _NoStoryMountedError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 15,
        message: dedent`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
      });
    }
  };
  __name(_NoStoryMountedError, "NoStoryMountedError");
  var NoStoryMountedError = _NoStoryMountedError, _StatusTypeIdMismatchError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 16,
        message: `Status has typeId "${data.status.typeId}" but was added to store with typeId "${data.typeId}". Full status: ${JSON.stringify(
          data.status,
          null,
          2
        )}`
      }), this.data = data;
    }
  };
  __name(_StatusTypeIdMismatchError, "StatusTypeIdMismatchError");
  var _NextJsSharpError = class extends StorybookError {
    constructor() {
      super({
        category: "FRAMEWORK_NEXTJS",
        code: 1,
        documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
        message: dedent`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
      });
    }
  };
  __name(_NextJsSharpError, "NextJsSharpError");
  var _NextjsRouterMocksNotAvailable = class extends StorybookError {
    constructor(data) {
      super({
        category: "FRAMEWORK_NEXTJS",
        code: 2,
        message: dedent`
        Tried to access router mocks from "${data.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
      }), this.data = data;
    }
  };
  __name(_NextjsRouterMocksNotAvailable, "NextjsRouterMocksNotAvailable");
  var _UnknownArgTypesError = class extends StorybookError {
    constructor(data) {
      super({
        category: "DOCS-TOOLS",
        code: 1,
        documentation: "https://github.com/storybookjs/storybook/issues/26606",
        message: dedent`
        There was a failure when generating detailed ArgTypes in ${data.language} for:
        ${JSON.stringify(data.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
      }), this.data = data;
    }
  };
  __name(_UnknownArgTypesError, "UnknownArgTypesError");
  var UnknownArgTypesError = _UnknownArgTypesError, _UnsupportedViewportDimensionError = class extends StorybookError {
    constructor(data) {
      super({
        category: "ADDON_VITEST",
        code: 1,
        // TODO: Add documentation about viewports support
        // documentation: '',
        message: dedent`
        Encountered an unsupported value "${data.value}" when setting the viewport ${data.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
      }), this.data = data;
    }
  };
  __name(_UnsupportedViewportDimensionError, "UnsupportedViewportDimensionError");
  var _ElementA11yParameterError = class extends StorybookError {
    constructor() {
      super({
        category: "ADDON_A11Y",
        code: 1,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
        message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
      });
    }
  };
  __name(_ElementA11yParameterError, "ElementA11yParameterError");

  // node_modules/storybook/dist/preview-errors.js
  init_chunk_OPCDBBL3();
  init_chunk_MM7DTO55();

  // node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js
  var require_dist = __commonJS2({
    "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports == "object" && typeof module < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.jtpp = {}));
      })(exports, function(exports2) {
        "use strict";
        function tokenToString(token) {
          return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
        }
        __name(tokenToString, "tokenToString");
        let _NoParsletFoundError = class _NoParsletFoundError2 extends Error {
          constructor(token) {
            super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, _NoParsletFoundError2.prototype);
          }
          getToken() {
            return this.token;
          }
        };
        __name(_NoParsletFoundError, "NoParsletFoundError");
        let NoParsletFoundError = _NoParsletFoundError, _EarlyEndOfParseError = class _EarlyEndOfParseError2 extends Error {
          constructor(token) {
            super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, _EarlyEndOfParseError2.prototype);
          }
          getToken() {
            return this.token;
          }
        };
        __name(_EarlyEndOfParseError, "EarlyEndOfParseError");
        let EarlyEndOfParseError = _EarlyEndOfParseError, _UnexpectedTypeError = class _UnexpectedTypeError2 extends Error {
          constructor(result, message) {
            let error = `Unexpected type: '${result.type}'.`;
            message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, _UnexpectedTypeError2.prototype);
          }
        };
        __name(_UnexpectedTypeError, "UnexpectedTypeError");
        let UnexpectedTypeError = _UnexpectedTypeError;
        function makePunctuationRule(type) {
          return (text) => text.startsWith(type) ? { type, text: type } : null;
        }
        __name(makePunctuationRule, "makePunctuationRule");
        function getQuoted(text) {
          let position = 0, char, mark = text[0], escaped = !1;
          if (mark !== "'" && mark !== '"')
            return null;
          for (; position < text.length; ) {
            if (position++, char = text[position], !escaped && char === mark) {
              position++;
              break;
            }
            escaped = !escaped && char === "\\";
          }
          if (char !== mark)
            throw new Error("Unterminated String");
          return text.slice(0, position);
        }
        __name(getQuoted, "getQuoted");
        let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
        function getIdentifier(text) {
          let char = text[0];
          if (!identifierStartRegex.test(char))
            return null;
          let position = 1;
          do {
            if (char = text[position], !identifierContinueRegex.test(char))
              break;
            position++;
          } while (position < text.length);
          return text.slice(0, position);
        }
        __name(getIdentifier, "getIdentifier");
        let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
        function getNumber(text) {
          var _a, _b;
          return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
        }
        __name(getNumber, "getNumber");
        let identifierRule = __name((text) => {
          let value2 = getIdentifier(text);
          return value2 == null ? null : {
            type: "Identifier",
            text: value2
          };
        }, "identifierRule");
        function makeKeyWordRule(type) {
          return (text) => {
            if (!text.startsWith(type))
              return null;
            let prepends = text[type.length];
            return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
              type,
              text: type
            };
          };
        }
        __name(makeKeyWordRule, "makeKeyWordRule");
        let stringValueRule = __name((text) => {
          let value2 = getQuoted(text);
          return value2 == null ? null : {
            type: "StringValue",
            text: value2
          };
        }, "stringValueRule"), eofRule = __name((text) => text.length > 0 ? null : {
          type: "EOF",
          text: ""
        }, "eofRule"), numberRule = __name((text) => {
          let value2 = getNumber(text);
          return value2 === null ? null : {
            type: "Number",
            text: value2
          };
        }, "numberRule"), rules = [
          eofRule,
          makePunctuationRule("=>"),
          makePunctuationRule("("),
          makePunctuationRule(")"),
          makePunctuationRule("{"),
          makePunctuationRule("}"),
          makePunctuationRule("["),
          makePunctuationRule("]"),
          makePunctuationRule("|"),
          makePunctuationRule("&"),
          makePunctuationRule("<"),
          makePunctuationRule(">"),
          makePunctuationRule(","),
          makePunctuationRule(";"),
          makePunctuationRule("*"),
          makePunctuationRule("?"),
          makePunctuationRule("!"),
          makePunctuationRule("="),
          makePunctuationRule(":"),
          makePunctuationRule("..."),
          makePunctuationRule("."),
          makePunctuationRule("#"),
          makePunctuationRule("~"),
          makePunctuationRule("/"),
          makePunctuationRule("@"),
          makeKeyWordRule("undefined"),
          makeKeyWordRule("null"),
          makeKeyWordRule("function"),
          makeKeyWordRule("this"),
          makeKeyWordRule("new"),
          makeKeyWordRule("module"),
          makeKeyWordRule("event"),
          makeKeyWordRule("extends"),
          makeKeyWordRule("external"),
          makeKeyWordRule("infer"),
          makeKeyWordRule("typeof"),
          makeKeyWordRule("keyof"),
          makeKeyWordRule("readonly"),
          makeKeyWordRule("import"),
          makeKeyWordRule("is"),
          makeKeyWordRule("in"),
          makeKeyWordRule("asserts"),
          numberRule,
          identifierRule,
          stringValueRule
        ], breakingWhitespaceRegex = /^\s*\n\s*/, _Lexer = class _Lexer2 {
          static create(text) {
            let current = this.read(text);
            text = current.text;
            let next = this.read(text);
            return text = next.text, new _Lexer2(text, void 0, current.token, next.token);
          }
          constructor(text, previous, current, next) {
            this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
          }
          static read(text, startOfLine = !1) {
            startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
            for (let rule of rules) {
              let partial2 = rule(text);
              if (partial2 !== null) {
                let token = Object.assign(Object.assign({}, partial2), { startOfLine });
                return text = text.slice(token.text.length), { text, token };
              }
            }
            throw new Error("Unexpected Token " + text);
          }
          advance() {
            let next = _Lexer2.read(this.text);
            return new _Lexer2(next.text, this.current, this.next, next.token);
          }
        };
        __name(_Lexer, "Lexer");
        let Lexer = _Lexer;
        function assertRootResult(result) {
          if (result === void 0)
            throw new Error("Unexpected undefined");
          if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
            throw new UnexpectedTypeError(result);
          return result;
        }
        __name(assertRootResult, "assertRootResult");
        function assertPlainKeyValueOrRootResult(result) {
          return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
        }
        __name(assertPlainKeyValueOrRootResult, "assertPlainKeyValueOrRootResult");
        function assertPlainKeyValueOrNameResult(result) {
          return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
        }
        __name(assertPlainKeyValueOrNameResult, "assertPlainKeyValueOrNameResult");
        function assertPlainKeyValueResult(result) {
          if (result.type !== "JsdocTypeKeyValue")
            throw new UnexpectedTypeError(result);
          return result;
        }
        __name(assertPlainKeyValueResult, "assertPlainKeyValueResult");
        function assertNumberOrVariadicNameResult(result) {
          var _a;
          if (result.type === "JsdocTypeVariadic") {
            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === "JsdocTypeName")
              return result;
            throw new UnexpectedTypeError(result);
          }
          if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(result);
          return result;
        }
        __name(assertNumberOrVariadicNameResult, "assertNumberOrVariadicNameResult");
        function assertArrayOrTupleResult(result) {
          if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
            return result;
          throw new UnexpectedTypeError(result);
        }
        __name(assertArrayOrTupleResult, "assertArrayOrTupleResult");
        function isSquaredProperty(result) {
          return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
        }
        __name(isSquaredProperty, "isSquaredProperty");
        var Precedence;
        (function(Precedence2) {
          Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
        })(Precedence || (Precedence = {}));
        let _Parser = class {
          constructor(grammar, textOrLexer, baseParser) {
            this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
          }
          get lexer() {
            return this._lexer;
          }
          /**
           * Parses a given string and throws an error if the parse ended before the end of the string.
           */
          parse() {
            let result = this.parseType(Precedence.ALL);
            if (this.lexer.current.type !== "EOF")
              throw new EarlyEndOfParseError(this.lexer.current);
            return result;
          }
          /**
           * Parses with the current lexer and asserts that the result is a {@link RootResult}.
           */
          parseType(precedence) {
            return assertRootResult(this.parseIntermediateType(precedence));
          }
          /**
           * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
           * to parse the state in the infix step.
           */
          parseIntermediateType(precedence) {
            let result = this.tryParslets(null, precedence);
            if (result === null)
              throw new NoParsletFoundError(this.lexer.current);
            return this.parseInfixIntermediateType(result, precedence);
          }
          /**
           * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
           * a result.
           */
          parseInfixIntermediateType(left2, precedence) {
            let result = this.tryParslets(left2, precedence);
            for (; result !== null; )
              left2 = result, result = this.tryParslets(left2, precedence);
            return left2;
          }
          /**
           * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
           */
          tryParslets(left2, precedence) {
            for (let parslet of this.grammar) {
              let result = parslet(this, precedence, left2);
              if (result !== null)
                return result;
            }
            return null;
          }
          /**
           * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
           * advanced.
           */
          consume(types2) {
            return Array.isArray(types2) || (types2 = [types2]), types2.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
          }
          acceptLexerState(parser) {
            this._lexer = parser.lexer;
          }
        };
        __name(_Parser, "Parser");
        let Parser = _Parser;
        function isQuestionMarkUnknownType(next) {
          return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
        }
        __name(isQuestionMarkUnknownType, "isQuestionMarkUnknownType");
        let nullableParslet = __name((parser, precedence, left2) => {
          let type = parser.lexer.current.type, next = parser.lexer.next.type;
          return left2 == null && type === "?" && !isQuestionMarkUnknownType(next) || left2 != null && type === "?" ? (parser.consume("?"), left2 == null ? {
            type: "JsdocTypeNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          } : {
            type: "JsdocTypeNullable",
            element: assertRootResult(left2),
            meta: {
              position: "suffix"
            }
          }) : null;
        }, "nullableParslet");
        function composeParslet(options2) {
          let parslet = __name((parser, curPrecedence, left2) => {
            let type = parser.lexer.current.type, next = parser.lexer.next.type;
            if (left2 === null) {
              if ("parsePrefix" in options2 && options2.accept(type, next))
                return options2.parsePrefix(parser);
            } else if ("parseInfix" in options2 && options2.precedence > curPrecedence && options2.accept(type, next))
              return options2.parseInfix(parser, left2);
            return null;
          }, "parslet");
          return Object.defineProperty(parslet, "name", {
            value: options2.name
          }), parslet;
        }
        __name(composeParslet, "composeParslet");
        let optionalParslet = composeParslet({
          name: "optionalParslet",
          accept: __name((type) => type === "=", "accept"),
          precedence: Precedence.OPTIONAL,
          parsePrefix: __name((parser) => (parser.consume("="), {
            type: "JsdocTypeOptional",
            element: parser.parseType(Precedence.OPTIONAL),
            meta: {
              position: "prefix"
            }
          }), "parsePrefix"),
          parseInfix: __name((parser, left2) => (parser.consume("="), {
            type: "JsdocTypeOptional",
            element: assertRootResult(left2),
            meta: {
              position: "suffix"
            }
          }), "parseInfix")
        }), numberParslet = composeParslet({
          name: "numberParslet",
          accept: __name((type) => type === "Number", "accept"),
          parsePrefix: __name((parser) => {
            let value2 = parseFloat(parser.lexer.current.text);
            return parser.consume("Number"), {
              type: "JsdocTypeNumber",
              value: value2
            };
          }, "parsePrefix")
        }), parenthesisParslet = composeParslet({
          name: "parenthesisParslet",
          accept: __name((type) => type === "(", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.consume("("), parser.consume(")"))
              return {
                type: "JsdocTypeParameterList",
                elements: []
              };
            let result = parser.parseIntermediateType(Precedence.ALL);
            if (!parser.consume(")"))
              throw new Error("Unterminated parenthesis");
            return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
              type: "JsdocTypeParameterList",
              elements: [result]
            } : {
              type: "JsdocTypeParenthesis",
              element: assertRootResult(result)
            };
          }, "parsePrefix")
        }), specialTypesParslet = composeParslet({
          name: "specialTypesParslet",
          accept: __name((type, next) => type === "?" && isQuestionMarkUnknownType(next) || type === "null" || type === "undefined" || type === "*", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.consume("null"))
              return {
                type: "JsdocTypeNull"
              };
            if (parser.consume("undefined"))
              return {
                type: "JsdocTypeUndefined"
              };
            if (parser.consume("*"))
              return {
                type: "JsdocTypeAny"
              };
            if (parser.consume("?"))
              return {
                type: "JsdocTypeUnknown"
              };
            throw new Error("Unacceptable token: " + parser.lexer.current.text);
          }, "parsePrefix")
        }), notNullableParslet = composeParslet({
          name: "notNullableParslet",
          accept: __name((type) => type === "!", "accept"),
          precedence: Precedence.NULLABLE,
          parsePrefix: __name((parser) => (parser.consume("!"), {
            type: "JsdocTypeNotNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          }), "parsePrefix"),
          parseInfix: __name((parser, left2) => (parser.consume("!"), {
            type: "JsdocTypeNotNullable",
            element: assertRootResult(left2),
            meta: {
              position: "suffix"
            }
          }), "parseInfix")
        });
        function createParameterListParslet({ allowTrailingComma }) {
          return composeParslet({
            name: "parameterListParslet",
            accept: __name((type) => type === ",", "accept"),
            precedence: Precedence.PARAMETER_LIST,
            parseInfix: __name((parser, left2) => {
              let elements = [
                assertPlainKeyValueOrRootResult(left2)
              ];
              parser.consume(",");
              do
                try {
                  let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                  elements.push(assertPlainKeyValueOrRootResult(next));
                } catch (e) {
                  if (e instanceof NoParsletFoundError)
                    break;
                  throw e;
                }
              while (parser.consume(","));
              if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === "JsdocTypeVariadic"))
                throw new Error("Only the last parameter may be a rest parameter");
              return {
                type: "JsdocTypeParameterList",
                elements
              };
            }, "parseInfix")
          });
        }
        __name(createParameterListParslet, "createParameterListParslet");
        let genericParslet = composeParslet({
          name: "genericParslet",
          accept: __name((type, next) => type === "<" || type === "." && next === "<", "accept"),
          precedence: Precedence.GENERIC,
          parseInfix: __name((parser, left2) => {
            let dot = parser.consume(".");
            parser.consume("<");
            let objects = [], infer = !1;
            if (parser.consume("infer")) {
              infer = !0;
              let left22 = parser.parseIntermediateType(Precedence.SYMBOL);
              if (left22.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(left22, "A typescript asserts always has to have a name on the left side.");
              objects.push(left22);
            } else
              do
                objects.push(parser.parseType(Precedence.PARAMETER_LIST));
              while (parser.consume(","));
            if (!parser.consume(">"))
              throw new Error("Unterminated generic parameter list");
            return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left2), elements: objects }, infer ? { infer: !0 } : {}), { meta: {
              brackets: "angle",
              dot
            } });
          }, "parseInfix")
        }), unionParslet = composeParslet({
          name: "unionParslet",
          accept: __name((type) => type === "|", "accept"),
          precedence: Precedence.UNION,
          parseInfix: __name((parser, left2) => {
            parser.consume("|");
            let elements = [];
            do
              elements.push(parser.parseType(Precedence.UNION));
            while (parser.consume("|"));
            return {
              type: "JsdocTypeUnion",
              elements: [assertRootResult(left2), ...elements]
            };
          }, "parseInfix")
        }), baseGrammar = [
          nullableParslet,
          optionalParslet,
          numberParslet,
          parenthesisParslet,
          specialTypesParslet,
          notNullableParslet,
          createParameterListParslet({
            allowTrailingComma: !0
          }),
          genericParslet,
          unionParslet,
          optionalParslet
        ];
        function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
          return __name(function(parser, precedence, left2) {
            if (left2 == null || precedence >= Precedence.NAME_PATH)
              return null;
            let type = parser.lexer.current.type, next = parser.lexer.next.type;
            if (!(type === "." && next !== "<" || type === "[" && (allowSquareBracketsOnAnyType || left2.type === "JsdocTypeName") || allowJsdocNamePaths && (type === "~" || type === "#")))
              return null;
            let pathType, brackets = !1;
            parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = !0) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
            let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
            parser.acceptLexerState(pathParser);
            let right2;
            switch (parsed.type) {
              case "JsdocTypeName":
                right2 = {
                  type: "JsdocTypeProperty",
                  value: parsed.value,
                  meta: {
                    quote: void 0
                  }
                };
                break;
              case "JsdocTypeNumber":
                right2 = {
                  type: "JsdocTypeProperty",
                  value: parsed.value.toString(10),
                  meta: {
                    quote: void 0
                  }
                };
                break;
              case "JsdocTypeStringValue":
                right2 = {
                  type: "JsdocTypeProperty",
                  value: parsed.value,
                  meta: {
                    quote: parsed.meta.quote
                  }
                };
                break;
              case "JsdocTypeSpecialNamePath":
                if (parsed.specialType === "event")
                  right2 = parsed;
                else
                  throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
                break;
              default:
                throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
            }
            if (brackets && !parser.consume("]")) {
              let token = parser.lexer.current;
              throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
            }
            return {
              type: "JsdocTypeNamePath",
              left: assertRootResult(left2),
              right: right2,
              pathType
            };
          }, "namePathParslet");
        }
        __name(createNamePathParslet, "createNamePathParslet");
        function createNameParslet({ allowedAdditionalTokens }) {
          return composeParslet({
            name: "nameParslet",
            accept: __name((type) => type === "Identifier" || type === "this" || type === "new" || allowedAdditionalTokens.includes(type), "accept"),
            parsePrefix: __name((parser) => {
              let { type, text } = parser.lexer.current;
              return parser.consume(type), {
                type: "JsdocTypeName",
                value: text
              };
            }, "parsePrefix")
          });
        }
        __name(createNameParslet, "createNameParslet");
        let stringValueParslet = composeParslet({
          name: "stringValueParslet",
          accept: __name((type) => type === "StringValue", "accept"),
          parsePrefix: __name((parser) => {
            let text = parser.lexer.current.text;
            return parser.consume("StringValue"), {
              type: "JsdocTypeStringValue",
              value: text.slice(1, -1),
              meta: {
                quote: text[0] === "'" ? "single" : "double"
              }
            };
          }, "parsePrefix")
        });
        function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
          return composeParslet({
            name: "specialNamePathParslet",
            accept: __name((type) => allowedTypes.includes(type), "accept"),
            parsePrefix: __name((parser) => {
              let type = parser.lexer.current.type;
              if (parser.consume(type), !parser.consume(":"))
                return {
                  type: "JsdocTypeName",
                  value: type
                };
              let result, token = parser.lexer.current;
              if (parser.consume("StringValue"))
                result = {
                  type: "JsdocTypeSpecialNamePath",
                  value: token.text.slice(1, -1),
                  specialType: type,
                  meta: {
                    quote: token.text[0] === "'" ? "single" : "double"
                  }
                };
              else {
                let value2 = "", allowed = ["Identifier", "@", "/"];
                for (; allowed.some((type2) => parser.consume(type2)); )
                  value2 += token.text, token = parser.lexer.current;
                result = {
                  type: "JsdocTypeSpecialNamePath",
                  value: value2,
                  specialType: type,
                  meta: {
                    quote: void 0
                  }
                };
              }
              let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
              return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
            }, "parsePrefix")
          });
        }
        __name(createSpecialNamePathParslet, "createSpecialNamePathParslet");
        let basePathGrammar = [
          createNameParslet({
            allowedAdditionalTokens: ["external", "module"]
          }),
          stringValueParslet,
          numberParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar: null
          })
        ], pathGrammar = [
          ...basePathGrammar,
          createSpecialNamePathParslet({
            allowedTypes: ["event"],
            pathGrammar: basePathGrammar
          })
        ];
        function getParameters(value2) {
          let parameters2;
          if (value2.type === "JsdocTypeParameterList")
            parameters2 = value2.elements;
          else if (value2.type === "JsdocTypeParenthesis")
            parameters2 = [value2.element];
          else
            throw new UnexpectedTypeError(value2);
          return parameters2.map((p4) => assertPlainKeyValueOrRootResult(p4));
        }
        __name(getParameters, "getParameters");
        function getUnnamedParameters(value2) {
          let parameters2 = getParameters(value2);
          if (parameters2.some((p4) => p4.type === "JsdocTypeKeyValue"))
            throw new Error("No parameter should be named");
          return parameters2;
        }
        __name(getUnnamedParameters, "getUnnamedParameters");
        function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
          return composeParslet({
            name: "functionParslet",
            accept: __name((type, next) => type === "function" || allowNewAsFunctionKeyword && type === "new" && next === "(", "accept"),
            parsePrefix: __name((parser) => {
              let newKeyword = parser.consume("new");
              parser.consume("function");
              let hasParenthesis = parser.lexer.current.type === "(";
              if (!hasParenthesis) {
                if (!allowWithoutParenthesis)
                  throw new Error("function is missing parameter list");
                return {
                  type: "JsdocTypeName",
                  value: "function"
                };
              }
              let result = {
                type: "JsdocTypeFunction",
                parameters: [],
                arrow: !1,
                constructor: newKeyword,
                parenthesis: hasParenthesis
              }, value2 = parser.parseIntermediateType(Precedence.FUNCTION);
              if (allowNamedParameters === void 0)
                result.parameters = getUnnamedParameters(value2);
              else {
                if (newKeyword && value2.type === "JsdocTypeFunction" && value2.arrow)
                  return result = value2, result.constructor = !0, result;
                result.parameters = getParameters(value2);
                for (let p4 of result.parameters)
                  if (p4.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p4.key))
                    throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p4.type}`);
              }
              if (parser.consume(":"))
                result.returnType = parser.parseType(Precedence.PREFIX);
              else if (!allowNoReturnType)
                throw new Error("function is missing return type");
              return result;
            }, "parsePrefix")
          });
        }
        __name(createFunctionParslet, "createFunctionParslet");
        function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
          return composeParslet({
            name: "variadicParslet",
            accept: __name((type) => type === "...", "accept"),
            precedence: Precedence.PREFIX,
            parsePrefix: __name((parser) => {
              parser.consume("...");
              let brackets = allowEnclosingBrackets && parser.consume("[");
              try {
                let element = parser.parseType(Precedence.PREFIX);
                if (brackets && !parser.consume("]"))
                  throw new Error("Unterminated variadic type. Missing ']'");
                return {
                  type: "JsdocTypeVariadic",
                  element: assertRootResult(element),
                  meta: {
                    position: "prefix",
                    squareBrackets: brackets
                  }
                };
              } catch (e) {
                if (e instanceof NoParsletFoundError) {
                  if (brackets)
                    throw new Error("Empty square brackets for variadic are not allowed.");
                  return {
                    type: "JsdocTypeVariadic",
                    meta: {
                      position: void 0,
                      squareBrackets: !1
                    }
                  };
                } else
                  throw e;
              }
            }, "parsePrefix"),
            parseInfix: allowPostfix ? (parser, left2) => (parser.consume("..."), {
              type: "JsdocTypeVariadic",
              element: assertRootResult(left2),
              meta: {
                position: "suffix",
                squareBrackets: !1
              }
            }) : void 0
          });
        }
        __name(createVariadicParslet, "createVariadicParslet");
        let symbolParslet = composeParslet({
          name: "symbolParslet",
          accept: __name((type) => type === "(", "accept"),
          precedence: Precedence.SYMBOL,
          parseInfix: __name((parser, left2) => {
            if (left2.type !== "JsdocTypeName")
              throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
            parser.consume("(");
            let result = {
              type: "JsdocTypeSymbol",
              value: left2.value
            };
            if (!parser.consume(")")) {
              let next = parser.parseIntermediateType(Precedence.SYMBOL);
              if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
                throw new Error("Symbol does not end after value");
            }
            return result;
          }, "parseInfix")
        }), arrayBracketsParslet = composeParslet({
          name: "arrayBracketsParslet",
          precedence: Precedence.ARRAY_BRACKETS,
          accept: __name((type, next) => type === "[" && next === "]", "accept"),
          parseInfix: __name((parser, left2) => (parser.consume("["), parser.consume("]"), {
            type: "JsdocTypeGeneric",
            left: {
              type: "JsdocTypeName",
              value: "Array"
            },
            elements: [
              assertRootResult(left2)
            ],
            meta: {
              brackets: "square",
              dot: !1
            }
          }), "parseInfix")
        });
        function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
          return composeParslet({
            name: "objectParslet",
            accept: __name((type) => type === "{", "accept"),
            parsePrefix: __name((parser) => {
              parser.consume("{");
              let result = {
                type: "JsdocTypeObject",
                meta: {
                  separator: "comma"
                },
                elements: []
              };
              if (!parser.consume("}")) {
                let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
                for (; ; ) {
                  fieldParser.acceptLexerState(parser);
                  let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                  parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                  let optional = !1;
                  if (field.type === "JsdocTypeNullable" && (optional = !0, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                    let quote2;
                    field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                      type: "JsdocTypeObjectField",
                      key: field.value.toString(),
                      right: void 0,
                      optional,
                      readonly: !1,
                      meta: {
                        quote: quote2
                      }
                    });
                  } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                    result.elements.push(field);
                  else
                    throw new UnexpectedTypeError(field);
                  if (parser.lexer.current.startOfLine)
                    separator = "linebreak", parser.consume(",") || parser.consume(";");
                  else if (parser.consume(","))
                    separator = "comma";
                  else if (parser.consume(";"))
                    separator = "semicolon";
                  else
                    break;
                  if (parser.lexer.current.type === "}")
                    break;
                }
                if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                  throw new Error("Unterminated record type. Missing '}'");
              }
              return result;
            }, "parsePrefix")
          });
        }
        __name(createObjectParslet, "createObjectParslet");
        function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
          return composeParslet({
            name: "objectFieldParslet",
            precedence: Precedence.KEY_VALUE,
            accept: __name((type) => type === ":", "accept"),
            parseInfix: __name((parser, left2) => {
              var _a;
              let optional = !1, readonlyProperty = !1;
              allowOptional && left2.type === "JsdocTypeNullable" && (optional = !0, left2 = left2.element), allowReadonly && left2.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = !0, left2 = left2.element);
              let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;
              if (parentParser.acceptLexerState(parser), left2.type === "JsdocTypeNumber" || left2.type === "JsdocTypeName" || left2.type === "JsdocTypeStringValue" || isSquaredProperty(left2)) {
                if (isSquaredProperty(left2) && !allowSquaredProperties)
                  throw new UnexpectedTypeError(left2);
                parentParser.consume(":");
                let quote2;
                left2.type === "JsdocTypeStringValue" && (quote2 = left2.meta.quote);
                let right2 = parentParser.parseType(Precedence.KEY_VALUE);
                return parser.acceptLexerState(parentParser), {
                  type: "JsdocTypeObjectField",
                  key: isSquaredProperty(left2) ? left2 : left2.value.toString(),
                  right: right2,
                  optional,
                  readonly: readonlyProperty,
                  meta: {
                    quote: quote2
                  }
                };
              } else {
                if (!allowKeyTypes)
                  throw new UnexpectedTypeError(left2);
                parentParser.consume(":");
                let right2 = parentParser.parseType(Precedence.KEY_VALUE);
                return parser.acceptLexerState(parentParser), {
                  type: "JsdocTypeJsdocObjectField",
                  left: assertRootResult(left2),
                  right: right2
                };
              }
            }, "parseInfix")
          });
        }
        __name(createObjectFieldParslet, "createObjectFieldParslet");
        function createKeyValueParslet({ allowOptional, allowVariadic }) {
          return composeParslet({
            name: "keyValueParslet",
            precedence: Precedence.KEY_VALUE,
            accept: __name((type) => type === ":", "accept"),
            parseInfix: __name((parser, left2) => {
              let optional = !1, variadic = !1;
              if (allowOptional && left2.type === "JsdocTypeNullable" && (optional = !0, left2 = left2.element), allowVariadic && left2.type === "JsdocTypeVariadic" && left2.element !== void 0 && (variadic = !0, left2 = left2.element), left2.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(left2);
              parser.consume(":");
              let right2 = parser.parseType(Precedence.KEY_VALUE);
              return {
                type: "JsdocTypeKeyValue",
                key: left2.value,
                right: right2,
                optional,
                variadic
              };
            }, "parseInfix")
          });
        }
        __name(createKeyValueParslet, "createKeyValueParslet");
        let jsdocBaseGrammar = [
          ...baseGrammar,
          createFunctionParslet({
            allowWithoutParenthesis: !0,
            allowNamedParameters: ["this", "new"],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1
          }),
          stringValueParslet,
          createSpecialNamePathParslet({
            allowedTypes: ["module", "external", "event"],
            pathGrammar
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !0,
            allowPostfix: !0
          }),
          createNameParslet({
            allowedAdditionalTokens: ["keyof"]
          }),
          symbolParslet,
          arrayBracketsParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar
          })
        ], jsdocGrammar = [
          ...jsdocBaseGrammar,
          createObjectParslet({
            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
            // we leave out the object type deliberately
            objectFieldGrammar: [
              createNameParslet({
                allowedAdditionalTokens: ["typeof", "module", "in"]
              }),
              createObjectFieldParslet({
                allowSquaredProperties: !1,
                allowKeyTypes: !0,
                allowOptional: !1,
                allowReadonly: !1
              }),
              ...jsdocBaseGrammar
            ],
            allowKeyTypes: !0
          }),
          createKeyValueParslet({
            allowOptional: !0,
            allowVariadic: !0
          })
        ], typeOfParslet = composeParslet({
          name: "typeOfParslet",
          accept: __name((type) => type === "typeof", "accept"),
          parsePrefix: __name((parser) => (parser.consume("typeof"), {
            type: "JsdocTypeTypeof",
            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
          }), "parsePrefix")
        }), objectFieldGrammar$1 = [
          createNameParslet({
            allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
          }),
          nullableParslet,
          optionalParslet,
          stringValueParslet,
          numberParslet,
          createObjectFieldParslet({
            allowSquaredProperties: !1,
            allowKeyTypes: !1,
            allowOptional: !1,
            allowReadonly: !1
          })
        ], closureGrammar = [
          ...baseGrammar,
          createObjectParslet({
            allowKeyTypes: !1,
            objectFieldGrammar: objectFieldGrammar$1
          }),
          createNameParslet({
            allowedAdditionalTokens: ["event", "external", "in"]
          }),
          typeOfParslet,
          createFunctionParslet({
            allowWithoutParenthesis: !1,
            allowNamedParameters: ["this", "new"],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !1,
            allowPostfix: !1
          }),
          // additional name parslet is needed for some special cases
          createNameParslet({
            allowedAdditionalTokens: ["keyof"]
          }),
          createSpecialNamePathParslet({
            allowedTypes: ["module"],
            pathGrammar
          }),
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar
          }),
          createKeyValueParslet({
            allowOptional: !1,
            allowVariadic: !1
          }),
          symbolParslet
        ], assertsParslet = composeParslet({
          name: "assertsParslet",
          accept: __name((type) => type === "asserts", "accept"),
          parsePrefix: __name((parser) => {
            parser.consume("asserts");
            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            return parser.consume("is") ? {
              type: "JsdocTypeAsserts",
              left: left2,
              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            } : {
              type: "JsdocTypeAssertsPlain",
              element: left2
            };
          }, "parsePrefix")
        });
        function createTupleParslet({ allowQuestionMark }) {
          return composeParslet({
            name: "tupleParslet",
            accept: __name((type) => type === "[", "accept"),
            parsePrefix: __name((parser) => {
              parser.consume("[");
              let result = {
                type: "JsdocTypeTuple",
                elements: []
              };
              if (parser.consume("]"))
                return result;
              let typeList = parser.parseIntermediateType(Precedence.ALL);
              if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
                throw new Error("Unterminated '['");
              if (result.elements.some((e) => e.type === "JsdocTypeUnknown"))
                throw new Error("Question mark in tuple not allowed");
              return result;
            }, "parsePrefix")
          });
        }
        __name(createTupleParslet, "createTupleParslet");
        let keyOfParslet = composeParslet({
          name: "keyOfParslet",
          accept: __name((type) => type === "keyof", "accept"),
          parsePrefix: __name((parser) => (parser.consume("keyof"), {
            type: "JsdocTypeKeyof",
            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
          }), "parsePrefix")
        }), importParslet = composeParslet({
          name: "importParslet",
          accept: __name((type) => type === "import", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.consume("import"), !parser.consume("("))
              throw new Error("Missing parenthesis after import keyword");
            let path = parser.parseType(Precedence.PREFIX);
            if (path.type !== "JsdocTypeStringValue")
              throw new Error("Only string values are allowed as paths for imports");
            if (!parser.consume(")"))
              throw new Error("Missing closing parenthesis after import keyword");
            return {
              type: "JsdocTypeImport",
              element: path
            };
          }, "parsePrefix")
        }), readonlyPropertyParslet = composeParslet({
          name: "readonlyPropertyParslet",
          accept: __name((type) => type === "readonly", "accept"),
          parsePrefix: __name((parser) => (parser.consume("readonly"), {
            type: "JsdocTypeReadonlyProperty",
            element: parser.parseIntermediateType(Precedence.KEY_VALUE)
          }), "parsePrefix")
        }), arrowFunctionParslet = composeParslet({
          name: "arrowFunctionParslet",
          precedence: Precedence.ARROW,
          accept: __name((type) => type === "=>", "accept"),
          parseInfix: __name((parser, left2) => (parser.consume("=>"), {
            type: "JsdocTypeFunction",
            parameters: getParameters(left2).map(assertPlainKeyValueOrNameResult),
            arrow: !0,
            constructor: !1,
            parenthesis: !0,
            returnType: parser.parseType(Precedence.OBJECT)
          }), "parseInfix")
        }), genericArrowFunctionParslet = composeParslet({
          name: "genericArrowFunctionParslet",
          accept: __name((type) => type === "<", "accept"),
          parsePrefix: __name((parser) => {
            let typeParameters = [];
            parser.consume("<");
            do {
              let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
              if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(name);
              let constraint;
              parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
              let typeParameter = {
                type: "JsdocTypeTypeParameter",
                name
              };
              if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
                break;
            } while (parser.consume(","));
            let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
            return functionBase.typeParameters = typeParameters, functionBase;
          }, "parsePrefix")
        }), intersectionParslet = composeParslet({
          name: "intersectionParslet",
          accept: __name((type) => type === "&", "accept"),
          precedence: Precedence.INTERSECTION,
          parseInfix: __name((parser, left2) => {
            parser.consume("&");
            let elements = [];
            do
              elements.push(parser.parseType(Precedence.INTERSECTION));
            while (parser.consume("&"));
            return {
              type: "JsdocTypeIntersection",
              elements: [assertRootResult(left2), ...elements]
            };
          }, "parseInfix")
        }), predicateParslet = composeParslet({
          name: "predicateParslet",
          precedence: Precedence.INFIX,
          accept: __name((type) => type === "is", "accept"),
          parseInfix: __name((parser, left2) => {
            if (left2.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left2, "A typescript predicate always has to have a name on the left side.");
            return parser.consume("is"), {
              type: "JsdocTypePredicate",
              left: left2,
              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            };
          }, "parseInfix")
        }), objectSquaredPropertyParslet = composeParslet({
          name: "objectSquareBracketPropertyParslet",
          accept: __name((type) => type === "[", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.baseParser === void 0)
              throw new Error("Only allowed inside object grammar");
            parser.consume("[");
            let key = parser.lexer.current.text;
            parser.consume("Identifier");
            let result;
            if (parser.consume(":")) {
              let parentParser = parser.baseParser;
              parentParser.acceptLexerState(parser), result = {
                type: "JsdocTypeIndexSignature",
                key,
                right: parentParser.parseType(Precedence.INDEX_BRACKETS)
              }, parser.acceptLexerState(parentParser);
            } else if (parser.consume("in")) {
              let parentParser = parser.baseParser;
              parentParser.acceptLexerState(parser), result = {
                type: "JsdocTypeMappedType",
                key,
                right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
              }, parser.acceptLexerState(parentParser);
            } else
              throw new Error("Missing ':' or 'in' inside square bracketed property.");
            if (!parser.consume("]"))
              throw new Error("Unterminated square brackets");
            return result;
          }, "parsePrefix")
        }), readonlyArrayParslet = composeParslet({
          name: "readonlyArrayParslet",
          accept: __name((type) => type === "readonly", "accept"),
          parsePrefix: __name((parser) => (parser.consume("readonly"), {
            type: "JsdocTypeReadonlyArray",
            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
          }), "parsePrefix")
        }), conditionalParslet = composeParslet({
          name: "conditionalParslet",
          precedence: Precedence.INFIX,
          accept: __name((type) => type === "extends", "accept"),
          parseInfix: __name((parser, left2) => {
            parser.consume("extends");
            let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
            return parser.consume(":"), {
              type: "JsdocTypeConditional",
              checksType: assertRootResult(left2),
              extendsType,
              trueType,
              falseType: parser.parseType(Precedence.INFIX)
            };
          }, "parseInfix")
        }), objectFieldGrammar = [
          readonlyPropertyParslet,
          createNameParslet({
            allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
          }),
          nullableParslet,
          optionalParslet,
          stringValueParslet,
          numberParslet,
          createObjectFieldParslet({
            allowSquaredProperties: !0,
            allowKeyTypes: !1,
            allowOptional: !0,
            allowReadonly: !0
          }),
          objectSquaredPropertyParslet
        ], typescriptGrammar = [
          ...baseGrammar,
          createObjectParslet({
            allowKeyTypes: !1,
            objectFieldGrammar
          }),
          readonlyArrayParslet,
          typeOfParslet,
          keyOfParslet,
          importParslet,
          stringValueParslet,
          createFunctionParslet({
            allowWithoutParenthesis: !0,
            allowNoReturnType: !1,
            allowNamedParameters: ["this", "new", "args"],
            allowNewAsFunctionKeyword: !0
          }),
          createTupleParslet({
            allowQuestionMark: !1
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !1,
            allowPostfix: !1
          }),
          assertsParslet,
          conditionalParslet,
          createNameParslet({
            allowedAdditionalTokens: ["event", "external", "in"]
          }),
          createSpecialNamePathParslet({
            allowedTypes: ["module"],
            pathGrammar
          }),
          arrayBracketsParslet,
          arrowFunctionParslet,
          genericArrowFunctionParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !0,
            allowJsdocNamePaths: !1,
            pathGrammar
          }),
          intersectionParslet,
          predicateParslet,
          createKeyValueParslet({
            allowVariadic: !0,
            allowOptional: !0
          })
        ];
        function parse33(expression, mode) {
          switch (mode) {
            case "closure":
              return new Parser(closureGrammar, expression).parse();
            case "jsdoc":
              return new Parser(jsdocGrammar, expression).parse();
            case "typescript":
              return new Parser(typescriptGrammar, expression).parse();
          }
        }
        __name(parse33, "parse");
        function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
          let error;
          for (let mode of modes)
            try {
              return parse33(expression, mode);
            } catch (e) {
              error = e;
            }
          throw error;
        }
        __name(tryParse, "tryParse");
        function transform(rules2, parseResult) {
          let rule = rules2[parseResult.type];
          if (rule === void 0)
            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
          return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
        }
        __name(transform, "transform");
        function notAvailableTransform(parseResult) {
          throw new Error("This transform is not available. Are you trying the correct parsing mode?");
        }
        __name(notAvailableTransform, "notAvailableTransform");
        function extractSpecialParams(source) {
          let result = {
            params: []
          };
          for (let param of source.parameters)
            param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
          return result;
        }
        __name(extractSpecialParams, "extractSpecialParams");
        function applyPosition(position, target, value2) {
          return position === "prefix" ? value2 + target : target + value2;
        }
        __name(applyPosition, "applyPosition");
        function quote(value2, quote2) {
          switch (quote2) {
            case "double":
              return `"${value2}"`;
            case "single":
              return `'${value2}'`;
            case void 0:
              return value2;
          }
        }
        __name(quote, "quote");
        function stringifyRules2() {
          return {
            JsdocTypeParenthesis: __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeParenthesis"),
            JsdocTypeKeyof: __name((result, transform2) => `keyof ${transform2(result.element)}`, "JsdocTypeKeyof"),
            JsdocTypeFunction: __name((result, transform2) => {
              var _a;
              if (result.arrow) {
                if (result.returnType === void 0)
                  throw new Error("Arrow function needs a return type.");
                let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(", ")) !== null && _a !== void 0 ? _a : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
                return result.constructor && (stringified = "new " + stringified), stringified;
              } else {
                let stringified = result.constructor ? "new" : "function";
                return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
              }
            }, "JsdocTypeFunction"),
            JsdocTypeName: __name((result) => result.value, "JsdocTypeName"),
            JsdocTypeTuple: __name((result, transform2) => `[${result.elements.map(transform2).join(", ")}]`, "JsdocTypeTuple"),
            JsdocTypeVariadic: __name((result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."), "JsdocTypeVariadic"),
            JsdocTypeNamePath: __name((result, transform2) => {
              let left2 = transform2(result.left), right2 = transform2(result.right);
              switch (result.pathType) {
                case "inner":
                  return `${left2}~${right2}`;
                case "instance":
                  return `${left2}#${right2}`;
                case "property":
                  return `${left2}.${right2}`;
                case "property-brackets":
                  return `${left2}[${right2}]`;
              }
            }, "JsdocTypeNamePath"),
            JsdocTypeStringValue: __name((result) => quote(result.value, result.meta.quote), "JsdocTypeStringValue"),
            JsdocTypeAny: __name(() => "*", "JsdocTypeAny"),
            JsdocTypeGeneric: __name((result, transform2) => {
              if (result.meta.brackets === "square") {
                let element = result.elements[0], transformed = transform2(element);
                return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
              } else
                return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === !0 ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
            }, "JsdocTypeGeneric"),
            JsdocTypeImport: __name((result, transform2) => `import(${transform2(result.element)})`, "JsdocTypeImport"),
            JsdocTypeObjectField: __name((result, transform2) => {
              let text = "";
              return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
            }, "JsdocTypeObjectField"),
            JsdocTypeJsdocObjectField: __name((result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`, "JsdocTypeJsdocObjectField"),
            JsdocTypeKeyValue: __name((result, transform2) => {
              let text = result.key;
              return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
            }, "JsdocTypeKeyValue"),
            JsdocTypeSpecialNamePath: __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, "JsdocTypeSpecialNamePath"),
            JsdocTypeNotNullable: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"), "JsdocTypeNotNullable"),
            JsdocTypeNull: __name(() => "null", "JsdocTypeNull"),
            JsdocTypeNullable: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"), "JsdocTypeNullable"),
            JsdocTypeNumber: __name((result) => result.value.toString(), "JsdocTypeNumber"),
            JsdocTypeObject: __name((result, transform2) => {
              var _a, _b;
              return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
            }, "JsdocTypeObject"),
            JsdocTypeOptional: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="), "JsdocTypeOptional"),
            JsdocTypeSymbol: __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeSymbol"),
            JsdocTypeTypeof: __name((result, transform2) => `typeof ${transform2(result.element)}`, "JsdocTypeTypeof"),
            JsdocTypeUndefined: __name(() => "undefined", "JsdocTypeUndefined"),
            JsdocTypeUnion: __name((result, transform2) => result.elements.map(transform2).join(" | "), "JsdocTypeUnion"),
            JsdocTypeUnknown: __name(() => "?", "JsdocTypeUnknown"),
            JsdocTypeIntersection: __name((result, transform2) => result.elements.map(transform2).join(" & "), "JsdocTypeIntersection"),
            JsdocTypeProperty: __name((result) => quote(result.value, result.meta.quote), "JsdocTypeProperty"),
            JsdocTypePredicate: __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypePredicate"),
            JsdocTypeIndexSignature: __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, "JsdocTypeIndexSignature"),
            JsdocTypeMappedType: __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, "JsdocTypeMappedType"),
            JsdocTypeAsserts: __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypeAsserts"),
            JsdocTypeReadonlyArray: __name((result, transform2) => `readonly ${transform2(result.element)}`, "JsdocTypeReadonlyArray"),
            JsdocTypeAssertsPlain: __name((result, transform2) => `asserts ${transform2(result.element)}`, "JsdocTypeAssertsPlain"),
            JsdocTypeConditional: __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, "JsdocTypeConditional"),
            JsdocTypeTypeParameter: __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
          };
        }
        __name(stringifyRules2, "stringifyRules");
        let storedStringifyRules = stringifyRules2();
        function stringify22(result) {
          return transform(storedStringifyRules, result);
        }
        __name(stringify22, "stringify");
        let reservedWords = [
          "null",
          "true",
          "false",
          "break",
          "case",
          "catch",
          "class",
          "const",
          "continue",
          "debugger",
          "default",
          "delete",
          "do",
          "else",
          "export",
          "extends",
          "finally",
          "for",
          "function",
          "if",
          "import",
          "in",
          "instanceof",
          "new",
          "return",
          "super",
          "switch",
          "this",
          "throw",
          "try",
          "typeof",
          "var",
          "void",
          "while",
          "with",
          "yield"
        ];
        function makeName(value2) {
          let result = {
            type: "NameExpression",
            name: value2
          };
          return reservedWords.includes(value2) && (result.reservedWord = !0), result;
        }
        __name(makeName, "makeName");
        let catharsisTransformRules = {
          JsdocTypeOptional: __name((result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.optional = !0, transformed;
          }, "JsdocTypeOptional"),
          JsdocTypeNullable: __name((result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.nullable = !0, transformed;
          }, "JsdocTypeNullable"),
          JsdocTypeNotNullable: __name((result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.nullable = !1, transformed;
          }, "JsdocTypeNotNullable"),
          JsdocTypeVariadic: __name((result, transform2) => {
            if (result.element === void 0)
              throw new Error("dots without value are not allowed in catharsis mode");
            let transformed = transform2(result.element);
            return transformed.repeatable = !0, transformed;
          }, "JsdocTypeVariadic"),
          JsdocTypeAny: __name(() => ({
            type: "AllLiteral"
          }), "JsdocTypeAny"),
          JsdocTypeNull: __name(() => ({
            type: "NullLiteral"
          }), "JsdocTypeNull"),
          JsdocTypeStringValue: __name((result) => makeName(quote(result.value, result.meta.quote)), "JsdocTypeStringValue"),
          JsdocTypeUndefined: __name(() => ({
            type: "UndefinedLiteral"
          }), "JsdocTypeUndefined"),
          JsdocTypeUnknown: __name(() => ({
            type: "UnknownLiteral"
          }), "JsdocTypeUnknown"),
          JsdocTypeFunction: __name((result, transform2) => {
            let params = extractSpecialParams(result), transformed = {
              type: "FunctionType",
              params: params.params.map(transform2)
            };
            return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
          }, "JsdocTypeFunction"),
          JsdocTypeGeneric: __name((result, transform2) => ({
            type: "TypeApplication",
            applications: result.elements.map((o2) => transform2(o2)),
            expression: transform2(result.left)
          }), "JsdocTypeGeneric"),
          JsdocTypeSpecialNamePath: __name((result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)), "JsdocTypeSpecialNamePath"),
          JsdocTypeName: __name((result) => result.value !== "function" ? makeName(result.value) : {
            type: "FunctionType",
            params: []
          }, "JsdocTypeName"),
          JsdocTypeNumber: __name((result) => makeName(result.value.toString()), "JsdocTypeNumber"),
          JsdocTypeObject: __name((result, transform2) => {
            let transformed = {
              type: "RecordType",
              fields: []
            };
            for (let field of result.elements)
              field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
                type: "FieldType",
                key: transform2(field),
                value: void 0
              }) : transformed.fields.push(transform2(field));
            return transformed;
          }, "JsdocTypeObject"),
          JsdocTypeObjectField: __name((result, transform2) => {
            if (typeof result.key != "string")
              throw new Error("Index signatures and mapped types are not supported");
            return {
              type: "FieldType",
              key: makeName(quote(result.key, result.meta.quote)),
              value: result.right === void 0 ? void 0 : transform2(result.right)
            };
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: __name((result, transform2) => ({
            type: "FieldType",
            key: transform2(result.left),
            value: transform2(result.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeUnion: __name((result, transform2) => ({
            type: "TypeUnion",
            elements: result.elements.map((e) => transform2(e))
          }), "JsdocTypeUnion"),
          JsdocTypeKeyValue: __name((result, transform2) => ({
            type: "FieldType",
            key: makeName(result.key),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          }), "JsdocTypeKeyValue"),
          JsdocTypeNamePath: __name((result, transform2) => {
            let leftResult = transform2(result.left), rightValue;
            result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
            let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
            return makeName(`${leftResult.name}${joiner}${rightValue}`);
          }, "JsdocTypeNamePath"),
          JsdocTypeSymbol: __name((result) => {
            let value2 = "", element = result.element, trailingDots = !1;
            return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value2 = "..." : trailingDots = !0, element = element.element), element?.type === "JsdocTypeName" ? value2 += element.value : element?.type === "JsdocTypeNumber" && (value2 += element.value.toString()), trailingDots && (value2 += "..."), makeName(`${result.value}(${value2})`);
          }, "JsdocTypeSymbol"),
          JsdocTypeParenthesis: __name((result, transform2) => transform2(assertRootResult(result.element)), "JsdocTypeParenthesis"),
          JsdocTypeMappedType: notAvailableTransform,
          JsdocTypeIndexSignature: notAvailableTransform,
          JsdocTypeImport: notAvailableTransform,
          JsdocTypeKeyof: notAvailableTransform,
          JsdocTypeTuple: notAvailableTransform,
          JsdocTypeTypeof: notAvailableTransform,
          JsdocTypeIntersection: notAvailableTransform,
          JsdocTypeProperty: notAvailableTransform,
          JsdocTypePredicate: notAvailableTransform,
          JsdocTypeAsserts: notAvailableTransform,
          JsdocTypeReadonlyArray: notAvailableTransform,
          JsdocTypeAssertsPlain: notAvailableTransform,
          JsdocTypeConditional: notAvailableTransform,
          JsdocTypeTypeParameter: notAvailableTransform
        };
        function catharsisTransform(result) {
          return transform(catharsisTransformRules, result);
        }
        __name(catharsisTransform, "catharsisTransform");
        function getQuoteStyle(quote2) {
          switch (quote2) {
            case void 0:
              return "none";
            case "single":
              return "single";
            case "double":
              return "double";
          }
        }
        __name(getQuoteStyle, "getQuoteStyle");
        function getMemberType(type) {
          switch (type) {
            case "inner":
              return "INNER_MEMBER";
            case "instance":
              return "INSTANCE_MEMBER";
            case "property":
              return "MEMBER";
            case "property-brackets":
              return "MEMBER";
          }
        }
        __name(getMemberType, "getMemberType");
        function nestResults(type, results) {
          return results.length === 2 ? {
            type,
            left: results[0],
            right: results[1]
          } : {
            type,
            left: results[0],
            right: nestResults(type, results.slice(1))
          };
        }
        __name(nestResults, "nestResults");
        let jtpRules = {
          JsdocTypeOptional: __name((result, transform2) => ({
            type: "OPTIONAL",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
            }
          }), "JsdocTypeOptional"),
          JsdocTypeNullable: __name((result, transform2) => ({
            type: "NULLABLE",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
            }
          }), "JsdocTypeNullable"),
          JsdocTypeNotNullable: __name((result, transform2) => ({
            type: "NOT_NULLABLE",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeVariadic: __name((result, transform2) => {
            let transformed = {
              type: "VARIADIC",
              meta: {
                syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
              }
            };
            return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
          }, "JsdocTypeVariadic"),
          JsdocTypeName: __name((result) => ({
            type: "NAME",
            name: result.value
          }), "JsdocTypeName"),
          JsdocTypeTypeof: __name((result, transform2) => ({
            type: "TYPE_QUERY",
            name: transform2(result.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeTuple: __name((result, transform2) => ({
            type: "TUPLE",
            entries: result.elements.map(transform2)
          }), "JsdocTypeTuple"),
          JsdocTypeKeyof: __name((result, transform2) => ({
            type: "KEY_QUERY",
            value: transform2(result.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeImport: __name((result) => ({
            type: "IMPORT",
            path: {
              type: "STRING_VALUE",
              quoteStyle: getQuoteStyle(result.element.meta.quote),
              string: result.element.value
            }
          }), "JsdocTypeImport"),
          JsdocTypeUndefined: __name(() => ({
            type: "NAME",
            name: "undefined"
          }), "JsdocTypeUndefined"),
          JsdocTypeAny: __name(() => ({
            type: "ANY"
          }), "JsdocTypeAny"),
          JsdocTypeFunction: __name((result, transform2) => {
            let specialParams = extractSpecialParams(result), transformed = {
              type: result.arrow ? "ARROW" : "FUNCTION",
              params: specialParams.params.map((param) => {
                if (param.type === "JsdocTypeKeyValue") {
                  if (param.right === void 0)
                    throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                  return {
                    type: "NAMED_PARAMETER",
                    name: param.key,
                    typeName: transform2(param.right)
                  };
                } else
                  return transform2(param);
              }),
              new: null,
              returns: null
            };
            return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
          }, "JsdocTypeFunction"),
          JsdocTypeGeneric: __name((result, transform2) => {
            let transformed = {
              type: "GENERIC",
              subject: transform2(result.left),
              objects: result.elements.map(transform2),
              meta: {
                syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
              }
            };
            return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
              type: "NAME",
              name: "function"
            }), transformed;
          }, "JsdocTypeGeneric"),
          JsdocTypeObjectField: __name((result, transform2) => {
            if (typeof result.key != "string")
              throw new Error("Index signatures and mapped types are not supported");
            if (result.right === void 0)
              return {
                type: "RECORD_ENTRY",
                key: result.key,
                quoteStyle: getQuoteStyle(result.meta.quote),
                value: null,
                readonly: !1
              };
            let right2 = transform2(result.right);
            return result.optional && (right2 = {
              type: "OPTIONAL",
              value: right2,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            }), {
              type: "RECORD_ENTRY",
              key: result.key.toString(),
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: right2,
              readonly: !1
            };
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: __name(() => {
            throw new Error("Keys may not be typed in jsdoctypeparser.");
          }, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: __name((result, transform2) => {
            if (result.right === void 0)
              return {
                type: "RECORD_ENTRY",
                key: result.key,
                quoteStyle: "none",
                value: null,
                readonly: !1
              };
            let right2 = transform2(result.right);
            return result.optional && (right2 = {
              type: "OPTIONAL",
              value: right2,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            }), {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: right2,
              readonly: !1
            };
          }, "JsdocTypeKeyValue"),
          JsdocTypeObject: __name((result, transform2) => {
            let entries = [];
            for (let field of result.elements)
              (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
            return {
              type: "RECORD",
              entries
            };
          }, "JsdocTypeObject"),
          JsdocTypeSpecialNamePath: __name((result) => {
            if (result.specialType !== "module")
              throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
            return {
              type: "MODULE",
              value: {
                type: "FILE_PATH",
                quoteStyle: getQuoteStyle(result.meta.quote),
                path: result.value
              }
            };
          }, "JsdocTypeSpecialNamePath"),
          JsdocTypeNamePath: __name((result, transform2) => {
            let hasEventPrefix = !1, name, quoteStyle;
            result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
            let transformed = {
              type: getMemberType(result.pathType),
              owner: transform2(result.left),
              name,
              quoteStyle,
              hasEventPrefix
            };
            if (transformed.owner.type === "MODULE") {
              let tModule = transformed.owner;
              return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
            } else
              return transformed;
          }, "JsdocTypeNamePath"),
          JsdocTypeUnion: __name((result, transform2) => nestResults("UNION", result.elements.map(transform2)), "JsdocTypeUnion"),
          JsdocTypeParenthesis: __name((result, transform2) => ({
            type: "PARENTHESIS",
            value: transform2(assertRootResult(result.element))
          }), "JsdocTypeParenthesis"),
          JsdocTypeNull: __name(() => ({
            type: "NAME",
            name: "null"
          }), "JsdocTypeNull"),
          JsdocTypeUnknown: __name(() => ({
            type: "UNKNOWN"
          }), "JsdocTypeUnknown"),
          JsdocTypeStringValue: __name((result) => ({
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.meta.quote),
            string: result.value
          }), "JsdocTypeStringValue"),
          JsdocTypeIntersection: __name((result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)), "JsdocTypeIntersection"),
          JsdocTypeNumber: __name((result) => ({
            type: "NUMBER_VALUE",
            number: result.value.toString()
          }), "JsdocTypeNumber"),
          JsdocTypeSymbol: notAvailableTransform,
          JsdocTypeProperty: notAvailableTransform,
          JsdocTypePredicate: notAvailableTransform,
          JsdocTypeMappedType: notAvailableTransform,
          JsdocTypeIndexSignature: notAvailableTransform,
          JsdocTypeAsserts: notAvailableTransform,
          JsdocTypeReadonlyArray: notAvailableTransform,
          JsdocTypeAssertsPlain: notAvailableTransform,
          JsdocTypeConditional: notAvailableTransform,
          JsdocTypeTypeParameter: notAvailableTransform
        };
        function jtpTransform(result) {
          return transform(jtpRules, result);
        }
        __name(jtpTransform, "jtpTransform");
        function identityTransformRules() {
          return {
            JsdocTypeIntersection: __name((result, transform2) => ({
              type: "JsdocTypeIntersection",
              elements: result.elements.map(transform2)
            }), "JsdocTypeIntersection"),
            JsdocTypeGeneric: __name((result, transform2) => ({
              type: "JsdocTypeGeneric",
              left: transform2(result.left),
              elements: result.elements.map(transform2),
              meta: {
                dot: result.meta.dot,
                brackets: result.meta.brackets
              }
            }), "JsdocTypeGeneric"),
            JsdocTypeNullable: __name((result) => result, "JsdocTypeNullable"),
            JsdocTypeUnion: __name((result, transform2) => ({
              type: "JsdocTypeUnion",
              elements: result.elements.map(transform2)
            }), "JsdocTypeUnion"),
            JsdocTypeUnknown: __name((result) => result, "JsdocTypeUnknown"),
            JsdocTypeUndefined: __name((result) => result, "JsdocTypeUndefined"),
            JsdocTypeTypeof: __name((result, transform2) => ({
              type: "JsdocTypeTypeof",
              element: transform2(result.element)
            }), "JsdocTypeTypeof"),
            JsdocTypeSymbol: __name((result, transform2) => {
              let transformed = {
                type: "JsdocTypeSymbol",
                value: result.value
              };
              return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
            }, "JsdocTypeSymbol"),
            JsdocTypeOptional: __name((result, transform2) => ({
              type: "JsdocTypeOptional",
              element: transform2(result.element),
              meta: {
                position: result.meta.position
              }
            }), "JsdocTypeOptional"),
            JsdocTypeObject: __name((result, transform2) => ({
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: result.elements.map(transform2)
            }), "JsdocTypeObject"),
            JsdocTypeNumber: __name((result) => result, "JsdocTypeNumber"),
            JsdocTypeNull: __name((result) => result, "JsdocTypeNull"),
            JsdocTypeNotNullable: __name((result, transform2) => ({
              type: "JsdocTypeNotNullable",
              element: transform2(result.element),
              meta: {
                position: result.meta.position
              }
            }), "JsdocTypeNotNullable"),
            JsdocTypeSpecialNamePath: __name((result) => result, "JsdocTypeSpecialNamePath"),
            JsdocTypeObjectField: __name((result, transform2) => ({
              type: "JsdocTypeObjectField",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              readonly: result.readonly,
              meta: result.meta
            }), "JsdocTypeObjectField"),
            JsdocTypeJsdocObjectField: __name((result, transform2) => ({
              type: "JsdocTypeJsdocObjectField",
              left: transform2(result.left),
              right: transform2(result.right)
            }), "JsdocTypeJsdocObjectField"),
            JsdocTypeKeyValue: __name((result, transform2) => ({
              type: "JsdocTypeKeyValue",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              variadic: result.variadic
            }), "JsdocTypeKeyValue"),
            JsdocTypeImport: __name((result, transform2) => ({
              type: "JsdocTypeImport",
              element: transform2(result.element)
            }), "JsdocTypeImport"),
            JsdocTypeAny: __name((result) => result, "JsdocTypeAny"),
            JsdocTypeStringValue: __name((result) => result, "JsdocTypeStringValue"),
            JsdocTypeNamePath: __name((result) => result, "JsdocTypeNamePath"),
            JsdocTypeVariadic: __name((result, transform2) => {
              let transformed = {
                type: "JsdocTypeVariadic",
                meta: {
                  position: result.meta.position,
                  squareBrackets: result.meta.squareBrackets
                }
              };
              return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
            }, "JsdocTypeVariadic"),
            JsdocTypeTuple: __name((result, transform2) => ({
              type: "JsdocTypeTuple",
              elements: result.elements.map(transform2)
            }), "JsdocTypeTuple"),
            JsdocTypeName: __name((result) => result, "JsdocTypeName"),
            JsdocTypeFunction: __name((result, transform2) => {
              let transformed = {
                type: "JsdocTypeFunction",
                arrow: result.arrow,
                parameters: result.parameters.map(transform2),
                constructor: result.constructor,
                parenthesis: result.parenthesis
              };
              return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
            }, "JsdocTypeFunction"),
            JsdocTypeKeyof: __name((result, transform2) => ({
              type: "JsdocTypeKeyof",
              element: transform2(result.element)
            }), "JsdocTypeKeyof"),
            JsdocTypeParenthesis: __name((result, transform2) => ({
              type: "JsdocTypeParenthesis",
              element: transform2(result.element)
            }), "JsdocTypeParenthesis"),
            JsdocTypeProperty: __name((result) => result, "JsdocTypeProperty"),
            JsdocTypePredicate: __name((result, transform2) => ({
              type: "JsdocTypePredicate",
              left: transform2(result.left),
              right: transform2(result.right)
            }), "JsdocTypePredicate"),
            JsdocTypeIndexSignature: __name((result, transform2) => ({
              type: "JsdocTypeIndexSignature",
              key: result.key,
              right: transform2(result.right)
            }), "JsdocTypeIndexSignature"),
            JsdocTypeMappedType: __name((result, transform2) => ({
              type: "JsdocTypeMappedType",
              key: result.key,
              right: transform2(result.right)
            }), "JsdocTypeMappedType"),
            JsdocTypeAsserts: __name((result, transform2) => ({
              type: "JsdocTypeAsserts",
              left: transform2(result.left),
              right: transform2(result.right)
            }), "JsdocTypeAsserts"),
            JsdocTypeReadonlyArray: __name((result, transform2) => ({
              type: "JsdocTypeReadonlyArray",
              element: transform2(result.element)
            }), "JsdocTypeReadonlyArray"),
            JsdocTypeAssertsPlain: __name((result, transform2) => ({
              type: "JsdocTypeAssertsPlain",
              element: transform2(result.element)
            }), "JsdocTypeAssertsPlain"),
            JsdocTypeConditional: __name((result, transform2) => ({
              type: "JsdocTypeConditional",
              checksType: transform2(result.checksType),
              extendsType: transform2(result.extendsType),
              trueType: transform2(result.trueType),
              falseType: transform2(result.falseType)
            }), "JsdocTypeConditional"),
            JsdocTypeTypeParameter: __name((result, transform2) => ({
              type: "JsdocTypeTypeParameter",
              name: transform2(result.name),
              constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
              defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
            }), "JsdocTypeTypeParameter")
          };
        }
        __name(identityTransformRules, "identityTransformRules");
        let visitorKeys = {
          JsdocTypeAny: [],
          JsdocTypeFunction: ["parameters", "returnType"],
          JsdocTypeGeneric: ["left", "elements"],
          JsdocTypeImport: [],
          JsdocTypeIndexSignature: ["right"],
          JsdocTypeIntersection: ["elements"],
          JsdocTypeKeyof: ["element"],
          JsdocTypeKeyValue: ["right"],
          JsdocTypeMappedType: ["right"],
          JsdocTypeName: [],
          JsdocTypeNamePath: ["left", "right"],
          JsdocTypeNotNullable: ["element"],
          JsdocTypeNull: [],
          JsdocTypeNullable: ["element"],
          JsdocTypeNumber: [],
          JsdocTypeObject: ["elements"],
          JsdocTypeObjectField: ["right"],
          JsdocTypeJsdocObjectField: ["left", "right"],
          JsdocTypeOptional: ["element"],
          JsdocTypeParenthesis: ["element"],
          JsdocTypeSpecialNamePath: [],
          JsdocTypeStringValue: [],
          JsdocTypeSymbol: ["element"],
          JsdocTypeTuple: ["elements"],
          JsdocTypeTypeof: ["element"],
          JsdocTypeUndefined: [],
          JsdocTypeUnion: ["elements"],
          JsdocTypeUnknown: [],
          JsdocTypeVariadic: ["element"],
          JsdocTypeProperty: [],
          JsdocTypePredicate: ["left", "right"],
          JsdocTypeAsserts: ["left", "right"],
          JsdocTypeReadonlyArray: ["element"],
          JsdocTypeAssertsPlain: ["element"],
          JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
          JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
        };
        function _traverse(node, parentNode, property, onEnter, onLeave) {
          onEnter?.(node, parentNode, property);
          let keysToVisit = visitorKeys[node.type];
          for (let key of keysToVisit) {
            let value2 = node[key];
            if (value2 !== void 0)
              if (Array.isArray(value2))
                for (let element of value2)
                  _traverse(element, node, key, onEnter, onLeave);
              else
                _traverse(value2, node, key, onEnter, onLeave);
          }
          onLeave?.(node, parentNode, property);
        }
        __name(_traverse, "_traverse");
        function traverse(node, onEnter, onLeave) {
          _traverse(node, void 0, void 0, onEnter, onLeave);
        }
        __name(traverse, "traverse"), exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse33, exports2.stringify = stringify22, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
      });
    }
  }), isLiteral = __name((type) => type.name === "literal", "isLiteral"), toEnumOption = __name((element) => element.value.replace(/['|"]/g, ""), "toEnumOption"), convertSig = __name((type) => {
    switch (type.type) {
      case "function":
        return { name: "function" };
      case "object":
        let values = {};
        return type.signature.properties.forEach((prop) => {
          values[prop.key] = convert2(prop.value);
        }), {
          name: "object",
          value: values
        };
      default:
        throw new UnknownArgTypesError({ type, language: "Flow" });
    }
  }, "convertSig"), convert2 = __name((type) => {
    let { name, raw } = type, base = {};
    switch (typeof raw < "u" && (base.raw = raw), type.name) {
      case "literal":
        return { ...base, name: "other", value: type.value };
      case "string":
      case "number":
      case "symbol":
      case "boolean":
        return { ...base, name };
      case "Array":
        return { ...base, name: "array", value: type.elements.map(convert2) };
      case "signature":
        return { ...base, ...convertSig(type) };
      case "union":
        return type.elements?.every(isLiteral) ? { ...base, name: "enum", value: type.elements?.map(toEnumOption) } : { ...base, name, value: type.elements?.map(convert2) };
      case "intersection":
        return { ...base, name, value: type.elements?.map(convert2) };
      default:
        return { ...base, name: "other", value: name };
    }
  }, "convert"), QUOTE_REGEX = /^['"]|['"]$/g, trimQuotes = __name((str2) => str2.replace(QUOTE_REGEX, ""), "trimQuotes"), includesQuotes = __name((str2) => QUOTE_REGEX.test(str2), "includesQuotes"), parseLiteral = __name((str2) => {
    let trimmedValue = trimQuotes(str2);
    return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);
  }, "parseLiteral"), SIGNATURE_REGEXP = /^\(.*\) => /, convert22 = __name((type) => {
    let { name, raw, computed, value: value2 } = type, base = {};
    switch (typeof raw < "u" && (base.raw = raw), name) {
      case "enum": {
        let values2 = computed ? value2 : value2.map((v3) => parseLiteral(v3.value));
        return { ...base, name, value: values2 };
      }
      case "string":
      case "number":
      case "symbol":
        return { ...base, name };
      case "func":
        return { ...base, name: "function" };
      case "bool":
      case "boolean":
        return { ...base, name: "boolean" };
      case "arrayOf":
      case "array":
        return { ...base, name: "array", value: value2 && convert22(value2) };
      case "object":
        return { ...base, name };
      case "objectOf":
        return { ...base, name, value: convert22(value2) };
      case "shape":
      case "exact":
        let values = mapValues(value2, (field) => convert22(field));
        return { ...base, name: "object", value: values };
      case "union":
        return { ...base, name: "union", value: value2.map((v3) => convert22(v3)) };
      case "instanceOf":
      case "element":
      case "elementType":
      default: {
        if (name?.indexOf("|") > 0)
          try {
            let literalValues = name.split("|").map((v3) => JSON.parse(v3));
            return { ...base, name: "enum", value: literalValues };
          } catch {
          }
        let otherVal = value2 ? `${name}(${value2})` : name, otherName = SIGNATURE_REGEXP.test(name) ? "function" : "other";
        return { ...base, name: otherName, value: otherVal };
      }
    }
  }, "convert"), convertSig2 = __name((type) => {
    switch (type.type) {
      case "function":
        return { name: "function" };
      case "object":
        let values = {};
        return type.signature.properties.forEach((prop) => {
          values[prop.key] = convert3(prop.value);
        }), {
          name: "object",
          value: values
        };
      default:
        throw new UnknownArgTypesError({ type, language: "Typescript" });
    }
  }, "convertSig"), convert3 = __name((type) => {
    let { name, raw } = type, base = {};
    switch (typeof raw < "u" && (base.raw = raw), type.name) {
      case "string":
      case "number":
      case "symbol":
      case "boolean":
        return { ...base, name };
      case "Array":
        return { ...base, name: "array", value: type.elements.map(convert3) };
      case "signature":
        return { ...base, ...convertSig2(type) };
      case "union":
        let result;
        return type.elements?.every((element) => element.name === "literal") ? result = {
          ...base,
          name: "enum",
          // @ts-expect-error fix types
          value: type.elements?.map((v3) => parseLiteral(v3.value))
        } : result = { ...base, name, value: type.elements?.map(convert3) }, result;
      case "intersection":
        return { ...base, name, value: type.elements?.map(convert3) };
      default:
        return { ...base, name: "other", value: name };
    }
  }, "convert"), convert4 = __name((docgenInfo) => {
    let { type, tsType, flowType } = docgenInfo;
    try {
      if (type != null)
        return convert22(type);
      if (tsType != null)
        return convert3(tsType);
      if (flowType != null)
        return convert2(flowType);
    } catch (err) {
      console.error(err);
    }
    return null;
  }, "convert"), TypeSystem = ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = "JavaScript", TypeSystem2.FLOW = "Flow", TypeSystem2.TYPESCRIPT = "TypeScript", TypeSystem2.UNKNOWN = "Unknown", TypeSystem2))(TypeSystem || {}), BLACKLIST = ["null", "undefined"];
  function isDefaultValueBlacklisted(value2) {
    return BLACKLIST.some((x3) => x3 === value2);
  }
  __name(isDefaultValueBlacklisted, "isDefaultValueBlacklisted");
  var str = __name((obj) => {
    if (!obj)
      return "";
    if (typeof obj == "string")
      return obj;
    throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);
  }, "str");
  function hasDocgen(component) {
    return !!component.__docgenInfo;
  }
  __name(hasDocgen, "hasDocgen");
  function isValidDocgenSection(docgenSection) {
    return docgenSection != null && Object.keys(docgenSection).length > 0;
  }
  __name(isValidDocgenSection, "isValidDocgenSection");
  function getDocgenSection(component, section) {
    return hasDocgen(component) ? component.__docgenInfo[section] : null;
  }
  __name(getDocgenSection, "getDocgenSection");
  function getDocgenDescription(component) {
    return hasDocgen(component) ? str(component.__docgenInfo.description) : "";
  }
  __name(getDocgenDescription, "getDocgenDescription");
  var Markers;
  (function(Markers2) {
    Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
  })(Markers = Markers || (Markers = {}));
  function isSpace(source) {
    return /^\s+$/.test(source);
  }
  __name(isSpace, "isSpace");
  function splitCR(source) {
    let matches3 = source.match(/\r+$/);
    return matches3 == null ? ["", source] : [source.slice(-matches3[0].length), source.slice(0, -matches3[0].length)];
  }
  __name(splitCR, "splitCR");
  function splitSpace(source) {
    let matches3 = source.match(/^\s+/);
    return matches3 == null ? ["", source] : [source.slice(0, matches3[0].length), source.slice(matches3[0].length)];
  }
  __name(splitSpace, "splitSpace");
  function splitLines(source) {
    return source.split(/\n/);
  }
  __name(splitLines, "splitLines");
  function seedSpec(spec = {}) {
    return Object.assign({ tag: "", name: "", type: "", optional: !1, description: "", problems: [], source: [] }, spec);
  }
  __name(seedSpec, "seedSpec");
  function seedTokens(tokens = {}) {
    return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, tokens);
  }
  __name(seedTokens, "seedTokens");
  var reTag = /^@\S+/;
  function getParser({ fence = "```" } = {}) {
    let fencer = getFencer(fence), toggleFence = __name((source, isFenced) => fencer(source) ? !isFenced : isFenced, "toggleFence");
    return __name(function(source) {
      let sections = [[]], isFenced = !1;
      for (let line of source)
        reTag.test(line.tokens.description) && !isFenced ? sections.push([line]) : sections[sections.length - 1].push(line), isFenced = toggleFence(line.tokens.description, isFenced);
      return sections;
    }, "parseBlock");
  }
  __name(getParser, "getParser");
  function getFencer(fence) {
    return typeof fence == "string" ? (source) => source.split(fence).length % 2 === 0 : fence;
  }
  __name(getFencer, "getFencer");
  function getParser2({ startLine = 0, markers = Markers } = {}) {
    let block = null, num = startLine;
    return __name(function(source) {
      let rest = source, tokens = seedTokens();
      if ([tokens.lineEnd, rest] = splitCR(rest), [tokens.start, rest] = splitSpace(rest), block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart) && (block = [], tokens.delimiter = rest.slice(0, markers.start.length), rest = rest.slice(markers.start.length), [tokens.postDelimiter, rest] = splitSpace(rest)), block === null)
        return num++, null;
      let isClosed = rest.trimRight().endsWith(markers.end);
      if (tokens.delimiter === "" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end) && (tokens.delimiter = markers.delim, rest = rest.slice(markers.delim.length), [tokens.postDelimiter, rest] = splitSpace(rest)), isClosed) {
        let trimmed = rest.trimRight();
        tokens.end = rest.slice(trimmed.length - markers.end.length), rest = trimmed.slice(0, -markers.end.length);
      }
      if (tokens.description = rest, block.push({ number: num, source, tokens }), num++, isClosed) {
        let result = block.slice();
        return block = null, result;
      }
      return null;
    }, "parseSource");
  }
  __name(getParser2, "getParser");
  function getParser3({ tokenizers }) {
    return __name(function(source) {
      var _a;
      let spec = seedSpec({ source });
      for (let tokenize of tokenizers)
        if (spec = tokenize(spec), !((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0) && _a.critical)
          break;
      return spec;
    }, "parseSpec");
  }
  __name(getParser3, "getParser");
  function tagTokenizer() {
    return (spec) => {
      let { tokens } = spec.source[0], match2 = tokens.description.match(/\s*(@(\S+))(\s*)/);
      return match2 === null ? (spec.problems.push({
        code: "spec:tag:prefix",
        message: 'tag should start with "@" symbol',
        line: spec.source[0].number,
        critical: !0
      }), spec) : (tokens.tag = match2[1], tokens.postTag = match2[3], tokens.description = tokens.description.slice(match2[0].length), spec.tag = match2[2], spec);
    };
  }
  __name(tagTokenizer, "tagTokenizer");
  function typeTokenizer(spacing = "compact") {
    let join2 = getJoiner(spacing);
    return (spec) => {
      let curlies = 0, lines = [];
      for (let [i3, { tokens }] of spec.source.entries()) {
        let type = "";
        if (i3 === 0 && tokens.description[0] !== "{")
          return spec;
        for (let ch of tokens.description)
          if (ch === "{" && curlies++, ch === "}" && curlies--, type += ch, curlies === 0)
            break;
        if (lines.push([tokens, type]), curlies === 0)
          break;
      }
      if (curlies !== 0)
        return spec.problems.push({
          code: "spec:type:unpaired-curlies",
          message: "unpaired curlies",
          line: spec.source[0].number,
          critical: !0
        }), spec;
      let parts = [], offset3 = lines[0][0].postDelimiter.length;
      for (let [i3, [tokens, type]] of lines.entries())
        tokens.type = type, i3 > 0 && (tokens.type = tokens.postDelimiter.slice(offset3) + type, tokens.postDelimiter = tokens.postDelimiter.slice(0, offset3)), [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length)), parts.push(tokens.type);
      return parts[0] = parts[0].slice(1), parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1), spec.type = join2(parts), spec;
    };
  }
  __name(typeTokenizer, "typeTokenizer");
  var trim = __name((x3) => x3.trim(), "trim");
  function getJoiner(spacing) {
    return spacing === "compact" ? (t) => t.map(trim).join("") : spacing === "preserve" ? (t) => t.join(`
`) : spacing;
  }
  __name(getJoiner, "getJoiner");
  var isQuoted = __name((s4) => s4 && s4.startsWith('"') && s4.endsWith('"'), "isQuoted");
  function nameTokenizer() {
    let typeEnd = __name((num, { tokens }, i3) => tokens.type === "" ? num : i3, "typeEnd");
    return (spec) => {
      let { tokens } = spec.source[spec.source.reduce(typeEnd, 0)], source = tokens.description.trimLeft(), quotedGroups = source.split('"');
      if (quotedGroups.length > 1 && quotedGroups[0] === "" && quotedGroups.length % 2 === 1)
        return spec.name = quotedGroups[1], tokens.name = `"${quotedGroups[1]}"`, [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;
      let brackets = 0, name = "", optional = !1, defaultValue;
      for (let ch of source) {
        if (brackets === 0 && isSpace(ch))
          break;
        ch === "[" && brackets++, ch === "]" && brackets--, name += ch;
      }
      if (brackets !== 0)
        return spec.problems.push({
          code: "spec:name:unpaired-brackets",
          message: "unpaired brackets",
          line: spec.source[0].number,
          critical: !0
        }), spec;
      let nameToken = name;
      if (name[0] === "[" && name[name.length - 1] === "]") {
        optional = !0, name = name.slice(1, -1);
        let parts = name.split("=");
        if (name = parts[0].trim(), parts[1] !== void 0 && (defaultValue = parts.slice(1).join("=").trim()), name === "")
          return spec.problems.push({
            code: "spec:name:empty-name",
            message: "empty name",
            line: spec.source[0].number,
            critical: !0
          }), spec;
        if (defaultValue === "")
          return spec.problems.push({
            code: "spec:name:empty-default",
            message: "empty default value",
            line: spec.source[0].number,
            critical: !0
          }), spec;
        if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue))
          return spec.problems.push({
            code: "spec:name:invalid-default",
            message: "invalid default value syntax",
            line: spec.source[0].number,
            critical: !0
          }), spec;
      }
      return spec.optional = optional, spec.name = name, tokens.name = nameToken, defaultValue !== void 0 && (spec.default = defaultValue), [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;
    };
  }
  __name(nameTokenizer, "nameTokenizer");
  function descriptionTokenizer(spacing = "compact", markers = Markers) {
    let join2 = getJoiner2(spacing);
    return (spec) => (spec.description = join2(spec.source, markers), spec);
  }
  __name(descriptionTokenizer, "descriptionTokenizer");
  function getJoiner2(spacing) {
    return spacing === "compact" ? compactJoiner : spacing === "preserve" ? preserveJoiner : spacing;
  }
  __name(getJoiner2, "getJoiner");
  function compactJoiner(lines, markers = Markers) {
    return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== "").join(" ");
  }
  __name(compactJoiner, "compactJoiner");
  var lineNo = __name((num, { tokens }, i3) => tokens.type === "" ? num : i3, "lineNo"), getDescription = __name(({ tokens }) => (tokens.delimiter === "" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, "getDescription");
  function preserveJoiner(lines, markers = Markers) {
    if (lines.length === 0)
      return "";
    lines[0].tokens.description === "" && lines[0].tokens.delimiter === markers.start && (lines = lines.slice(1));
    let lastLine = lines[lines.length - 1];
    return lastLine !== void 0 && lastLine.tokens.description === "" && lastLine.tokens.end.endsWith(markers.end) && (lines = lines.slice(0, -1)), lines = lines.slice(lines.reduce(lineNo, 0)), lines.map(getDescription).join(`
`);
  }
  __name(preserveJoiner, "preserveJoiner");
  function getParser4({ startLine = 0, fence = "```", spacing = "compact", markers = Markers, tokenizers = [
    tagTokenizer(),
    typeTokenizer(spacing),
    nameTokenizer(),
    descriptionTokenizer(spacing)
  ] } = {}) {
    if (startLine < 0 || startLine % 1 > 0)
      throw new Error("Invalid startLine");
    let parseSource = getParser2({ startLine, markers }), parseBlock = getParser({ fence }), parseSpec = getParser3({ tokenizers }), joinDescription = getJoiner2(spacing);
    return function(source) {
      let blocks = [];
      for (let line of splitLines(source)) {
        let lines = parseSource(line);
        if (lines === null)
          continue;
        let sections = parseBlock(lines), specs = sections.slice(1).map(parseSpec);
        blocks.push({
          description: joinDescription(sections[0], markers),
          tags: specs,
          source: lines,
          problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])
        });
      }
      return blocks;
    };
  }
  __name(getParser4, "getParser");
  function join(tokens) {
    return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;
  }
  __name(join, "join");
  function getStringifier() {
    return (block) => block.source.map(({ tokens }) => join(tokens)).join(`
`);
  }
  __name(getStringifier, "getStringifier");
  var zeroWidth = {
    line: 0,
    start: 0,
    delimiter: 0,
    postDelimiter: 0,
    tag: 0,
    postTag: 0,
    name: 0,
    postName: 0,
    type: 0,
    postType: 0,
    description: 0,
    end: 0,
    lineEnd: 0
  }, fields = Object.keys(zeroWidth);
  function parse(source, options2 = {}) {
    return getParser4(options2)(source);
  }
  __name(parse, "parse");
  var stringify = getStringifier(), import_jsdoc_type_pratt_parser = __toESM2(require_dist(), 1);
  function containsJsDoc(value2) {
    return value2 != null && value2.includes("@");
  }
  __name(containsJsDoc, "containsJsDoc");
  function parse2(content) {
    let normalisedContent = `/**
` + (content ?? "").split(`
`).map((line) => ` * ${line}`).join(`
`) + `
*/`, ast = parse(normalisedContent, {
      spacing: "preserve"
    });
    if (!ast || ast.length === 0)
      throw new Error("Cannot parse JSDoc tags.");
    return ast[0];
  }
  __name(parse2, "parse");
  var DEFAULT_OPTIONS2 = {
    tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
  }, parseJsDoc = __name((value2, options2 = DEFAULT_OPTIONS2) => {
    if (!containsJsDoc(value2))
      return {
        includesJsDoc: !1,
        ignore: !1
      };
    let jsDocAst = parse2(value2), extractedTags = extractJsDocTags(jsDocAst, options2.tags);
    return extractedTags.ignore ? {
      includesJsDoc: !0,
      ignore: !0
    } : {
      includesJsDoc: !0,
      ignore: !1,
      // Always use the parsed description to ensure JSDoc is removed from the description.
      description: jsDocAst.description.trim(),
      extractedTags
    };
  }, "parseJsDoc");
  function extractJsDocTags(ast, tags) {
    let extractedTags = {
      params: null,
      deprecated: null,
      returns: null,
      ignore: !1
    };
    for (let tagSpec of ast.tags)
      if (!(tags !== void 0 && !tags.includes(tagSpec.tag)))
        if (tagSpec.tag === "ignore") {
          extractedTags.ignore = !0;
          break;
        } else
          switch (tagSpec.tag) {
            // arg & argument are aliases for param.
            case "param":
            case "arg":
            case "argument": {
              let paramTag = extractParam(tagSpec);
              paramTag != null && (extractedTags.params == null && (extractedTags.params = []), extractedTags.params.push(paramTag));
              break;
            }
            case "deprecated": {
              let deprecatedTag = extractDeprecated(tagSpec);
              deprecatedTag != null && (extractedTags.deprecated = deprecatedTag);
              break;
            }
            case "returns": {
              let returnsTag = extractReturns(tagSpec);
              returnsTag != null && (extractedTags.returns = returnsTag);
              break;
            }
            default:
              break;
          }
    return extractedTags;
  }
  __name(extractJsDocTags, "extractJsDocTags");
  function normaliseParamName(name) {
    return name.replace(/[\.-]$/, "");
  }
  __name(normaliseParamName, "normaliseParamName");
  function extractParam(tag) {
    if (!tag.name || tag.name === "-")
      return null;
    let type = extractType(tag.type);
    return {
      name: tag.name,
      type,
      description: normaliseDescription(tag.description),
      getPrettyName: __name(() => normaliseParamName(tag.name), "getPrettyName"),
      getTypeName: __name(() => type ? extractTypeName(type) : null, "getTypeName")
    };
  }
  __name(extractParam, "extractParam");
  function extractDeprecated(tag) {
    return tag.name ? joinNameAndDescription(tag.name, tag.description) : null;
  }
  __name(extractDeprecated, "extractDeprecated");
  function joinNameAndDescription(name, desc) {
    let joined = name === "" ? desc : `${name} ${desc}`;
    return normaliseDescription(joined);
  }
  __name(joinNameAndDescription, "joinNameAndDescription");
  function normaliseDescription(text) {
    let normalised = text.replace(/^- /g, "").trim();
    return normalised === "" ? null : normalised;
  }
  __name(normaliseDescription, "normaliseDescription");
  function extractReturns(tag) {
    let type = extractType(tag.type);
    return type ? {
      type,
      description: joinNameAndDescription(tag.name, tag.description),
      getTypeName: __name(() => extractTypeName(type), "getTypeName")
    } : null;
  }
  __name(extractReturns, "extractReturns");
  var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
  jsdocStringifyRules.JsdocTypeAny = () => "any";
  jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
  jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
  function extractType(typeString) {
    try {
      return (0, import_jsdoc_type_pratt_parser.parse)(typeString, "typescript");
    } catch {
      return null;
    }
  }
  __name(extractType, "extractType");
  function extractTypeName(type) {
    return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);
  }
  __name(extractTypeName, "extractTypeName");
  var MAX_TYPE_SUMMARY_LENGTH = 90, MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;
  function isTooLongForTypeSummary(value2) {
    return value2.length > MAX_TYPE_SUMMARY_LENGTH;
  }
  __name(isTooLongForTypeSummary, "isTooLongForTypeSummary");
  function isTooLongForDefaultValueSummary(value2) {
    return value2.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;
  }
  __name(isTooLongForDefaultValueSummary, "isTooLongForDefaultValueSummary");
  function createSummaryValue(summary, detail) {
    return summary === detail ? { summary } : { summary, detail };
  }
  __name(createSummaryValue, "createSummaryValue");
  var normalizeNewlines = __name((string) => string.replace(/\\r\\n/g, "\\n"), "normalizeNewlines");
  function createDefaultValue(defaultValue, type) {
    if (defaultValue != null) {
      let { value: value2 } = defaultValue;
      if (!isDefaultValueBlacklisted(value2))
        return isTooLongForDefaultValueSummary(value2) ? createSummaryValue(type?.name, value2) : createSummaryValue(value2);
    }
    return null;
  }
  __name(createDefaultValue, "createDefaultValue");
  function generateUnionElement({ name, value: value2, elements, raw }) {
    return value2 ?? (elements != null ? elements.map(generateUnionElement).join(" | ") : raw ?? name);
  }
  __name(generateUnionElement, "generateUnionElement");
  function generateUnion({ name, raw, elements }) {
    return elements != null ? createSummaryValue(elements.map(generateUnionElement).join(" | ")) : raw != null ? createSummaryValue(raw.replace(/^\|\s*/, "")) : createSummaryValue(name);
  }
  __name(generateUnion, "generateUnion");
  function generateFuncSignature({ type, raw }) {
    return raw != null ? createSummaryValue(raw) : createSummaryValue(type);
  }
  __name(generateFuncSignature, "generateFuncSignature");
  function generateObjectSignature({ type, raw }) {
    return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(type, raw) : createSummaryValue(raw) : createSummaryValue(type);
  }
  __name(generateObjectSignature, "generateObjectSignature");
  function generateSignature(flowType) {
    let { type } = flowType;
    return type === "object" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);
  }
  __name(generateSignature, "generateSignature");
  function generateDefault({ name, raw }) {
    return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(name, raw) : createSummaryValue(raw) : createSummaryValue(name);
  }
  __name(generateDefault, "generateDefault");
  function createType(type) {
    if (type == null)
      return null;
    switch (type.name) {
      case "union":
        return generateUnion(type);
      case "signature":
        return generateSignature(type);
      default:
        return generateDefault(type);
    }
  }
  __name(createType, "createType");
  var createFlowPropDef = __name((propName, docgenInfo) => {
    let { flowType, description, required, defaultValue } = docgenInfo;
    return {
      name: propName,
      type: createType(flowType),
      required,
      description,
      defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)
    };
  }, "createFlowPropDef");
  function createDefaultValue2({ defaultValue }) {
    if (defaultValue != null) {
      let { value: value2 } = defaultValue;
      if (!isDefaultValueBlacklisted(value2))
        return createSummaryValue(value2);
    }
    return null;
  }
  __name(createDefaultValue2, "createDefaultValue");
  function createType2({ tsType, required }) {
    if (tsType == null)
      return null;
    let typeName = tsType.name;
    return required || (typeName = typeName.replace(" | undefined", "")), createSummaryValue(
      ["Array", "Record", "signature"].includes(tsType.name) ? tsType.raw : typeName
    );
  }
  __name(createType2, "createType");
  var createTsPropDef = __name((propName, docgenInfo) => {
    let { description, required } = docgenInfo;
    return {
      name: propName,
      type: createType2(docgenInfo),
      required,
      description,
      defaultValue: createDefaultValue2(docgenInfo)
    };
  }, "createTsPropDef");
  function createType3(type) {
    return type != null ? createSummaryValue(type.name) : null;
  }
  __name(createType3, "createType");
  function isReactDocgenTypescript(defaultValue) {
    let { computed, func } = defaultValue;
    return typeof computed > "u" && typeof func > "u";
  }
  __name(isReactDocgenTypescript, "isReactDocgenTypescript");
  function isStringValued(type) {
    return type ? type.name === "string" ? !0 : type.name === "enum" ? Array.isArray(type.value) && type.value.every(
      ({ value: tv }) => typeof tv == "string" && tv[0] === '"' && tv[tv.length - 1] === '"'
    ) : !1 : !1;
  }
  __name(isStringValued, "isStringValued");
  function createDefaultValue3(defaultValue, type) {
    if (defaultValue != null) {
      let { value: value2 } = defaultValue;
      if (!isDefaultValueBlacklisted(value2))
        return isReactDocgenTypescript(defaultValue) && isStringValued(type) ? createSummaryValue(JSON.stringify(value2)) : createSummaryValue(value2);
    }
    return null;
  }
  __name(createDefaultValue3, "createDefaultValue");
  function createBasicPropDef(name, type, docgenInfo) {
    let { description, required, defaultValue } = docgenInfo;
    return {
      name,
      type: createType3(type),
      required,
      description,
      defaultValue: createDefaultValue3(defaultValue, type)
    };
  }
  __name(createBasicPropDef, "createBasicPropDef");
  function applyJsDocResult(propDef, jsDocParsingResult) {
    if (jsDocParsingResult?.includesJsDoc) {
      let { description, extractedTags } = jsDocParsingResult;
      description != null && (propDef.description = jsDocParsingResult.description);
      let value2 = {
        ...extractedTags,
        params: extractedTags?.params?.map(
          (x3) => ({
            name: x3.getPrettyName(),
            description: x3.description
          })
        )
      };
      Object.values(value2).filter(Boolean).length > 0 && (propDef.jsDocTags = value2);
    }
    return propDef;
  }
  __name(applyJsDocResult, "applyJsDocResult");
  var javaScriptFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);
    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
  }, "javaScriptFactory"), tsFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createTsPropDef(propName, docgenInfo);
    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
  }, "tsFactory"), flowFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createFlowPropDef(propName, docgenInfo);
    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
  }, "flowFactory"), unknownFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createBasicPropDef(propName, { name: "unknown" }, docgenInfo);
    return applyJsDocResult(propDef, jsDocParsingResult);
  }, "unknownFactory"), getPropDefFactory = __name((typeSystem) => {
    switch (typeSystem) {
      case "JavaScript":
        return javaScriptFactory;
      case "TypeScript":
        return tsFactory;
      case "Flow":
        return flowFactory;
      default:
        return unknownFactory;
    }
  }, "getPropDefFactory"), getTypeSystem = __name((docgenInfo) => docgenInfo.type != null ? "JavaScript" : docgenInfo.flowType != null ? "Flow" : docgenInfo.tsType != null ? "TypeScript" : "Unknown", "getTypeSystem"), extractComponentSectionArray = __name((docgenSection) => {
    let typeSystem = getTypeSystem(docgenSection[0]), createPropDef = getPropDefFactory(typeSystem);
    return docgenSection.map((item) => {
      let sanitizedItem = item;
      return item.type?.elements && (sanitizedItem = {
        ...item,
        type: {
          ...item.type,
          value: item.type.elements
        }
      }), extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);
    });
  }, "extractComponentSectionArray"), extractComponentSectionObject = __name((docgenSection) => {
    let docgenPropsKeys = Object.keys(docgenSection), typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]), createPropDef = getPropDefFactory(typeSystem);
    return docgenPropsKeys.map((propName) => {
      let docgenInfo = docgenSection[propName];
      return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;
    }).filter(Boolean);
  }, "extractComponentSectionObject"), extractComponentProps = __name((component, section) => {
    let docgenSection = getDocgenSection(component, section);
    return isValidDocgenSection(docgenSection) ? Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection) : [];
  }, "extractComponentProps");
  function extractProp(propName, docgenInfo, typeSystem, createPropDef) {
    let jsDocParsingResult = parseJsDoc(docgenInfo.description);
    return jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore ? null : {
      propDef: createPropDef(propName, docgenInfo, jsDocParsingResult),
      jsDocTags: jsDocParsingResult.extractedTags,
      docgenInfo,
      typeSystem
    };
  }
  __name(extractProp, "extractProp");
  function extractComponentDescription(component) {
    return component != null ? getDocgenDescription(component) : "";
  }
  __name(extractComponentDescription, "extractComponentDescription");
  var combineParameters = __name((...parameterSets) => {
    let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value2]) => {
      let existing = acc[key];
      Array.isArray(value2) || typeof existing > "u" ? acc[key] = value2 : isPlainObject(value2) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value2 < "u" && (acc[key] = value2);
    }), acc), {});
    return Object.keys(mergeKeys).forEach((key) => {
      let mergeValues = definedParametersSets.filter(Boolean).map((p4) => p4[key]).filter((value2) => typeof value2 < "u");
      mergeValues.every((value2) => isPlainObject(value2)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
    }), combined;
  }, "combineParameters"), enhanceArgTypes = __name((context) => {
    let {
      component,
      argTypes: userArgTypes,
      parameters: { docs = {} }
    } = context, { extractArgTypes } = docs;
    if (!extractArgTypes || !component)
      return userArgTypes;
    let extractedArgTypes = extractArgTypes(component);
    return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;
  }, "enhanceArgTypes"), ADDON_ID4 = "storybook/docs", PANEL_ID = `${ADDON_ID4}/panel`;
  var SNIPPET_RENDERED = `${ADDON_ID4}/snippet-rendered`, SourceType = ((SourceType2) => (SourceType2.AUTO = "auto", SourceType2.CODE = "code", SourceType2.DYNAMIC = "dynamic", SourceType2))(SourceType || {});

  // node_modules/storybook/dist/_browser-chunks/chunk-ZNRFDIVA.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_AB7OOPUX();
  init_chunk_MM7DTO55();
  function eq(value2, other) {
    return value2 === other || Number.isNaN(value2) && Number.isNaN(other);
  }
  __name(eq, "eq");
  function isEqualWith(a3, b3, areValuesEqual) {
    return isEqualWithImpl(a3, b3, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  __name(isEqualWith, "isEqualWith");
  function isEqualWithImpl(a3, b3, property, aParent, bParent, stack, areValuesEqual) {
    let result = areValuesEqual(a3, b3, property, aParent, bParent, stack);
    if (result !== void 0)
      return result;
    if (typeof a3 == typeof b3)
      switch (typeof a3) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined":
          return a3 === b3;
        case "number":
          return a3 === b3 || Object.is(a3, b3);
        case "function":
          return a3 === b3;
        case "object":
          return areObjectsEqual(a3, b3, stack, areValuesEqual);
      }
    return areObjectsEqual(a3, b3, stack, areValuesEqual);
  }
  __name(isEqualWithImpl, "isEqualWithImpl");
  function areObjectsEqual(a3, b3, stack, areValuesEqual) {
    if (Object.is(a3, b3))
      return !0;
    let aTag = getTag(a3), bTag = getTag(b3);
    if (aTag === argumentsTag && (aTag = objectTag), bTag === argumentsTag && (bTag = objectTag), aTag !== bTag)
      return !1;
    switch (aTag) {
      case stringTag:
        return a3.toString() === b3.toString();
      case numberTag: {
        let x3 = a3.valueOf(), y3 = b3.valueOf();
        return eq(x3, y3);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a3.valueOf(), b3.valueOf());
      case regexpTag:
        return a3.source === b3.source && a3.flags === b3.flags;
      case functionTag:
        return a3 === b3;
    }
    stack = stack ?? /* @__PURE__ */ new Map();
    let aStack = stack.get(a3), bStack = stack.get(b3);
    if (aStack != null && bStack != null)
      return aStack === b3;
    stack.set(a3, b3), stack.set(b3, a3);
    try {
      switch (aTag) {
        case mapTag: {
          if (a3.size !== b3.size)
            return !1;
          for (let [key, value2] of a3.entries())
            if (!b3.has(key) || !isEqualWithImpl(value2, b3.get(key), key, a3, b3, stack, areValuesEqual))
              return !1;
          return !0;
        }
        case setTag: {
          if (a3.size !== b3.size)
            return !1;
          let aValues = Array.from(a3.values()), bValues = Array.from(b3.values());
          for (let i3 = 0; i3 < aValues.length; i3++) {
            let aValue = aValues[i3], index3 = bValues.findIndex((bValue) => isEqualWithImpl(aValue, bValue, void 0, a3, b3, stack, areValuesEqual));
            if (index3 === -1)
              return !1;
            bValues.splice(index3, 1);
          }
          return !0;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer < "u" && Buffer.isBuffer(a3) !== Buffer.isBuffer(b3) || a3.length !== b3.length)
            return !1;
          for (let i3 = 0; i3 < a3.length; i3++)
            if (!isEqualWithImpl(a3[i3], b3[i3], i3, a3, b3, stack, areValuesEqual))
              return !1;
          return !0;
        }
        case arrayBufferTag:
          return a3.byteLength !== b3.byteLength ? !1 : areObjectsEqual(new Uint8Array(a3), new Uint8Array(b3), stack, areValuesEqual);
        case dataViewTag:
          return a3.byteLength !== b3.byteLength || a3.byteOffset !== b3.byteOffset ? !1 : areObjectsEqual(new Uint8Array(a3), new Uint8Array(b3), stack, areValuesEqual);
        case errorTag:
          return a3.name === b3.name && a3.message === b3.message;
        case objectTag: {
          if (!(areObjectsEqual(a3.constructor, b3.constructor, stack, areValuesEqual) || isPlainObject(a3) && isPlainObject(b3)))
            return !1;
          let aKeys = [...Object.keys(a3), ...getSymbols(a3)], bKeys = [...Object.keys(b3), ...getSymbols(b3)];
          if (aKeys.length !== bKeys.length)
            return !1;
          for (let i3 = 0; i3 < aKeys.length; i3++) {
            let propKey = aKeys[i3], aProp = a3[propKey];
            if (!Object.hasOwn(b3, propKey))
              return !1;
            let bProp = b3[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a3, b3, stack, areValuesEqual))
              return !1;
          }
          return !0;
        }
        default:
          return !1;
      }
    } finally {
      stack.delete(a3), stack.delete(b3);
    }
  }
  __name(areObjectsEqual, "areObjectsEqual");
  function isEqual(a3, b3) {
    return isEqualWith(a3, b3, noop3);
  }
  __name(isEqual, "isEqual");

  // node_modules/storybook/dist/_browser-chunks/chunk-FUOHXXZT.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var isProduction = !1, prefix = "Invariant failed";
  function invariant(condition, message) {
    if (!condition) {
      if (isProduction)
        throw new Error(prefix);
      var provided = typeof message == "function" ? message() : message, value2 = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value2);
    }
  }
  __name(invariant, "invariant");

  // node_modules/storybook/dist/_browser-chunks/chunk-F4Q6SGTB.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var require_entities = __commonJS2({
    "../node_modules/entities/lib/maps/entities.json"(exports, module) {
      module.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
    }
  }), require_legacy = __commonJS2({
    "../node_modules/entities/lib/maps/legacy.json"(exports, module) {
      module.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
    }
  }), require_xml = __commonJS2({
    "../node_modules/entities/lib/maps/xml.json"(exports, module) {
      module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
    }
  }), require_decode = __commonJS2({
    "../node_modules/entities/lib/maps/decode.json"(exports, module) {
      module.exports = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
    }
  }), require_decode_codepoint = __commonJS2({
    "../node_modules/entities/lib/decode_codepoint.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 });
      var decode_json_1 = __importDefault(require_decode()), fromCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.fromCodePoint || function(codePoint) {
          var output = "";
          return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
        }
      );
      function decodeCodePoint(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "\uFFFD" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
      }
      __name(decodeCodePoint, "decodeCodePoint"), exports.default = decodeCodePoint;
    }
  }), require_decode2 = __commonJS2({
    "../node_modules/entities/lib/decode.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
      var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      exports.decodeXML = getStrictDecoder(xml_json_1.default), exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
      function getStrictDecoder(map2) {
        var replace = getReplacer(map2);
        return function(str2) {
          return String(str2).replace(strictEntityRe, replace);
        };
      }
      __name(getStrictDecoder, "getStrictDecoder");
      var sorter = __name(function(a3, b3) {
        return a3 < b3 ? 1 : -1;
      }, "sorter");
      exports.decodeHTML = (function() {
        for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i3 = 0, j2 = 0; i3 < keys.length; i3++)
          legacy[j2] === keys[i3] ? (keys[i3] += ";?", j2++) : keys[i3] += ";";
        var re3 = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
        function replacer(str2) {
          return str2.substr(-1) !== ";" && (str2 += ";"), replace(str2);
        }
        return __name(replacer, "replacer"), function(str2) {
          return String(str2).replace(re3, replacer);
        };
      })();
      function getReplacer(map2) {
        return __name(function(str2) {
          if (str2.charAt(1) === "#") {
            var secondChar = str2.charAt(2);
            return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str2.substr(3), 16)) : decode_codepoint_1.default(parseInt(str2.substr(2), 10));
          }
          return map2[str2.slice(1, -1)] || str2;
        }, "replace");
      }
      __name(getReplacer, "getReplacer");
    }
  }), require_encode = __commonJS2({
    "../node_modules/entities/lib/encode.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
      var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
      exports.encodeXML = getASCIIEncoder(inverseXML);
      var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
      exports.encodeHTML = getInverse(inverseHTML, htmlReplacer), exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
      function getInverseObj(obj) {
        return Object.keys(obj).sort().reduce(function(inverse, name) {
          return inverse[obj[name]] = "&" + name + ";", inverse;
        }, {});
      }
      __name(getInverseObj, "getInverseObj");
      function getInverseReplacer(inverse) {
        for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
          var k3 = _a[_i];
          k3.length === 1 ? single.push("\\" + k3) : multiple.push(k3);
        }
        single.sort();
        for (var start2 = 0; start2 < single.length - 1; start2++) {
          for (var end2 = start2; end2 < single.length - 1 && single[end2].charCodeAt(1) + 1 === single[end2 + 1].charCodeAt(1); )
            end2 += 1;
          var count3 = 1 + end2 - start2;
          count3 < 3 || single.splice(start2, count3, single[start2] + "-" + single[end2]);
        }
        return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
      }
      __name(getInverseReplacer, "getInverseReplacer");
      var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.prototype.codePointAt != null ? (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          (function(str2) {
            return str2.codePointAt(0);
          })
        ) : (
          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          (function(c3) {
            return (c3.charCodeAt(0) - 55296) * 1024 + c3.charCodeAt(1) - 56320 + 65536;
          })
        )
      );
      function singleCharReplacer(c3) {
        return "&#x" + (c3.length > 1 ? getCodePoint(c3) : c3.charCodeAt(0)).toString(16).toUpperCase() + ";";
      }
      __name(singleCharReplacer, "singleCharReplacer");
      function getInverse(inverse, re3) {
        return function(data) {
          return data.replace(re3, function(name) {
            return inverse[name];
          }).replace(reNonASCII, singleCharReplacer);
        };
      }
      __name(getInverse, "getInverse");
      var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
      function escape2(data) {
        return data.replace(reEscapeChars, singleCharReplacer);
      }
      __name(escape2, "escape"), exports.escape = escape2;
      function escapeUTF8(data) {
        return data.replace(xmlReplacer, singleCharReplacer);
      }
      __name(escapeUTF8, "escapeUTF8"), exports.escapeUTF8 = escapeUTF8;
      function getASCIIEncoder(obj) {
        return function(data) {
          return data.replace(reEscapeChars, function(c3) {
            return obj[c3] || singleCharReplacer(c3);
          });
        };
      }
      __name(getASCIIEncoder, "getASCIIEncoder");
    }
  }), require_lib = __commonJS2({
    "../node_modules/entities/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
      var decode_1 = require_decode2(), encode_1 = require_encode();
      function decode(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
      }
      __name(decode, "decode"), exports.decode = decode;
      function decodeStrict(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
      }
      __name(decodeStrict, "decodeStrict"), exports.decodeStrict = decodeStrict;
      function encode(data, level) {
        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
      }
      __name(encode, "encode"), exports.encode = encode;
      var encode_2 = require_encode();
      Object.defineProperty(exports, "encodeXML", { enumerable: !0, get: __name(function() {
        return encode_2.encodeXML;
      }, "get") }), Object.defineProperty(exports, "encodeHTML", { enumerable: !0, get: __name(function() {
        return encode_2.encodeHTML;
      }, "get") }), Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: !0, get: __name(function() {
        return encode_2.encodeNonAsciiHTML;
      }, "get") }), Object.defineProperty(exports, "escape", { enumerable: !0, get: __name(function() {
        return encode_2.escape;
      }, "get") }), Object.defineProperty(exports, "escapeUTF8", { enumerable: !0, get: __name(function() {
        return encode_2.escapeUTF8;
      }, "get") }), Object.defineProperty(exports, "encodeHTML4", { enumerable: !0, get: __name(function() {
        return encode_2.encodeHTML;
      }, "get") }), Object.defineProperty(exports, "encodeHTML5", { enumerable: !0, get: __name(function() {
        return encode_2.encodeHTML;
      }, "get") });
      var decode_2 = require_decode2();
      Object.defineProperty(exports, "decodeXML", { enumerable: !0, get: __name(function() {
        return decode_2.decodeXML;
      }, "get") }), Object.defineProperty(exports, "decodeHTML", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTML;
      }, "get") }), Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTMLStrict;
      }, "get") }), Object.defineProperty(exports, "decodeHTML4", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTML;
      }, "get") }), Object.defineProperty(exports, "decodeHTML5", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTML;
      }, "get") }), Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTMLStrict;
      }, "get") }), Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTMLStrict;
      }, "get") }), Object.defineProperty(exports, "decodeXMLStrict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeXML;
      }, "get") });
    }
  }), require_ansi_to_html = __commonJS2({
    "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor))
          throw new TypeError("Cannot call a class as a function");
      }
      __name(_classCallCheck, "_classCallCheck");
      function _defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      __name(_defineProperties, "_defineProperties");
      function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
      }
      __name(_createClass, "_createClass");
      function _createForOfIteratorHelper(o2, allowArrayLike) {
        var it = typeof Symbol < "u" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length == "number") {
            it && (o2 = it);
            var i3 = 0, F3 = __name(function() {
            }, "F");
            return { s: F3, n: __name(function() {
              return i3 >= o2.length ? { done: !0 } : { done: !1, value: o2[i3++] };
            }, "n"), e: __name(function(_e2) {
              throw _e2;
            }, "e"), f: F3 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var normalCompletion = !0, didErr = !1, err;
        return { s: __name(function() {
          it = it.call(o2);
        }, "s"), n: __name(function() {
          var step2 = it.next();
          return normalCompletion = step2.done, step2;
        }, "n"), e: __name(function(_e2) {
          didErr = !0, err = _e2;
        }, "e"), f: __name(function() {
          try {
            !normalCompletion && it.return != null && it.return();
          } finally {
            if (didErr) throw err;
          }
        }, "f") };
      }
      __name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
      function _unsupportedIterableToArray2(o2, minLen) {
        if (o2) {
          if (typeof o2 == "string") return _arrayLikeToArray2(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set") return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray2(o2, minLen);
        }
      }
      __name(_unsupportedIterableToArray2, "_unsupportedIterableToArray");
      function _arrayLikeToArray2(arr, len) {
        (len == null || len > arr.length) && (len = arr.length);
        for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
          arr2[i3] = arr[i3];
        return arr2;
      }
      __name(_arrayLikeToArray2, "_arrayLikeToArray");
      var entities = require_lib(), defaults = {
        fg: "#FFF",
        bg: "#000",
        newline: !1,
        escapeXML: !1,
        stream: !1,
        colors: getDefaultColors()
      };
      function getDefaultColors() {
        var colors3 = {
          0: "#000",
          1: "#A00",
          2: "#0A0",
          3: "#A50",
          4: "#00A",
          5: "#A0A",
          6: "#0AA",
          7: "#AAA",
          8: "#555",
          9: "#F55",
          10: "#5F5",
          11: "#FF5",
          12: "#55F",
          13: "#F5F",
          14: "#5FF",
          15: "#FFF"
        };
        return range(0, 5).forEach(function(red) {
          range(0, 5).forEach(function(green) {
            range(0, 5).forEach(function(blue) {
              return setStyleColor(red, green, blue, colors3);
            });
          });
        }), range(0, 23).forEach(function(gray) {
          var c3 = gray + 232, l2 = toHexString(gray * 10 + 8);
          colors3[c3] = "#" + l2 + l2 + l2;
        }), colors3;
      }
      __name(getDefaultColors, "getDefaultColors");
      function setStyleColor(red, green, blue, colors3) {
        var c3 = 16 + red * 36 + green * 6 + blue, r2 = red > 0 ? red * 40 + 55 : 0, g3 = green > 0 ? green * 40 + 55 : 0, b3 = blue > 0 ? blue * 40 + 55 : 0;
        colors3[c3] = toColorHexString([r2, g3, b3]);
      }
      __name(setStyleColor, "setStyleColor");
      function toHexString(num) {
        for (var str2 = num.toString(16); str2.length < 2; )
          str2 = "0" + str2;
        return str2;
      }
      __name(toHexString, "toHexString");
      function toColorHexString(ref) {
        var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var r2 = _step.value;
            results.push(toHexString(r2));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return "#" + results.join("");
      }
      __name(toColorHexString, "toColorHexString");
      function generateOutput(stack, token, data, options2) {
        var result;
        return token === "text" ? result = pushText(data, options2) : token === "display" ? result = handleDisplay(stack, data, options2) : token === "xterm256Foreground" ? result = pushForegroundColor(stack, options2.colors[data]) : token === "xterm256Background" ? result = pushBackgroundColor(stack, options2.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
      }
      __name(generateOutput, "generateOutput");
      function handleRgb(stack, data) {
        data = data.substring(2).slice(0, -1);
        var operation = +data.substr(0, 2), color2 = data.substring(5).split(";"), rgb2 = color2.map(function(value2) {
          return ("0" + Number(value2).toString(16)).substr(-2);
        }).join("");
        return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb2);
      }
      __name(handleRgb, "handleRgb");
      function handleDisplay(stack, code, options2) {
        code = parseInt(code, 10);
        var codeMap = {
          "-1": __name(function() {
            return "<br/>";
          }, "_"),
          0: __name(function() {
            return stack.length && resetStyles(stack);
          }, "_"),
          1: __name(function() {
            return pushTag(stack, "b");
          }, "_"),
          3: __name(function() {
            return pushTag(stack, "i");
          }, "_"),
          4: __name(function() {
            return pushTag(stack, "u");
          }, "_"),
          8: __name(function() {
            return pushStyle(stack, "display:none");
          }, "_"),
          9: __name(function() {
            return pushTag(stack, "strike");
          }, "_"),
          22: __name(function() {
            return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
          }, "_"),
          23: __name(function() {
            return closeTag(stack, "i");
          }, "_"),
          24: __name(function() {
            return closeTag(stack, "u");
          }, "_"),
          39: __name(function() {
            return pushForegroundColor(stack, options2.fg);
          }, "_"),
          49: __name(function() {
            return pushBackgroundColor(stack, options2.bg);
          }, "_"),
          53: __name(function() {
            return pushStyle(stack, "text-decoration:overline");
          }, "_")
        }, result;
        return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options2.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options2.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options2.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options2.colors[8 + (code - 100)])), result;
      }
      __name(handleDisplay, "handleDisplay");
      function resetStyles(stack) {
        var stackClone = stack.slice(0);
        return stack.length = 0, stackClone.reverse().map(function(tag) {
          return "</" + tag + ">";
        }).join("");
      }
      __name(resetStyles, "resetStyles");
      function range(low, high) {
        for (var results = [], j2 = low; j2 <= high; j2++)
          results.push(j2);
        return results;
      }
      __name(range, "range");
      function notCategory(category) {
        return function(e) {
          return (category === null || e.category !== category) && category !== "all";
        };
      }
      __name(notCategory, "notCategory");
      function categoryForCode(code) {
        code = parseInt(code, 10);
        var result = null;
        return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
      }
      __name(categoryForCode, "categoryForCode");
      function pushText(text, options2) {
        return options2.escapeXML ? entities.encodeXML(text) : text;
      }
      __name(pushText, "pushText");
      function pushTag(stack, tag, style) {
        return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
      }
      __name(pushTag, "pushTag");
      function pushStyle(stack, style) {
        return pushTag(stack, "span", style);
      }
      __name(pushStyle, "pushStyle");
      function pushForegroundColor(stack, color2) {
        return pushTag(stack, "span", "color:" + color2);
      }
      __name(pushForegroundColor, "pushForegroundColor");
      function pushBackgroundColor(stack, color2) {
        return pushTag(stack, "span", "background-color:" + color2);
      }
      __name(pushBackgroundColor, "pushBackgroundColor");
      function closeTag(stack, style) {
        var last;
        if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
          return "</" + style + ">";
      }
      __name(closeTag, "closeTag");
      function tokenize(text, options2, callback) {
        var ansiMatch = !1, ansiHandler = 3;
        function remove() {
          return "";
        }
        __name(remove, "remove");
        function removeXterm256Foreground(m3, g1) {
          return callback("xterm256Foreground", g1), "";
        }
        __name(removeXterm256Foreground, "removeXterm256Foreground");
        function removeXterm256Background(m3, g1) {
          return callback("xterm256Background", g1), "";
        }
        __name(removeXterm256Background, "removeXterm256Background");
        function newline(m3) {
          return options2.newline ? callback("display", -1) : callback("text", m3), "";
        }
        __name(newline, "newline");
        function ansiMess(m3, g1) {
          ansiMatch = !0, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
          var _iterator2 = _createForOfIteratorHelper(g1), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var g3 = _step2.value;
              callback("display", g3);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return "";
        }
        __name(ansiMess, "ansiMess");
        function realText(m3) {
          return callback("text", m3), "";
        }
        __name(realText, "realText");
        function rgb2(m3) {
          return callback("rgb", m3), "";
        }
        __name(rgb2, "rgb");
        var tokens = [{
          pattern: /^\x08+/,
          sub: remove
        }, {
          pattern: /^\x1b\[[012]?K/,
          sub: remove
        }, {
          pattern: /^\x1b\[\(B/,
          sub: remove
        }, {
          pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
          sub: rgb2
        }, {
          pattern: /^\x1b\[38;5;(\d+)m/,
          sub: removeXterm256Foreground
        }, {
          pattern: /^\x1b\[48;5;(\d+)m/,
          sub: removeXterm256Background
        }, {
          pattern: /^\n/,
          sub: newline
        }, {
          pattern: /^\r+\n/,
          sub: newline
        }, {
          pattern: /^\r/,
          sub: newline
        }, {
          pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
          sub: ansiMess
        }, {
          // CSI n J
          // ED - Erase in Display Clears part of the screen.
          // If n is 0 (or missing), clear from cursor to end of screen.
          // If n is 1, clear from cursor to beginning of the screen.
          // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
          // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
          //   (this feature was added for xterm and is supported by other terminal applications).
          pattern: /^\x1b\[\d?J/,
          sub: remove
        }, {
          // CSI n ; m f
          // HVP - Horizontal Vertical Position Same as CUP
          pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
          sub: remove
        }, {
          // catch-all for CSI sequences?
          pattern: /^\x1b\[?[\d;]{0,3}/,
          sub: remove
        }, {
          /**
           * extracts real text - not containing:
           * - `\x1b' - ESC - escape (Ascii 27)
           * - '\x08' - BS - backspace (Ascii 8)
           * - `\n` - Newline - linefeed (LF) (ascii 10)
           * - `\r` - Windows Carriage Return (CR)
           */
          pattern: /^(([^\x1b\x08\r\n])+)/,
          sub: realText
        }];
        function process2(handler2, i22) {
          i22 > ansiHandler && ansiMatch || (ansiMatch = !1, text = text.replace(handler2.pattern, handler2.sub));
        }
        __name(process2, "process");
        var results1 = [], _text = text, length2 = _text.length;
        outer: for (; length2 > 0; ) {
          for (var i3 = 0, o2 = 0, len = tokens.length; o2 < len; i3 = ++o2) {
            var handler = tokens[i3];
            if (process2(handler, i3), text.length !== length2) {
              length2 = text.length;
              continue outer;
            }
          }
          if (text.length === length2)
            break;
          results1.push(0), length2 = text.length;
        }
        return results1;
      }
      __name(tokenize, "tokenize");
      function updateStickyStack(stickyStack, token, data) {
        return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({
          token,
          data,
          category: categoryForCode(data)
        })), stickyStack;
      }
      __name(updateStickyStack, "updateStickyStack");
      var Filter = (function() {
        function Filter2(options2) {
          _classCallCheck(this, Filter2), options2 = options2 || {}, options2.colors && (options2.colors = Object.assign({}, defaults.colors, options2.colors)), this.options = Object.assign({}, defaults, options2), this.stack = [], this.stickyStack = [];
        }
        return __name(Filter2, "Filter"), _createClass(Filter2, [{
          key: "toHtml",
          value: __name(function(input) {
            var _this = this;
            input = typeof input == "string" ? [input] : input;
            var stack = this.stack, options2 = this.options, buf = [];
            return this.stickyStack.forEach(function(element) {
              var output = generateOutput(stack, element.token, element.data, options2);
              output && buf.push(output);
            }), tokenize(input.join(""), options2, function(token, data) {
              var output = generateOutput(stack, token, data, options2);
              output && buf.push(output), options2.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
            }), stack.length && buf.push(resetStyles(stack)), buf.join("");
          }, "toHtml")
        }]), Filter2;
      })();
      module.exports = Filter;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-W4QKLQSC.js
  init_chunk_NVV6MIOE();
  init_chunk_OPCDBBL3();
  init_chunk_MM7DTO55();
  init_dist();

  // global-externals:storybook/internal/channels
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var channels_default = __STORYBOOK_CHANNELS__, { Channel, HEARTBEAT_INTERVAL, HEARTBEAT_MAX_LATENCY, PostMessageTransport, WebsocketTransport, createBrowserChannel } = __STORYBOOK_CHANNELS__;

  // node_modules/storybook/dist/_browser-chunks/chunk-W4QKLQSC.js
  init_client_logger();

  // global-externals:storybook/internal/core-events
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var core_events_default = __STORYBOOK_CORE_EVENTS__, { ARGTYPES_INFO_REQUEST, ARGTYPES_INFO_RESPONSE, CHANNEL_CREATED, CHANNEL_WS_DISCONNECT, CONFIG_ERROR, CREATE_NEW_STORYFILE_REQUEST, CREATE_NEW_STORYFILE_RESPONSE, CURRENT_STORY_WAS_SET, DOCS_PREPARED, DOCS_RENDERED, FILE_COMPONENT_SEARCH_REQUEST, FILE_COMPONENT_SEARCH_RESPONSE, FORCE_REMOUNT, FORCE_RE_RENDER, GLOBALS_UPDATED, NAVIGATE_URL, OPEN_IN_EDITOR_REQUEST, OPEN_IN_EDITOR_RESPONSE, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_INITIALIZED, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, REQUEST_WHATS_NEW_DATA, RESET_STORY_ARGS, RESULT_WHATS_NEW_DATA, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_FILTER, SET_GLOBALS, SET_INDEX, SET_STORIES, SET_WHATS_NEW_CACHE, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_FINISHED, STORY_HOT_UPDATED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDERED, STORY_RENDER_PHASE_CHANGED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, TELEMETRY_ERROR, TOGGLE_WHATS_NEW_NOTIFICATIONS, UNHANDLED_ERRORS_WHILE_PLAYING, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = __STORYBOOK_CORE_EVENTS__;

  // node_modules/storybook/dist/_browser-chunks/chunk-W4QKLQSC.js
  init_dist();
  init_client_logger();
  init_client_logger();
  init_client_logger();
  init_client_logger();
  init_dist();
  init_dist();
  init_client_logger();
  init_client_logger();
  init_dist();
  init_client_logger();
  init_client_logger();
  init_dist();
  init_dist();
  init_client_logger();
  init_dist();
  init_client_logger();
  init_client_logger();
  init_dist();
  init_dist();
  function mockChannel() {
    let transport = {
      setHandler: __name(() => {
      }, "setHandler"),
      send: __name(() => {
      }, "send")
    };
    return new Channel({ transport });
  }
  __name(mockChannel, "mockChannel");
  var _AddonStore = class {
    constructor() {
      this.getChannel = __name(() => {
        if (!this.channel) {
          let channel = mockChannel();
          return this.setChannel(channel), channel;
        }
        return this.channel;
      }, "getChannel"), this.ready = __name(() => this.promise, "ready"), this.hasChannel = __name(() => !!this.channel, "hasChannel"), this.setChannel = __name((channel) => {
        this.channel = channel, this.resolve();
      }, "setChannel"), this.promise = new Promise((res) => {
        this.resolve = () => res(this.getChannel());
      });
    }
  };
  __name(_AddonStore, "AddonStore");
  var AddonStore = _AddonStore, KEY = "__STORYBOOK_ADDONS_PREVIEW";
  function getAddonsStore() {
    return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];
  }
  __name(getAddonsStore, "getAddonsStore");
  var addons = getAddonsStore(), _HooksContext = class {
    constructor() {
      this.hookListsMap = void 0, this.mountedDecorators = void 0, this.prevMountedDecorators = void 0, this.currentHooks = void 0, this.nextHookIndex = void 0, this.currentPhase = void 0, this.currentEffects = void 0, this.prevEffects = void 0, this.currentDecoratorName = void 0, this.hasUpdates = void 0, this.currentContext = void 0, this.renderListener = __name((storyId) => {
        storyId === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
      }, "renderListener"), this.init();
    }
    init() {
      this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;
    }
    clean() {
      this.prevEffects.forEach((effect4) => {
        effect4.destroy && effect4.destroy();
      }), this.init(), this.removeRenderListeners();
    }
    getNextHook() {
      let hook = this.currentHooks[this.nextHookIndex];
      return this.nextHookIndex += 1, hook;
    }
    triggerEffects() {
      this.prevEffects.forEach((effect4) => {
        !this.currentEffects.includes(effect4) && effect4.destroy && effect4.destroy();
      }), this.currentEffects.forEach((effect4) => {
        this.prevEffects.includes(effect4) || (effect4.destroy = effect4.create());
      }), this.prevEffects = this.currentEffects, this.currentEffects = [];
    }
    addRenderListeners() {
      this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);
    }
    removeRenderListeners() {
      addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);
    }
  };
  __name(_HooksContext, "HooksContext");
  var HooksContext = _HooksContext;
  function hookify(fn3) {
    let hookified = __name((...args) => {
      let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
      hooks.currentDecoratorName = fn3.name, hooks.prevMountedDecorators.has(fn3) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn3) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn3, hooks.currentHooks), hooks.prevMountedDecorators.add(fn3)), hooks.nextHookIndex = 0;
      let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
      scope.STORYBOOK_HOOKS_CONTEXT = hooks;
      let result = fn3(...args);
      if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
        throw new Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
    }, "hookified");
    return hookified.originalFn = fn3, hookified;
  }
  __name(hookify, "hookify");
  var numberOfRenders = 0, RENDER_LIMIT = 25, applyHooks = __name((applyDecorators) => (storyFn, decorators4) => {
    let decorated = applyDecorators(
      hookify(storyFn),
      decorators4.map((decorator) => hookify(decorator))
    );
    return (context) => {
      let { hooks } = context;
      hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set(), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]), hooks.currentContext = context, hooks.hasUpdates = !1;
      let result = decorated(context);
      for (numberOfRenders = 1; hooks.hasUpdates; )
        if (hooks.hasUpdates = !1, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
          throw new Error(
            "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
          );
      return hooks.addRenderListeners(), result;
    };
  }, "applyHooks"), areDepsEqual = __name((deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i3) => dep === nextDeps[i3]), "areDepsEqual"), invalidHooksError = __name(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
  function getHooksContextOrNull() {
    return scope.STORYBOOK_HOOKS_CONTEXT || null;
  }
  __name(getHooksContextOrNull, "getHooksContextOrNull");
  function getHooksContextOrThrow() {
    let hooks = getHooksContextOrNull();
    if (hooks == null)
      throw invalidHooksError();
    return hooks;
  }
  __name(getHooksContextOrThrow, "getHooksContextOrThrow");
  function useHook(name, callback, deps) {
    let hooks = getHooksContextOrThrow();
    if (hooks.currentPhase === "MOUNT") {
      deps != null && !Array.isArray(deps) && logger.warn(
        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
      );
      let hook = { name, deps };
      return hooks.currentHooks.push(hook), callback(hook), hook;
    }
    if (hooks.currentPhase === "UPDATE") {
      let hook = hooks.getNextHook();
      if (hook == null)
        throw new Error("Rendered more hooks than during the previous render.");
      return hook.name !== name && logger.warn(
        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
      ), deps != null && hook.deps == null && logger.warn(
        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
      ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;
    }
    throw invalidHooksError();
  }
  __name(useHook, "useHook");
  function useMemoLike(name, nextCreate, deps) {
    let { memoizedState } = useHook(
      name,
      (hook) => {
        hook.memoizedState = nextCreate();
      },
      deps
    );
    return memoizedState;
  }
  __name(useMemoLike, "useMemoLike");
  function useMemo2(nextCreate, deps) {
    return useMemoLike("useMemo", nextCreate, deps);
  }
  __name(useMemo2, "useMemo");
  function useCallback2(callback, deps) {
    return useMemoLike("useCallback", () => callback, deps);
  }
  __name(useCallback2, "useCallback");
  function useRefLike(name, initialValue) {
    return useMemoLike(name, () => ({ current: initialValue }), []);
  }
  __name(useRefLike, "useRefLike");
  function useRef2(initialValue) {
    return useRefLike("useRef", initialValue);
  }
  __name(useRef2, "useRef");
  function triggerUpdate() {
    let hooks = getHooksContextOrNull();
    if (hooks != null && hooks.currentPhase !== "NONE")
      hooks.hasUpdates = !0;
    else
      try {
        addons.getChannel().emit(FORCE_RE_RENDER);
      } catch {
        logger.warn("State updates of Storybook preview hooks work only in browser");
      }
  }
  __name(triggerUpdate, "triggerUpdate");
  function useStateLike(name, initialState) {
    let stateRef = useRefLike(
      name,
      // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
      typeof initialState == "function" ? initialState() : initialState
    ), setState = __name((update) => {
      stateRef.current = typeof update == "function" ? update(stateRef.current) : update, triggerUpdate();
    }, "setState");
    return [stateRef.current, setState];
  }
  __name(useStateLike, "useStateLike");
  function useState2(initialState) {
    return useStateLike("useState", initialState);
  }
  __name(useState2, "useState");
  function useReducer2(reducer, initialArg, init2) {
    let initialState = init2 != null ? () => init2(initialArg) : initialArg, [state3, setState] = useStateLike("useReducer", initialState), dispatch = __name((action2) => setState((prevState) => reducer(prevState, action2)), "dispatch");
    return [state3, dispatch];
  }
  __name(useReducer2, "useReducer");
  function useEffect2(create2, deps) {
    let hooks = getHooksContextOrThrow(), effect4 = useMemoLike("useEffect", () => ({ create: create2 }), deps);
    hooks.currentEffects.includes(effect4) || hooks.currentEffects.push(effect4);
  }
  __name(useEffect2, "useEffect");
  function useChannel(eventMap, deps = []) {
    let channel = addons.getChannel();
    return useEffect2(() => (Object.entries(eventMap).forEach(([type, listener]) => channel.on(type, listener)), () => {
      Object.entries(eventMap).forEach(
        ([type, listener]) => channel.removeListener(type, listener)
      );
    }), [...Object.keys(eventMap), ...deps]), useCallback2(channel.emit.bind(channel), [channel]);
  }
  __name(useChannel, "useChannel");
  function useStoryContext() {
    let { currentContext } = getHooksContextOrThrow();
    if (currentContext == null)
      throw invalidHooksError();
    return currentContext;
  }
  __name(useStoryContext, "useStoryContext");
  function useParameter(parameterKey, defaultValue) {
    let { parameters: parameters2 } = useStoryContext();
    if (parameterKey)
      return parameters2[parameterKey] ?? defaultValue;
  }
  __name(useParameter, "useParameter");
  function useArgs() {
    let channel = addons.getChannel(), { id: storyId, args } = useStoryContext(), updateArgs = useCallback2(
      (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),
      [channel, storyId]
    ), resetArgs = useCallback2(
      (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),
      [channel, storyId]
    );
    return [args, updateArgs, resetArgs];
  }
  __name(useArgs, "useArgs");
  function useGlobals() {
    let channel = addons.getChannel(), { globals } = useStoryContext(), updateGlobals = useCallback2(
      (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),
      [channel]
    );
    return [globals, updateGlobals];
  }
  __name(useGlobals, "useGlobals");
  var makeDecorator = __name(({
    name,
    parameterName,
    wrapper,
    skipIfNoParametersOrOptions = !1
  }) => {
    let decorator = __name((options2) => (storyFn, context) => {
      let parameters2 = context.parameters && context.parameters[parameterName];
      return parameters2 && parameters2.disable || skipIfNoParametersOrOptions && !options2 && !parameters2 ? storyFn(context) : wrapper(storyFn, context, {
        options: options2,
        parameters: parameters2
      });
    }, "decorator");
    return (...args) => typeof args[0] == "function" ? decorator()(...args) : (...innerArgs) => {
      if (innerArgs.length > 1)
        return args.length > 1 ? decorator(args)(...innerArgs) : decorator(...args)(...innerArgs);
      throw new Error(
        `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
      );
    };
  }, "makeDecorator"), import_memoizerific2 = __toESM2(require_memoizerific(), 1), INCOMPATIBLE = Symbol("incompatible"), map = __name((arg, argType) => {
    let type = argType.type;
    if (arg == null || !type || argType.mapping)
      return arg;
    switch (type.name) {
      case "string":
        return String(arg);
      case "enum":
        return arg;
      case "number":
        return Number(arg);
      case "boolean":
        return String(arg) === "true";
      case "array":
        return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index3) => {
          let mapped = map(item, { type: type.value });
          return mapped !== INCOMPATIBLE && (acc[index3] = mapped), acc;
        }, new Array(arg.length));
      case "object":
        return typeof arg == "string" || typeof arg == "number" ? arg : !type.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
          let mapped = map(val, { type: type.value[key] });
          return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
        }, {});
      case "other": {
        let isPrimitiveArg = typeof arg == "string" || typeof arg == "number" || typeof arg == "boolean";
        return type.value === "ReactNode" && isPrimitiveArg ? arg : INCOMPATIBLE;
      }
      default:
        return INCOMPATIBLE;
    }
  }, "map"), mapArgsToTypes = __name((args, argTypes) => Object.entries(args).reduce((acc, [key, value2]) => {
    if (!argTypes[key])
      return acc;
    let mapped = map(value2, argTypes[key]);
    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
  }, {}), "mapArgsToTypes"), combineArgs = __name((value2, update) => Array.isArray(value2) && Array.isArray(update) ? update.reduce(
    (acc, upd, index3) => (acc[index3] = combineArgs(value2[index3], update[index3]), acc),
    [...value2]
  ).filter((v3) => v3 !== void 0) : !isPlainObject(value2) || !isPlainObject(update) ? update : Object.keys({ ...value2, ...update }).reduce((acc, key) => {
    if (key in update) {
      let combined = combineArgs(value2[key], update[key]);
      combined !== void 0 && (acc[key] = combined);
    } else
      acc[key] = value2[key];
    return acc;
  }, {}), "combineArgs"), validateOptions = __name((args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options: options2 }]) => {
    function allowArg() {
      return key in args && (acc[key] = args[key]), acc;
    }
    if (__name(allowArg, "allowArg"), !options2)
      return allowArg();
    if (!Array.isArray(options2))
      return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), allowArg();
    if (options2.some((opt) => opt && ["object", "function"].includes(typeof opt)))
      return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), allowArg();
    let isArray2 = Array.isArray(args[key]), invalidIndex = isArray2 && args[key].findIndex((val) => !options2.includes(val)), isValidArray = isArray2 && invalidIndex === -1;
    if (args[key] === void 0 || options2.includes(args[key]) || isValidArray)
      return allowArg();
    let field = isArray2 ? `${key}[${invalidIndex}]` : key, supportedOptions = options2.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
    return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
  }, {}), "validateOptions"), DEEPLY_EQUAL = Symbol("Deeply equal"), deepDiff = __name((value2, update) => {
    if (typeof value2 != typeof update)
      return update;
    if (isEqual(value2, update))
      return DEEPLY_EQUAL;
    if (Array.isArray(value2) && Array.isArray(update)) {
      let res = update.reduce((acc, upd, index3) => {
        let diff2 = deepDiff(value2[index3], upd);
        return diff2 !== DEEPLY_EQUAL && (acc[index3] = diff2), acc;
      }, new Array(update.length));
      return update.length >= value2.length ? res : res.concat(new Array(value2.length - update.length).fill(void 0));
    }
    return isPlainObject(value2) && isPlainObject(update) ? Object.keys({ ...value2, ...update }).reduce((acc, key) => {
      let diff2 = deepDiff(value2?.[key], update?.[key]);
      return diff2 === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff2 });
    }, {}) : update;
  }, "deepDiff"), UNTARGETED = "UNTARGETED";
  function groupArgsByTarget({
    args,
    argTypes
  }) {
    let groupedArgs = {};
    return Object.entries(args).forEach(([name, value2]) => {
      let { target = UNTARGETED } = argTypes[name] || {};
      groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value2;
    }), groupedArgs;
  }
  __name(groupArgsByTarget, "groupArgsByTarget");
  function deleteUndefined(obj) {
    return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
  }
  __name(deleteUndefined, "deleteUndefined");
  var _ArgsStore = class {
    constructor() {
      this.initialArgsByStoryId = {}, this.argsByStoryId = {};
    }
    get(storyId) {
      if (!(storyId in this.argsByStoryId))
        throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
      return this.argsByStoryId[storyId];
    }
    setInitial(story) {
      if (!this.initialArgsByStoryId[story.id])
        this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
      else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
        let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
        this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
      }
    }
    updateFromDelta(story, delta) {
      let validatedDelta = validateOptions(delta, story.argTypes);
      this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
    }
    updateFromPersisted(story, persisted) {
      let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
      return this.updateFromDelta(story, mappedPersisted);
    }
    update(storyId, argsUpdate) {
      if (!(storyId in this.argsByStoryId))
        throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
      this.argsByStoryId[storyId] = deleteUndefined({
        ...this.argsByStoryId[storyId],
        ...argsUpdate
      });
    }
  };
  __name(_ArgsStore, "ArgsStore");
  var ArgsStore = _ArgsStore, getValuesFromArgTypes = __name((argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {}), "getValuesFromArgTypes"), _GlobalsStore = class {
    constructor({
      globals = {},
      globalTypes = {}
    }) {
      this.set({ globals, globalTypes });
    }
    set({ globals = {}, globalTypes = {} }) {
      let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
      this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
      let defaultGlobals = getValuesFromArgTypes(globalTypes);
      this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
    }
    filterAllowedGlobals(globals) {
      return Object.entries(globals).reduce((acc, [key, value2]) => (this.allowedGlobalNames.has(key) ? acc[key] = value2 : logger.warn(
        `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
      ), acc), {});
    }
    updateFromPersisted(persisted) {
      let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
      this.globals = { ...this.globals, ...allowedUrlGlobals };
    }
    get() {
      return this.globals;
    }
    update(newGlobals) {
      this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
      for (let key in newGlobals)
        newGlobals[key] === void 0 && (this.globals[key] = this.initialGlobals[key]);
    }
  };
  __name(_GlobalsStore, "GlobalsStore");
  var GlobalsStore = _GlobalsStore, import_memoizerific3 = __toESM2(require_memoizerific(), 1), getImportPathMap = (0, import_memoizerific3.default)(1)(
    (entries) => Object.values(entries).reduce(
      (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),
      {}
    )
  ), _StoryIndexStore = class {
    constructor({ entries } = { v: 5, entries: {} }) {
      this.entries = entries;
    }
    entryFromSpecifier(specifier) {
      let entries = Object.values(this.entries);
      if (specifier === "*")
        return entries[0];
      if (typeof specifier == "string")
        return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
      let { name, title } = specifier;
      return entries.find((entry) => entry.name === name && entry.title === title);
    }
    storyIdToEntry(storyId) {
      let storyEntry = this.entries[storyId];
      if (!storyEntry)
        throw new MissingStoryAfterHmrError({ storyId });
      return storyEntry;
    }
    importPathToEntry(importPath) {
      return getImportPathMap(this.entries)[importPath];
    }
  };
  __name(_StoryIndexStore, "StoryIndexStore");
  var StoryIndexStore = _StoryIndexStore, normalizeType = __name((type) => typeof type == "string" ? { name: type } : type, "normalizeType"), normalizeControl = __name((control) => typeof control == "string" ? { type: control } : control, "normalizeControl"), normalizeInputType = __name((inputType, key) => {
    let { type, control, ...rest } = inputType, normalized = {
      name: key,
      ...rest
    };
    return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === !1 && (normalized.control = { disable: !0 }), normalized;
  }, "normalizeInputType"), normalizeInputTypes = __name((inputTypes) => mapValues(inputTypes, normalizeInputType), "normalizeInputTypes"), normalizeArrays = __name((array2) => Array.isArray(array2) ? array2 : array2 ? [array2] : [], "normalizeArrays"), deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
  function normalizeStory(key, storyAnnotations, meta) {
    let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
    story && (logger.debug("deprecated story", story), deprecate(deprecatedStoryAnnotation));
    let exportName = storyNameFromExport(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || story?.name || exportName, decorators4 = [
      ...normalizeArrays(storyObject.decorators),
      ...normalizeArrays(story?.decorators)
    ], parameters2 = { ...story?.parameters, ...storyObject.parameters }, args = { ...story?.args, ...storyObject.args }, argTypes = { ...story?.argTypes, ...storyObject.argTypes }, loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)], beforeEach = [
      ...normalizeArrays(storyObject.beforeEach),
      ...normalizeArrays(story?.beforeEach)
    ], afterEach = [
      ...normalizeArrays(storyObject.afterEach),
      ...normalizeArrays(story?.afterEach)
    ], { render: render2, play, tags = [], globals = {} } = storyObject, id2 = parameters2.__id || toId(meta.id, exportName);
    return {
      moduleExport: storyAnnotations,
      id: id2,
      name,
      tags,
      decorators: decorators4,
      parameters: parameters2,
      args,
      argTypes: normalizeInputTypes(argTypes),
      loaders: loaders2,
      beforeEach,
      afterEach,
      globals,
      ...render2 && { render: render2 },
      ...userStoryFn && { userStoryFn },
      ...play && { play }
    };
  }
  __name(normalizeStory, "normalizeStory");
  function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
    let { id: id2, argTypes } = defaultExport;
    return {
      id: sanitize(id2 || title),
      ...defaultExport,
      title,
      ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
      parameters: {
        fileName: importPath,
        ...defaultExport.parameters
      }
    };
  }
  __name(normalizeComponentAnnotations, "normalizeComponentAnnotations");
  var checkGlobals = __name((parameters2) => {
    let { globals, globalTypes } = parameters2;
    (globals || globalTypes) && logger.error(
      "Global args/argTypes can only be set globally",
      JSON.stringify({
        globals,
        globalTypes
      })
    );
  }, "checkGlobals"), checkStorySort = __name((parameters2) => {
    let { options: options2 } = parameters2;
    options2?.storySort && logger.error("The storySort option parameter can only be set globally");
  }, "checkStorySort"), checkDisallowedParameters = __name((parameters2) => {
    parameters2 && (checkGlobals(parameters2), checkStorySort(parameters2));
  }, "checkDisallowedParameters");
  function processCSFFile(moduleExports, importPath, title) {
    let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, firstStory = Object.values(namedExports)[0];
    if (isStory(firstStory)) {
      let meta2 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);
      checkDisallowedParameters(meta2.parameters);
      let csfFile2 = { meta: meta2, stories: {}, moduleExports };
      return Object.keys(namedExports).forEach((key) => {
        if (isExportStory(key, meta2)) {
          let story = namedExports[key], storyMeta = normalizeStory(key, story.input, meta2);
          checkDisallowedParameters(storyMeta.parameters), csfFile2.stories[storyMeta.id] = storyMeta, getStoryChildren(story).forEach((child) => {
            let name = child.input.name, childId = toTestId(storyMeta.id, name);
            child.input.parameters ??= {}, child.input.parameters.__id = childId, csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);
          });
        }
      }), csfFile2.projectAnnotations = firstStory.meta.preview.composed, csfFile2;
    }
    let meta = normalizeComponentAnnotations(
      defaultExport,
      title,
      importPath
    );
    checkDisallowedParameters(meta.parameters);
    let csfFile = { meta, stories: {}, moduleExports };
    return Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta)) {
        let storyMeta = normalizeStory(key, namedExports[key], meta);
        checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
      }
    }), csfFile;
  }
  __name(processCSFFile, "processCSFFile");
  function mountDestructured(playFunction) {
    return playFunction != null && getUsedProps(playFunction).includes("mount");
  }
  __name(mountDestructured, "mountDestructured");
  function getUsedProps(fn3) {
    let match2 = fn3.toString().match(/[^(]*\(([^)]*)/);
    if (!match2)
      return [];
    let args = splitByComma(match2[1]);
    if (!args.length)
      return [];
    let first = args[0];
    return first.startsWith("{") && first.endsWith("}") ? splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => prop.replace(/:.*|=.*/g, "")) : [];
  }
  __name(getUsedProps, "getUsedProps");
  function splitByComma(s4) {
    let result = [], stack = [], start2 = 0;
    for (let i3 = 0; i3 < s4.length; i3++)
      if (s4[i3] === "{" || s4[i3] === "[")
        stack.push(s4[i3] === "{" ? "}" : "]");
      else if (s4[i3] === stack[stack.length - 1])
        stack.pop();
      else if (!stack.length && s4[i3] === ",") {
        let token = s4.substring(start2, i3).trim();
        token && result.push(token), start2 = i3 + 1;
      }
    let lastToken = s4.substring(start2).trim();
    return lastToken && result.push(lastToken), result;
  }
  __name(splitByComma, "splitByComma");
  function decorateStory(storyFn, decorator, bindWithContext) {
    let boundStoryFunction = bindWithContext(storyFn);
    return (context) => decorator(boundStoryFunction, context);
  }
  __name(decorateStory, "decorateStory");
  function sanitizeStoryContextUpdate({
    componentId,
    title,
    kind,
    id: id2,
    name,
    story,
    parameters: parameters2,
    initialArgs,
    argTypes,
    ...update
  } = {}) {
    return update;
  }
  __name(sanitizeStoryContextUpdate, "sanitizeStoryContextUpdate");
  function defaultDecorateStory(storyFn, decorators4) {
    let contextStore = {}, bindWithContext = __name((decoratedStoryFn) => (update) => {
      if (!contextStore.value)
        throw new Error("Decorated function called without init");
      return contextStore.value = {
        ...contextStore.value,
        ...sanitizeStoryContextUpdate(update)
      }, decoratedStoryFn(contextStore.value);
    }, "bindWithContext"), decoratedWithContextStore = decorators4.reduce(
      (story, decorator) => decorateStory(story, decorator, bindWithContext),
      storyFn
    );
    return (context) => (contextStore.value = context, decoratedWithContextStore(context));
  }
  __name(defaultDecorateStory, "defaultDecorateStory");
  function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
    let { moduleExport, id: id2, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(
      storyAnnotations,
      componentAnnotations,
      projectAnnotations
    ), applyLoaders = __name(async (context) => {
      let loaded = {};
      for (let loaders2 of [
        normalizeArrays(projectAnnotations.loaders),
        normalizeArrays(componentAnnotations.loaders),
        normalizeArrays(storyAnnotations.loaders)
      ]) {
        if (context.abortSignal.aborted)
          return loaded;
        let loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
        Object.assign(loaded, ...loadResults);
      }
      return loaded;
    }, "applyLoaders"), applyBeforeEach = __name(async (context) => {
      let cleanupCallbacks = new Array();
      for (let beforeEach of [
        ...normalizeArrays(projectAnnotations.beforeEach),
        ...normalizeArrays(componentAnnotations.beforeEach),
        ...normalizeArrays(storyAnnotations.beforeEach)
      ]) {
        if (context.abortSignal.aborted)
          return cleanupCallbacks;
        let cleanup = await beforeEach(context);
        cleanup && cleanupCallbacks.push(cleanup);
      }
      return cleanupCallbacks;
    }, "applyBeforeEach"), applyAfterEach = __name(async (context) => {
      let reversedFinalizers = [
        ...normalizeArrays(projectAnnotations.afterEach),
        ...normalizeArrays(componentAnnotations.afterEach),
        ...normalizeArrays(storyAnnotations.afterEach)
      ].reverse();
      for (let finalizer of reversedFinalizers) {
        if (context.abortSignal.aborted)
          return;
        await finalizer(context);
      }
    }, "applyAfterEach"), undecoratedStoryFn = __name((context) => context.originalStoryFn(context.args, context), "undecoratedStoryFn"), { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators4 = [
      ...normalizeArrays(storyAnnotations?.decorators),
      ...normalizeArrays(componentAnnotations?.decorators),
      ...normalizeArrays(projectAnnotations?.decorators)
    ], render2 = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render, decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators4), unboundStoryFn = __name((context) => decoratedStoryFn(context), "unboundStoryFn"), playFunction = storyAnnotations?.play ?? componentAnnotations?.play, usesMount = mountDestructured(playFunction);
    if (!render2 && !usesMount)
      throw new NoRenderFunctionError({ id: id2 });
    let defaultMount = __name((context) => async () => (await context.renderToCanvas(), context.canvas), "defaultMount"), mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount, testingLibraryRender = projectAnnotations.testingLibraryRender;
    return {
      storyGlobals: {},
      ...partialAnnotations,
      moduleExport,
      id: id2,
      name,
      story: name,
      originalStoryFn: render2,
      undecoratedStoryFn,
      unboundStoryFn,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      playFunction,
      runStep,
      mount,
      testingLibraryRender,
      renderToCanvas: projectAnnotations.renderToCanvas,
      usesMount
    };
  }
  __name(prepareStory, "prepareStory");
  function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
    return {
      ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
      moduleExport
    };
  }
  __name(prepareMeta, "prepareMeta");
  function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
    let defaultTags = ["dev", "test"], extraTags = scope.DOCS_OPTIONS?.autodocs === !0 ? ["autodocs"] : [], overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [], tags = combineTags2(
      ...defaultTags,
      ...extraTags,
      ...projectAnnotations.tags ?? [],
      ...componentAnnotations.tags ?? [],
      ...overrideTags,
      ...storyAnnotations?.tags ?? []
    ), parameters2 = combineParameters(
      projectAnnotations.parameters,
      componentAnnotations.parameters,
      storyAnnotations?.parameters
    ), { argTypesEnhancers = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations, passedArgTypes = combineParameters(
      projectAnnotations.argTypes,
      componentAnnotations.argTypes,
      storyAnnotations?.argTypes
    );
    if (storyAnnotations) {
      let render2 = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
      parameters2.__isArgsStory = render2 && render2.length > 0;
    }
    let passedArgs = {
      ...projectAnnotations.args,
      ...componentAnnotations.args,
      ...storyAnnotations?.args
    }, storyGlobals = {
      ...componentAnnotations.globals,
      ...storyAnnotations?.globals
    }, contextForEnhancers = {
      componentId: componentAnnotations.id,
      title: componentAnnotations.title,
      kind: componentAnnotations.title,
      // Back compat
      id: storyAnnotations?.id || componentAnnotations.id,
      // if there's no story name, we create a fake one since enhancers expect a name
      name: storyAnnotations?.name || "__meta",
      story: storyAnnotations?.name || "__meta",
      // Back compat
      component: componentAnnotations.component,
      subcomponents: componentAnnotations.subcomponents,
      tags,
      parameters: parameters2,
      initialArgs: passedArgs,
      argTypes: passedArgTypes,
      storyGlobals
    };
    contextForEnhancers.argTypes = argTypesEnhancers.reduce(
      (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
      contextForEnhancers.argTypes
    );
    let initialArgsBeforeEnhancers = { ...passedArgs };
    contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
      (accumulatedArgs, enhancer) => ({
        ...accumulatedArgs,
        ...enhancer({
          ...contextForEnhancers,
          initialArgs: accumulatedArgs
        })
      }),
      initialArgsBeforeEnhancers
    );
    let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
    return withoutStoryIdentifiers;
  }
  __name(preparePartialAnnotations, "preparePartialAnnotations");
  function prepareContext(context) {
    let { args: unmappedArgs } = context, targetedContext = {
      ...context,
      allArgs: void 0,
      argsByTarget: void 0
    };
    if (scope.FEATURES?.argTypeTargetsV7) {
      let argsByTarget = groupArgsByTarget(context);
      targetedContext = {
        ...context,
        allArgs: context.args,
        argsByTarget,
        args: argsByTarget[UNTARGETED] || {}
      };
    }
    let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
      if (!targetedContext.argTypes[key]?.mapping)
        return acc[key] = val, acc;
      let mappingFn = __name((originalValue) => {
        let mapping = targetedContext.argTypes[key].mapping;
        return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
      }, "mappingFn");
      return acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;
    }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
      let argType = targetedContext.argTypes[key] || {};
      return includeConditionalArg(argType, mappedArgs, targetedContext.globals) && (acc[key] = val), acc;
    }, {});
    return { ...targetedContext, unmappedArgs, args: includedArgs };
  }
  __name(prepareContext, "prepareContext");
  var inferType = __name((value2, name, visited) => {
    let type = typeof value2;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "function":
      case "symbol":
        return { name: type };
      default:
        break;
    }
    return value2 ? visited.has(value2) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value2), Array.isArray(value2) ? { name: "array", value: value2.length > 0 ? inferType(value2[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: mapValues(value2, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
  }, "inferType"), inferArgTypes = __name((context) => {
    let { id: id2, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues(initialArgs, (arg, key) => ({
      name: key,
      type: inferType(arg, `${id2}.${key}`, /* @__PURE__ */ new Set())
    })), userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
      name: key
    }));
    return combineParameters(argTypes, userArgTypesNames, userArgTypes);
  }, "inferArgTypes");
  inferArgTypes.secondPass = !0;
  var matches = __name((name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), "matches"), filterArgTypes = __name((argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {
    let name = argType.name || key.toString();
    return !!(!include || matches(name, include)) && (!exclude || !matches(name, exclude));
  }), "filterArgTypes"), inferControl = __name((argType, name, matchers) => {
    let { type, options: options2 } = argType;
    if (type) {
      if (matchers.color && matchers.color.test(name)) {
        let controlType = type.name;
        if (controlType === "string")
          return { control: { type: "color" } };
        controlType !== "enum" && logger.warn(
          `Addon controls: Control of type color only supports string, received "${controlType}" instead`
        );
      }
      if (matchers.date && matchers.date.test(name))
        return { control: { type: "date" } };
      switch (type.name) {
        case "array":
          return { control: { type: "object" } };
        case "boolean":
          return { control: { type: "boolean" } };
        case "string":
          return { control: { type: "text" } };
        case "number":
          return { control: { type: "number" } };
        case "enum": {
          let { value: value2 } = type;
          return { control: { type: value2?.length <= 5 ? "radio" : "select" }, options: value2 };
        }
        case "function":
        case "symbol":
          return null;
        default:
          return { control: { type: options2 ? "select" : "object" } };
      }
    }
  }, "inferControl"), inferControls = __name((context) => {
    let {
      argTypes,
      parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }
    } = context;
    if (!__isArgsStory)
      return argTypes;
    let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = mapValues(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));
    return combineParameters(withControls, filteredArgTypes);
  }, "inferControls");
  inferControls.secondPass = !0;
  function normalizeProjectAnnotations({
    argTypes,
    globalTypes,
    argTypesEnhancers,
    decorators: decorators4,
    loaders: loaders2,
    beforeEach,
    afterEach,
    initialGlobals: initialGlobals5,
    ...annotations
  }) {
    return {
      ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
      ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
      decorators: normalizeArrays(decorators4),
      loaders: normalizeArrays(loaders2),
      beforeEach: normalizeArrays(beforeEach),
      afterEach: normalizeArrays(afterEach),
      argTypesEnhancers: [
        ...argTypesEnhancers || [],
        inferArgTypes,
        // There's an architectural decision to be made regarding embedded addons in core:
        //
        // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
        // (like inferControls) to live alongside the addon code itself. This maintains the
        // concept of core addons while improving code organization.
        //
        // Option 2: Fully integrate these addons into core, potentially moving UI components
        // into the manager and treating them as core features rather than addons. This is a
        // bigger architectural change requiring careful consideration.
        //
        // For now, we're keeping inferControls here as we need time to properly evaluate
        // these options and their implications. Some features (like Angular's cleanArgsDecorator)
        // currently rely on this behavior.
        //
        // TODO: Make an architectural decision on the handling of core addons
        inferControls
      ],
      initialGlobals: initialGlobals5,
      ...annotations
    };
  }
  __name(normalizeProjectAnnotations, "normalizeProjectAnnotations");
  var composeBeforeAllHooks = __name((hooks) => async () => {
    let cleanups2 = [];
    for (let hook of hooks) {
      let cleanup = await hook();
      cleanup && cleanups2.unshift(cleanup);
    }
    return async () => {
      for (let cleanup of cleanups2)
        await cleanup();
    };
  }, "composeBeforeAllHooks");
  function composeStepRunners(stepRunners) {
    return async (label, play, playContext) => {
      await stepRunners.reduceRight(
        (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
        async () => play(playContext)
      )();
    };
  }
  __name(composeStepRunners, "composeStepRunners");
  function getField(moduleExportList, field) {
    return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
  }
  __name(getField, "getField");
  function getArrayField(moduleExportList, field, options2 = {}) {
    return getField(moduleExportList, field).reduce((prev, cur) => {
      let normalized = normalizeArrays(cur);
      return options2.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
    }, []);
  }
  __name(getArrayField, "getArrayField");
  function getObjectField(moduleExportList, field) {
    return Object.assign({}, ...getField(moduleExportList, field));
  }
  __name(getObjectField, "getObjectField");
  function getSingletonField(moduleExportList, field) {
    return getField(moduleExportList, field).pop();
  }
  __name(getSingletonField, "getSingletonField");
  function composeConfigs(moduleExportList) {
    let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep"), beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
    return {
      parameters: combineParameters(...getField(moduleExportList, "parameters")),
      decorators: getArrayField(moduleExportList, "decorators", {
        reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? !1)
      }),
      args: getObjectField(moduleExportList, "args"),
      argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
      argTypes: getObjectField(moduleExportList, "argTypes"),
      argTypesEnhancers: [
        ...allArgTypeEnhancers.filter((e) => !e.secondPass),
        ...allArgTypeEnhancers.filter((e) => e.secondPass)
      ],
      initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
      globalTypes: getObjectField(moduleExportList, "globalTypes"),
      loaders: getArrayField(moduleExportList, "loaders"),
      beforeAll: composeBeforeAllHooks(beforeAllHooks),
      beforeEach: getArrayField(moduleExportList, "beforeEach"),
      afterEach: getArrayField(moduleExportList, "afterEach"),
      render: getSingletonField(moduleExportList, "render"),
      renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
      applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
      runStep: composeStepRunners(stepRunners),
      tags: getArrayField(moduleExportList, "tags"),
      mount: getSingletonField(moduleExportList, "mount"),
      testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
    };
  }
  __name(composeConfigs, "composeConfigs");
  var _ReporterAPI = class {
    constructor() {
      this.reports = [];
    }
    async addReport(report) {
      this.reports.push(report);
    }
  };
  __name(_ReporterAPI, "ReporterAPI");
  var ReporterAPI = _ReporterAPI;
  function getCsfFactoryAnnotations(story, meta, projectAnnotations) {
    return isStory(story) ? {
      story: story.input,
      meta: story.meta.input,
      preview: story.meta.preview.composed
    } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };
  }
  __name(getCsfFactoryAnnotations, "getCsfFactoryAnnotations");
  function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
    globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
  }
  __name(setDefaultProjectAnnotations, "setDefaultProjectAnnotations");
  var DEFAULT_STORY_TITLE = "ComposedStory", DEFAULT_STORY_NAME = "Unnamed Story";
  function extractAnnotation(annotation) {
    return annotation ? composeConfigs([annotation]) : {};
  }
  __name(extractAnnotation, "extractAnnotation");
  function setProjectAnnotations(projectAnnotations) {
    let annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
    return globalThis.globalProjectAnnotations = composeConfigs([
      ...getCoreAnnotations(),
      globalThis.defaultProjectAnnotations ?? {},
      composeConfigs(annotations.map(extractAnnotation))
    ]), globalThis.globalProjectAnnotations ?? {};
  }
  __name(setProjectAnnotations, "setProjectAnnotations");
  var cleanups = [];
  function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig2, exportsName) {
    if (storyAnnotations === void 0)
      throw new Error("Expected a story but received undefined.");
    componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
    let normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations), storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME, normalizedStory = normalizeStory(
      storyName,
      storyAnnotations,
      normalizedComponentAnnotations
    ), normalizedProjectAnnotations = normalizeProjectAnnotations(
      composeConfigs([
        defaultConfig2 ?? globalThis.globalProjectAnnotations ?? {},
        projectAnnotations ?? {}
      ])
    ), story = prepareStory(
      normalizedStory,
      normalizedComponentAnnotations,
      normalizedProjectAnnotations
    ), globals = {
      ...getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes),
      ...normalizedProjectAnnotations.initialGlobals,
      ...story.storyGlobals
    }, reporting = new ReporterAPI(), initializeContext = __name(() => {
      let context = prepareContext({
        hooks: new HooksContext(),
        globals,
        args: { ...story.initialArgs },
        viewMode: "story",
        reporting,
        loaded: {},
        abortSignal: new AbortController().signal,
        step: __name((label, play2) => story.runStep(label, play2, context), "step"),
        canvasElement: null,
        canvas: {},
        userEvent: {},
        globalTypes: normalizedProjectAnnotations.globalTypes,
        ...story,
        context: null,
        mount: null
      });
      return context.parameters.__isPortableStory = !0, context.context = context, story.renderToCanvas && (context.renderToCanvas = async () => {
        let unmount = await story.renderToCanvas?.(
          {
            componentId: story.componentId,
            title: story.title,
            id: story.id,
            name: story.name,
            tags: story.tags,
            showMain: __name(() => {
            }, "showMain"),
            showError: __name((error) => {
              throw new Error(`${error.title}
${error.description}`);
            }, "showError"),
            showException: __name((error) => {
              throw error;
            }, "showException"),
            forceRemount: !0,
            storyContext: context,
            storyFn: __name(() => story.unboundStoryFn(context), "storyFn"),
            unboundStoryFn: story.unboundStoryFn
          },
          context.canvasElement
        );
        unmount && cleanups.push(unmount);
      }), context.mount = story.mount(context), context;
    }, "initializeContext"), loadedContext, play = __name(async (extraContext) => {
      let context = initializeContext();
      return context.canvasElement ??= globalThis?.document?.body, loadedContext && (context.loaded = loadedContext.loaded), Object.assign(context, extraContext), story.playFunction(context);
    }, "play"), run = __name((extraContext) => {
      let context = initializeContext();
      return Object.assign(context, extraContext), runStory(story, context);
    }, "run"), playFunction = story.playFunction ? play : void 0;
    return Object.assign(
      __name(function(extraArgs) {
        let context = initializeContext();
        return loadedContext && (context.loaded = loadedContext.loaded), context.args = {
          ...context.initialArgs,
          ...extraArgs
        }, story.unboundStoryFn(context);
      }, "storyFn"),
      {
        id: story.id,
        storyName,
        load: __name(async () => {
          for (let callback of [...cleanups].reverse())
            await callback();
          cleanups.length = 0;
          let context = initializeContext();
          context.loaded = await story.applyLoaders(context), cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean)), loadedContext = context;
        }, "load"),
        globals,
        args: story.initialArgs,
        parameters: story.parameters,
        argTypes: story.argTypes,
        play: playFunction,
        run,
        reporting,
        tags: story.tags
      }
    );
  }
  __name(composeStory, "composeStory");
  var defaultComposeStory = __name((story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName), "defaultComposeStory");
  function composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {
    let { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport, meta = metaExport;
    return Object.entries(stories).reduce(
      (storiesMap, [exportsName, story]) => {
        let { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);
        return !meta && componentAnnotations && (meta = componentAnnotations), isExportStory(exportsName, meta) ? Object.assign(storiesMap, {
          [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)
        }) : storiesMap;
      },
      {}
    );
  }
  __name(composeStories, "composeStories");
  function createPlaywrightTest(baseTest) {
    return baseTest.extend({
      mount: __name(async ({ mount, page }, use) => {
        await use(async (storyRef, ...restArgs) => {
          if (!("__pw_type" in storyRef) || "__pw_type" in storyRef && storyRef.__pw_type !== "jsx")
            throw new Error(dedent`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
          let { props, ...storyRefWithoutProps } = storyRef;
          await page.evaluate(async (wrappedStoryRef) => {
            let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
            return ("__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef)?.load?.();
          }, storyRefWithoutProps);
          let mountResult = await mount(storyRef, ...restArgs);
          return await page.evaluate(async (wrappedStoryRef) => {
            let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef), story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef, canvasElement = document.querySelector("#root");
            return story?.play?.({ canvasElement });
          }, storyRefWithoutProps), mountResult;
        });
      }, "mount")
    });
  }
  __name(createPlaywrightTest, "createPlaywrightTest");
  async function runStory(story, context) {
    for (let callback of [...cleanups].reverse())
      await callback();
    if (cleanups.length = 0, !context.canvasElement) {
      let container = document.createElement("div");
      globalThis?.document?.body?.appendChild(container), context.canvasElement = container, cleanups.push(() => {
        globalThis?.document?.body?.contains(container) && globalThis?.document?.body?.removeChild(container);
      });
    }
    if (context.loaded = await story.applyLoaders(context), context.abortSignal.aborted)
      return;
    cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
    let playFunction = story.playFunction, isMountDestructured = story.usesMount;
    if (isMountDestructured || await context.mount(), context.abortSignal.aborted)
      return;
    playFunction && (isMountDestructured || (context.mount = async () => {
      throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
    }), await playFunction(context));
    let cleanUp;
    isTestEnvironment() ? cleanUp = pauseAnimations() : await waitForAnimations(context.abortSignal), await story.applyAfterEach(context), await cleanUp?.();
  }
  __name(runStory, "runStory");
  var CSF_CACHE_SIZE = 1e3, STORY_CACHE_SIZE = 1e4, _StoryStore = class {
    constructor(storyIndex, importFn, projectAnnotations) {
      this.importFn = importFn, this.storyIndex = new StoryIndexStore(storyIndex), this.projectAnnotations = normalizeProjectAnnotations(
        composeConfigs([...getCoreAnnotations(), projectAnnotations])
      );
      let { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
      this.args = new ArgsStore(), this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
    }
    setProjectAnnotations(projectAnnotations) {
      this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
      let { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
      this.userGlobals.set({ globals: initialGlobals5, globalTypes });
    }
    // This means that one of the CSF files has changed.
    // If the `importFn` has changed, we will invalidate both caches.
    // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
    // on whether we've loaded the relevant files yet.
    async onStoriesChanged({
      importFn,
      storyIndex
    }) {
      importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
    }
    // Get an entry from the index, waiting on initialization if necessary
    async storyIdToEntry(storyId) {
      return this.storyIndex.storyIdToEntry(storyId);
    }
    // To load a single CSF file to service a story we need to look up the importPath in the index
    async loadCSFFileByStoryId(storyId) {
      let { importPath, title } = this.storyIndex.storyIdToEntry(storyId), moduleExports = await this.importFn(importPath);
      return this.processCSFFileWithCache(moduleExports, importPath, title);
    }
    async loadAllCSFFiles() {
      let importPaths = {};
      return Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
        importPaths[importPath] = storyId;
      }), (await Promise.all(
        Object.entries(importPaths).map(async ([importPath, storyId]) => ({
          importPath,
          csfFile: await this.loadCSFFileByStoryId(storyId)
        }))
      )).reduce(
        (acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc),
        {}
      );
    }
    async cacheAllCSFFiles() {
      this.cachedCSFFiles = await this.loadAllCSFFiles();
    }
    preparedMetaFromCSFFile({ csfFile }) {
      let componentAnnotations = csfFile.meta;
      return this.prepareMetaWithCache(
        componentAnnotations,
        this.projectAnnotations,
        csfFile.moduleExports.default
      );
    }
    // Load the CSF file for a story and prepare the story from it and the project annotations.
    async loadStory({ storyId }) {
      let csfFile = await this.loadCSFFileByStoryId(storyId);
      return this.storyFromCSFFile({ storyId, csfFile });
    }
    // This function is synchronous for convenience -- often times if you have a CSF file already
    // it is easier not to have to await `loadStory`.
    storyFromCSFFile({
      storyId,
      csfFile
    }) {
      let storyAnnotations = csfFile.stories[storyId];
      if (!storyAnnotations)
        throw new MissingStoryFromCsfFileError({ storyId });
      let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(
        storyAnnotations,
        componentAnnotations,
        csfFile.projectAnnotations ?? this.projectAnnotations
      );
      return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
    }
    // If we have a CSF file we can get all the stories from it synchronously
    componentStoriesFromCSFFile({
      csfFile
    }) {
      return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
    }
    async loadEntry(id2) {
      let entry = await this.storyIdToEntry(id2), storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([
        this.importFn(entry.importPath),
        ...storyImports.map((storyImportPath) => {
          let firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
          return this.loadCSFFileByStoryId(firstStoryEntry.id);
        })
      ]);
      return { entryExports, csfFiles };
    }
    // A prepared story does not include args, globals or hooks. These are stored in the story store
    // and updated separately to the (immutable) story.
    getStoryContext(story, { forceInitialArgs = !1 } = {}) {
      let userGlobals = this.userGlobals.get(), { initialGlobals: initialGlobals5 } = this.userGlobals, reporting = new ReporterAPI();
      return prepareContext({
        ...story,
        args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
        initialGlobals: initialGlobals5,
        globalTypes: this.projectAnnotations.globalTypes,
        userGlobals,
        reporting,
        globals: {
          ...userGlobals,
          ...story.storyGlobals
        },
        hooks: this.hooks[story.id]
      });
    }
    addCleanupCallbacks(story, ...callbacks) {
      this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
    }
    async cleanupStory(story) {
      this.hooks[story.id].clean();
      let callbacks = this.cleanupCallbacks[story.id];
      if (callbacks)
        for (let callback of [...callbacks].reverse())
          await callback();
      delete this.cleanupCallbacks[story.id];
    }
    extract(options2 = { includeDocsOnly: !1 }) {
      let { cachedCSFFiles } = this;
      if (console.log("extract: extracting stories", cachedCSFFiles), !cachedCSFFiles)
        throw new CalledExtractOnStoreError();
      let stories = Object.entries(this.storyIndex.entries).reduce(
        (acc, [storyId, entry]) => {
          if (entry.type === "docs")
            return acc;
          let csfFile = cachedCSFFiles[entry.importPath], story = this.storyFromCSFFile({ storyId, csfFile });
          return !options2.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce(
            (storyAcc, [key, value2]) => key === "story" && entry.subtype === "test" ? { ...storyAcc, story: entry.parentName } : key === "moduleExport" || typeof value2 == "function" ? storyAcc : Array.isArray(value2) ? Object.assign(storyAcc, { [key]: value2.slice().sort() }) : Object.assign(storyAcc, { [key]: value2 }),
            {
              args: story.initialArgs,
              globals: {
                ...this.userGlobals.initialGlobals,
                ...this.userGlobals.globals,
                ...story.storyGlobals
              },
              storyId: entry.parent ? entry.parent : storyId
            }
          )), acc;
        },
        {}
      );
      return console.log("extract: stories", stories), stories;
    }
  };
  __name(_StoryStore, "StoryStore");
  var StoryStore = _StoryStore;
  function slash(path) {
    return path.startsWith("\\\\?\\") ? path : path.replace(/\\/g, "/");
  }
  __name(slash, "slash");
  var sanitize2 = __name((parts) => {
    if (parts.length === 0)
      return parts;
    let last = parts[parts.length - 1], lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
    if (parts.length === 1)
      return [lastStripped];
    let nextToLast = parts[parts.length - 2];
    return lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase() ? [...parts.slice(0, -2), lastStripped] : lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
  }, "sanitize");
  function pathJoin(paths) {
    return paths.flatMap((p4) => p4.split("/")).filter(Boolean).join("/");
  }
  __name(pathJoin, "pathJoin");
  var userOrAutoTitleFromSpecifier = __name((fileName, entry, userTitle) => {
    let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
    typeof fileName == "number" && once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
    let normalizedFileName = slash(String(fileName));
    if (importPathMatcher.exec(normalizedFileName)) {
      if (!userTitle) {
        let suffix = normalizedFileName.replace(directory, ""), parts = pathJoin([titlePrefix, suffix]).split("/");
        return parts = sanitize2(parts), parts.join("/");
      }
      return titlePrefix ? pathJoin([titlePrefix, userTitle]) : userTitle;
    }
  }, "userOrAutoTitleFromSpecifier"), userOrAutoTitle = __name((fileName, storiesEntries, userTitle) => {
    for (let i3 = 0; i3 < storiesEntries.length; i3 += 1) {
      let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i3], userTitle);
      if (title)
        return title;
    }
    return userTitle || void 0;
  }, "userOrAutoTitle"), STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/, storySort = __name((options2 = {}) => (a3, b3) => {
    if (a3.title === b3.title && !options2.includeNames)
      return 0;
    let method = options2.method || "configure", order2 = options2.order || [], storyTitleA = a3.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b3.title.trim().split(STORY_KIND_PATH_SEPARATOR);
    options2.includeNames && (storyTitleA.push(a3.name), storyTitleB.push(b3.name));
    let depth = 0;
    for (; storyTitleA[depth] || storyTitleB[depth]; ) {
      if (!storyTitleA[depth])
        return -1;
      if (!storyTitleB[depth])
        return 1;
      let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
      if (nameA !== nameB) {
        let indexA = order2.indexOf(nameA), indexB = order2.indexOf(nameB), indexWildcard = order2.indexOf("*");
        return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order2.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order2.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options2.locales ? options2.locales : void 0, {
          numeric: !0,
          sensitivity: "accent"
        });
      }
      let index3 = order2.indexOf(nameA);
      index3 === -1 && (index3 = order2.indexOf("*")), order2 = index3 !== -1 && Array.isArray(order2[index3 + 1]) ? order2[index3 + 1] : [], depth += 1;
    }
    return 0;
  }, "storySort"), sortStoriesCommon = __name((stories, storySortParameter, fileNameOrder) => {
    if (storySortParameter) {
      let sortFn;
      typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
    } else
      stories.sort(
        (s1, s22) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s22.importPath)
      );
    return stories;
  }, "sortStoriesCommon"), sortStoriesV7 = __name((stories, storySortParameter, fileNameOrder) => {
    try {
      return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
    } catch (err) {
      throw new Error(dedent`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
    }
  }, "sortStoriesV7"), PREPARE_ABORTED = new Error("prepareAborted"), { AbortController: AbortController2 } = globalThis;
  function serializeError(error) {
    try {
      let { name = "Error", message = String(error), stack } = error;
      return { name, message, stack };
    } catch {
      return { name: "Error", message: String(error) };
    }
  }
  __name(serializeError, "serializeError");
  var _StoryRender = class {
    constructor(channel, store, renderToScreen, callbacks, id2, viewMode, renderOptions = { autoplay: !0, forceInitialArgs: !1 }, story) {
      this.channel = channel, this.store = store, this.renderToScreen = renderToScreen, this.callbacks = callbacks, this.id = id2, this.viewMode = viewMode, this.renderOptions = renderOptions, this.type = "story", this.notYetRendered = !0, this.rerenderEnqueued = !1, this.disableKeyListeners = !1, this.teardownRender = __name(() => {
      }, "teardownRender"), this.torndown = !1, this.abortController = new AbortController2(), this.renderId = Date.now(), story && (this.story = story, this.phase = "preparing");
    }
    async runPhase(signal, phase, phaseFn) {
      this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
        newPhase: this.phase,
        renderId: this.renderId,
        storyId: this.id
      }), phaseFn && (await phaseFn(), this.checkIfAborted(signal));
    }
    checkIfAborted(signal) {
      return signal.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
        newPhase: this.phase,
        renderId: this.renderId,
        storyId: this.id
      })), signal.aborted;
    }
    async prepare() {
      if (await this.runPhase(this.abortController.signal, "preparing", async () => {
        this.story = await this.store.loadStory({ storyId: this.id });
      }), this.abortController.signal.aborted)
        throw await this.store.cleanupStory(this.story), PREPARE_ABORTED;
    }
    // The two story "renders" are equal and have both loaded the same story
    isEqual(other) {
      return !!(this.id === other.id && this.story && this.story === other.story);
    }
    isPreparing() {
      return ["preparing"].includes(this.phase);
    }
    isPending() {
      return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
        this.phase
      );
    }
    async renderToElement(canvasElement) {
      return this.canvasElement = canvasElement, this.render({ initial: !0, forceRemount: !0 });
    }
    storyContext() {
      if (!this.story)
        throw new Error("Cannot call storyContext before preparing");
      let { forceInitialArgs } = this.renderOptions;
      return this.store.getStoryContext(this.story, { forceInitialArgs });
    }
    async render({
      initial = !1,
      forceRemount = !1
    } = {}) {
      let { canvasElement } = this;
      if (!this.story)
        throw new Error("cannot render when not prepared");
      let story = this.story;
      if (!canvasElement)
        throw new Error("cannot render when canvasElement is unset");
      let {
        id: id2,
        componentId,
        title,
        name,
        tags,
        applyLoaders,
        applyBeforeEach,
        applyAfterEach,
        unboundStoryFn,
        playFunction,
        runStep
      } = story;
      forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController2());
      let abortSignal = this.abortController.signal, mounted = !1, isMountDestructured = story.usesMount;
      try {
        let context = {
          ...this.storyContext(),
          viewMode: this.viewMode,
          abortSignal,
          canvasElement,
          loaded: {},
          step: __name((label, play) => runStep(label, play, context), "step"),
          context: null,
          canvas: {},
          userEvent: {},
          renderToCanvas: __name(async () => {
            let teardown = await this.renderToScreen(renderContext, canvasElement);
            this.teardownRender = teardown || (() => {
            }), mounted = !0;
          }, "renderToCanvas"),
          // The story provides (set in a renderer) a mount function that is a higher order function
          // (context) => (...args) => Canvas
          //
          // Before assigning it to the context, we resolve the context dependency,
          // so that a user can just call it as await mount(...args) in their play function.
          mount: __name(async (...args) => {
            this.callbacks.showStoryDuringRender?.();
            let mountReturn = null;
            return await this.runPhase(abortSignal, "rendering", async () => {
              mountReturn = await story.mount(context)(...args);
            }), isMountDestructured && await this.runPhase(abortSignal, "playing"), mountReturn;
          }, "mount")
        };
        context.context = context;
        let renderContext = {
          componentId,
          title,
          kind: title,
          id: id2,
          name,
          story: name,
          tags,
          ...this.callbacks,
          showError: __name((error) => (this.phase = "errored", this.callbacks.showError(error)), "showError"),
          showException: __name((error) => (this.phase = "errored", this.callbacks.showException(error)), "showException"),
          forceRemount: forceRemount || this.notYetRendered,
          storyContext: context,
          storyFn: __name(() => unboundStoryFn(context), "storyFn"),
          unboundStoryFn
        };
        if (await this.runPhase(abortSignal, "loading", async () => {
          context.loaded = await applyLoaders(context);
        }), abortSignal.aborted)
          return;
        let cleanupCallbacks = await applyBeforeEach(context);
        if (this.store.addCleanupCallbacks(story, ...cleanupCallbacks), this.checkIfAborted(abortSignal) || (!mounted && !isMountDestructured && await context.mount(), this.notYetRendered = !1, abortSignal.aborted))
          return;
        let ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, unhandledErrors = /* @__PURE__ */ new Set(), onError = __name((event) => {
          event.error && unhandledErrors.add(event.error);
        }, "onError"), onUnhandledRejection = __name((event) => {
          event.reason && unhandledErrors.add(event.reason);
        }, "onUnhandledRejection");
        if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
          window?.addEventListener?.("error", onError), window?.addEventListener?.("unhandledrejection", onUnhandledRejection), this.disableKeyListeners = !0;
          try {
            if (isMountDestructured ? await playFunction(context) : (context.mount = async () => {
              throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
            }, await this.runPhase(abortSignal, "playing", async () => playFunction(context))), !mounted)
              throw new NoStoryMountedError();
            this.checkIfAborted(abortSignal), !ignoreUnhandledErrors && unhandledErrors.size > 0 ? await this.runPhase(abortSignal, "errored") : await this.runPhase(abortSignal, "played");
          } catch (error) {
            if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(abortSignal, "errored", async () => {
              this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
            }), this.story.parameters.throwPlayFunctionExceptions !== !1)
              throw error;
            console.error(error);
          }
          if (!ignoreUnhandledErrors && unhandledErrors.size > 0 && this.channel.emit(
            UNHANDLED_ERRORS_WHILE_PLAYING,
            Array.from(unhandledErrors).map(serializeError)
          ), this.disableKeyListeners = !1, window?.removeEventListener?.("unhandledrejection", onUnhandledRejection), window?.removeEventListener?.("error", onError), abortSignal.aborted)
            return;
        }
        await this.runPhase(abortSignal, "completing", async () => {
          isTestEnvironment() ? this.store.addCleanupCallbacks(story, pauseAnimations()) : await waitForAnimations(abortSignal);
        }), await this.runPhase(abortSignal, "completed", async () => {
          this.channel.emit(STORY_RENDERED, id2);
        }), this.phase !== "errored" && await this.runPhase(abortSignal, "afterEach", async () => {
          await applyAfterEach(context);
        });
        let hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0, hasSomeReportsFailed = context.reporting.reports.some(
          (report) => report.status === "failed"
        ), hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
        await this.runPhase(
          abortSignal,
          "finished",
          async () => this.channel.emit(STORY_FINISHED, {
            storyId: id2,
            status: hasStoryErrored ? "error" : "success",
            reporters: context.reporting.reports
          })
        );
      } catch (err) {
        this.phase = "errored", this.callbacks.showException(err), await this.runPhase(
          abortSignal,
          "finished",
          async () => this.channel.emit(STORY_FINISHED, {
            storyId: id2,
            status: "error",
            reporters: []
          })
        );
      }
      this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());
    }
    /**
     * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
     * enqueued, and will be executed after the current render is completed. Rerendering while playing
     * will not be enqueued, and will be executed immediately, to support rendering args changes while
     * playing.
     */
    async rerender() {
      if (this.isPending() && this.phase !== "playing")
        this.rerenderEnqueued = !0;
      else
        return this.render();
    }
    async remount() {
      return await this.teardown(), this.render({ forceRemount: !0 });
    }
    // If the story is torn down (either a new story is rendered or the docs page removes it)
    // we need to consider the fact that the initial render may not be finished
    // (possibly the loaders or the play function are still running). We use the controller
    // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
    // happens inside the user's code.
    cancelRender() {
      this.abortController.abort();
    }
    cancelPlayFunction() {
      this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
    }
    async teardown() {
      this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
      for (let i3 = 0; i3 < 3; i3 += 1) {
        if (!this.isPending()) {
          await this.teardownRender();
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
      window?.location?.reload?.(), await new Promise(() => {
      });
    }
  };
  __name(_StoryRender, "StoryRender");
  var StoryRender = _StoryRender, { fetch } = scope, STORY_INDEX_PATH = "./index.json", _Preview = class {
    constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = !0) {
      this.importFn = importFn, this.getProjectAnnotations = getProjectAnnotations, this.channel = channel, this.storyRenders = [], this.storeInitializationPromise = new Promise((resolve, reject) => {
        this.resolveStoreInitializationPromise = resolve, this.rejectStoreInitializationPromise = reject;
      }), shouldInitialize && this.initialize();
    }
    // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
    // That proxies through to the store once ready, and errors beforehand. This means we can set
    // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
    // similarly integrators can access the `storyStore` on the preview at any time, although
    // it is considered deprecated and we will no longer allow access in 9.0
    get storyStore() {
      return new Proxy(
        {},
        {
          get: __name((_3, method) => {
            if (this.storyStoreValue)
              return deprecate("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[method];
            throw new StoryStoreAccessedBeforeInitializationError();
          }, "get")
        }
      );
    }
    // INITIALIZATION
    async initialize() {
      this.setupListeners();
      try {
        let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
        await this.runBeforeAllHook(projectAnnotations), await this.initializeWithProjectAnnotations(projectAnnotations);
        let userAgent = globalThis?.navigator?.userAgent;
        await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });
      } catch (err) {
        this.rejectStoreInitializationPromise(err);
      }
    }
    ready() {
      return this.storeInitializationPromise;
    }
    setupListeners() {
      this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this)), this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
    }
    async getProjectAnnotationsOrRenderError() {
      try {
        let projectAnnotations = await this.getProjectAnnotations();
        if (this.renderToCanvas = projectAnnotations.renderToCanvas, !this.renderToCanvas)
          throw new MissingRenderToCanvasError();
        return projectAnnotations;
      } catch (err) {
        throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
      }
    }
    // If initialization gets as far as project annotations, this function runs.
    async initializeWithProjectAnnotations(projectAnnotations) {
      this.projectAnnotationsBeforeInitialization = projectAnnotations;
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        return this.initializeWithStoryIndex(storyIndex);
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
    }
    async runBeforeAllHook(projectAnnotations) {
      try {
        await this.beforeAllCleanup?.(), this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
      } catch (err) {
        throw this.renderPreviewEntryError("Error in beforeAll hook:", err), err;
      }
    }
    async getStoryIndexFromServer() {
      let result = await fetch(STORY_INDEX_PATH);
      if (result.status === 200)
        return result.json();
      throw new StoryIndexFetchError({ text: await result.text() });
    }
    // If initialization gets as far as the story index, this function runs.
    initializeWithStoryIndex(storyIndex) {
      if (!this.projectAnnotationsBeforeInitialization)
        throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
      this.storyStoreValue = new StoryStore(
        storyIndex,
        this.importFn,
        this.projectAnnotationsBeforeInitialization
      ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
    }
    async setInitialGlobals() {
      this.emitGlobals();
    }
    emitGlobals() {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
      let payload = {
        globals: this.storyStoreValue.userGlobals.get() || {},
        globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
      };
      this.channel.emit(SET_GLOBALS, payload);
    }
    // EVENT HANDLERS
    // This happens when a config file gets reloaded
    async onGetProjectAnnotationsChanged({
      getProjectAnnotations
    }) {
      delete this.previewEntryError, this.getProjectAnnotations = getProjectAnnotations;
      let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      if (await this.runBeforeAllHook(projectAnnotations), !this.storyStoreValue) {
        await this.initializeWithProjectAnnotations(projectAnnotations);
        return;
      }
      this.storyStoreValue.setProjectAnnotations(projectAnnotations), this.emitGlobals();
    }
    async onStoryIndexChanged() {
      if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
        try {
          let storyIndex = await this.getStoryIndexFromServer();
          if (this.projectAnnotationsBeforeInitialization) {
            this.initializeWithStoryIndex(storyIndex);
            return;
          }
          await this.onStoriesChanged({ storyIndex });
        } catch (err) {
          throw this.renderPreviewEntryError("Error loading story index:", err), err;
        }
    }
    // This happens when a glob gets HMR-ed
    async onStoriesChanged({
      importFn,
      storyIndex
    }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
      await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });
    }
    async onUpdateGlobals({
      globals: updatedGlobals,
      currentStory
    }) {
      if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
      if (this.storyStoreValue.userGlobals.update(updatedGlobals), currentStory) {
        let { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
        this.channel.emit(GLOBALS_UPDATED, {
          initialGlobals: initialGlobals5,
          userGlobals,
          storyGlobals,
          globals
        });
      } else {
        let { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
        this.channel.emit(GLOBALS_UPDATED, {
          initialGlobals: initialGlobals5,
          userGlobals: globals,
          storyGlobals: {},
          globals
        });
      }
      await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
    }
    async onUpdateArgs({ storyId, updatedArgs }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
      this.storyStoreValue.args.update(storyId, updatedArgs), await Promise.all(
        this.storyRenders.filter((r2) => r2.id === storyId && !r2.renderOptions.forceInitialArgs).map(
          (r2) => (
            // We only run the play function, with in a force remount.
            // But when mount is destructured, the rendering happens inside of the play function.
            r2.story && r2.story.usesMount ? r2.remount() : r2.rerender()
          )
        )
      ), this.channel.emit(STORY_ARGS_UPDATED, {
        storyId,
        args: this.storyStoreValue.args.get(storyId)
      });
    }
    async onRequestArgTypesInfo({ id: id2, payload }) {
      try {
        await this.storeInitializationPromise;
        let story = await this.storyStoreValue?.loadStory(payload);
        this.channel.emit(ARGTYPES_INFO_RESPONSE, {
          id: id2,
          success: !0,
          payload: { argTypes: story?.argTypes || {} },
          error: null
        });
      } catch (e) {
        this.channel.emit(ARGTYPES_INFO_RESPONSE, {
          id: id2,
          success: !1,
          error: e?.message
        });
      }
    }
    async onResetArgs({ storyId, argNames }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
      let story = this.storyRenders.find((r2) => r2.id === storyId)?.story || await this.storyStoreValue.loadStory({ storyId }), updatedArgs = (argNames || [
        .../* @__PURE__ */ new Set([
          ...Object.keys(story.initialArgs),
          ...Object.keys(this.storyStoreValue.args.get(storyId))
        ])
      ]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
      await this.onUpdateArgs({ storyId, updatedArgs });
    }
    // ForceReRender does not include a story id, so we simply must
    // re-render all stories in case they are relevant
    async onForceReRender() {
      await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
    }
    async onForceRemount({ storyId }) {
      await Promise.all(this.storyRenders.filter((r2) => r2.id === storyId).map((r2) => r2.remount()));
    }
    async onStoryHotUpdated() {
      await Promise.all(this.storyRenders.map((r2) => r2.cancelPlayFunction()));
    }
    // Used by docs to render a story to a given element
    // Note this short-circuits the `prepare()` phase of the StoryRender,
    // main to be consistent with the previous behaviour. In the future,
    // we will change it to go ahead and load the story, which will end up being
    // "instant", although async.
    renderStoryToElement(story, element, callbacks, options2) {
      if (!this.renderToCanvas || !this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({
          methodName: "renderStoryToElement"
        });
      let render2 = new StoryRender(
        this.channel,
        this.storyStoreValue,
        this.renderToCanvas,
        callbacks,
        story.id,
        "docs",
        options2,
        story
      );
      return render2.renderToElement(element), this.storyRenders.push(render2), async () => {
        await this.teardownRender(render2);
      };
    }
    async teardownRender(render2, { viewModeChanged } = {}) {
      this.storyRenders = this.storyRenders.filter((r2) => r2 !== render2), await render2?.teardown?.({ viewModeChanged });
    }
    // API
    async loadStory({ storyId }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
      return this.storyStoreValue.loadStory({ storyId });
    }
    getStoryContext(story, { forceInitialArgs = !1 } = {}) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
      return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
    }
    async extract(options2) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
      if (this.previewEntryError)
        throw this.previewEntryError;
      return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(options2);
    }
    // UTILITIES
    renderPreviewEntryError(reason, err) {
      this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
    }
  };
  __name(_Preview, "Preview");
  var Preview = _Preview, _DocsContext = class {
    constructor(channel, store, renderStoryToElement, csfFiles) {
      this.channel = channel, this.store = store, this.renderStoryToElement = renderStoryToElement, this.storyIdByName = __name((storyName) => {
        let storyId = this.nameToStoryId.get(storyName);
        if (storyId)
          return storyId;
        throw new Error(`No story found with that name: ${storyName}`);
      }, "storyIdByName"), this.componentStories = __name(() => this.componentStoriesValue, "componentStories"), this.componentStoriesFromCSFFile = __name((csfFile) => this.store.componentStoriesFromCSFFile({ csfFile }), "componentStoriesFromCSFFile"), this.storyById = __name((storyId) => {
        if (!storyId) {
          if (!this.primaryStory)
            throw new Error(
              "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
            );
          return this.primaryStory;
        }
        let csfFile = this.storyIdToCSFFile.get(storyId);
        if (!csfFile)
          throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
        return this.store.storyFromCSFFile({ storyId, csfFile });
      }, "storyById"), this.getStoryContext = __name((story) => ({
        ...this.store.getStoryContext(story),
        loaded: {},
        viewMode: "docs"
      }), "getStoryContext"), this.loadStory = __name((id2) => this.store.loadStory({ storyId: id2 }), "loadStory"), this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), csfFiles.forEach((csfFile, index3) => {
        this.referenceCSFFile(csfFile);
      });
    }
    // This docs entry references this CSF file and can synchronously load the stories, as well
    // as reference them by module export. If the CSF is part of the "component" stories, they
    // can also be referenced by name and are in the componentStories list.
    referenceCSFFile(csfFile) {
      this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
        let annotation = csfFile.stories[story.id];
        this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
      });
    }
    attachCSFFile(csfFile) {
      if (!this.exportsToCSFFile.has(csfFile.moduleExports))
        throw new Error("Cannot attach a CSF file that has not been referenced");
      if (this.attachedCSFFiles.has(csfFile))
        return;
      this.attachedCSFFiles.add(csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
        this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
      });
    }
    referenceMeta(metaExports, attach) {
      let resolved = this.resolveModuleExport(metaExports);
      if (resolved.type !== "meta")
        throw new Error(
          "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
        );
      attach && this.attachCSFFile(resolved.csfFile);
    }
    get projectAnnotations() {
      let { projectAnnotations } = this.store;
      if (!projectAnnotations)
        throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
      return projectAnnotations;
    }
    resolveAttachedModuleExportType(moduleExportType) {
      if (moduleExportType === "story") {
        if (!this.primaryStory)
          throw new Error(
            "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
          );
        return { type: "story", story: this.primaryStory };
      }
      if (this.attachedCSFFiles.size === 0)
        throw new Error(
          "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
        );
      let firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
      if (moduleExportType === "meta")
        return { type: "meta", csfFile: firstAttachedCSFFile };
      let { component } = firstAttachedCSFFile.meta;
      if (!component)
        throw new Error(
          "Attached CSF file does not defined a component, did you forget to export one?"
        );
      return { type: "component", component };
    }
    resolveModuleExport(moduleExportOrType) {
      let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
      if (csfFile)
        return { type: "meta", csfFile };
      let story = this.exportToStory.get(
        isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
      );
      return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
    }
    resolveOf(moduleExportOrType, validTypes = []) {
      let resolved;
      if (["component", "meta", "story"].includes(moduleExportOrType)) {
        let type = moduleExportOrType;
        resolved = this.resolveAttachedModuleExportType(type);
      } else
        resolved = this.resolveModuleExport(moduleExportOrType);
      if (validTypes.length && !validTypes.includes(resolved.type)) {
        let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
        throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
          ", "
        )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
      }
      switch (resolved.type) {
        case "component":
          return {
            ...resolved,
            projectAnnotations: this.projectAnnotations
          };
        case "meta":
          return {
            ...resolved,
            preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
          };
        case "story":
        default:
          return resolved;
      }
    }
  };
  __name(_DocsContext, "DocsContext");
  var DocsContext = _DocsContext, _CsfDocsRender = class {
    constructor(channel, store, entry, callbacks) {
      this.channel = channel, this.store = store, this.entry = entry, this.callbacks = callbacks, this.type = "docs", this.subtype = "csf", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = entry.id, this.renderId = Date.now();
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
      if (this.torndown)
        throw PREPARE_ABORTED;
      let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(
        entryExports,
        importPath,
        title
      ), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
      this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = !1;
    }
    isEqual(other) {
      return !!(this.id === other.id && this.story && this.story === other.story);
    }
    docsContext(renderStoryToElement) {
      if (!this.csfFiles)
        throw new Error("Cannot render docs before preparing");
      let docsContext = new DocsContext(
        this.channel,
        this.store,
        renderStoryToElement,
        this.csfFiles
      );
      return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
    }
    async renderToElement(canvasElement, renderStoryToElement) {
      if (!this.story || !this.csfFiles)
        throw new Error("Cannot render docs before preparing");
      let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
      if (!docsParameter)
        throw new Error(
          "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
        );
      let renderer = await docsParameter.renderer(), { render: render2 } = renderer, renderDocs = __name(async () => {
        try {
          await render2(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
        } catch (err) {
          this.callbacks.showException(err);
        }
      }, "renderDocs");
      return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
        !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
      }, renderDocs();
    }
    async teardown({ viewModeChanged } = {}) {
      this.teardownRender?.({ viewModeChanged }), this.torndown = !0;
    }
  };
  __name(_CsfDocsRender, "CsfDocsRender");
  var CsfDocsRender = _CsfDocsRender, _MdxDocsRender = class {
    constructor(channel, store, entry, callbacks) {
      this.channel = channel, this.store = store, this.entry = entry, this.callbacks = callbacks, this.type = "docs", this.subtype = "mdx", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = entry.id, this.renderId = Date.now();
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
      if (this.torndown)
        throw PREPARE_ABORTED;
      this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = !1;
    }
    isEqual(other) {
      return !!(this.id === other.id && this.exports && this.exports === other.exports);
    }
    docsContext(renderStoryToElement) {
      if (!this.csfFiles)
        throw new Error("Cannot render docs before preparing");
      return new DocsContext(
        this.channel,
        this.store,
        renderStoryToElement,
        this.csfFiles
      );
    }
    async renderToElement(canvasElement, renderStoryToElement) {
      if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
        throw new Error("Cannot render docs before preparing");
      let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters ?? {};
      if (!docs)
        throw new Error(
          "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
        );
      let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render: render2 } = renderer, renderDocs = __name(async () => {
        try {
          await render2(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
        } catch (err) {
          this.callbacks.showException(err);
        }
      }, "renderDocs");
      return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
        !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = !0);
      }, renderDocs();
    }
    async teardown({ viewModeChanged } = {}) {
      this.teardownRender?.({ viewModeChanged }), this.torndown = !0;
    }
  };
  __name(_MdxDocsRender, "MdxDocsRender");
  var MdxDocsRender = _MdxDocsRender, globalWindow2 = globalThis;
  function focusInInput(event) {
    let target = event.composedPath && event.composedPath()[0] || event.target;
    return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
  }
  __name(focusInInput, "focusInInput");
  var ATTACHED_MDX_TAG = "attached-mdx", UNATTACHED_MDX_TAG = "unattached-mdx";
  function isMdxEntry({ tags }) {
    return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);
  }
  __name(isMdxEntry, "isMdxEntry");
  function isStoryRender(r2) {
    return r2.type === "story";
  }
  __name(isStoryRender, "isStoryRender");
  function isDocsRender(r2) {
    return r2.type === "docs";
  }
  __name(isDocsRender, "isDocsRender");
  function isCsfDocsRender(r2) {
    return isDocsRender(r2) && r2.subtype === "csf";
  }
  __name(isCsfDocsRender, "isCsfDocsRender");
  var _PreviewWithSelection = class extends Preview {
    constructor(importFn, getProjectAnnotations, selectionStore, view) {
      super(importFn, getProjectAnnotations, void 0, !1), this.importFn = importFn, this.getProjectAnnotations = getProjectAnnotations, this.selectionStore = selectionStore, this.view = view, this.initialize();
    }
    setupListeners() {
      super.setupListeners(), globalWindow2.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
    }
    async setInitialGlobals() {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "setInitialGlobals" });
      let { globals } = this.selectionStore.selectionSpecifier || {};
      globals && this.storyStoreValue.userGlobals.updateFromPersisted(globals), this.emitGlobals();
    }
    // If initialization gets as far as the story index, this function runs.
    async initializeWithStoryIndex(storyIndex) {
      return await super.initializeWithStoryIndex(storyIndex), this.selectSpecifiedStory();
    }
    // Use the selection specifier to choose a story, then render it
    async selectSpecifiedStory() {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({
          methodName: "selectSpecifiedStory"
        });
      if (this.selectionStore.selection) {
        await this.renderSelection();
        return;
      }
      if (!this.selectionStore.selectionSpecifier) {
        this.renderMissingStory();
        return;
      }
      let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);
      if (!entry) {
        storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new EmptyIndexError()) : this.renderStoryLoadingException(
          storySpecifier,
          new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })
        );
        return;
      }
      let { id: storyId, type: viewMode } = entry;
      this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });
    }
    // EVENT HANDLERS
    // This happens when a config file gets reloaded
    async onGetProjectAnnotationsChanged({
      getProjectAnnotations
    }) {
      await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();
    }
    // This happens when a glob gets HMR-ed
    async onStoriesChanged({
      importFn,
      storyIndex
    }) {
      await super.onStoriesChanged({ importFn, storyIndex }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
    }
    onKeydown(event) {
      if (!this.storyRenders.find((r2) => r2.disableKeyListeners) && !focusInInput(event)) {
        let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
        this.channel.emit(PREVIEW_KEYDOWN, {
          event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }
        });
      }
    }
    async onSetCurrentStory(selection) {
      this.selectionStore.setSelection({ viewMode: "story", ...selection }), await this.storeInitializationPromise, this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
    }
    onUpdateQueryParams(queryParams) {
      this.selectionStore.setQueryParams(queryParams);
    }
    async onUpdateGlobals({ globals }) {
      let currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;
      super.onUpdateGlobals({ globals, currentStory }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await this.currentRender.rerender?.();
    }
    async onUpdateArgs({ storyId, updatedArgs }) {
      super.onUpdateArgs({ storyId, updatedArgs });
    }
    async onPreloadStories({ ids }) {
      await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(ids.map((id2) => this.storyStoreValue?.loadEntry(id2)));
    }
    // RENDERING
    // We can either have:
    // - a story selected in "story" viewMode,
    //     in which case we render it to the root element, OR
    // - a story selected in "docs" viewMode,
    //     in which case we render the docsPage for that story
    async renderSelection({ persistedArgs } = {}) {
      let { renderToCanvas } = this;
      if (!this.storyStoreValue || !renderToCanvas)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "renderSelection" });
      let { selection } = this.selectionStore;
      if (!selection)
        throw new Error("Cannot call renderSelection as no selection was made");
      let { storyId } = selection, entry;
      try {
        entry = await this.storyStoreValue.storyIdToEntry(storyId);
      } catch (err) {
        this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
        return;
      }
      let storyIdChanged = this.currentSelection?.storyId !== storyId, viewModeChanged = this.currentRender?.type !== entry.type;
      entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
      let render2;
      entry.type === "story" ? render2 = new StoryRender(
        this.channel,
        this.storyStoreValue,
        renderToCanvas,
        this.mainStoryCallbacks(storyId),
        storyId,
        "story"
      ) : isMdxEntry(entry) ? render2 = new MdxDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      ) : render2 = new CsfDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      );
      let lastSelection = this.currentSelection;
      this.currentSelection = selection;
      let lastRender = this.currentRender;
      this.currentRender = render2;
      try {
        await render2.prepare();
      } catch (err) {
        lastRender && await this.teardownRender(lastRender), err !== PREPARE_ABORTED && this.renderStoryLoadingException(storyId, err);
        return;
      }
      let implementationChanged = !storyIdChanged && lastRender && !render2.isEqual(lastRender);
      if (persistedArgs && isStoryRender(render2) && (invariant(!!render2.story), this.storyStoreValue.args.updateFromPersisted(render2.story, persistedArgs)), lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
        this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
        return;
      }
      if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render2)) {
        invariant(!!render2.story);
        let {
          parameters: parameters2,
          initialArgs,
          argTypes,
          unmappedArgs,
          initialGlobals: initialGlobals5,
          userGlobals,
          storyGlobals,
          globals
        } = this.storyStoreValue.getStoryContext(render2.story);
        this.channel.emit(STORY_PREPARED, {
          id: storyId,
          parameters: parameters2,
          initialArgs,
          argTypes,
          args: unmappedArgs
        }), this.channel.emit(GLOBALS_UPDATED, { userGlobals, storyGlobals, globals, initialGlobals: initialGlobals5 });
      } else {
        let { parameters: parameters2 } = this.storyStoreValue.projectAnnotations, { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
        if (this.channel.emit(GLOBALS_UPDATED, {
          globals,
          initialGlobals: initialGlobals5,
          storyGlobals: {},
          userGlobals: globals
        }), isCsfDocsRender(render2) || render2.entry.tags?.includes(ATTACHED_MDX_TAG)) {
          if (!render2.csfFiles)
            throw new MdxFileWithNoCsfReferencesError({ storyId });
          ({ parameters: parameters2 } = this.storyStoreValue.preparedMetaFromCSFFile({
            csfFile: render2.csfFiles[0]
          }));
        }
        this.channel.emit(DOCS_PREPARED, {
          id: storyId,
          parameters: parameters2
        });
      }
      isStoryRender(render2) ? (invariant(!!render2.story), this.storyRenders.push(render2), this.currentRender.renderToElement(
        this.view.prepareForStory(render2.story)
      )) : this.currentRender.renderToElement(
        this.view.prepareForDocs(),
        // This argument is used for docs, which is currently only compatible with HTMLElements
        this.renderStoryToElement.bind(this)
      );
    }
    async teardownRender(render2, { viewModeChanged = !1 } = {}) {
      this.storyRenders = this.storyRenders.filter((r2) => r2 !== render2), await render2?.teardown?.({ viewModeChanged });
    }
    // UTILITIES
    mainStoryCallbacks(storyId) {
      return {
        showStoryDuringRender: __name(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
        showMain: __name(() => this.view.showMain(), "showMain"),
        showError: __name((err) => this.renderError(storyId, err), "showError"),
        showException: __name((err) => this.renderException(storyId, err), "showException")
      };
    }
    renderPreviewEntryError(reason, err) {
      super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
    }
    renderMissingStory() {
      this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
    }
    renderStoryLoadingException(storySpecifier, err) {
      logger.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
    }
    // renderException is used if we fail to render the story and it is uncaught by the app layer
    renderException(storyId, error) {
      let { name = "Error", message = String(error), stack } = error, renderId = this.currentRender?.renderId;
      this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay(error), logger.error(`Error rendering story '${storyId}':`), logger.error(error);
    }
    // renderError is used by the various app layers to inform the user they have done something
    // wrong -- for instance returned the wrong thing from a story
    renderError(storyId, { title, description }) {
      let renderId = this.currentRender?.renderId;
      this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay({ message: title, stack: description }), logger.error(`Error rendering story ${title}: ${description}`);
    }
  };
  __name(_PreviewWithSelection, "PreviewWithSelection");
  var PreviewWithSelection = _PreviewWithSelection, import_picoquery2 = __toESM2(require_main(), 1), import_picoquery = __toESM2(require_main(), 1), VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/, NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/, HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, validateArgs = __name((key = "", value2) => key === null || key === "" || !VALIDATION_REGEXP.test(key) ? !1 : value2 == null || value2 instanceof Date || typeof value2 == "number" || typeof value2 == "boolean" ? !0 : typeof value2 == "string" ? VALIDATION_REGEXP.test(value2) || NUMBER_REGEXP.test(value2) || HEX_REGEXP.test(value2) || COLOR_REGEXP.test(value2) : Array.isArray(value2) ? value2.every((v3) => validateArgs(key, v3)) : isPlainObject(value2) ? Object.entries(value2).every(([k3, v3]) => validateArgs(k3, v3)) : !1, "validateArgs"), QUERY_OPTIONS = {
    delimiter: ";",
    // we're parsing a single query param
    nesting: !0,
    arrayRepeat: !0,
    arrayRepeatSyntax: "bracket",
    nestingSyntax: "js",
    // objects are encoded using dot notation
    valueDeserializer(str2) {
      if (str2.startsWith("!")) {
        if (str2 === "!undefined")
          return;
        if (str2 === "!null")
          return null;
        if (str2 === "!true")
          return !0;
        if (str2 === "!false")
          return !1;
        if (str2.startsWith("!date(") && str2.endsWith(")"))
          return new Date(str2.replaceAll(" ", "+").slice(6, -1));
        if (str2.startsWith("!hex(") && str2.endsWith(")"))
          return `#${str2.slice(5, -1)}`;
        let color2 = str2.slice(1).match(COLOR_REGEXP);
        if (color2)
          return str2.startsWith("!rgba") || str2.startsWith("!RGBA") ? `${color2[1]}(${color2[2]}, ${color2[3]}, ${color2[4]}, ${color2[5]})` : str2.startsWith("!hsla") || str2.startsWith("!HSLA") ? `${color2[1]}(${color2[2]}, ${color2[3]}%, ${color2[4]}%, ${color2[5]})` : str2.startsWith("!rgb") || str2.startsWith("!RGB") ? `${color2[1]}(${color2[2]}, ${color2[3]}, ${color2[4]})` : `${color2[1]}(${color2[2]}, ${color2[3]}%, ${color2[4]}%)`;
      }
      return NUMBER_REGEXP.test(str2) ? Number(str2) : str2;
    }
  }, parseArgsParam = __name((argsString) => {
    let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
    return Object.entries((0, import_picoquery.parse)(parts.join(";"), QUERY_OPTIONS)).reduce((acc, [key, value2]) => validateArgs(key, value2) ? Object.assign(acc, { [key]: value2 }) : (once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), acc), {});
  }, "parseArgsParam"), { history, document: document23 } = scope;
  function pathToId(path) {
    let match2 = (path || "").match(/^\/story\/(.+)/);
    if (!match2)
      throw new Error(`Invalid path '${path}',  must start with '/story/'`);
    return match2[1];
  }
  __name(pathToId, "pathToId");
  var getQueryString = __name(({
    selection,
    extraParams
  }) => {
    let search = document23?.location.search.slice(1), { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);
    return `?${(0, import_picoquery2.stringify)({
      ...rest,
      ...extraParams,
      ...selection && { id: selection.storyId, viewMode: selection.viewMode }
    })}`;
  }, "getQueryString"), setPath = __name((selection) => {
    if (!selection)
      return;
    let query = getQueryString({ selection }), { hash: hash3 = "" } = document23.location;
    document23.title = selection.storyId, history.replaceState({}, "", `${document23.location.pathname}${query}${hash3}`);
  }, "setPath"), isObject = __name((val) => val != null && typeof val == "object" && Array.isArray(val) === !1, "isObject"), getFirstString = __name((v3) => {
    if (v3 !== void 0) {
      if (typeof v3 == "string")
        return v3;
      if (Array.isArray(v3))
        return getFirstString(v3[0]);
      if (isObject(v3))
        return getFirstString(
          Object.values(v3).filter(Boolean)
        );
    }
  }, "getFirstString"), getSelectionSpecifierFromPath = __name(() => {
    if (typeof document23 < "u") {
      let queryStr = document23.location.search.slice(1), query = (0, import_picoquery2.parse)(queryStr), args = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
      (typeof viewMode != "string" || !viewMode.match(/docs|story/)) && (viewMode = "story");
      let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
      if (storyId)
        return { storySpecifier: storyId, args, globals, viewMode };
    }
    return null;
  }, "getSelectionSpecifierFromPath"), _UrlStore = class {
    constructor() {
      this.selectionSpecifier = getSelectionSpecifierFromPath();
    }
    setSelection(selection) {
      this.selection = selection, setPath(this.selection);
    }
    setQueryParams(queryParams) {
      let query = getQueryString({ extraParams: queryParams }), { hash: hash3 = "" } = document23.location;
      history.replaceState({}, "", `${document23.location.pathname}${query}${hash3}`);
    }
  };
  __name(_UrlStore, "UrlStore");
  var UrlStore = _UrlStore, import_ansi_to_html = __toESM2(require_ansi_to_html(), 1), import_picoquery3 = __toESM2(require_main(), 1), { document: document3 } = scope, PREPARING_DELAY = 100, Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {}), classes = {
    PREPARING_STORY: "sb-show-preparing-story",
    PREPARING_DOCS: "sb-show-preparing-docs",
    MAIN: "sb-show-main",
    NOPREVIEW: "sb-show-nopreview",
    ERROR: "sb-show-errordisplay"
  }, layoutClassMap = {
    centered: "sb-main-centered",
    fullscreen: "sb-main-fullscreen",
    padded: "sb-main-padded"
  }, ansiConverter = new import_ansi_to_html.default({
    escapeXML: !0
  }), _WebView = class {
    constructor() {
      if (this.testing = !1, typeof document3 < "u") {
        let { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document3.location.search.slice(1));
        switch (__SPECIAL_TEST_PARAMETER__) {
          case "preparing-story": {
            this.showPreparingStory(), this.testing = !0;
            break;
          }
          case "preparing-docs": {
            this.showPreparingDocs(), this.testing = !0;
            break;
          }
          default:
        }
      }
    }
    // Get ready to render a story, returning the element to render to
    prepareForStory(story) {
      return this.showStory(), this.applyLayout(story.parameters.layout), document3.documentElement.scrollTop = 0, document3.documentElement.scrollLeft = 0, this.storyRoot();
    }
    storyRoot() {
      return document3.getElementById("storybook-root");
    }
    prepareForDocs() {
      return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), document3.documentElement.scrollTop = 0, document3.documentElement.scrollLeft = 0, this.docsRoot();
    }
    docsRoot() {
      return document3.getElementById("storybook-docs");
    }
    applyLayout(layout = "padded") {
      if (layout === "none") {
        document3.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
        return;
      }
      this.checkIfLayoutExists(layout);
      let layoutClass = layoutClassMap[layout];
      document3.body.classList.remove(this.currentLayoutClass), document3.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
    }
    checkIfLayoutExists(layout) {
      layoutClassMap[layout] || logger.warn(
        dedent`
          The desired layout: ${layout} is not a valid option.
          The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.
        `
      );
    }
    showMode(mode) {
      clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
        otherMode === mode ? document3.body.classList.add(classes[otherMode]) : document3.body.classList.remove(classes[otherMode]);
      });
    }
    showErrorDisplay({ message = "", stack = "" }) {
      let header = message, detail = stack, parts = message.split(`
`);
      parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`).replace(/^\n/, "")), document3.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document3.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode(
        "ERROR"
        /* ERROR */
      );
    }
    showNoPreview() {
      this.testing || (this.showMode(
        "NOPREVIEW"
        /* NOPREVIEW */
      ), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
    }
    showPreparingStory({ immediate = !1 } = {}) {
      clearTimeout(this.preparingTimeout), immediate ? this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      ) : this.preparingTimeout = setTimeout(
        () => this.showMode(
          "PREPARING_STORY"
          /* PREPARING_STORY */
        ),
        PREPARING_DELAY
      );
    }
    showPreparingDocs({ immediate = !1 } = {}) {
      clearTimeout(this.preparingTimeout), immediate ? this.showMode(
        "PREPARING_DOCS"
        /* PREPARING_DOCS */
      ) : this.preparingTimeout = setTimeout(() => this.showMode(
        "PREPARING_DOCS"
        /* PREPARING_DOCS */
      ), PREPARING_DELAY);
    }
    showMain() {
      this.showMode(
        "MAIN"
        /* MAIN */
      );
    }
    showDocs() {
      this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
    }
    showStory() {
      this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
    }
    showStoryDuringRender() {
      document3.body.classList.add(classes.MAIN);
    }
  };
  __name(_WebView, "WebView");
  var WebView = _WebView, _PreviewWeb = class extends PreviewWithSelection {
    constructor(importFn, getProjectAnnotations) {
      super(importFn, getProjectAnnotations, new UrlStore(), new WebView()), this.importFn = importFn, this.getProjectAnnotations = getProjectAnnotations, scope.__STORYBOOK_PREVIEW__ = this;
    }
  };
  __name(_PreviewWeb, "PreviewWeb");
  var { document: document4 } = scope, runScriptTypes = [
    "application/javascript",
    "application/ecmascript",
    "application/x-ecmascript",
    "application/x-javascript",
    "text/ecmascript",
    "text/javascript",
    "text/javascript1.0",
    "text/javascript1.1",
    "text/javascript1.2",
    "text/javascript1.3",
    "text/javascript1.4",
    "text/javascript1.5",
    "text/jscript",
    "text/livescript",
    "text/x-ecmascript",
    "text/x-javascript",
    // Support modern javascript
    "module"
  ], SCRIPT = "script", SCRIPTS_ROOT_ID = "scripts-root";
  function simulateDOMContentLoaded() {
    let DOMContentLoadedEvent = document4.createEvent("Event");
    DOMContentLoadedEvent.initEvent("DOMContentLoaded", !0, !0), document4.dispatchEvent(DOMContentLoadedEvent);
  }
  __name(simulateDOMContentLoaded, "simulateDOMContentLoaded");
  function insertScript($script, callback, $scriptRoot) {
    let scriptEl = document4.createElement("script");
    scriptEl.type = $script.type === "module" ? "module" : "text/javascript", $script.src ? (scriptEl.onload = callback, scriptEl.onerror = callback, scriptEl.src = $script.src) : scriptEl.textContent = $script.innerText, $scriptRoot ? $scriptRoot.appendChild(scriptEl) : document4.head.appendChild(scriptEl), $script.parentNode.removeChild($script), $script.src || callback();
  }
  __name(insertScript, "insertScript");
  function insertScriptsSequentially(scriptsToExecute, callback, index3 = 0) {
    scriptsToExecute[index3](() => {
      index3++, index3 === scriptsToExecute.length ? callback() : insertScriptsSequentially(scriptsToExecute, callback, index3);
    });
  }
  __name(insertScriptsSequentially, "insertScriptsSequentially");
  function simulatePageLoad($container) {
    let $scriptsRoot = document4.getElementById(SCRIPTS_ROOT_ID);
    $scriptsRoot ? $scriptsRoot.innerHTML = "" : ($scriptsRoot = document4.createElement("div"), $scriptsRoot.id = SCRIPTS_ROOT_ID, document4.body.appendChild($scriptsRoot));
    let $scripts = Array.from($container.querySelectorAll(SCRIPT));
    if ($scripts.length) {
      let scriptsToExecute = [];
      $scripts.forEach(($script) => {
        let typeAttr = $script.getAttribute("type");
        (!typeAttr || runScriptTypes.includes(typeAttr)) && scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
      }), scriptsToExecute.length && insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
    } else
      simulateDOMContentLoaded();
  }
  __name(simulatePageLoad, "simulatePageLoad");
  async function emitTransformCode(source, context) {
    let transform = context.parameters?.docs?.source?.transform, { id: id2, unmappedArgs } = context, transformed = transform && source ? transform?.(source, context) : source, result = transformed ? await transformed : void 0;
    addons.getChannel().emit(SNIPPET_RENDERED, {
      id: id2,
      source: result,
      args: unmappedArgs
    });
  }
  __name(emitTransformCode, "emitTransformCode");

  // node_modules/storybook/dist/csf/index.js
  init_chunk_AB7OOPUX();
  init_chunk_NVV6MIOE();
  init_chunk_OPCDBBL3();

  // node_modules/storybook/dist/_browser-chunks/chunk-GTKOCWCT.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID5 = "storybook/highlight", HIGHLIGHT = `${ADDON_ID5}/add`, REMOVE_HIGHLIGHT = `${ADDON_ID5}/remove`, RESET_HIGHLIGHT = `${ADDON_ID5}/reset`, SCROLL_INTO_VIEW = `${ADDON_ID5}/scroll-into-view`, MAX_Z_INDEX = 2147483647, MIN_TOUCH_AREA_SIZE = 28;

  // node_modules/storybook/dist/_browser-chunks/chunk-ECQ75MKQ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-PB6FZ3WE.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-XW6KSYKF.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var PARAM_KEY4 = "actions", ADDON_ID6 = "storybook/actions", PANEL_ID2 = `${ADDON_ID6}/panel`, EVENT_ID = `${ADDON_ID6}/action-event`, CLEAR_ID = `${ADDON_ID6}/action-clear`;

  // node_modules/storybook/dist/_browser-chunks/chunk-PB6FZ3WE.js
  init_chunk_MM7DTO55();
  init_dist();

  // node_modules/storybook/dist/preview-api/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_AB7OOPUX();
  init_chunk_NVV6MIOE();
  init_chunk_OPCDBBL3();
  init_chunk_MM7DTO55();

  // node_modules/storybook/dist/_browser-chunks/chunk-PB6FZ3WE.js
  var config = {
    depth: 10,
    clearOnStoryChange: !0,
    limit: 50
  }, configureActions = __name((options2 = {}) => {
    Object.assign(config, options2);
  }, "configureActions"), findProto = __name((obj, callback) => {
    let proto = Object.getPrototypeOf(obj);
    return !proto || callback(proto) ? proto : findProto(proto, callback);
  }, "findProto"), isReactSyntheticEvent = __name((e) => !!(typeof e == "object" && e && findProto(e, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e.persist == "function"), "isReactSyntheticEvent"), serializeArg = __name((a3) => {
    if (isReactSyntheticEvent(a3)) {
      let e = Object.create(
        a3.constructor.prototype,
        Object.getOwnPropertyDescriptors(a3)
      );
      e.persist();
      let viewDescriptor = Object.getOwnPropertyDescriptor(e, "view"), view = viewDescriptor?.value;
      return typeof view == "object" && view?.constructor.name === "Window" && Object.defineProperty(e, "view", {
        ...viewDescriptor,
        value: Object.create(view.constructor.prototype)
      }), e;
    }
    return a3;
  }, "serializeArg");
  function action(name, options2 = {}) {
    let actionOptions = {
      ...config,
      ...options2
    }, handler = __name(function(...args) {
      if (options2.implicit) {
        let storyRenderer = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
          (render2) => render2.phase === "playing" || render2.phase === "rendering"
        );
        if (storyRenderer) {
          let deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, error = new ImplicitActionsDuringRendering({
            phase: storyRenderer.phase,
            name,
            deprecated
          });
          if (deprecated)
            console.warn(error);
          else
            throw error;
        }
      }
      let channel = addons.getChannel(), id2 = Date.now().toString(36) + Math.random().toString(36).substring(2), minDepth = 5, serializedArgs = args.map(serializeArg), normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0], actionDisplayToEmit = {
        id: id2,
        count: 0,
        data: { name, args: normalizedArgs },
        options: {
          ...actionOptions,
          maxDepth: minDepth + (actionOptions.depth || 3)
        }
      };
      channel.emit(EVENT_ID, actionDisplayToEmit);
    }, "actionHandler");
    return handler.isAction = !0, handler.implicit = options2.implicit, handler;
  }
  __name(action, "action");
  var actions = __name((...args) => {
    let options2 = config, names = args;
    names.length === 1 && Array.isArray(names[0]) && ([names] = names), names.length !== 1 && typeof names[names.length - 1] != "string" && (options2 = {
      ...config,
      ...names.pop()
    });
    let namesObject = names[0];
    (names.length !== 1 || typeof namesObject == "string") && (namesObject = {}, names.forEach((name) => {
      namesObject[name] = name;
    }));
    let actionsObject = {};
    return Object.keys(namesObject).forEach((name) => {
      actionsObject[name] = action(namesObject[name], options2);
    }), actionsObject;
  }, "actions");

  // node_modules/storybook/dist/_browser-chunks/chunk-HHW4FUMO.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID7 = "storybook/viewport", PARAM_KEY5 = "viewport", PANEL_ID3 = `${ADDON_ID7}/panel`, TOOL_ID2 = `${ADDON_ID7}/tool`;

  // node_modules/storybook/dist/csf/index.js
  init_chunk_MM7DTO55();

  // global-externals:storybook/test
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var test_default = __STORYBOOK_TEST__, { buildQueries, clearAllMocks, configure, createEvent, expect, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, fn: fn2, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getConfig, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, getSuggestedQuery, isInaccessible, isMockFunction, logDOM, logRoles, mocked, mocks, onMockCall, prettyDOM, prettyFormat, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers, resetAllMocks, restoreAllMocks, sb, screen, spyOn, uninstrumentedUserEvent, userEvent, waitFor, waitForElementToBeRemoved, within: within2 } = __STORYBOOK_TEST__;

  // node_modules/storybook/dist/instrumenter/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-SN4J4IQ3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var EVENTS3 = {
    CALL: "storybook/instrumenter/call",
    SYNC: "storybook/instrumenter/sync",
    START: "storybook/instrumenter/start",
    BACK: "storybook/instrumenter/back",
    GOTO: "storybook/instrumenter/goto",
    NEXT: "storybook/instrumenter/next",
    END: "storybook/instrumenter/end"
  }, CallStates = ((CallStates2) => (CallStates2.DONE = "done", CallStates2.ERROR = "error", CallStates2.ACTIVE = "active", CallStates2.WAITING = "waiting", CallStates2))(CallStates || {});

  // node_modules/storybook/dist/_browser-chunks/chunk-JVSKG4YS.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var f = {
    reset: [0, 0],
    bold: [1, 22, "\x1B[22m\x1B[1m"],
    dim: [2, 22, "\x1B[22m\x1B[2m"],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }, h = Object.entries(f);
  function a(n2) {
    return String(n2);
  }
  __name(a, "a");
  a.open = "";
  a.close = "";
  var B = h.reduce(
    (n2, [e]) => (n2[e] = a, n2),
    { isColorSupported: !1 }
  );
  function C(n2 = !1) {
    let e = typeof process < "u" ? process : void 0, i3 = e?.env || {}, g3 = e?.argv || [];
    return !("NO_COLOR" in i3 || g3.includes("--no-color")) && ("FORCE_COLOR" in i3 || g3.includes("--color") || e?.platform === "win32" || n2 && i3.TERM !== "dumb" || "CI" in i3) || typeof window < "u" && !!window.chrome;
  }
  __name(C, "C");
  function p(n2 = !1) {
    let e = C(n2), i3 = __name((r2, t, c3, o2) => {
      let l2 = "", s22 = 0;
      do
        l2 += r2.substring(s22, o2) + c3, s22 = o2 + t.length, o2 = r2.indexOf(t, s22);
      while (~o2);
      return l2 + r2.substring(s22);
    }, "i"), g3 = __name((r2, t, c3 = r2) => {
      let o2 = __name((l2) => {
        let s22 = String(l2), b3 = s22.indexOf(t, r2.length);
        return ~b3 ? r2 + i3(s22, t, c3, b3) + t : r2 + s22 + t;
      }, "o");
      return o2.open = r2, o2.close = t, o2;
    }, "g"), u3 = {
      isColorSupported: e
    }, d3 = __name((r2) => `\x1B[${r2}m`, "d");
    for (let [r2, t] of h)
      u3[r2] = e ? g3(
        d3(t[0]),
        d3(t[1]),
        t[2]
      ) : a;
    return u3;
  }
  __name(p, "p");
  var s = p();
  function _mergeNamespaces(n2, m22) {
    return m22.forEach(function(e) {
      e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k3) {
        if (k3 !== "default" && !(k3 in n2)) {
          var d3 = Object.getOwnPropertyDescriptor(e, k3);
          Object.defineProperty(n2, k3, d3.get ? d3 : {
            enumerable: !0,
            get: __name(function() {
              return e[k3];
            }, "get")
          });
        }
      });
    }), Object.freeze(n2);
  }
  __name(_mergeNamespaces, "_mergeNamespaces");
  function getKeysOfEnumerableProperties(object2, compareKeys) {
    let rawKeys = Object.keys(object2), keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
    if (Object.getOwnPropertySymbols)
      for (let symbol of Object.getOwnPropertySymbols(object2))
        Object.getOwnPropertyDescriptor(object2, symbol).enumerable && keys.push(symbol);
    return keys;
  }
  __name(getKeysOfEnumerableProperties, "getKeysOfEnumerableProperties");
  function printIteratorEntries(iterator, config2, indentation, depth, refs, printer2, separator = ": ") {
    let result = "", width = 0, current = iterator.next();
    if (!current.done) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (; !current.done; ) {
        if (result += indentationNext, width++ === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        let name = printer2(current.value[0], config2, indentationNext, depth, refs), value2 = printer2(current.value[1], config2, indentationNext, depth, refs);
        result += name + separator + value2, current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printIteratorEntries, "printIteratorEntries");
  function printIteratorValues(iterator, config2, indentation, depth, refs, printer2) {
    let result = "", width = 0, current = iterator.next();
    if (!current.done) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (; !current.done; ) {
        if (result += indentationNext, width++ === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        result += printer2(current.value, config2, indentationNext, depth, refs), current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printIteratorValues, "printIteratorValues");
  function printListItems(list, config2, indentation, depth, refs, printer2) {
    let result = "";
    list = list instanceof ArrayBuffer ? new DataView(list) : list;
    let isDataView = __name((l2) => l2 instanceof DataView, "isDataView"), length2 = isDataView(list) ? list.byteLength : list.length;
    if (length2 > 0) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (let i3 = 0; i3 < length2; i3++) {
        if (result += indentationNext, i3 === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        (isDataView(list) || i3 in list) && (result += printer2(isDataView(list) ? list.getInt8(i3) : list[i3], config2, indentationNext, depth, refs)), i3 < length2 - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printListItems, "printListItems");
  function printObjectProperties(val, config2, indentation, depth, refs, printer2) {
    let result = "", keys = getKeysOfEnumerableProperties(val, config2.compareKeys);
    if (keys.length > 0) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (let i3 = 0; i3 < keys.length; i3++) {
        let key = keys[i3], name = printer2(key, config2, indentationNext, depth, refs), value2 = printer2(val[key], config2, indentationNext, depth, refs);
        result += `${indentationNext + name}: ${value2}`, i3 < keys.length - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printObjectProperties, "printObjectProperties");
  var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, SPACE$2 = " ", serialize$5 = __name((val, config2, indentation, depth, refs, printer2) => {
    let stringedValue = val.toString();
    if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining")
      return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config2, indentation, depth, refs, printer2)}]`;
    if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining")
      return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config2, indentation, depth, refs, printer2)}}`;
    if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining")
      return stringedValue + SPACE$2 + printer2(val.sample, config2, indentation, depth, refs);
    if (typeof val.toAsymmetricMatcher != "function")
      throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    return val.toAsymmetricMatcher();
  }, "serialize$5"), test$5 = __name((val) => val && val.$$typeof === asymmetricMatcher, "test$5"), plugin$5 = {
    serialize: serialize$5,
    test: test$5
  }, SPACE$1 = " ", OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
  function testName(name) {
    return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
  }
  __name(testName, "testName");
  var test$4 = __name((val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name), "test$4");
  function isNamedNodeMap(collection) {
    return collection.constructor.name === "NamedNodeMap";
  }
  __name(isNamedNodeMap, "isNamedNodeMap");
  var serialize$4 = __name((collection, config2, indentation, depth, refs, printer2) => {
    let name = collection.constructor.name;
    return ++depth > config2.maxDepth ? `[${name}]` : (config2.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config2, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config2, indentation, depth, refs, printer2)}]`);
  }, "serialize$4"), plugin$4 = {
    serialize: serialize$4,
    test: test$4
  };
  function escapeHTML(str2) {
    return str2.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
  }
  __name(escapeHTML, "escapeHTML");
  function printProps(keys, props, config2, indentation, depth, refs, printer2) {
    let indentationNext = indentation + config2.indent, colors3 = config2.colors;
    return keys.map((key) => {
      let value2 = props[key], printed = printer2(value2, config2, indentationNext, depth, refs);
      return typeof value2 != "string" && (printed.includes(`
`) && (printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation), printed = `{${printed}}`), `${config2.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
    }).join("");
  }
  __name(printProps, "printProps");
  function printChildren(children, config2, indentation, depth, refs, printer2) {
    return children.map((child) => config2.spacingOuter + indentation + (typeof child == "string" ? printText(child, config2) : printer2(child, config2, indentation, depth, refs))).join("");
  }
  __name(printChildren, "printChildren");
  function printText(text, config2) {
    let contentColor = config2.colors.content;
    return contentColor.open + escapeHTML(text) + contentColor.close;
  }
  __name(printText, "printText");
  function printComment(comment, config2) {
    let commentColor = config2.colors.comment;
    return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
  }
  __name(printComment, "printComment");
  function printElement(type, printedProps, printedChildren, config2, indentation) {
    let tagColor = config2.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config2.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config2.min ? "" : " "}/`}>${tagColor.close}`;
  }
  __name(printElement, "printElement");
  function printElementAsLeaf(type, config2) {
    let tagColor = config2.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} \u2026${tagColor.open} />${tagColor.close}`;
  }
  __name(printElementAsLeaf, "printElementAsLeaf");
  var ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, FRAGMENT_NODE = 11, ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
  function testHasAttribute(val) {
    try {
      return typeof val.hasAttribute == "function" && val.hasAttribute("is");
    } catch {
      return !1;
    }
  }
  __name(testHasAttribute, "testHasAttribute");
  function testNode(val) {
    let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
  }
  __name(testNode, "testNode");
  var test$3 = __name((val) => {
    var _val$constructor;
    return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
  }, "test$3");
  function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
  }
  __name(nodeIsText, "nodeIsText");
  function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
  }
  __name(nodeIsComment, "nodeIsComment");
  function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
  }
  __name(nodeIsFragment, "nodeIsFragment");
  var serialize$3 = __name((node, config2, indentation, depth, refs, printer2) => {
    if (nodeIsText(node))
      return printText(node.data, config2);
    if (nodeIsComment(node))
      return printComment(node.data, config2);
    let type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
    return ++depth > config2.maxDepth ? printElementAsLeaf(type, config2) : printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config2, indentation + config2.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation);
  }, "serialize$3"), plugin$3 = {
    serialize: serialize$3,
    test: test$3
  }, IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", getImmutableName = __name((name) => `Immutable.${name}`, "getImmutableName"), printAsLeaf = __name((name) => `[${name}]`, "printAsLeaf"), SPACE = " ", LAZY = "\u2026";
  function printImmutableEntries(val, config2, indentation, depth, refs, printer2, type) {
    return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2)}}`;
  }
  __name(printImmutableEntries, "printImmutableEntries");
  function getRecordEntries(val) {
    let i3 = 0;
    return { next() {
      if (i3 < val._keys.length) {
        let key = val._keys[i3++];
        return {
          done: !1,
          value: [key, val.get(key)]
        };
      }
      return {
        done: !0,
        value: void 0
      };
    } };
  }
  __name(getRecordEntries, "getRecordEntries");
  function printImmutableRecord(val, config2, indentation, depth, refs, printer2) {
    let name = getImmutableName(val._name || "Record");
    return ++depth > config2.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config2, indentation, depth, refs, printer2)}}`;
  }
  __name(printImmutableRecord, "printImmutableRecord");
  function printImmutableSeq(val, config2, indentation, depth, refs, printer2) {
    let name = getImmutableName("Seq");
    return ++depth > config2.maxDepth ? printAsLeaf(name) : val[IS_KEYED_SENTINEL] ? `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2) : LAZY}}` : `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config2, indentation, depth, refs, printer2) : LAZY}]`;
  }
  __name(printImmutableSeq, "printImmutableSeq");
  function printImmutableValues(val, config2, indentation, depth, refs, printer2, type) {
    return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config2, indentation, depth, refs, printer2)}]`;
  }
  __name(printImmutableValues, "printImmutableValues");
  var serialize$2 = __name((val, config2, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config2, indentation, depth, refs, printer2) : printImmutableRecord(val, config2, indentation, depth, refs, printer2), "serialize$2"), test$2 = __name((val) => val && (val[IS_ITERABLE_SENTINEL] === !0 || val[IS_RECORD_SENTINEL] === !0), "test$2"), plugin$2 = {
    serialize: serialize$2,
    test: test$2
  };
  function getDefaultExportFromCjs(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
  }
  __name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
  var reactIs$1 = { exports: {} }, reactIs_production = {}, hasRequiredReactIs_production;
  function requireReactIs_production() {
    if (hasRequiredReactIs_production) return reactIs_production;
    hasRequiredReactIs_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function typeOf(object2) {
      if (typeof object2 == "object" && object2 !== null) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object2 = object2.type, object2) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object2;
              default:
                switch (object2 = object2 && object2.$$typeof, object2) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object2;
                  case REACT_CONSUMER_TYPE:
                    return object2;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    return __name(typeOf, "typeOf"), reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_production.ContextProvider = REACT_CONTEXT_TYPE, reactIs_production.Element = REACT_ELEMENT_TYPE, reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_production.Fragment = REACT_FRAGMENT_TYPE, reactIs_production.Lazy = REACT_LAZY_TYPE, reactIs_production.Memo = REACT_MEMO_TYPE, reactIs_production.Portal = REACT_PORTAL_TYPE, reactIs_production.Profiler = REACT_PROFILER_TYPE, reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_production.Suspense = REACT_SUSPENSE_TYPE, reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_production.isContextConsumer = function(object2) {
      return typeOf(object2) === REACT_CONSUMER_TYPE;
    }, reactIs_production.isContextProvider = function(object2) {
      return typeOf(object2) === REACT_CONTEXT_TYPE;
    }, reactIs_production.isElement = function(object2) {
      return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
    }, reactIs_production.isForwardRef = function(object2) {
      return typeOf(object2) === REACT_FORWARD_REF_TYPE;
    }, reactIs_production.isFragment = function(object2) {
      return typeOf(object2) === REACT_FRAGMENT_TYPE;
    }, reactIs_production.isLazy = function(object2) {
      return typeOf(object2) === REACT_LAZY_TYPE;
    }, reactIs_production.isMemo = function(object2) {
      return typeOf(object2) === REACT_MEMO_TYPE;
    }, reactIs_production.isPortal = function(object2) {
      return typeOf(object2) === REACT_PORTAL_TYPE;
    }, reactIs_production.isProfiler = function(object2) {
      return typeOf(object2) === REACT_PROFILER_TYPE;
    }, reactIs_production.isStrictMode = function(object2) {
      return typeOf(object2) === REACT_STRICT_MODE_TYPE;
    }, reactIs_production.isSuspense = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_TYPE;
    }, reactIs_production.isSuspenseList = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
    }, reactIs_production.isValidElementType = function(type) {
      return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0);
    }, reactIs_production.typeOf = typeOf, reactIs_production;
  }
  __name(requireReactIs_production, "requireReactIs_production");
  var reactIs_development$1 = {}, hasRequiredReactIs_development$1;
  function requireReactIs_development$1() {
    return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, (function() {
      function typeOf(object2) {
        if (typeof object2 == "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object2 = object2.type, object2) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object2;
                default:
                  switch (object2 = object2 && object2.$$typeof, object2) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object2;
                    case REACT_CONSUMER_TYPE:
                      return object2;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      __name(typeOf, "typeOf");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE, reactIs_development$1.Element = REACT_ELEMENT_TYPE, reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE, reactIs_development$1.Lazy = REACT_LAZY_TYPE, reactIs_development$1.Memo = REACT_MEMO_TYPE, reactIs_development$1.Portal = REACT_PORTAL_TYPE, reactIs_development$1.Profiler = REACT_PROFILER_TYPE, reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE, reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_development$1.isContextConsumer = function(object2) {
        return typeOf(object2) === REACT_CONSUMER_TYPE;
      }, reactIs_development$1.isContextProvider = function(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }, reactIs_development$1.isElement = function(object2) {
        return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }, reactIs_development$1.isForwardRef = function(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }, reactIs_development$1.isFragment = function(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }, reactIs_development$1.isLazy = function(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }, reactIs_development$1.isMemo = function(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }, reactIs_development$1.isPortal = function(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }, reactIs_development$1.isProfiler = function(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }, reactIs_development$1.isStrictMode = function(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }, reactIs_development$1.isSuspense = function(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }, reactIs_development$1.isSuspenseList = function(object2) {
        return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
      }, reactIs_development$1.isValidElementType = function(type) {
        return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0);
      }, reactIs_development$1.typeOf = typeOf;
    })()), reactIs_development$1;
  }
  __name(requireReactIs_development$1, "requireReactIs_development$1");
  var hasRequiredReactIs$1;
  function requireReactIs$1() {
    return hasRequiredReactIs$1 || (hasRequiredReactIs$1 = 1, reactIs$1.exports = requireReactIs_development$1()), reactIs$1.exports;
  }
  __name(requireReactIs$1, "requireReactIs$1");
  var reactIsExports$1 = requireReactIs$1(), index$1 = getDefaultExportFromCjs(reactIsExports$1), ReactIs19 = _mergeNamespaces({
    __proto__: null,
    default: index$1
  }, [reactIsExports$1]), reactIs = { exports: {} }, reactIs_production_min = {}, hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b3 = Symbol.for("react.element"), c3 = Symbol.for("react.portal"), d3 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f22 = Symbol.for("react.profiler"), g3 = Symbol.for("react.provider"), h22 = Symbol.for("react.context"), k3 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m22 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p22 = Symbol.for("react.memo"), q3 = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u3;
    u3 = Symbol.for("react.module.reference");
    function v3(a22) {
      if (typeof a22 == "object" && a22 !== null) {
        var r2 = a22.$$typeof;
        switch (r2) {
          case b3:
            switch (a22 = a22.type, a22) {
              case d3:
              case f22:
              case e:
              case m22:
              case n2:
                return a22;
              default:
                switch (a22 = a22 && a22.$$typeof, a22) {
                  case k3:
                  case h22:
                  case l2:
                  case q3:
                  case p22:
                  case g3:
                    return a22;
                  default:
                    return r2;
                }
            }
          case c3:
            return r2;
        }
      }
    }
    return __name(v3, "v"), reactIs_production_min.ContextConsumer = h22, reactIs_production_min.ContextProvider = g3, reactIs_production_min.Element = b3, reactIs_production_min.ForwardRef = l2, reactIs_production_min.Fragment = d3, reactIs_production_min.Lazy = q3, reactIs_production_min.Memo = p22, reactIs_production_min.Portal = c3, reactIs_production_min.Profiler = f22, reactIs_production_min.StrictMode = e, reactIs_production_min.Suspense = m22, reactIs_production_min.SuspenseList = n2, reactIs_production_min.isAsyncMode = function() {
      return !1;
    }, reactIs_production_min.isConcurrentMode = function() {
      return !1;
    }, reactIs_production_min.isContextConsumer = function(a22) {
      return v3(a22) === h22;
    }, reactIs_production_min.isContextProvider = function(a22) {
      return v3(a22) === g3;
    }, reactIs_production_min.isElement = function(a22) {
      return typeof a22 == "object" && a22 !== null && a22.$$typeof === b3;
    }, reactIs_production_min.isForwardRef = function(a22) {
      return v3(a22) === l2;
    }, reactIs_production_min.isFragment = function(a22) {
      return v3(a22) === d3;
    }, reactIs_production_min.isLazy = function(a22) {
      return v3(a22) === q3;
    }, reactIs_production_min.isMemo = function(a22) {
      return v3(a22) === p22;
    }, reactIs_production_min.isPortal = function(a22) {
      return v3(a22) === c3;
    }, reactIs_production_min.isProfiler = function(a22) {
      return v3(a22) === f22;
    }, reactIs_production_min.isStrictMode = function(a22) {
      return v3(a22) === e;
    }, reactIs_production_min.isSuspense = function(a22) {
      return v3(a22) === m22;
    }, reactIs_production_min.isSuspenseList = function(a22) {
      return v3(a22) === n2;
    }, reactIs_production_min.isValidElementType = function(a22) {
      return typeof a22 == "string" || typeof a22 == "function" || a22 === d3 || a22 === f22 || a22 === e || a22 === m22 || a22 === n2 || a22 === t || typeof a22 == "object" && a22 !== null && (a22.$$typeof === q3 || a22.$$typeof === p22 || a22.$$typeof === g3 || a22.$$typeof === h22 || a22.$$typeof === l2 || a22.$$typeof === u3 || a22.getModuleId !== void 0);
    }, reactIs_production_min.typeOf = v3, reactIs_production_min;
  }
  __name(requireReactIs_production_min, "requireReactIs_production_min");
  var reactIs_development = {}, hasRequiredReactIs_development;
  function requireReactIs_development() {
    return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      __name(isValidElementType, "isValidElementType");
      function typeOf(object2) {
        if (typeof object2 == "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object2.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      __name(typeOf, "typeOf");
      var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment3 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal3 = REACT_PORTAL_TYPE, Profiler2 = REACT_PROFILER_TYPE, StrictMode2 = REACT_STRICT_MODE_TYPE, Suspense2 = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
      function isAsyncMode(object2) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      __name(isAsyncMode, "isAsyncMode");
      function isConcurrentMode(object2) {
        return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      __name(isConcurrentMode, "isConcurrentMode");
      function isContextConsumer(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }
      __name(isContextConsumer, "isContextConsumer");
      function isContextProvider(object2) {
        return typeOf(object2) === REACT_PROVIDER_TYPE;
      }
      __name(isContextProvider, "isContextProvider");
      function isElement2(object2) {
        return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      __name(isElement2, "isElement");
      function isForwardRef(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }
      __name(isForwardRef, "isForwardRef");
      function isFragment(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }
      __name(isFragment, "isFragment");
      function isLazy(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }
      __name(isLazy, "isLazy");
      function isMemo(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }
      __name(isMemo, "isMemo");
      function isPortal(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }
      __name(isPortal, "isPortal");
      function isProfiler(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }
      __name(isProfiler, "isProfiler");
      function isStrictMode(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }
      __name(isStrictMode, "isStrictMode");
      function isSuspense(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }
      __name(isSuspense, "isSuspense");
      function isSuspenseList(object2) {
        return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
      }
      __name(isSuspenseList, "isSuspenseList"), reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment3, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal3, reactIs_development.Profiler = Profiler2, reactIs_development.StrictMode = StrictMode2, reactIs_development.Suspense = Suspense2, reactIs_development.SuspenseList = SuspenseList, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement2, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isSuspenseList = isSuspenseList, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf;
    })()), reactIs_development;
  }
  __name(requireReactIs_development, "requireReactIs_development");
  var hasRequiredReactIs;
  function requireReactIs() {
    return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_development()), reactIs.exports;
  }
  __name(requireReactIs, "requireReactIs");
  var reactIsExports = requireReactIs(), index = getDefaultExportFromCjs(reactIsExports), ReactIs18 = _mergeNamespaces({
    __proto__: null,
    default: index
  }, [reactIsExports]), reactIsMethods = [
    "isAsyncMode",
    "isConcurrentMode",
    "isContextConsumer",
    "isContextProvider",
    "isElement",
    "isForwardRef",
    "isFragment",
    "isLazy",
    "isMemo",
    "isPortal",
    "isProfiler",
    "isStrictMode",
    "isSuspense",
    "isSuspenseList",
    "isValidElementType"
  ], ReactIs = Object.fromEntries(reactIsMethods.map((m22) => [m22, (v3) => ReactIs18[m22](v3) || ReactIs19[m22](v3)]));
  function getChildren(arg, children = []) {
    if (Array.isArray(arg))
      for (let item of arg)
        getChildren(item, children);
    else arg != null && arg !== !1 && arg !== "" && children.push(arg);
    return children;
  }
  __name(getChildren, "getChildren");
  function getType(element) {
    let type = element.type;
    if (typeof type == "string")
      return type;
    if (typeof type == "function")
      return type.displayName || type.name || "Unknown";
    if (ReactIs.isFragment(element))
      return "React.Fragment";
    if (ReactIs.isSuspense(element))
      return "React.Suspense";
    if (typeof type == "object" && type !== null) {
      if (ReactIs.isContextProvider(element))
        return "Context.Provider";
      if (ReactIs.isContextConsumer(element))
        return "Context.Consumer";
      if (ReactIs.isForwardRef(element)) {
        if (type.displayName)
          return type.displayName;
        let functionName = type.render.displayName || type.render.name || "";
        return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
      }
      if (ReactIs.isMemo(element)) {
        let functionName = type.displayName || type.type.displayName || type.type.name || "";
        return functionName === "" ? "Memo" : `Memo(${functionName})`;
      }
    }
    return "UNDEFINED";
  }
  __name(getType, "getType");
  function getPropKeys$1(element) {
    let { props } = element;
    return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
  }
  __name(getPropKeys$1, "getPropKeys$1");
  var serialize$1 = __name((element, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(getType(element), config2) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config2, indentation + config2.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation), "serialize$1"), test$1 = __name((val) => val != null && ReactIs.isElement(val), "test$1"), plugin$1 = {
    serialize: serialize$1,
    test: test$1
  }, testSymbol = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
  function getPropKeys(object2) {
    let { props } = object2;
    return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
  }
  __name(getPropKeys, "getPropKeys");
  var serialize = __name((object2, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(object2.type, config2) : printElement(object2.type, object2.props ? printProps(getPropKeys(object2), object2.props, config2, indentation + config2.indent, depth, refs, printer2) : "", object2.children ? printChildren(object2.children, config2, indentation + config2.indent, depth, refs, printer2) : "", config2, indentation), "serialize"), test = __name((val) => val && val.$$typeof === testSymbol, "test"), plugin = {
    serialize,
    test
  }, toString = Object.prototype.toString, toISOString = Date.prototype.toISOString, errorToString = Error.prototype.toString, regExpToString = RegExp.prototype.toString;
  function getConstructorName(val) {
    return typeof val.constructor == "function" && val.constructor.name || "Object";
  }
  __name(getConstructorName, "getConstructorName");
  function isWindow(val) {
    return typeof window < "u" && val === window;
  }
  __name(isWindow, "isWindow");
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP = /\n/g, _PrettyFormatPluginError = class extends Error {
    constructor(message, stack) {
      super(message), this.stack = stack, this.name = this.constructor.name;
    }
  };
  __name(_PrettyFormatPluginError, "PrettyFormatPluginError");
  var PrettyFormatPluginError = _PrettyFormatPluginError;
  function isToStringedArrayType(toStringed) {
    return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
  }
  __name(isToStringedArrayType, "isToStringedArrayType");
  function printNumber(val) {
    return Object.is(val, -0) ? "-0" : String(val);
  }
  __name(printNumber, "printNumber");
  function printBigInt(val) {
    return `${val}n`;
  }
  __name(printBigInt, "printBigInt");
  function printFunction(val, printFunctionName) {
    return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
  }
  __name(printFunction, "printFunction");
  function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  }
  __name(printSymbol, "printSymbol");
  function printError(val) {
    return `[${errorToString.call(val)}]`;
  }
  __name(printError, "printError");
  function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (val === !0 || val === !1)
      return `${val}`;
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    let typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "bigint")
      return printBigInt(val);
    if (typeOf === "string")
      return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
    if (typeOf === "function")
      return printFunction(val, printFunctionName);
    if (typeOf === "symbol")
      return printSymbol(val);
    let toStringed = toString.call(val);
    return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
  }
  __name(printBasicValue, "printBasicValue");
  function printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON) {
    if (refs.includes(val))
      return "[Circular]";
    refs = [...refs], refs.push(val);
    let hitMaxDepth = ++depth > config2.maxDepth, min2 = config2.min;
    if (config2.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
      return printer(val.toJSON(), config2, indentation, depth, refs, !0);
    let toStringed = toString.call(val);
    return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min2 ? "" : "Arguments "}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min2 || !config2.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config2, indentation, depth, refs, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min2 || !config2.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config2, indentation, depth, refs, printer)}}`;
  }
  __name(printComplexValue, "printComplexValue");
  var ErrorPlugin = {
    test: __name((val) => val && val instanceof Error, "test"),
    serialize(val, config2, indentation, depth, refs, printer2) {
      if (refs.includes(val))
        return "[Circular]";
      refs = [...refs, val];
      let hitMaxDepth = ++depth > config2.maxDepth, { message, cause, ...rest } = val, entries = {
        message,
        ...typeof cause < "u" ? { cause } : {},
        ...val instanceof AggregateError ? { errors: val.errors } : {},
        ...rest
      }, name = val.name !== "Error" ? val.name : getConstructorName(val);
      return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config2, indentation, depth, refs, printer2)}}`;
    }
  };
  function isNewPlugin(plugin2) {
    return plugin2.serialize != null;
  }
  __name(isNewPlugin, "isNewPlugin");
  function printPlugin(plugin2, val, config2, indentation, depth, refs) {
    let printed;
    try {
      printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config2, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config2, indentation, depth, refs), (str2) => {
        let indentationNext = indentation + config2.indent;
        return indentationNext + str2.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
      }, {
        edgeSpacing: config2.spacingOuter,
        min: config2.min,
        spacing: config2.spacingInner
      }, config2.colors);
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if (typeof printed != "string")
      throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    return printed;
  }
  __name(printPlugin, "printPlugin");
  function findPlugin(plugins2, val) {
    for (let plugin2 of plugins2)
      try {
        if (plugin2.test(val))
          return plugin2;
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
    return null;
  }
  __name(findPlugin, "findPlugin");
  function printer(val, config2, indentation, depth, refs, hasCalledToJSON) {
    let plugin2 = findPlugin(config2.plugins, val);
    if (plugin2 !== null)
      return printPlugin(plugin2, val, config2, indentation, depth, refs);
    let basicResult = printBasicValue(val, config2.printFunctionName, config2.escapeRegex, config2.escapeString);
    return basicResult !== null ? basicResult : printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON);
  }
  __name(printer, "printer");
  var DEFAULT_THEME = {
    comment: "gray",
    content: "reset",
    prop: "yellow",
    tag: "cyan",
    value: "green"
  }, DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME), DEFAULT_OPTIONS3 = {
    callToJSON: !0,
    compareKeys: void 0,
    escapeRegex: !1,
    escapeString: !0,
    highlight: !1,
    indent: 2,
    maxDepth: Number.POSITIVE_INFINITY,
    maxWidth: Number.POSITIVE_INFINITY,
    min: !1,
    plugins: [],
    printBasicPrototype: !0,
    printFunctionName: !0,
    theme: DEFAULT_THEME
  };
  function validateOptions2(options2) {
    for (let key of Object.keys(options2))
      if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS3, key))
        throw new Error(`pretty-format: Unknown option "${key}".`);
    if (options2.min && options2.indent !== void 0 && options2.indent !== 0)
      throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
  }
  __name(validateOptions2, "validateOptions");
  function getColorsHighlight() {
    return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
      let value2 = DEFAULT_THEME[key], color2 = value2 && s[value2];
      if (color2 && typeof color2.close == "string" && typeof color2.open == "string")
        colors3[key] = color2;
      else
        throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value2}" is undefined in ansi-styles.`);
      return colors3;
    }, /* @__PURE__ */ Object.create(null));
  }
  __name(getColorsHighlight, "getColorsHighlight");
  function getColorsEmpty() {
    return DEFAULT_THEME_KEYS.reduce((colors3, key) => (colors3[key] = {
      close: "",
      open: ""
    }, colors3), /* @__PURE__ */ Object.create(null));
  }
  __name(getColorsEmpty, "getColorsEmpty");
  function getPrintFunctionName(options2) {
    return options2?.printFunctionName ?? DEFAULT_OPTIONS3.printFunctionName;
  }
  __name(getPrintFunctionName, "getPrintFunctionName");
  function getEscapeRegex(options2) {
    return options2?.escapeRegex ?? DEFAULT_OPTIONS3.escapeRegex;
  }
  __name(getEscapeRegex, "getEscapeRegex");
  function getEscapeString(options2) {
    return options2?.escapeString ?? DEFAULT_OPTIONS3.escapeString;
  }
  __name(getEscapeString, "getEscapeString");
  function getConfig2(options2) {
    return {
      callToJSON: options2?.callToJSON ?? DEFAULT_OPTIONS3.callToJSON,
      colors: options2?.highlight ? getColorsHighlight() : getColorsEmpty(),
      compareKeys: typeof options2?.compareKeys == "function" || options2?.compareKeys === null ? options2.compareKeys : DEFAULT_OPTIONS3.compareKeys,
      escapeRegex: getEscapeRegex(options2),
      escapeString: getEscapeString(options2),
      indent: options2?.min ? "" : createIndent(options2?.indent ?? DEFAULT_OPTIONS3.indent),
      maxDepth: options2?.maxDepth ?? DEFAULT_OPTIONS3.maxDepth,
      maxWidth: options2?.maxWidth ?? DEFAULT_OPTIONS3.maxWidth,
      min: options2?.min ?? DEFAULT_OPTIONS3.min,
      plugins: options2?.plugins ?? DEFAULT_OPTIONS3.plugins,
      printBasicPrototype: options2?.printBasicPrototype ?? !0,
      printFunctionName: getPrintFunctionName(options2),
      spacingInner: options2?.min ? " " : `
`,
      spacingOuter: options2?.min ? "" : `
`
    };
  }
  __name(getConfig2, "getConfig");
  function createIndent(indent) {
    return Array.from({ length: indent + 1 }).join(" ");
  }
  __name(createIndent, "createIndent");
  function format2(val, options2) {
    if (options2 && (validateOptions2(options2), options2.plugins)) {
      let plugin2 = findPlugin(options2.plugins, val);
      if (plugin2 !== null)
        return printPlugin(plugin2, val, getConfig2(options2), "", 0, []);
    }
    let basicResult = printBasicValue(val, getPrintFunctionName(options2), getEscapeRegex(options2), getEscapeString(options2));
    return basicResult !== null ? basicResult : printComplexValue(val, getConfig2(options2), "", 0, []);
  }
  __name(format2, "format");
  var plugins = {
    AsymmetricMatcher: plugin$5,
    DOMCollection: plugin$4,
    DOMElement: plugin$3,
    Immutable: plugin$2,
    ReactElement: plugin$1,
    ReactTestComponent: plugin,
    Error: ErrorPlugin
  }, ansiColors = {
    bold: ["1", "22"],
    dim: ["2", "22"],
    italic: ["3", "23"],
    underline: ["4", "24"],
    // 5 & 6 are blinking
    inverse: ["7", "27"],
    hidden: ["8", "28"],
    strike: ["9", "29"],
    // 10-20 are fonts
    // 21-29 are resets for 1-9
    black: ["30", "39"],
    red: ["31", "39"],
    green: ["32", "39"],
    yellow: ["33", "39"],
    blue: ["34", "39"],
    magenta: ["35", "39"],
    cyan: ["36", "39"],
    white: ["37", "39"],
    brightblack: ["30;1", "39"],
    brightred: ["31;1", "39"],
    brightgreen: ["32;1", "39"],
    brightyellow: ["33;1", "39"],
    brightblue: ["34;1", "39"],
    brightmagenta: ["35;1", "39"],
    brightcyan: ["36;1", "39"],
    brightwhite: ["37;1", "39"],
    grey: ["90", "39"]
  }, styles = {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red"
  }, truncator = "\u2026";
  function colorise(value2, styleType) {
    let color2 = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
    return color2 ? `\x1B[${color2[0]}m${String(value2)}\x1B[${color2[1]}m` : String(value2);
  }
  __name(colorise, "colorise");
  function normaliseOptions({
    showHidden = !1,
    depth = 2,
    colors: colors3 = !1,
    customInspect = !0,
    showProxy = !1,
    maxArrayLength = 1 / 0,
    breakLength = 1 / 0,
    seen = [],
    // eslint-disable-next-line no-shadow
    truncate: truncate2 = 1 / 0,
    stylize = String
  } = {}, inspect3) {
    let options2 = {
      showHidden: !!showHidden,
      depth: Number(depth),
      colors: !!colors3,
      customInspect: !!customInspect,
      showProxy: !!showProxy,
      maxArrayLength: Number(maxArrayLength),
      breakLength: Number(breakLength),
      truncate: Number(truncate2),
      seen,
      inspect: inspect3,
      stylize
    };
    return options2.colors && (options2.stylize = colorise), options2;
  }
  __name(normaliseOptions, "normaliseOptions");
  function isHighSurrogate(char) {
    return char >= "\uD800" && char <= "\uDBFF";
  }
  __name(isHighSurrogate, "isHighSurrogate");
  function truncate(string, length2, tail = truncator) {
    string = String(string);
    let tailLength = tail.length, stringLength = string.length;
    if (tailLength > length2 && stringLength > tailLength)
      return tail;
    if (stringLength > length2 && stringLength > tailLength) {
      let end2 = length2 - tailLength;
      return end2 > 0 && isHighSurrogate(string[end2 - 1]) && (end2 = end2 - 1), `${string.slice(0, end2)}${tail}`;
    }
    return string;
  }
  __name(truncate, "truncate");
  function inspectList(list, options2, inspectItem, separator = ", ") {
    inspectItem = inspectItem || options2.inspect;
    let size = list.length;
    if (size === 0)
      return "";
    let originalLength = options2.truncate, output = "", peek = "", truncated = "";
    for (let i3 = 0; i3 < size; i3 += 1) {
      let last = i3 + 1 === list.length, secondToLast = i3 + 2 === list.length;
      truncated = `${truncator}(${list.length - i3})`;
      let value2 = list[i3];
      options2.truncate = originalLength - output.length - (last ? 0 : separator.length);
      let string = peek || inspectItem(value2, options2) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
      if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i3 + 1], options2) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
        break;
      if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
        truncated = `${truncator}(${list.length - i3 - 1})`;
        break;
      }
      truncated = "";
    }
    return `${output}${truncated}`;
  }
  __name(inspectList, "inspectList");
  function quoteComplexKey(key) {
    return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
  }
  __name(quoteComplexKey, "quoteComplexKey");
  function inspectProperty([key, value2], options2) {
    return options2.truncate -= 2, typeof key == "string" ? key = quoteComplexKey(key) : typeof key != "number" && (key = `[${options2.inspect(key, options2)}]`), options2.truncate -= key.length, value2 = options2.inspect(value2, options2), `${key}: ${value2}`;
  }
  __name(inspectProperty, "inspectProperty");
  function inspectArray(array2, options2) {
    let nonIndexProperties = Object.keys(array2).slice(array2.length);
    if (!array2.length && !nonIndexProperties.length)
      return "[]";
    options2.truncate -= 4;
    let listContents = inspectList(array2, options2);
    options2.truncate -= listContents.length;
    let propertyContents = "";
    return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options2, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  __name(inspectArray, "inspectArray");
  var getArrayName = __name((array2) => typeof Buffer == "function" && array2 instanceof Buffer ? "Buffer" : array2[Symbol.toStringTag] ? array2[Symbol.toStringTag] : array2.constructor.name, "getArrayName");
  function inspectTypedArray(array2, options2) {
    let name = getArrayName(array2);
    options2.truncate -= name.length + 4;
    let nonIndexProperties = Object.keys(array2).slice(array2.length);
    if (!array2.length && !nonIndexProperties.length)
      return `${name}[]`;
    let output = "";
    for (let i3 = 0; i3 < array2.length; i3++) {
      let string = `${options2.stylize(truncate(array2[i3], options2.truncate), "number")}${i3 === array2.length - 1 ? "" : ", "}`;
      if (options2.truncate -= string.length, array2[i3] !== array2.length && options2.truncate <= 3) {
        output += `${truncator}(${array2.length - array2[i3] + 1})`;
        break;
      }
      output += string;
    }
    let propertyContents = "";
    return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options2, inspectProperty)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  __name(inspectTypedArray, "inspectTypedArray");
  function inspectDate(dateObject, options2) {
    let stringRepresentation = dateObject.toJSON();
    if (stringRepresentation === null)
      return "Invalid Date";
    let split = stringRepresentation.split("T"), date = split[0];
    return options2.stylize(`${date}T${truncate(split[1], options2.truncate - date.length - 1)}`, "date");
  }
  __name(inspectDate, "inspectDate");
  function inspectFunction(func, options2) {
    let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
    return name ? options2.stylize(`[${functionType} ${truncate(name, options2.truncate - 11)}]`, "special") : options2.stylize(`[${functionType}]`, "special");
  }
  __name(inspectFunction, "inspectFunction");
  function inspectMapEntry([key, value2], options2) {
    return options2.truncate -= 4, key = options2.inspect(key, options2), options2.truncate -= key.length, value2 = options2.inspect(value2, options2), `${key} => ${value2}`;
  }
  __name(inspectMapEntry, "inspectMapEntry");
  function mapToEntries(map2) {
    let entries = [];
    return map2.forEach((value2, key) => {
      entries.push([key, value2]);
    }), entries;
  }
  __name(mapToEntries, "mapToEntries");
  function inspectMap(map2, options2) {
    return map2.size === 0 ? "Map{}" : (options2.truncate -= 7, `Map{ ${inspectList(mapToEntries(map2), options2, inspectMapEntry)} }`);
  }
  __name(inspectMap, "inspectMap");
  var isNaN2 = Number.isNaN || ((i3) => i3 !== i3);
  function inspectNumber(number, options2) {
    return isNaN2(number) ? options2.stylize("NaN", "number") : number === 1 / 0 ? options2.stylize("Infinity", "number") : number === -1 / 0 ? options2.stylize("-Infinity", "number") : number === 0 ? options2.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options2.stylize(truncate(String(number), options2.truncate), "number");
  }
  __name(inspectNumber, "inspectNumber");
  function inspectBigInt(number, options2) {
    let nums = truncate(number.toString(), options2.truncate - 1);
    return nums !== truncator && (nums += "n"), options2.stylize(nums, "bigint");
  }
  __name(inspectBigInt, "inspectBigInt");
  function inspectRegExp(value2, options2) {
    let flags = value2.toString().split("/")[2], sourceLength = options2.truncate - (2 + flags.length), source = value2.source;
    return options2.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
  }
  __name(inspectRegExp, "inspectRegExp");
  function arrayFromSet(set) {
    let values = [];
    return set.forEach((value2) => {
      values.push(value2);
    }), values;
  }
  __name(arrayFromSet, "arrayFromSet");
  function inspectSet(set, options2) {
    return set.size === 0 ? "Set{}" : (options2.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set), options2)} }`);
  }
  __name(inspectSet, "inspectSet");
  var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    "'": "\\'",
    "\\": "\\\\"
  }, hex = 16, unicodeLength = 4;
  function escape(char) {
    return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
  }
  __name(escape, "escape");
  function inspectString(string, options2) {
    return stringEscapeChars.test(string) && (string = string.replace(stringEscapeChars, escape)), options2.stylize(`'${truncate(string, options2.truncate - 2)}'`, "string");
  }
  __name(inspectString, "inspectString");
  function inspectSymbol(value2) {
    return "description" in Symbol.prototype ? value2.description ? `Symbol(${value2.description})` : "Symbol()" : value2.toString();
  }
  __name(inspectSymbol, "inspectSymbol");
  var getPromiseValue = __name(() => "Promise{\u2026}", "getPromiseValue"), promise_default = getPromiseValue;
  function inspectObject(object2, options2) {
    let properties = Object.getOwnPropertyNames(object2), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
    if (properties.length === 0 && symbols.length === 0)
      return "{}";
    if (options2.truncate -= 4, options2.seen = options2.seen || [], options2.seen.includes(object2))
      return "[Circular]";
    options2.seen.push(object2);
    let propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options2, inspectProperty), symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options2, inspectProperty);
    options2.seen.pop();
    let sep = "";
    return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
  }
  __name(inspectObject, "inspectObject");
  var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
  function inspectClass(value2, options2) {
    let name = "";
    return toStringTag && toStringTag in value2 && (name = value2[toStringTag]), name = name || value2.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options2.truncate -= name.length, `${name}${inspectObject(value2, options2)}`;
  }
  __name(inspectClass, "inspectClass");
  function inspectArguments(args, options2) {
    return args.length === 0 ? "Arguments[]" : (options2.truncate -= 13, `Arguments[ ${inspectList(args, options2)} ]`);
  }
  __name(inspectArguments, "inspectArguments");
  var errorKeys = [
    "stack",
    "line",
    "column",
    "name",
    "message",
    "fileName",
    "lineNumber",
    "columnNumber",
    "number",
    "description",
    "cause"
  ];
  function inspectObject2(error, options2) {
    let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1), name = error.name;
    options2.truncate -= name.length;
    let message = "";
    if (typeof error.message == "string" ? message = truncate(error.message, options2.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options2.truncate -= message.length + 5, options2.seen = options2.seen || [], options2.seen.includes(error))
      return "[Circular]";
    options2.seen.push(error);
    let propertyContents = inspectList(properties.map((key) => [key, error[key]]), options2, inspectProperty);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
  }
  __name(inspectObject2, "inspectObject");
  function inspectAttribute([key, value2], options2) {
    return options2.truncate -= 3, value2 ? `${options2.stylize(String(key), "yellow")}=${options2.stylize(`"${value2}"`, "string")}` : `${options2.stylize(String(key), "yellow")}`;
  }
  __name(inspectAttribute, "inspectAttribute");
  function inspectNodeCollection(collection, options2) {
    return inspectList(collection, options2, inspectNode, `
`);
  }
  __name(inspectNodeCollection, "inspectNodeCollection");
  function inspectNode(node, options2) {
    switch (node.nodeType) {
      case 1:
        return inspectHTML(node, options2);
      case 3:
        return options2.inspect(node.data, options2);
      default:
        return options2.inspect(node, options2);
    }
  }
  __name(inspectNode, "inspectNode");
  function inspectHTML(element, options2) {
    let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options2.stylize(`<${name}`, "special"), headClose = options2.stylize(">", "special"), tail = options2.stylize(`</${name}>`, "special");
    options2.truncate -= name.length * 2 + 5;
    let propertyContents = "";
    properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options2, inspectAttribute, " ")), options2.truncate -= propertyContents.length;
    let truncate2 = options2.truncate, children = inspectNodeCollection(element.children, options2);
    return children && children.length > truncate2 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
  }
  __name(inspectHTML, "inspectHTML");
  var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect = Symbol.for("nodejs.util.inspect.custom"), constructorMap = /* @__PURE__ */ new WeakMap(), stringTagMap = {}, baseTypesMap = {
    undefined: __name((value2, options2) => options2.stylize("undefined", "undefined"), "undefined"),
    null: __name((value2, options2) => options2.stylize("null", "null"), "null"),
    boolean: __name((value2, options2) => options2.stylize(String(value2), "boolean"), "boolean"),
    Boolean: __name((value2, options2) => options2.stylize(String(value2), "boolean"), "Boolean"),
    number: inspectNumber,
    Number: inspectNumber,
    bigint: inspectBigInt,
    BigInt: inspectBigInt,
    string: inspectString,
    String: inspectString,
    function: inspectFunction,
    Function: inspectFunction,
    symbol: inspectSymbol,
    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
    Symbol: inspectSymbol,
    Array: inspectArray,
    Date: inspectDate,
    Map: inspectMap,
    Set: inspectSet,
    RegExp: inspectRegExp,
    Promise: promise_default,
    // WeakSet, WeakMap are totally opaque to us
    WeakSet: __name((value2, options2) => options2.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
    WeakMap: __name((value2, options2) => options2.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
    Arguments: inspectArguments,
    Int8Array: inspectTypedArray,
    Uint8Array: inspectTypedArray,
    Uint8ClampedArray: inspectTypedArray,
    Int16Array: inspectTypedArray,
    Uint16Array: inspectTypedArray,
    Int32Array: inspectTypedArray,
    Uint32Array: inspectTypedArray,
    Float32Array: inspectTypedArray,
    Float64Array: inspectTypedArray,
    Generator: __name(() => "", "Generator"),
    DataView: __name(() => "", "DataView"),
    ArrayBuffer: __name(() => "", "ArrayBuffer"),
    Error: inspectObject2,
    HTMLCollection: inspectNodeCollection,
    NodeList: inspectNodeCollection
  }, inspectCustom = __name((value2, options2, type, inspectFn) => chaiInspect in value2 && typeof value2[chaiInspect] == "function" ? value2[chaiInspect](options2) : nodeInspect in value2 && typeof value2[nodeInspect] == "function" ? value2[nodeInspect](options2.depth, options2, inspectFn) : "inspect" in value2 && typeof value2.inspect == "function" ? value2.inspect(options2.depth, options2) : "constructor" in value2 && constructorMap.has(value2.constructor) ? constructorMap.get(value2.constructor)(value2, options2) : stringTagMap[type] ? stringTagMap[type](value2, options2) : "", "inspectCustom"), toString2 = Object.prototype.toString;
  function inspect(value2, opts = {}) {
    let options2 = normaliseOptions(opts, inspect), { customInspect } = options2, type = value2 === null ? "null" : typeof value2;
    if (type === "object" && (type = toString2.call(value2).slice(8, -1)), type in baseTypesMap)
      return baseTypesMap[type](value2, options2);
    if (customInspect && value2) {
      let output = inspectCustom(value2, options2, type, inspect);
      if (output)
        return typeof output == "string" ? output : inspect(output, options2);
    }
    let proto = value2 ? Object.getPrototypeOf(value2) : !1;
    return proto === Object.prototype || proto === null ? inspectObject(value2, options2) : value2 && typeof HTMLElement == "function" && value2 instanceof HTMLElement ? inspectHTML(value2, options2) : "constructor" in value2 ? value2.constructor !== Object ? inspectClass(value2, options2) : inspectObject(value2, options2) : value2 === Object(value2) ? inspectObject(value2, options2) : options2.stylize(String(value2), type);
  }
  __name(inspect, "inspect");
  var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins, PLUGINS = [
    ReactTestComponent,
    ReactElement,
    DOMElement,
    DOMCollection,
    Immutable,
    AsymmetricMatcher
  ];
  function stringify2(object2, maxDepth = 10, { maxLength, ...options2 } = {}) {
    let MAX_LENGTH = maxLength ?? 1e4, result;
    try {
      result = format2(object2, {
        maxDepth,
        escapeString: !1,
        plugins: PLUGINS,
        ...options2
      });
    } catch {
      result = format2(object2, {
        callToJSON: !1,
        maxDepth,
        escapeString: !1,
        plugins: PLUGINS,
        ...options2
      });
    }
    return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object2, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
      maxLength,
      ...options2
    }) : result;
  }
  __name(stringify2, "stringify");
  var formatRegExp = /%[sdjifoOc%]/g;
  function format22(...args) {
    if (typeof args[0] != "string") {
      let objects = [];
      for (let i22 = 0; i22 < args.length; i22++)
        objects.push(inspect2(args[i22], {
          depth: 0,
          colors: !1
        }));
      return objects.join(" ");
    }
    let len = args.length, i3 = 1, template = args[0], str2 = String(template).replace(formatRegExp, (x3) => {
      if (x3 === "%%")
        return "%";
      if (i3 >= len)
        return x3;
      switch (x3) {
        case "%s": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : typeof value2 == "number" && value2 === 0 && 1 / value2 < 0 ? "-0" : typeof value2 == "object" && value2 !== null ? typeof value2.toString == "function" && value2.toString !== Object.prototype.toString ? value2.toString() : inspect2(value2, {
            depth: 0,
            colors: !1
          }) : String(value2);
        }
        case "%d": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : Number(value2).toString();
        }
        case "%i": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : Number.parseInt(String(value2)).toString();
        }
        case "%f":
          return Number.parseFloat(String(args[i3++])).toString();
        case "%o":
          return inspect2(args[i3++], {
            showHidden: !0,
            showProxy: !0
          });
        case "%O":
          return inspect2(args[i3++]);
        case "%c":
          return i3++, "";
        case "%j":
          try {
            return JSON.stringify(args[i3++]);
          } catch (err) {
            let m22 = err.message;
            if (m22.includes("circular structure") || m22.includes("cyclic structures") || m22.includes("cyclic object"))
              return "[Circular]";
            throw err;
          }
        default:
          return x3;
      }
    });
    for (let x3 = args[i3]; i3 < len; x3 = args[++i3])
      x3 === null || typeof x3 != "object" ? str2 += ` ${x3}` : str2 += ` ${inspect2(x3)}`;
    return str2;
  }
  __name(format22, "format");
  function inspect2(obj, options2 = {}) {
    return options2.truncate === 0 && (options2.truncate = Number.POSITIVE_INFINITY), inspect(obj, options2);
  }
  __name(inspect2, "inspect");
  function getDefaultExportFromCjs2(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
  }
  __name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");
  function assertTypes(value2, name, types2) {
    let receivedType = typeof value2;
    if (!types2.includes(receivedType))
      throw new TypeError(`${name} value must be ${types2.join(" or ")}, received "${receivedType}"`);
  }
  __name(assertTypes, "assertTypes");
  function isObject2(item) {
    return item != null && typeof item == "object" && !Array.isArray(item);
  }
  __name(isObject2, "isObject");
  function isFinalObj(obj) {
    return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
  }
  __name(isFinalObj, "isFinalObj");
  function getType2(value2) {
    return Object.prototype.toString.apply(value2).slice(8, -1);
  }
  __name(getType2, "getType");
  function collectOwnProperties(obj, collector) {
    let collect = typeof collector == "function" ? collector : (key) => collector.add(key);
    Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
  }
  __name(collectOwnProperties, "collectOwnProperties");
  function getOwnProperties(obj) {
    let ownProps = /* @__PURE__ */ new Set();
    return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
  }
  __name(getOwnProperties, "getOwnProperties");
  var defaultCloneOptions = { forceWritable: !1 };
  function deepClone(val, options2 = defaultCloneOptions) {
    return clone(val, /* @__PURE__ */ new WeakMap(), options2);
  }
  __name(deepClone, "deepClone");
  function clone(val, seen, options2 = defaultCloneOptions) {
    let k3, out;
    if (seen.has(val))
      return seen.get(val);
    if (Array.isArray(val)) {
      for (out = Array.from({ length: k3 = val.length }), seen.set(val, out); k3--; )
        out[k3] = clone(val[k3], seen, options2);
      return out;
    }
    if (Object.prototype.toString.call(val) === "[object Object]") {
      out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
      let props = getOwnProperties(val);
      for (let k22 of props) {
        let descriptor = Object.getOwnPropertyDescriptor(val, k22);
        if (!descriptor)
          continue;
        let cloned = clone(val[k22], seen, options2);
        options2.forceWritable ? Object.defineProperty(out, k22, {
          enumerable: descriptor.enumerable,
          configurable: !0,
          writable: !0,
          value: cloned
        }) : "get" in descriptor ? Object.defineProperty(out, k22, {
          ...descriptor,
          get() {
            return cloned;
          }
        }) : Object.defineProperty(out, k22, {
          ...descriptor,
          value: cloned
        });
      }
      return out;
    }
    return val;
  }
  __name(clone, "clone");
  function noop4() {
  }
  __name(noop4, "noop");
  var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0, _Diff = class {
    0;
    1;
    constructor(op, text) {
      this[0] = op, this[1] = text;
    }
  };
  __name(_Diff, "Diff");
  var Diff = _Diff;
  function diff_commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
      return 0;
    let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
    for (; pointermin < pointermid; )
      text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    return pointermid;
  }
  __name(diff_commonPrefix, "diff_commonPrefix");
  function diff_commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
      return 0;
    let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
    for (; pointermin < pointermid; )
      text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    return pointermid;
  }
  __name(diff_commonSuffix, "diff_commonSuffix");
  function diff_commonOverlap_(text1, text2) {
    let text1_length = text1.length, text2_length = text2.length;
    if (text1_length === 0 || text2_length === 0)
      return 0;
    text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
    let text_length = Math.min(text1_length, text2_length);
    if (text1 === text2)
      return text_length;
    let best = 0, length2 = 1;
    for (; ; ) {
      let pattern = text1.substring(text_length - length2), found = text2.indexOf(pattern);
      if (found === -1)
        return best;
      length2 += found, (found === 0 || text1.substring(text_length - length2) === text2.substring(0, length2)) && (best = length2, length2++);
    }
  }
  __name(diff_commonOverlap_, "diff_commonOverlap_");
  function diff_cleanupSemantic(diffs) {
    let changes = !1, equalities = [], equalitiesLength = 0, lastEquality = null, pointer2 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
    for (; pointer2 < diffs.length; )
      diffs[pointer2][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer2, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer2][1]) : (diffs[pointer2][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer2][1].length : length_deletions2 += diffs[pointer2][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer2 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = !0)), pointer2++;
    for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer2 = 1; pointer2 < diffs.length; ) {
      if (diffs[pointer2 - 1][0] === DIFF_DELETE && diffs[pointer2][0] === DIFF_INSERT) {
        let deletion = diffs[pointer2 - 1][1], insertion = diffs[pointer2][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
        overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer2 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer2 + 1][1] = insertion.substring(overlap_length1), pointer2++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer2 - 1][0] = DIFF_INSERT, diffs[pointer2 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer2 + 1][0] = DIFF_DELETE, diffs[pointer2 + 1][1] = deletion.substring(overlap_length2), pointer2++), pointer2++;
      }
      pointer2++;
    }
  }
  __name(diff_cleanupSemantic, "diff_cleanupSemantic");
  var nonAlphaNumericRegex_ = /[^a-z0-9]/i, whitespaceRegex_ = /\s/, linebreakRegex_ = /[\r\n]/, blanklineEndRegex_ = /\n\r?\n$/, blanklineStartRegex_ = /^\r?\n\r?\n/;
  function diff_cleanupSemanticLossless(diffs) {
    let pointer2 = 1;
    for (; pointer2 < diffs.length - 1; ) {
      if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
        let equality1 = diffs[pointer2 - 1][1], edit = diffs[pointer2][1], equality2 = diffs[pointer2 + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          let commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
        }
        let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        for (; edit.charAt(0) === equality2.charAt(0); ) {
          equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
          let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
        }
        diffs[pointer2 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer2 - 1][1] = bestEquality1 : (diffs.splice(pointer2 - 1, 1), pointer2--), diffs[pointer2][1] = bestEdit, bestEquality2 ? diffs[pointer2 + 1][1] = bestEquality2 : (diffs.splice(pointer2 + 1, 1), pointer2--));
      }
      pointer2++;
    }
  }
  __name(diff_cleanupSemanticLossless, "diff_cleanupSemanticLossless");
  function diff_cleanupMerge(diffs) {
    diffs.push(new Diff(DIFF_EQUAL, ""));
    let pointer2 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
    for (; pointer2 < diffs.length; )
      switch (diffs[pointer2][0]) {
        case DIFF_INSERT:
          count_insert++, text_insert += diffs[pointer2][1], pointer2++;
          break;
        case DIFF_DELETE:
          count_delete++, text_delete += diffs[pointer2][1], pointer2++;
          break;
        case DIFF_EQUAL:
          count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer2 - count_delete - count_insert > 0 && diffs[pointer2 - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer2 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer2++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer2][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer2][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer2 -= count_delete + count_insert, diffs.splice(pointer2, count_delete + count_insert), text_delete.length && (diffs.splice(pointer2, 0, new Diff(DIFF_DELETE, text_delete)), pointer2++), text_insert.length && (diffs.splice(pointer2, 0, new Diff(DIFF_INSERT, text_insert)), pointer2++), pointer2++) : pointer2 !== 0 && diffs[pointer2 - 1][0] === DIFF_EQUAL ? (diffs[pointer2 - 1][1] += diffs[pointer2][1], diffs.splice(pointer2, 1)) : pointer2++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
          break;
      }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let changes = !1;
    for (pointer2 = 1; pointer2 < diffs.length - 1; )
      diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL && (diffs[pointer2][1].substring(diffs[pointer2][1].length - diffs[pointer2 - 1][1].length) === diffs[pointer2 - 1][1] ? (diffs[pointer2][1] = diffs[pointer2 - 1][1] + diffs[pointer2][1].substring(0, diffs[pointer2][1].length - diffs[pointer2 - 1][1].length), diffs[pointer2 + 1][1] = diffs[pointer2 - 1][1] + diffs[pointer2 + 1][1], diffs.splice(pointer2 - 1, 1), changes = !0) : diffs[pointer2][1].substring(0, diffs[pointer2 + 1][1].length) === diffs[pointer2 + 1][1] && (diffs[pointer2 - 1][1] += diffs[pointer2 + 1][1], diffs[pointer2][1] = diffs[pointer2][1].substring(diffs[pointer2 + 1][1].length) + diffs[pointer2 + 1][1], diffs.splice(pointer2 + 1, 1), changes = !0)), pointer2++;
    changes && diff_cleanupMerge(diffs);
  }
  __name(diff_cleanupMerge, "diff_cleanupMerge");
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two)
      return 6;
    let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
  var NO_DIFF_MESSAGE = "Compared values have no visual difference.", SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", build = {}, hasRequiredBuild;
  function requireBuild() {
    if (hasRequiredBuild) return build;
    hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", {
      value: !0
    }), build.default = diffSequence;
    let pkg = "diff-sequences", NOT_YET_SET = 0, countCommonItemsF = __name((aIndex, aEnd, bIndex, bEnd, isCommon) => {
      let nCommon = 0;
      for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); )
        aIndex += 1, bIndex += 1, nCommon += 1;
      return nCommon;
    }, "countCommonItemsF"), countCommonItemsR = __name((aStart, aIndex, bStart, bIndex, isCommon) => {
      let nCommon = 0;
      for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); )
        aIndex -= 1, bIndex -= 1, nCommon += 1;
      return nCommon;
    }, "countCommonItemsR"), extendPathsF = __name((d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
      let iF = 0, kF = -d3, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
      aIndexesF[iF] += countCommonItemsF(
        aFirst + 1,
        aEnd,
        bF + aFirst - kF + 1,
        bEnd,
        isCommon
      );
      let nF = d3 < iMaxF ? d3 : iMaxF;
      for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
        if (iF !== d3 && aIndexPrev1 < aIndexesF[iF])
          aFirst = aIndexesF[iF];
        else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst)
          return iF - 1;
        aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
      }
      return iMaxF;
    }, "extendPathsF"), extendPathsR = __name((d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
      let iR = 0, kR = d3, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
      aIndexesR[iR] -= countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
      let nR = d3 < iMaxR ? d3 : iMaxR;
      for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
        if (iR !== d3 && aIndexesR[iR] < aIndexPrev1)
          aFirst = aIndexesR[iR];
        else if (aFirst = aIndexPrev1 - 1, aFirst < aStart)
          return iR - 1;
        aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bR + aFirst - kR - 1,
          isCommon
        );
      }
      return iMaxR;
    }, "extendPathsR"), extendOverlappablePathsF = __name((d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d3 - 1), kMaxOverlapF = -baDeltaLength + (d3 - 1), aIndexPrev1 = NOT_YET_SET, nF = d3 < iMaxF ? d3 : iMaxF;
      for (let iF = 0, kF = -d3; iF <= nF; iF += 1, kF += 2) {
        let insert = iF === 0 || iF !== d3 && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(
          aFirst + 1,
          aEnd,
          bFirst + 1,
          bEnd,
          isCommon
        ), aLast = aFirst + nCommonF;
        if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
          let iR = (d3 - 1 - (kF + baDeltaLength)) / 2;
          if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
            let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(
              aStart,
              aLastPrev,
              bStart,
              bLastPrev,
              isCommon
            ), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
            division.nChangePreceding = d3 - 1, d3 - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
            let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
            return division.nChangeFollowing = d3 - 1, d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), !0;
          }
        }
      }
      return !1;
    }, "extendOverlappablePathsF"), extendOverlappablePathsR = __name((d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d3, kMaxOverlapR = baDeltaLength + d3, aIndexPrev1 = NOT_YET_SET, nR = d3 < iMaxR ? d3 : iMaxR;
      for (let iR = 0, kR = d3; iR <= nR; iR += 1, kR -= 2) {
        let insert = iR === 0 || iR !== d3 && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bFirst - 1,
          isCommon
        ), aLast = aFirst - nCommonR;
        if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
          let iF = (d3 + (kR - baDeltaLength)) / 2;
          if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
            let bLast = bFirst - nCommonR;
            if (division.nChangePreceding = d3, d3 === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d3 - 1, d3 === 1)
              division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
            else {
              let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(
                aLastPrev,
                aEnd,
                bLastPrev,
                bEnd,
                isCommon
              );
              division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
              let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
              d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
            }
            return !0;
          }
        }
      }
      return !1;
    }, "extendOverlappablePathsR"), divide = __name((nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
      let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
      if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
        let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
        for (let d3 = 1; d3 <= dMax; d3 += 1)
          if (iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 < dMin)
            iMaxR = extendPathsR(d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
          else if (
            // If a reverse path overlaps a forward path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsR(
              d3,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          )
            return;
      } else {
        let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d3 = 1;
        for (iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 += 1; d3 <= dMax; d3 += 1)
          if (iMaxR = extendPathsR(
            d3 - 1,
            aStart,
            bStart,
            bR,
            isCommon,
            aIndexesR,
            iMaxR
          ), d3 < dMin)
            iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
          else if (
            // If a forward path overlaps a reverse path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsF(
              d3,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          )
            return;
      }
      throw new Error(
        `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
      );
    }, "divide"), findSubsequences = __name((nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
      if (bEnd - bStart < aEnd - aStart) {
        if (transposed = !transposed, transposed && callbacks.length === 1) {
          let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
          callbacks[1] = {
            foundSubsequence: __name((nCommon, bCommon, aCommon) => {
              foundSubsequence2(nCommon, aCommon, bCommon);
            }, "foundSubsequence"),
            isCommon: __name((bIndex, aIndex) => isCommon2(aIndex, bIndex), "isCommon")
          };
        }
        let tStart = aStart, tEnd = aEnd;
        aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
      }
      let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
      divide(
        nChange,
        aStart,
        aEnd,
        bStart,
        bEnd,
        isCommon,
        aIndexesF,
        aIndexesR,
        division
      );
      let {
        nChangePreceding,
        aEndPreceding,
        bEndPreceding,
        nCommonPreceding,
        aCommonPreceding,
        bCommonPreceding,
        nCommonFollowing,
        aCommonFollowing,
        bCommonFollowing,
        nChangeFollowing,
        aStartFollowing,
        bStartFollowing
      } = division;
      aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(
        nChangePreceding,
        aStart,
        aEndPreceding,
        bStart,
        bEndPreceding,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      ), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(
        nChangeFollowing,
        aStartFollowing,
        aEnd,
        bStartFollowing,
        bEnd,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }, "findSubsequences"), validateLength = __name((name, arg) => {
      if (typeof arg != "number")
        throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
      if (!Number.isSafeInteger(arg))
        throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
      if (arg < 0)
        throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }, "validateLength"), validateCallback = __name((name, arg) => {
      let type = typeof arg;
      if (type !== "function")
        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    }, "validateCallback");
    function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
      validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
      let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
      if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
        let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(
          aStart,
          aLength - 1,
          bStart,
          bLength - 1,
          isCommon
        ), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
        aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(
          0,
          aStart,
          aEnd,
          bStart,
          bEnd,
          !1,
          [
            {
              foundSubsequence,
              isCommon
            }
          ],
          [NOT_YET_SET],
          [NOT_YET_SET],
          {
            aCommonFollowing: NOT_YET_SET,
            aCommonPreceding: NOT_YET_SET,
            aEndPreceding: NOT_YET_SET,
            aStartFollowing: NOT_YET_SET,
            bCommonFollowing: NOT_YET_SET,
            bCommonPreceding: NOT_YET_SET,
            bEndPreceding: NOT_YET_SET,
            bStartFollowing: NOT_YET_SET,
            nChangeFollowing: NOT_YET_SET,
            nChangePreceding: NOT_YET_SET,
            nCommonFollowing: NOT_YET_SET,
            nCommonPreceding: NOT_YET_SET
          }
        ), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
    return __name(diffSequence, "diffSequence"), build;
  }
  __name(requireBuild, "requireBuild");
  var buildExports = requireBuild(), diffSequences = getDefaultExportFromCjs2(buildExports);
  function formatTrailingSpaces(line, trailingSpaceFormatter) {
    return line.replace(/\s+$/, (match2) => trailingSpaceFormatter(match2));
  }
  __name(formatTrailingSpaces, "formatTrailingSpaces");
  function printDiffLine(line, isFirstOrLast, color2, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
    return line.length !== 0 ? color2(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color2(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color2(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
  }
  __name(printDiffLine, "printDiffLine");
  function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  __name(printDeleteLine, "printDeleteLine");
  function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  __name(printInsertLine, "printInsertLine");
  function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  __name(printCommonLine, "printCommonLine");
  function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
    return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
  }
  __name(createPatchMark, "createPatchMark");
  function joinAlignedDiffsNoExpand(diffs, options2) {
    let iLength = diffs.length, nContextLines = options2.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = !1, nExcessesBetweenChanges = 0, i3 = 0;
    for (; i3 !== iLength; ) {
      let iStart = i3;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_EQUAL; )
        i3 += 1;
      if (iStart !== i3)
        if (iStart === 0)
          i3 > nContextLines && (jLength -= i3 - nContextLines, hasExcessAtStartOrEnd = !0);
        else if (i3 === iLength) {
          let n2 = i3 - iStart;
          n2 > nContextLines && (jLength -= n2 - nContextLines, hasExcessAtStartOrEnd = !0);
        } else {
          let n2 = i3 - iStart;
          n2 > nContextLines2 && (jLength -= n2 - nContextLines2, nExcessesBetweenChanges += 1);
        }
      for (; i3 !== iLength && diffs[i3][0] !== DIFF_EQUAL; )
        i3 += 1;
    }
    let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
    nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
    let jLast = jLength - 1, lines = [], jPatchMark = 0;
    hasPatch && lines.push("");
    let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = __name((line) => {
      let j2 = lines.length;
      lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options2)), aEnd += 1, bEnd += 1;
    }, "pushCommonLine"), pushDeleteLine = __name((line) => {
      let j2 = lines.length;
      lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options2)), aEnd += 1;
    }, "pushDeleteLine"), pushInsertLine = __name((line) => {
      let j2 = lines.length;
      lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options2)), bEnd += 1;
    }, "pushInsertLine");
    for (i3 = 0; i3 !== iLength; ) {
      let iStart = i3;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_EQUAL; )
        i3 += 1;
      if (iStart !== i3)
        if (iStart === 0) {
          i3 > nContextLines && (iStart = i3 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
          for (let iCommon = iStart; iCommon !== i3; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else if (i3 === iLength) {
          let iEnd = i3 - iStart > nContextLines ? iStart + nContextLines : i3;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else {
          let nCommon = i3 - iStart;
          if (nCommon > nContextLines2) {
            let iEnd = iStart + nContextLines;
            for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
            lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options2), jPatchMark = lines.length, lines.push("");
            let nOmit = nCommon - nContextLines2;
            aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
            for (let iCommon = i3 - nContextLines; iCommon !== i3; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
          } else
            for (let iCommon = iStart; iCommon !== i3; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
        }
      for (; i3 !== iLength && diffs[i3][0] === DIFF_DELETE; )
        pushDeleteLine(diffs[i3][1]), i3 += 1;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_INSERT; )
        pushInsertLine(diffs[i3][1]), i3 += 1;
    }
    return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options2)), lines.join(`
`);
  }
  __name(joinAlignedDiffsNoExpand, "joinAlignedDiffsNoExpand");
  function joinAlignedDiffsExpand(diffs, options2) {
    return diffs.map((diff2, i3, diffs2) => {
      let line = diff2[1], isFirstOrLast = i3 === 0 || i3 === diffs2.length - 1;
      switch (diff2[0]) {
        case DIFF_DELETE:
          return printDeleteLine(line, isFirstOrLast, options2);
        case DIFF_INSERT:
          return printInsertLine(line, isFirstOrLast, options2);
        default:
          return printCommonLine(line, isFirstOrLast, options2);
      }
    }).join(`
`);
  }
  __name(joinAlignedDiffsExpand, "joinAlignedDiffsExpand");
  var noColor = __name((string) => string, "noColor"), DIFF_CONTEXT_DEFAULT = 5, DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
  function getDefaultOptions() {
    return {
      aAnnotation: "Expected",
      aColor: s.green,
      aIndicator: "-",
      bAnnotation: "Received",
      bColor: s.red,
      bIndicator: "+",
      changeColor: s.inverse,
      changeLineTrailingSpaceColor: noColor,
      commonColor: s.dim,
      commonIndicator: " ",
      commonLineTrailingSpaceColor: noColor,
      compareKeys: void 0,
      contextLines: DIFF_CONTEXT_DEFAULT,
      emptyFirstOrLastLinePlaceholder: "",
      expand: !1,
      includeChangeCounts: !1,
      omitAnnotationLines: !1,
      patchColor: s.yellow,
      printBasicPrototype: !1,
      truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
      truncateAnnotation: "... Diff result is truncated",
      truncateAnnotationColor: noColor
    };
  }
  __name(getDefaultOptions, "getDefaultOptions");
  function getCompareKeys(compareKeys) {
    return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
  }
  __name(getCompareKeys, "getCompareKeys");
  function getContextLines(contextLines) {
    return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
  }
  __name(getContextLines, "getContextLines");
  function normalizeDiffOptions(options2 = {}) {
    return {
      ...getDefaultOptions(),
      ...options2,
      compareKeys: getCompareKeys(options2.compareKeys),
      contextLines: getContextLines(options2.contextLines)
    };
  }
  __name(normalizeDiffOptions, "normalizeDiffOptions");
  function isEmptyString(lines) {
    return lines.length === 1 && lines[0].length === 0;
  }
  __name(isEmptyString, "isEmptyString");
  function countChanges(diffs) {
    let a22 = 0, b3 = 0;
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          a22 += 1;
          break;
        case DIFF_INSERT:
          b3 += 1;
          break;
      }
    }), {
      a: a22,
      b: b3
    };
  }
  __name(countChanges, "countChanges");
  function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
    if (omitAnnotationLines)
      return "";
    let aRest = "", bRest = "";
    if (includeChangeCounts) {
      let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
      aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
    }
    let a22 = `${aIndicator} ${aAnnotation}${aRest}`, b3 = `${bIndicator} ${bAnnotation}${bRest}`;
    return `${aColor(a22)}
${bColor(b3)}

`;
  }
  __name(printAnnotation, "printAnnotation");
  function printDiffLines(diffs, truncated, options2) {
    return printAnnotation(options2, countChanges(diffs)) + (options2.expand ? joinAlignedDiffsExpand(diffs, options2) : joinAlignedDiffsNoExpand(diffs, options2)) + (truncated ? options2.truncateAnnotationColor(`
${options2.truncateAnnotation}`) : "");
  }
  __name(printDiffLines, "printDiffLines");
  function diffLinesUnified(aLines, bLines, options2) {
    let normalizedOptions = normalizeDiffOptions(options2), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
    return printDiffLines(diffs, truncated, normalizedOptions);
  }
  __name(diffLinesUnified, "diffLinesUnified");
  function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options2) {
    if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length)
      return diffLinesUnified(aLinesDisplay, bLinesDisplay, options2);
    let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options2), aIndex = 0, bIndex = 0;
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          diff2[1] = aLinesDisplay[aIndex], aIndex += 1;
          break;
        case DIFF_INSERT:
          diff2[1] = bLinesDisplay[bIndex], bIndex += 1;
          break;
        default:
          diff2[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
      }
    }), printDiffLines(diffs, truncated, normalizeDiffOptions(options2));
  }
  __name(diffLinesUnified2, "diffLinesUnified2");
  function diffLinesRaw(aLines, bLines, options2) {
    let truncate2 = options2?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options2?.truncateThreshold ?? 0), 0), aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = __name((aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], "isCommon"), diffs = [], aIndex = 0, bIndex = 0, foundSubsequence = __name((nCommon, aCommon, bCommon) => {
      for (; aIndex !== aCommon; aIndex += 1)
        diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
      for (; bIndex !== bCommon; bIndex += 1)
        diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
      for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)
        diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }, "foundSubsequence");
    for (diffSequences(aLength, bLength, isCommon, foundSubsequence); aIndex !== aLength; aIndex += 1)
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bLength; bIndex += 1)
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    return [diffs, truncated];
  }
  __name(diffLinesRaw, "diffLinesRaw");
  function getType3(value2) {
    if (value2 === void 0)
      return "undefined";
    if (value2 === null)
      return "null";
    if (Array.isArray(value2))
      return "array";
    if (typeof value2 == "boolean")
      return "boolean";
    if (typeof value2 == "function")
      return "function";
    if (typeof value2 == "number")
      return "number";
    if (typeof value2 == "string")
      return "string";
    if (typeof value2 == "bigint")
      return "bigint";
    if (typeof value2 == "object") {
      if (value2 != null) {
        if (value2.constructor === RegExp)
          return "regexp";
        if (value2.constructor === Map)
          return "map";
        if (value2.constructor === Set)
          return "set";
        if (value2.constructor === Date)
          return "date";
      }
      return "object";
    } else if (typeof value2 == "symbol")
      return "symbol";
    throw new Error(`value of unknown type: ${value2}`);
  }
  __name(getType3, "getType");
  function getNewLineSymbol(string) {
    return string.includes(`\r
`) ? `\r
` : `
`;
  }
  __name(getNewLineSymbol, "getNewLineSymbol");
  function diffStrings(a22, b3, options2) {
    let truncate2 = options2?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options2?.truncateThreshold ?? 0), 0), aLength = a22.length, bLength = b3.length;
    if (truncate2) {
      let aMultipleLines = a22.includes(`
`), bMultipleLines = b3.includes(`
`), aNewLineSymbol = getNewLineSymbol(a22), bNewLineSymbol = getNewLineSymbol(b3), _a = aMultipleLines ? `${a22.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a22, _b = bMultipleLines ? `${b3.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b3;
      aLength = _a.length, bLength = _b.length;
    }
    let truncated = aLength !== a22.length || bLength !== b3.length, isCommon = __name((aIndex2, bIndex2) => a22[aIndex2] === b3[bIndex2], "isCommon"), aIndex = 0, bIndex = 0, diffs = [], foundSubsequence = __name((nCommon, aCommon, bCommon) => {
      aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b3.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b3.slice(bCommon, bIndex)));
    }, "foundSubsequence");
    return diffSequences(aLength, bLength, isCommon, foundSubsequence), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b3.slice(bIndex))), [diffs, truncated];
  }
  __name(diffStrings, "diffStrings");
  function concatenateRelevantDiffs(op, diffs, changeColor) {
    return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
  }
  __name(concatenateRelevantDiffs, "concatenateRelevantDiffs");
  var _ChangeBuffer = class {
    op;
    line;
    lines;
    changeColor;
    constructor(op, changeColor) {
      this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
    }
    pushSubstring(substring) {
      this.pushDiff(new Diff(this.op, substring));
    }
    pushLine() {
      this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
    }
    isLineEmpty() {
      return this.line.length === 0;
    }
    // Minor input to buffer.
    pushDiff(diff2) {
      this.line.push(diff2);
    }
    // Main input to buffer.
    align(diff2) {
      let string = diff2[1];
      if (string.includes(`
`)) {
        let substrings = string.split(`
`), iLast = substrings.length - 1;
        substrings.forEach((substring, i3) => {
          i3 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
        });
      } else
        this.pushDiff(diff2);
    }
    // Output from buffer.
    moveLinesTo(lines) {
      this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
    }
  };
  __name(_ChangeBuffer, "ChangeBuffer");
  var ChangeBuffer = _ChangeBuffer, _CommonBuffer = class {
    deleteBuffer;
    insertBuffer;
    lines;
    constructor(deleteBuffer, insertBuffer) {
      this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
    }
    pushDiffCommonLine(diff2) {
      this.lines.push(diff2);
    }
    pushDiffChangeLines(diff2) {
      let isDiffEmpty = diff2[1].length === 0;
      (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff2), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff2);
    }
    flushChangeLines() {
      this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
    }
    // Input to buffer.
    align(diff2) {
      let op = diff2[0], string = diff2[1];
      if (string.includes(`
`)) {
        let substrings = string.split(`
`), iLast = substrings.length - 1;
        substrings.forEach((substring, i3) => {
          if (i3 === 0) {
            let subdiff = new Diff(op, substring);
            this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
          } else i3 < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
        });
      } else
        this.pushDiffChangeLines(diff2);
    }
    // Output from buffer.
    getLines() {
      return this.flushChangeLines(), this.lines;
    }
  };
  __name(_CommonBuffer, "CommonBuffer");
  var CommonBuffer = _CommonBuffer;
  function getAlignedDiffs(diffs, changeColor) {
    let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          deleteBuffer.align(diff2);
          break;
        case DIFF_INSERT:
          insertBuffer.align(diff2);
          break;
        default:
          commonBuffer.align(diff2);
      }
    }), commonBuffer.getLines();
  }
  __name(getAlignedDiffs, "getAlignedDiffs");
  function hasCommonDiff(diffs, isMultiline) {
    if (isMultiline) {
      let iLast = diffs.length - 1;
      return diffs.some((diff2, i3) => diff2[0] === DIFF_EQUAL && (i3 !== iLast || diff2[1] !== `
`));
    }
    return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
  }
  __name(hasCommonDiff, "hasCommonDiff");
  function diffStringsUnified(a22, b3, options2) {
    if (a22 !== b3 && a22.length !== 0 && b3.length !== 0) {
      let isMultiline = a22.includes(`
`) || b3.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a22}
` : a22, isMultiline ? `${b3}
` : b3, !0, options2);
      if (hasCommonDiff(diffs, isMultiline)) {
        let optionsNormalized = normalizeDiffOptions(options2), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
        return printDiffLines(lines, truncated, optionsNormalized);
      }
    }
    return diffLinesUnified(a22.split(`
`), b3.split(`
`), options2);
  }
  __name(diffStringsUnified, "diffStringsUnified");
  function diffStringsRaw(a22, b3, cleanup, options2) {
    let [diffs, truncated] = diffStrings(a22, b3, options2);
    return cleanup && diff_cleanupSemantic(diffs), [diffs, truncated];
  }
  __name(diffStringsRaw, "diffStringsRaw");
  function getCommonMessage(message, options2) {
    let { commonColor } = normalizeDiffOptions(options2);
    return commonColor(message);
  }
  __name(getCommonMessage, "getCommonMessage");
  var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins, PLUGINS2 = [
    ReactTestComponent2,
    ReactElement2,
    DOMElement2,
    DOMCollection2,
    Immutable2,
    AsymmetricMatcher2,
    plugins.Error
  ], FORMAT_OPTIONS = {
    maxDepth: 20,
    plugins: PLUGINS2
  }, FALLBACK_FORMAT_OPTIONS = {
    callToJSON: !1,
    maxDepth: 8,
    plugins: PLUGINS2
  };
  function diff(a22, b3, options2) {
    if (Object.is(a22, b3))
      return "";
    let aType = getType3(a22), expectedType = aType, omitDifference = !1;
    if (aType === "object" && typeof a22.asymmetricMatch == "function") {
      if (a22.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a22.getExpectedType != "function")
        return;
      expectedType = a22.getExpectedType(), omitDifference = expectedType === "string";
    }
    if (expectedType !== getType3(b3)) {
      let truncate2 = function(s22) {
        return s22.length <= MAX_LENGTH ? s22 : `${s22.slice(0, MAX_LENGTH)}...`;
      };
      __name(truncate2, "truncate");
      let { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options2), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options2), aDisplay = format2(a22, formatOptions), bDisplay = format2(b3, formatOptions), MAX_LENGTH = 1e5;
      aDisplay = truncate2(aDisplay), bDisplay = truncate2(bDisplay);
      let aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
      return `${aDiff}

${bDiff}`;
    }
    if (!omitDifference)
      switch (aType) {
        case "string":
          return diffLinesUnified(a22.split(`
`), b3.split(`
`), options2);
        case "boolean":
        case "number":
          return comparePrimitive(a22, b3, options2);
        case "map":
          return compareObjects(sortMap(a22), sortMap(b3), options2);
        case "set":
          return compareObjects(sortSet(a22), sortSet(b3), options2);
        default:
          return compareObjects(a22, b3, options2);
      }
  }
  __name(diff, "diff");
  function comparePrimitive(a22, b3, options2) {
    let aFormat = format2(a22, FORMAT_OPTIONS), bFormat = format2(b3, FORMAT_OPTIONS);
    return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options2);
  }
  __name(comparePrimitive, "comparePrimitive");
  function sortMap(map2) {
    return new Map(Array.from(map2.entries()).sort());
  }
  __name(sortMap, "sortMap");
  function sortSet(set) {
    return new Set(Array.from(set.values()).sort());
  }
  __name(sortSet, "sortSet");
  function compareObjects(a22, b3, options2) {
    let difference, hasThrown = !1;
    try {
      let formatOptions = getFormatOptions(FORMAT_OPTIONS, options2);
      difference = getObjectsDifference(a22, b3, formatOptions, options2);
    } catch {
      hasThrown = !0;
    }
    let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options2);
    if (difference === void 0 || difference === noDiffMessage) {
      let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options2);
      difference = getObjectsDifference(a22, b3, formatOptions, options2), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options2)}

${difference}`);
    }
    return difference;
  }
  __name(compareObjects, "compareObjects");
  function getFormatOptions(formatOptions, options2) {
    let { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options2);
    return {
      ...formatOptions,
      compareKeys,
      printBasicPrototype,
      maxDepth: maxDepth ?? formatOptions.maxDepth
    };
  }
  __name(getFormatOptions, "getFormatOptions");
  function getObjectsDifference(a22, b3, formatOptions, options2) {
    let formatOptionsZeroIndent = {
      ...formatOptions,
      indent: 0
    }, aCompare = format2(a22, formatOptionsZeroIndent), bCompare = format2(b3, formatOptionsZeroIndent);
    if (aCompare === bCompare)
      return getCommonMessage(NO_DIFF_MESSAGE, options2);
    {
      let aDisplay = format2(a22, formatOptions), bDisplay = format2(b3, formatOptions);
      return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options2);
    }
  }
  __name(getObjectsDifference, "getObjectsDifference");
  var MAX_DIFF_STRING_LENGTH = 2e4;
  function isAsymmetricMatcher(data) {
    return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
  }
  __name(isAsymmetricMatcher, "isAsymmetricMatcher");
  function isReplaceable(obj1, obj2) {
    let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
    return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
  }
  __name(isReplaceable, "isReplaceable");
  function printDiffOrStringify(received, expected, options2) {
    let { aAnnotation, bAnnotation } = normalizeDiffOptions(options2);
    if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
      if (expected.includes(`
`) || received.includes(`
`))
        return diffStringsUnified(expected, received, options2);
      let [diffs] = diffStringsRaw(expected, received, !0), hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
      return `${expectedLine}
${receivedLine}`;
    }
    let clonedExpected = deepClone(expected, { forceWritable: !0 }), clonedReceived = deepClone(received, { forceWritable: !0 }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
    return diff(replacedExpected, replacedActual, options2);
  }
  __name(printDiffOrStringify, "printDiffOrStringify");
  function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
    return actual instanceof Error && expected instanceof Error && typeof actual.cause < "u" && typeof expected.cause > "u" ? (delete actual.cause, {
      replacedActual: actual,
      replacedExpected: expected
    }) : isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? {
      replacedActual: actual,
      replacedExpected: expected
    } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key) => {
      let expectedValue = expected[key], actualValue = actual[key];
      if (isAsymmetricMatcher(expectedValue))
        expectedValue.asymmetricMatch(actualValue) && (actual[key] = expectedValue);
      else if (isAsymmetricMatcher(actualValue))
        actualValue.asymmetricMatch(expectedValue) && (expected[key] = actualValue);
      else if (isReplaceable(actualValue, expectedValue)) {
        let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
        actual[key] = replaced.replacedActual, expected[key] = replaced.replacedExpected;
      }
    }), {
      replacedActual: actual,
      replacedExpected: expected
    }) : {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  __name(replaceAsymmetricMatcher, "replaceAsymmetricMatcher");
  function getLabelPrinter(...strings) {
    let maxLength = strings.reduce((max2, string) => string.length > max2 ? string.length : max2, 0);
    return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
  }
  __name(getLabelPrinter, "getLabelPrinter");
  var SPACE_SYMBOL = "\xB7";
  function replaceTrailingSpaces(text) {
    return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
  }
  __name(replaceTrailingSpaces, "replaceTrailingSpaces");
  function printReceived(object2) {
    return s.red(replaceTrailingSpaces(stringify2(object2)));
  }
  __name(printReceived, "printReceived");
  function printExpected(value2) {
    return s.green(replaceTrailingSpaces(stringify2(value2)));
  }
  __name(printExpected, "printExpected");
  function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
    return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
  }
  __name(getCommonAndChangedSubstrings, "getCommonAndChangedSubstrings");
  var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@", IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
  function isImmutable(v3) {
    return v3 && (v3[IS_COLLECTION_SYMBOL] || v3[IS_RECORD_SYMBOL]);
  }
  __name(isImmutable, "isImmutable");
  var OBJECT_PROTO = Object.getPrototypeOf({});
  function getUnserializableMessage(err) {
    return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
  }
  __name(getUnserializableMessage, "getUnserializableMessage");
  function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
    if (!val || typeof val == "string")
      return val;
    if (val instanceof Error && "toJSON" in val && typeof val.toJSON == "function") {
      let jsonValue = val.toJSON();
      return jsonValue && jsonValue !== val && typeof jsonValue == "object" && (typeof val.message == "string" && safe(() => jsonValue.message ?? (jsonValue.message = val.message)), typeof val.stack == "string" && safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack)), typeof val.name == "string" && safe(() => jsonValue.name ?? (jsonValue.name = val.name)), val.cause != null && safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)))), serializeValue(jsonValue, seen);
    }
    if (typeof val == "function")
      return `Function<${val.name || "anonymous"}>`;
    if (typeof val == "symbol")
      return val.toString();
    if (typeof val != "object")
      return val;
    if (typeof Buffer < "u" && val instanceof Buffer)
      return `<Buffer(${val.length}) ...>`;
    if (typeof Uint8Array < "u" && val instanceof Uint8Array)
      return `<Uint8Array(${val.length}) ...>`;
    if (isImmutable(val))
      return serializeValue(val.toJSON(), seen);
    if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction")
      return "Promise";
    if (typeof Element < "u" && val instanceof Element)
      return val.tagName;
    if (typeof val.asymmetricMatch == "function")
      return `${val.toString()} ${format22(val.sample)}`;
    if (typeof val.toJSON == "function")
      return serializeValue(val.toJSON(), seen);
    if (seen.has(val))
      return seen.get(val);
    if (Array.isArray(val)) {
      let clone2 = new Array(val.length);
      return seen.set(val, clone2), val.forEach((e, i3) => {
        try {
          clone2[i3] = serializeValue(e, seen);
        } catch (err) {
          clone2[i3] = getUnserializableMessage(err);
        }
      }), clone2;
    } else {
      let clone2 = /* @__PURE__ */ Object.create(null);
      seen.set(val, clone2);
      let obj = val;
      for (; obj && obj !== OBJECT_PROTO; )
        Object.getOwnPropertyNames(obj).forEach((key) => {
          if (!(key in clone2))
            try {
              clone2[key] = serializeValue(val[key], seen);
            } catch (err) {
              delete clone2[key], clone2[key] = getUnserializableMessage(err);
            }
        }), obj = Object.getPrototypeOf(obj);
      return clone2;
    }
  }
  __name(serializeValue, "serializeValue");
  function safe(fn3) {
    try {
      return fn3();
    } catch {
    }
  }
  __name(safe, "safe");
  function normalizeErrorMessage(message) {
    return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
  }
  __name(normalizeErrorMessage, "normalizeErrorMessage");
  function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
    if (!_err || typeof _err != "object")
      return { message: String(_err) };
    let err = _err;
    (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, {
      ...diffOptions,
      ...err.diffOptions
    })), "expected" in err && typeof err.expected != "string" && (err.expected = stringify2(err.expected, 10)), "actual" in err && typeof err.actual != "string" && (err.actual = stringify2(err.actual, 10));
    try {
      typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
    } catch {
    }
    try {
      !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
    } catch {
    }
    try {
      return serializeValue(err);
    } catch (e) {
      return serializeValue(new Error(`Failed to fully serialize error: ${e?.message}
Inner error message: ${err?.message}`));
    }
  }
  __name(processError, "processError");

  // node_modules/storybook/dist/instrumenter/index.js
  init_chunk_MM7DTO55();
  init_client_logger();
  init_dist();
  var addons2 = globalThis.__STORYBOOK_ADDONS_PREVIEW, alreadyCompletedException = new Error(
    "This function ran after the play function completed. Did you forget to `await` it?"
  ), isObject3 = __name((o2) => Object.prototype.toString.call(o2) === "[object Object]", "isObject"), isModule = __name((o2) => Object.prototype.toString.call(o2) === "[object Module]", "isModule"), isInstrumentable = __name((o2) => {
    if (!isObject3(o2) && !isModule(o2))
      return !1;
    if (o2.constructor === void 0)
      return !0;
    let proto = o2.constructor.prototype;
    return !!isObject3(proto);
  }, "isInstrumentable"), construct = __name((obj) => {
    try {
      return new obj.constructor();
    } catch {
      return {};
    }
  }, "construct"), getInitialState = __name(() => ({
    renderPhase: "preparing",
    isDebugging: !1,
    isPlaying: !1,
    isLocked: !1,
    cursor: 0,
    calls: [],
    shadowCalls: [],
    callRefsByResult: /* @__PURE__ */ new Map(),
    chainedCallIds: /* @__PURE__ */ new Set(),
    ancestors: [],
    playUntil: void 0,
    resolvers: {},
    syncTimeout: void 0
  }), "getInitialState"), getRetainedState = __name((state3, isDebugging = !1) => {
    let calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call) => call.retain);
    if (!calls.length)
      return;
    let callRefsByResult = new Map(
      Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
    );
    return { cursor: calls.length, calls, callRefsByResult };
  }, "getRetainedState"), _Instrumenter = class {
    constructor() {
      this.detached = !1, this.initialized = !1, this.state = {}, this.loadParentWindowState = __name(() => {
        try {
          this.state = scope.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
        } catch {
          this.detached = !0;
        }
      }, "loadParentWindowState"), this.updateParentWindowState = __name(() => {
        try {
          scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
        } catch {
          this.detached = !0;
        }
      }, "updateParentWindowState"), this.loadParentWindowState();
      let resetState = __name(({
        storyId,
        renderPhase,
        isPlaying = !0,
        isDebugging = !1
      }) => {
        let state3 = this.getState(storyId);
        this.setState(storyId, {
          ...getInitialState(),
          ...getRetainedState(state3, isDebugging),
          renderPhase: renderPhase || state3.renderPhase,
          shadowCalls: isDebugging ? state3.shadowCalls : [],
          chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
          playUntil: isDebugging ? state3.playUntil : void 0,
          isPlaying,
          isDebugging
        }), this.sync(storyId);
      }, "resetState"), start2 = __name((channel) => ({ storyId, playUntil }) => {
        this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({
          calls: [],
          shadowCalls: calls.map((call) => ({
            ...call,
            status: "waiting"
            /* WAITING */
          })),
          isDebugging: !0
        }));
        let log = this.getLog(storyId);
        this.setState(storyId, ({ shadowCalls }) => {
          if (playUntil || !log.length)
            return { playUntil };
          let firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);
          return {
            playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id
          };
        }), channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });
      }, "start"), back = __name((channel) => ({ storyId }) => {
        let log = this.getLog(storyId).filter((call) => !call.ancestors?.length), last = log.reduceRight((res, item, index3) => res >= 0 || item.status === "waiting" ? res : index3, -1);
        start2(channel)({ storyId, playUntil: log[last - 1]?.callId });
      }, "back"), goto = __name((channel) => ({ storyId, callId }) => {
        let { calls, shadowCalls, resolvers } = this.getState(storyId), call = calls.find(({ id: id2 }) => id2 === callId), shadowCall = shadowCalls.find(({ id: id2 }) => id2 === callId);
        if (!call && shadowCall && Object.values(resolvers).length > 0) {
          let nextId = this.getLog(storyId).find(
            (c3) => c3.status === "waiting"
            /* WAITING */
          )?.callId;
          shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());
        } else
          start2(channel)({ storyId, playUntil: callId });
      }, "goto"), next = __name((channel) => ({ storyId }) => {
        let { resolvers } = this.getState(storyId);
        if (Object.values(resolvers).length > 0)
          Object.values(resolvers).forEach((resolve) => resolve());
        else {
          let nextId = this.getLog(storyId).find(
            (c3) => c3.status === "waiting"
            /* WAITING */
          )?.callId;
          nextId ? start2(channel)({ storyId, playUntil: nextId }) : end2({ storyId });
        }
      }, "next"), end2 = __name(({ storyId }) => {
        this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
      }, "end"), renderPhaseChanged = __name(({
        storyId,
        newPhase
      }) => {
        let { isDebugging } = this.getState(storyId);
        if (newPhase === "preparing" && isDebugging)
          return resetState({ storyId, renderPhase: newPhase, isDebugging });
        if (newPhase === "playing")
          return resetState({ storyId, renderPhase: newPhase, isDebugging });
        newPhase === "played" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !1,
          isPlaying: !1,
          isDebugging: !1
        }) : newPhase === "errored" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !1,
          isPlaying: !1
        }) : newPhase === "aborted" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !0,
          isPlaying: !1
        }) : this.setState(storyId, {
          renderPhase: newPhase
        }), this.sync(storyId);
      }, "renderPhaseChanged");
      addons2 && addons2.ready().then(() => {
        this.channel = addons2.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {
          this.initialized ? this.cleanup() : this.initialized = !0;
        }), this.channel.on(EVENTS3.START, start2(this.channel)), this.channel.on(EVENTS3.BACK, back(this.channel)), this.channel.on(EVENTS3.GOTO, goto(this.channel)), this.channel.on(EVENTS3.NEXT, next(this.channel)), this.channel.on(EVENTS3.END, end2);
      });
    }
    getState(storyId) {
      return this.state[storyId] || getInitialState();
    }
    setState(storyId, update) {
      if (storyId) {
        let state3 = this.getState(storyId), patch = typeof update == "function" ? update(state3) : update;
        this.state = { ...this.state, [storyId]: { ...state3, ...patch } }, this.updateParentWindowState();
      }
    }
    cleanup() {
      this.state = Object.entries(this.state).reduce(
        (acc, [storyId, state3]) => {
          let retainedState = getRetainedState(state3);
          return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;
        },
        {}
      );
      let payload = { controlStates: {
        detached: this.detached,
        start: !1,
        back: !1,
        goto: !1,
        next: !1,
        end: !1
      }, logItems: [] };
      this.channel?.emit(EVENTS3.SYNC, payload), this.updateParentWindowState();
    }
    getLog(storyId) {
      let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];
      calls.forEach((call, index3) => {
        merged[index3] = call;
      });
      let seen = /* @__PURE__ */ new Set();
      return merged.reduceRight((acc, call) => (call.args.forEach((arg) => {
        arg?.__callId__ && seen.add(arg.__callId__);
      }), call.path.forEach((node) => {
        node.__callId__ && seen.add(node.__callId__);
      }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors }), seen.add(call.id)), acc), []);
    }
    // Traverses the object structure to recursively patch all function properties.
    // Returns the original object, or a new object with the same constructor,
    // depending on whether it should mutate.
    instrument(obj, options2, depth = 0) {
      if (!isInstrumentable(obj))
        return obj;
      let { mutate = !1, path = [] } = options2, keys = options2.getKeys ? options2.getKeys(obj, depth) : Object.keys(obj);
      return depth += 1, keys.reduce(
        (acc, key) => {
          let descriptor = getPropertyDescriptor(obj, key);
          if (typeof descriptor?.get == "function") {
            if (descriptor.configurable) {
              let getter = __name(() => descriptor?.get?.bind(obj)?.(), "getter");
              Object.defineProperty(acc, key, {
                get: __name(() => this.instrument(getter(), { ...options2, path: path.concat(key) }, depth), "get")
              });
            }
            return acc;
          }
          let value2 = obj[key];
          return typeof value2 != "function" ? (acc[key] = this.instrument(value2, { ...options2, path: path.concat(key) }, depth), acc) : "__originalFn__" in value2 && typeof value2.__originalFn__ == "function" ? (acc[key] = value2, acc) : (acc[key] = (...args) => this.track(key, value2, obj, args, options2), acc[key].__originalFn__ = value2, Object.defineProperty(acc[key], "name", { value: key, writable: !1 }), Object.keys(value2).length > 0 && Object.assign(
            acc[key],
            this.instrument({ ...value2 }, { ...options2, path: path.concat(key) }, depth)
          ), acc);
        },
        mutate ? obj : construct(obj)
      );
    }
    // Monkey patch an object method to record calls.
    // Returns a function that invokes the original function, records the invocation ("call") and
    // returns the original result.
    track(method, fn3, object2, args, options2) {
      let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);
      this.setState(storyId, { cursor: cursor + 1 });
      let id2 = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options2, interceptable = typeof intercept == "function" ? intercept(method, path) : intercept, call = { id: id2, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn3, object2, call, options2);
      return this.instrument(result, { ...options2, mutate: !0, path: [{ __callId__: call.id }] });
    }
    intercept(fn3, object2, call, options2) {
      let { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId), isChainedUpon = chainedCallIds.has(call.id);
      return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, { playUntil: void 0 }), this.invoke(fn3, object2, call, options2)) : new Promise((resolve) => {
        this.setState(call.storyId, ({ resolvers }) => ({
          isLocked: !1,
          resolvers: { ...resolvers, [call.id]: resolve }
        }));
      }).then(() => (this.setState(call.storyId, (state3) => {
        let { [call.id]: _3, ...resolvers } = state3.resolvers;
        return { isLocked: !0, resolvers };
      }), this.invoke(fn3, object2, call, options2)));
    }
    invoke(fn3, object2, call, options2) {
      let { callRefsByResult, renderPhase } = this.getState(call.storyId), maximumDepth = 25, serializeValues = __name((value2, depth, seen) => {
        if (seen.includes(value2))
          return "[Circular]";
        if (seen = [...seen, value2], depth > maximumDepth)
          return "...";
        if (callRefsByResult.has(value2))
          return callRefsByResult.get(value2);
        if (value2 instanceof Array)
          return value2.map((it) => serializeValues(it, ++depth, seen));
        if (value2 instanceof Date)
          return { __date__: { value: value2.toISOString() } };
        if (value2 instanceof Error) {
          let { name, message, stack } = value2;
          return { __error__: { name, message, stack } };
        }
        if (value2 instanceof RegExp) {
          let { flags, source } = value2;
          return { __regexp__: { flags, source } };
        }
        if (value2 instanceof scope.window?.HTMLElement) {
          let { prefix: prefix2, localName, id: id2, classList, innerText } = value2, classNames = Array.from(classList);
          return { __element__: { prefix: prefix2, localName, id: id2, classNames, innerText } };
        }
        return typeof value2 == "function" ? {
          __function__: { name: "getMockName" in value2 ? value2.getMockName() : value2.name }
        } : typeof value2 == "symbol" ? { __symbol__: { description: value2.description } } : typeof value2 == "object" && value2?.constructor?.name && value2?.constructor?.name !== "Object" ? { __class__: { name: value2.constructor.name } } : Object.prototype.toString.call(value2) === "[object Object]" ? Object.fromEntries(
          Object.entries(value2).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
        ) : value2;
      }, "serializeValues"), info = {
        ...call,
        args: call.args.map((arg) => serializeValues(arg, 0, []))
      };
      call.path.forEach((ref) => {
        ref?.__callId__ && this.setState(call.storyId, ({ chainedCallIds }) => ({
          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
        }));
      });
      let handleException = __name((e) => {
        if (e instanceof Error) {
          let { name, message, stack, callId = call.id } = e, {
            showDiff = void 0,
            diff: diff2 = void 0,
            actual = void 0,
            expected = void 0
          } = e.name === "AssertionError" ? processError(e) : e, exception = { name, message, stack, callId, showDiff, diff: diff2, actual, expected };
          if (this.update({ ...info, status: "error", exception }), this.setState(call.storyId, (state3) => ({
            callRefsByResult: new Map([
              ...Array.from(state3.callRefsByResult.entries()),
              [e, { __callId__: call.id, retain: call.retain }]
            ])
          })), call.ancestors?.length)
            throw Object.prototype.hasOwnProperty.call(e, "callId") || Object.defineProperty(e, "callId", { value: call.id }), e;
        }
        throw e;
      }, "handleException");
      try {
        if (renderPhase === "played" && !call.retain)
          throw alreadyCompletedException;
        let finalArgs = (options2.getArgs ? options2.getArgs(call, this.getState(call.storyId)) : call.args).map((arg) => typeof arg != "function" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {
          let { cursor, ancestors } = this.getState(call.storyId);
          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });
          let restore = __name(() => this.setState(call.storyId, { cursor, ancestors }), "restore"), willRestore = !1;
          try {
            let res = arg(...args);
            return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;
          } finally {
            willRestore || restore();
          }
        }), result = fn3.apply(object2, finalArgs);
        return result && ["object", "function", "symbol"].includes(typeof result) && this.setState(call.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [result, { __callId__: call.id, retain: call.retain }]
          ])
        })), this.update({
          ...info,
          status: result instanceof Promise ? "active" : "done"
          /* DONE */
        }), result instanceof Promise ? result.then((value2) => (this.update({
          ...info,
          status: "done"
          /* DONE */
        }), value2), handleException) : result;
      } catch (e) {
        return handleException(e);
      }
    }
    // Sends the call info to the manager and synchronizes the log.
    update(call) {
      this.channel?.emit(EVENTS3.CALL, call), this.setState(call.storyId, ({ calls }) => {
        let callsById = calls.concat(call).reduce((a3, c3) => Object.assign(a3, { [c3.id]: c3 }), {});
        return {
          // Calls are sorted to ensure parent calls always come before calls in their callback.
          calls: Object.values(callsById).sort(
            (a3, b3) => a3.id.localeCompare(b3.id, void 0, { numeric: !0 })
          )
        };
      }), this.sync(call.storyId);
    }
    // Builds a log of interceptable calls and control states and sends it to the manager.
    // Uses a 0ms debounce because this might get called many times in one tick.
    sync(storyId) {
      let synchronize = __name(() => {
        let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find(
          (item) => item.status === "waiting"
          /* WAITING */
        )?.callId, hasActive = logItems.some(
          (item) => item.status === "active"
          /* ACTIVE */
        );
        if (this.detached || isLocked || hasActive || logItems.length === 0) {
          let payload2 = { controlStates: {
            detached: this.detached,
            start: !1,
            back: !1,
            goto: !1,
            next: !1,
            end: !1
          }, logItems };
          this.channel?.emit(EVENTS3.SYNC, payload2);
          return;
        }
        let hasPrevious = logItems.some(
          (item) => item.status === "done" || item.status === "error"
          /* ERROR */
        ), payload = { controlStates: {
          detached: this.detached,
          start: hasPrevious,
          back: hasPrevious,
          goto: !0,
          next: isPlaying,
          end: isPlaying
        }, logItems, pausedAt };
        this.channel?.emit(EVENTS3.SYNC, payload);
      }, "synchronize");
      this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));
    }
  };
  __name(_Instrumenter, "Instrumenter");
  var Instrumenter = _Instrumenter;
  function instrument(obj, options2 = {}) {
    try {
      let forceInstrument = !1, skipInstrument = !1;
      return scope.window?.location?.search?.includes("instrument=true") ? forceInstrument = !0 : scope.window?.location?.search?.includes("instrument=false") && (skipInstrument = !0), scope.window?.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (scope.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options2));
    } catch (e) {
      return once.warn(e), obj;
    }
  }
  __name(instrument, "instrument");
  function getPropertyDescriptor(obj, propName) {
    let target = obj;
    for (; target != null; ) {
      let descriptor = Object.getOwnPropertyDescriptor(target, propName);
      if (descriptor)
        return descriptor;
      target = Object.getPrototypeOf(target);
    }
  }
  __name(getPropertyDescriptor, "getPropertyDescriptor");
  function isClass(obj) {
    if (typeof obj != "function")
      return !1;
    let descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
    return descriptor ? !descriptor.writable : !1;
  }
  __name(isClass, "isClass");

  // node_modules/storybook/dist/csf/index.js
  init_dist();
  init_dist();
  init_dist();
  init_dist();
  var require_tiny_isequal = __commonJS2({
    "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isEqual = /* @__PURE__ */ (function() {
        var e = Object.prototype.toString, r2 = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {
          return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));
        } : Object.keys;
        return function(n2, a3) {
          return __name(function n22(a22, c3, u3) {
            var i3, s4, l2, o2 = e.call(a22), f4 = e.call(c3);
            if (a22 === c3) return !0;
            if (a22 == null || c3 == null) return !1;
            if (u3.indexOf(a22) > -1 && u3.indexOf(c3) > -1) return !0;
            if (u3.push(a22, c3), o2 != f4 || (i3 = t(a22), s4 = t(c3), i3.length != s4.length || i3.some(function(e2) {
              return !n22(a22[e2], c3[e2], u3);
            }))) return !1;
            switch (o2.slice(8, -1)) {
              case "Symbol":
                return a22.valueOf() == c3.valueOf();
              case "Date":
              case "Number":
                return +a22 == +c3 || +a22 != +a22 && +c3 != +c3;
              case "RegExp":
              case "Function":
              case "String":
              case "Boolean":
                return "" + a22 == "" + c3;
              case "Set":
              case "Map":
                i3 = a22.entries(), s4 = c3.entries();
                do
                  if (!n22((l2 = i3.next()).value, s4.next().value, u3)) return !1;
                while (!l2.done);
                return !0;
              case "ArrayBuffer":
                a22 = new Uint8Array(a22), c3 = new Uint8Array(c3);
              case "DataView":
                a22 = new Uint8Array(a22.buffer), c3 = new Uint8Array(c3.buffer);
              case "Float32Array":
              case "Float64Array":
              case "Int8Array":
              case "Int16Array":
              case "Int32Array":
              case "Uint8Array":
              case "Uint16Array":
              case "Uint32Array":
              case "Uint8ClampedArray":
              case "Arguments":
              case "Array":
                if (a22.length != c3.length) return !1;
                for (l2 = 0; l2 < a22.length; l2++) if ((l2 in a22 || l2 in c3) && (l2 in a22 != l2 in c3 || !n22(a22[l2], c3[l2], u3))) return !1;
                return !0;
              case "Object":
                return n22(r2(a22), r2(c3), u3);
              default:
                return !1;
            }
          }, "n")(n2, a3, []);
        };
      })();
    }
  });
  function toStartCaseStr(str2) {
    return str2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str22, $1, $22, $3) => `${$1} ${$22}${$3}`).replace(/([a-z])([A-Z])/g, (str22, $1, $22) => `${$1} ${$22}`).replace(/([a-z])([0-9])/gi, (str22, $1, $22) => `${$1} ${$22}`).replace(/([0-9])([a-z])/gi, (str22, $1, $22) => `${$1} ${$22}`).replace(/(\s|^)(\w)/g, (str22, $1, $22) => `${$1}${$22.toUpperCase()}`).replace(/ +/g, " ").trim();
  }
  __name(toStartCaseStr, "toStartCaseStr");
  var import_tiny_isequal = __toESM2(require_tiny_isequal(), 1), count = __name((vals) => vals.map((v3) => typeof v3 < "u").filter(Boolean).length, "count"), testValue = __name((cond, value2) => {
    let { exists, eq: eq2, neq, truthy } = cond;
    if (count([exists, eq2, neq, truthy]) > 1)
      throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq2, neq })}`);
    if (typeof eq2 < "u")
      return (0, import_tiny_isequal.isEqual)(value2, eq2);
    if (typeof neq < "u")
      return !(0, import_tiny_isequal.isEqual)(value2, neq);
    if (typeof exists < "u") {
      let valueExists = typeof value2 < "u";
      return exists ? valueExists : !valueExists;
    }
    return (typeof truthy > "u" ? !0 : truthy) ? !!value2 : !value2;
  }, "testValue"), includeConditionalArg = __name((argType, args, globals) => {
    if (!argType.if)
      return !0;
    let { arg, global: global5 } = argType.if;
    if (count([arg, global5]) !== 1)
      throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global5 })}`);
    let value2 = arg ? args[arg] : globals[global5];
    return testValue(argType.if, value2);
  }, "includeConditionalArg"), addArgs_exports = {};
  __export2(addArgs_exports, {
    argsEnhancers: () => argsEnhancers
  });
  var isInInitialArgs = __name((name, initialArgs) => typeof initialArgs[name] > "u" && !(name in initialArgs), "isInInitialArgs"), inferActionsFromArgTypesRegex = __name((context) => {
    let {
      initialArgs,
      argTypes,
      id: id2,
      parameters: { actions: actions2 }
    } = context;
    if (!actions2 || actions2.disable || !actions2.argTypesRegex || !argTypes)
      return {};
    let argTypesRegex = new RegExp(actions2.argTypesRegex);
    return Object.entries(argTypes).filter(
      ([name]) => !!argTypesRegex.test(name)
    ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: !0, id: id2 })), acc), {});
  }, "inferActionsFromArgTypesRegex"), addActionsFromArgTypes = __name((context) => {
    let {
      initialArgs,
      argTypes,
      parameters: { actions: actions2 }
    } = context;
    return actions2?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == "string" ? argType.action : name)), acc), {});
  }, "addActionsFromArgTypes"), argsEnhancers = [
    addActionsFromArgTypes,
    inferActionsFromArgTypesRegex
  ], loaders_exports = {};
  __export2(loaders_exports, {
    loaders: () => loaders
  });
  var subscribed = !1, logActionsWhenMockCalled = __name((context) => {
    let { parameters: parameters2 } = context;
    parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {
      let name = mock.getMockName();
      name !== "spy" && name !== "vi.fn()" && (!/^next\/.*::/.test(name) || [
        "next/router::useRouter()",
        "next/navigation::useRouter()",
        "next/navigation::redirect",
        "next/cache::",
        "next/headers::cookies().set",
        "next/headers::cookies().delete",
        "next/headers::headers().set",
        "next/headers::headers().delete"
      ].some((prefix2) => name.startsWith(prefix2))) && action(name)(args);
    }), subscribed = !0);
  }, "logActionsWhenMockCalled"), loaders = [logActionsWhenMockCalled], preview_default = __name(() => ({
    ...addArgs_exports,
    ...loaders_exports
  }), "default"), { document: document24 } = globalThis, isReduceMotionEnabled = __name(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, "isReduceMotionEnabled"), clearStyles = __name((selector) => {
    (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);
  }, "clearStyles"), clearStyle = __name((selector) => {
    if (!document24)
      return;
    let element = document24.getElementById(selector);
    element && element.parentElement && element.parentElement.removeChild(element);
  }, "clearStyle"), addGridStyle = __name((selector, css2) => {
    if (!document24)
      return;
    let existingStyle = document24.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = document24.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2, document24.head.appendChild(style);
    }
  }, "addGridStyle"), addBackgroundStyle = __name((selector, css2, storyId) => {
    if (!document24)
      return;
    let existingStyle = document24.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = document24.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2;
      let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`, existingGridStyle = document24.getElementById(gridStyleSelector);
      existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document24.head.appendChild(style);
    }
  }, "addBackgroundStyle"), defaultGrid = {
    cellSize: 100,
    cellAmount: 10,
    opacity: 0.8
  }, BG_SELECTOR_BASE = "addon-backgrounds", GRID_SELECTOR_BASE = "addon-backgrounds-grid", transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;", withBackgroundAndGrid = __name((StoryFn, context) => {
    let { globals = {}, parameters: parameters2 = {}, viewMode, id: id2 } = context, {
      options: options2 = DEFAULT_BACKGROUNDS,
      disable,
      grid = defaultGrid
    } = parameters2[PARAM_KEY] || {}, data = globals[PARAM_KEY] || {}, backgroundName = typeof data == "string" ? data : data?.value, item = backgroundName ? options2[backgroundName] : void 0, value2 = typeof item == "string" ? item : item?.value || "transparent", showGrid = typeof data == "string" ? !1 : data.grid || !1, shownBackground = !!item && !disable, backgroundSelector = viewMode === "docs" ? `#anchor--${id2} .docs-story` : ".sb-show-main", gridSelector = viewMode === "docs" ? `#anchor--${id2} .docs-story` : ".sb-show-main", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded", defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id2}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === "docs" ? id2 : null;
    useEffect2(() => {
      let backgroundStyles = `
    ${backgroundSelector} {
      background: ${value2} !important;
      ${transitionStyle}
      }`;
      if (!shownBackground) {
        clearStyles(backgroundSelectorId);
        return;
      }
      addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
    }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value2]);
    let gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id2}` : `${GRID_SELECTOR_BASE}`;
    return useEffect2(() => {
      if (!showGrid) {
        clearStyles(gridSelectorId);
        return;
      }
      let gridSize = [
        `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
        `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
        `${cellSize}px ${cellSize}px`,
        `${cellSize}px ${cellSize}px`
      ].join(", "), gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
      addGridStyle(gridSelectorId, gridStyles);
    }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();
  }, "withBackgroundAndGrid"), decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [], parameters = {
    [PARAM_KEY]: {
      grid: {
        cellSize: 20,
        opacity: 0.5,
        cellAmount: 5
      },
      disable: !1
    }
  }, initialGlobals = {
    [PARAM_KEY]: { value: void 0, grid: !1 }
  }, preview_default2 = __name(() => ({
    decorators,
    parameters,
    initialGlobals
  }), "default"), { step } = instrument(
    {
      // It seems like the label is unused, but the instrumenter has access to it
      // The context will be bounded later in StoryRender, so that the user can write just:
      // await step("label", (context) => {
      //   // labeled step
      // });
      step: __name(async (label, play, context) => play(context), "step")
    },
    { intercept: !0 }
  ), preview_default3 = __name(() => ({
    parameters: {
      throwPlayFunctionExceptions: !1
    },
    runStep: step
  }), "default"), iconPaths = {
    chevronLeft: [
      "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
    ],
    chevronRight: [
      "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
    ],
    info: [
      "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
      "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
    ],
    shareAlt: [
      "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
      "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
    ]
  }, svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), createElement2 = __name((type, props = {}, children) => {
    let element = svgElements.includes(type) ? document.createElementNS("http://www.w3.org/2000/svg", type) : document.createElement(type);
    return Object.entries(props).forEach(([key, val]) => {
      /[A-Z]/.test(key) ? (key === "onClick" && (element.addEventListener("click", val), element.addEventListener("keydown", (e) => {
        (e.key === "Enter" || e.key === " ") && (e.preventDefault(), val());
      })), key === "onMouseEnter" && element.addEventListener("mouseenter", val), key === "onMouseLeave" && element.addEventListener("mouseleave", val)) : element.setAttribute(key, val);
    }), children?.forEach((child) => {
      if (!(child == null || child === !1))
        try {
          element.appendChild(child);
        } catch {
          element.appendChild(document.createTextNode(String(child)));
        }
    }), element;
  }, "createElement"), createIcon = __name((name) => iconPaths[name] && createElement2(
    "svg",
    { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
    iconPaths[name].map(
      (d3) => createElement2("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: d3
      })
    )
  ), "createIcon"), normalizeOptions = __name((options2) => {
    if ("elements" in options2) {
      let { elements, color: color2, style } = options2;
      return {
        id: void 0,
        priority: 0,
        selectors: elements,
        styles: {
          outline: `2px ${style} ${color2}`,
          outlineOffset: "2px",
          boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
        },
        menu: void 0
      };
    }
    let { menu, ...rest } = options2;
    return {
      id: void 0,
      priority: 0,
      styles: {
        outline: "2px dashed #029cfd"
      },
      ...rest,
      menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
    };
  }, "normalizeOptions"), isFunction = __name((obj) => obj instanceof Function, "isFunction"), state = /* @__PURE__ */ new Map(), listeners = /* @__PURE__ */ new Map(), teardowns = /* @__PURE__ */ new Map(), useStore = __name((initialValue) => {
    let key = Symbol();
    listeners.set(key, []), state.set(key, initialValue);
    let get = __name(() => state.get(key), "get"), set = __name((update) => {
      let current = state.get(key), next = isFunction(update) ? update(current) : update;
      next !== current && (state.set(key, next), listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.(), teardowns.set(listener, listener(next));
      }));
    }, "set"), subscribe = __name((listener) => (listeners.get(key)?.push(listener), () => {
      let list = listeners.get(key);
      list && listeners.set(
        key,
        list.filter((l2) => l2 !== listener)
      );
    }), "subscribe"), teardown = __name(() => {
      listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.(), teardowns.delete(listener);
      }), listeners.delete(key), state.delete(key);
    }, "teardown");
    return { get, set, subscribe, teardown };
  }, "useStore"), mapElements = __name((highlights) => {
    let root = document.getElementById("storybook-root"), map2 = /* @__PURE__ */ new Map();
    for (let highlight2 of highlights) {
      let { priority = 0 } = highlight2;
      for (let selector of highlight2.selectors) {
        let elements = [
          ...document.querySelectorAll(
            // Elements matching the selector, excluding storybook elements and their descendants.
            // Necessary to find portaled elements (e.g. children of `body`).
            `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
          ),
          // Elements matching the selector inside the storybook root, as these were excluded above.
          ...root?.querySelectorAll(selector) || []
        ];
        for (let element of elements) {
          let existing = map2.get(element);
          (!existing || existing.priority <= priority) && map2.set(element, {
            ...highlight2,
            priority,
            selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
          });
        }
      }
    }
    return map2;
  }, "mapElements"), mapBoxes = __name((elements) => Array.from(elements.entries()).map(([element, { selectors, styles: styles3, hoverStyles, focusStyles, menu }]) => {
    let { top: top2, left: left2, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);
    return {
      element,
      selectors,
      styles: styles3,
      hoverStyles,
      focusStyles,
      menu,
      top: position === "fixed" ? top2 : top2 + window.scrollY,
      left: position === "fixed" ? left2 : left2 + window.scrollX,
      width,
      height
    };
  }).sort((a3, b3) => b3.width * b3.height - a3.width * a3.height), "mapBoxes"), isOverMenu = __name((menuElement, coordinates) => {
    let menu = menuElement.getBoundingClientRect(), { x: x3, y: y3 } = coordinates;
    return menu?.top && menu?.left && x3 >= menu.left && x3 <= menu.left + menu.width && y3 >= menu.top && y3 <= menu.top + menu.height;
  }, "isOverMenu"), isTargeted = __name((box, boxElement, coordinates) => {
    if (!boxElement || !coordinates)
      return !1;
    let { left: left2, top: top2, width, height } = box;
    height < MIN_TOUCH_AREA_SIZE && (top2 = top2 - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left2 = left2 - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === "fixed" && (left2 += window.scrollX, top2 += window.scrollY);
    let { x: x3, y: y3 } = coordinates;
    return x3 >= left2 && x3 <= left2 + width && y3 >= top2 && y3 <= top2 + height;
  }, "isTargeted"), keepInViewport = __name((element, targetCoordinates, options2 = {}) => {
    let { x: x3, y: y3 } = targetCoordinates, { margin = 5, topOffset = 0, centered = !1 } = options2, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top2 = Math.min(
      element.style.position === "fixed" ? y3 - scrollY : y3,
      windowHeight - element.clientHeight - margin - topOffset + scrollY
    ), leftOffset = centered ? element.clientWidth / 2 : 0, left2 = element.style.position === "fixed" ? Math.max(Math.min(x3 - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
      Math.min(x3, windowWidth - leftOffset - margin + scrollX),
      leftOffset + margin + scrollX
    );
    Object.assign(element.style, {
      ...left2 !== x3 && { left: `${left2}px` },
      ...top2 !== y3 && { top: `${top2}px` }
    });
  }, "keepInViewport"), showPopover = __name((element) => {
    window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.showPopover();
  }, "showPopover"), hidePopover = __name((element) => {
    window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.hidePopover();
  }, "hidePopover"), getEventDetails = __name((target) => ({
    top: target.top,
    left: target.left,
    width: target.width,
    height: target.height,
    selectors: target.selectors,
    element: {
      attributes: Object.fromEntries(
        Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
      ),
      localName: target.element.localName,
      tagName: target.element.tagName,
      outerHTML: target.element.outerHTML
    }
  }), "getEventDetails"), menuId = "storybook-highlights-menu", rootId = "storybook-highlights-root", storybookRootId = "storybook-root", useHighlights = __name((channel) => {
    if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
      return;
    globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
    let { document: document32 } = globalThis, highlights = useStore([]), elements = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root = document32.getElementById(rootId);
    highlights.subscribe(() => {
      root || (root = createElement2("div", { id: rootId }), document32.body.appendChild(root));
    }), highlights.subscribe((value2) => {
      let storybookRoot = document32.getElementById(storybookRootId);
      if (!storybookRoot)
        return;
      elements.set(mapElements(value2));
      let observer = new MutationObserver(() => elements.set(mapElements(value2)));
      return observer.observe(storybookRoot, { subtree: !0, childList: !0 }), () => {
        observer.disconnect();
      };
    }), elements.subscribe((value2) => {
      let updateBoxes = __name(() => requestAnimationFrame(() => boxes.set(mapBoxes(value2))), "updateBoxes"), observer = new ResizeObserver(updateBoxes);
      observer.observe(document32.body), Array.from(value2.keys()).forEach((element) => observer.observe(element));
      let scrollers = Array.from(document32.body.querySelectorAll("*")).filter((el) => {
        let { overflow, overflowX, overflowY } = window.getComputedStyle(el);
        return ["auto", "scroll"].some((o2) => [overflow, overflowX, overflowY].includes(o2));
      });
      return scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes)), () => {
        observer.disconnect(), scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
      };
    }), elements.subscribe((value2) => {
      let sticky = Array.from(value2.keys()).filter(({ style }) => style.position === "sticky"), updateBoxes = __name(() => requestAnimationFrame(() => {
        boxes.set(
          (current) => current.map((box) => {
            if (sticky.includes(box.element)) {
              let { top: top2, left: left2 } = box.element.getBoundingClientRect();
              return { ...box, top: top2 + window.scrollY, left: left2 + window.scrollX };
            }
            return box;
          })
        );
      }), "updateBoxes");
      return document32.addEventListener("scroll", updateBoxes), () => document32.removeEventListener("scroll", updateBoxes);
    }), elements.subscribe((value2) => {
      targets.set((t) => t.filter(({ element }) => value2.has(element)));
    }), targets.subscribe((value2) => {
      value2.length ? (selected.set((s4) => value2.some((t) => t.element === s4?.element) ? s4 : void 0), focused.set((s4) => value2.some((t) => t.element === s4?.element) ? s4 : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));
    });
    let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
    highlights.subscribe((value2) => {
      value2.forEach(({ keyframes: keyframes2 }) => {
        if (keyframes2) {
          let style = styleElementByHighlight.get(keyframes2);
          style || (style = document32.createElement("style"), style.setAttribute("data-highlight", "keyframes"), styleElementByHighlight.set(keyframes2, style), document32.head.appendChild(style)), style.innerHTML = keyframes2;
        }
      }), styleElementByHighlight.forEach((style, keyframes2) => {
        value2.some((v3) => v3.keyframes === keyframes2) || (style.remove(), styleElementByHighlight.delete(keyframes2));
      });
    });
    let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
    boxes.subscribe((value2) => {
      value2.forEach((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        if (root && !boxElement) {
          let props = {
            popover: "manual",
            "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
            "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
          };
          boxElement = root.appendChild(
            createElement2("div", props, [createElement2("div")])
          ), boxElementByTargetElement.set(box.element, boxElement);
        }
      }), boxElementByTargetElement.forEach((box, element) => {
        value2.some(({ element: e }) => e === element) || (box.remove(), boxElementByTargetElement.delete(element));
      });
    }), boxes.subscribe((value2) => {
      let targetable = value2.filter((box) => box.menu);
      if (!targetable.length)
        return;
      let onClick = __name((event) => {
        requestAnimationFrame(() => {
          let menu = document32.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };
          if (menu && !isOverMenu(menu, coords)) {
            let results = targetable.filter((box) => {
              let boxElement = boxElementByTargetElement.get(box.element);
              return isTargeted(box, boxElement, coords);
            });
            clickCoords.set(results.length ? coords : void 0), targets.set(results);
          }
        });
      }, "onClick");
      return document32.addEventListener("click", onClick), () => document32.removeEventListener("click", onClick);
    });
    let updateHovered = __name(() => {
      let menu = document32.getElementById(menuId), coords = hoverCoords.get();
      !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {
        let update = boxes.get().filter((box) => {
          let boxElement = boxElementByTargetElement.get(box.element);
          return isTargeted(box, boxElement, coords);
        }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;
        return additions.length || hasRemovals ? [...existing, ...additions] : current;
      });
    }, "updateHovered");
    hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);
    let updateBoxStyles = __name(() => {
      let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;
      boxes.get().forEach((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        if (boxElement) {
          let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
          Object.assign(boxElement.style, {
            animation: "none",
            background: "transparent",
            border: "none",
            boxSizing: "border-box",
            outline: "none",
            outlineOffset: "0px",
            ...box.styles,
            ...isHovered ? box.hoverStyles : {},
            ...isFocused ? box.focusStyles : {},
            position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
            zIndex: MAX_Z_INDEX - 10,
            top: `${box.top}px`,
            left: `${box.left}px`,
            width: `${box.width}px`,
            height: `${box.height}px`,
            margin: 0,
            padding: 0,
            cursor: box.menu && isHovered ? "pointer" : "default",
            pointerEvents: box.menu ? "auto" : "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            overflow: "visible"
          }), Object.assign(boxElement.children[0].style, {
            width: "100%",
            height: "100%",
            minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
            minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
            boxSizing: "content-box",
            padding: boxElement.style.outlineWidth || "0px"
          }), showPopover(boxElement);
        }
      });
    }, "updateBoxStyles");
    boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);
    let renderMenu = __name(() => {
      if (!root)
        return;
      let menu = document32.getElementById(menuId);
      if (menu)
        menu.innerHTML = "";
      else {
        let props = { id: menuId, popover: "manual" };
        menu = root.appendChild(createElement2("div", props)), root.appendChild(
          createElement2("style", {}, [
            `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
          ])
        );
      }
      let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();
      if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute", menu.appendChild(
        createElement2(
          "ul",
          { class: "element-list" },
          elementList.map((target) => {
            let selectable = elementList.length > 1 && !!target.menu?.some(
              (group) => group.some(
                (item) => !item.selectors || item.selectors.some((s4) => target.selectors.includes(s4))
              )
            ), props = selectable ? {
              class: "selectable",
              onClick: __name(() => selected.set(target), "onClick"),
              onMouseEnter: __name(() => focused.set(target), "onMouseEnter"),
              onMouseLeave: __name(() => focused.set(void 0), "onMouseLeave")
            } : selectedElement ? { class: "selected", onClick: __name(() => selected.set(void 0), "onClick") } : {}, asButton = selectable || selectedElement;
            return createElement2("li", props, [
              createElement2(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
                selectedElement ? createIcon("chevronLeft") : null,
                createElement2("code", {}, [target.element.outerHTML]),
                selectable ? createIcon("chevronRight") : null
              ])
            ]);
          })
        )
      )), selected.get() || targets.get().length === 1) {
        let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(
          (group) => group.some(
            (item) => !item.selectors || item.selectors.some((s4) => target.selectors.includes(s4))
          )
        );
        menuGroups?.length && menu.appendChild(
          createElement2(
            "ul",
            { class: "menu-list" },
            menuGroups.map(
              (menuItems) => createElement2("li", {}, [
                createElement2(
                  "ul",
                  { class: "menu-items" },
                  menuItems.map(
                    ({ id: id2, title, description, iconLeft, iconRight, clickEvent: event }) => {
                      let onClick = event && (() => channel.emit(event, id2, getEventDetails(target)));
                      return createElement2("li", {}, [
                        createElement2(
                          onClick ? "button" : "div",
                          onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                          [
                            iconLeft ? createIcon(iconLeft) : null,
                            createElement2("div", { class: "menu-item-content" }, [
                              createElement2(description ? "strong" : "span", {}, [title]),
                              description && createElement2("span", {}, [description])
                            ]),
                            iconRight ? createIcon(iconRight) : null
                          ]
                        )
                      ]);
                    }
                  )
                )
              ])
            )
          )
        );
      }
      let coords = clickCoords.get();
      coords ? (Object.assign(menu.style, {
        display: "block",
        left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
        top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
      }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: !0 }))) : (hidePopover(menu), Object.assign(menu.style, { display: "none" }));
    }, "renderMenu");
    targets.subscribe(renderMenu), selected.subscribe(renderMenu);
    let addHighlight = __name((highlight2) => {
      let info = normalizeOptions(highlight2);
      highlights.set((value2) => {
        let others = info.id ? value2.filter((h4) => h4.id !== info.id) : value2;
        return info.selectors?.length ? [...others, info] : others;
      });
    }, "addHighlight"), removeHighlight = __name((id2) => {
      id2 && highlights.set((value2) => value2.filter((h4) => h4.id !== id2));
    }, "removeHighlight"), resetState = __name(() => {
      highlights.set([]), elements.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);
    }, "resetState"), removeTimeout, scrollIntoView = __name((target, options2) => {
      let id2 = "scrollIntoView-highlight";
      clearTimeout(removeTimeout), removeHighlight(id2);
      let element = document32.querySelector(target);
      if (!element) {
        console.warn(`Cannot scroll into view: ${target} not found`);
        return;
      }
      element.scrollIntoView({ behavior: "smooth", block: "center", ...options2 });
      let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
      highlights.set((value2) => [
        ...value2,
        {
          id: id2,
          priority: 1e3,
          selectors: [target],
          styles: {
            outline: "2px solid #1EA7FD",
            outlineOffset: "-1px",
            animation: `${keyframeName} 3s linear forwards`
          },
          keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
        }
      ]), removeTimeout = setTimeout(() => removeHighlight(id2), 3500);
    }, "scrollIntoView"), onMouseMove = __name((event) => {
      requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
    }, "onMouseMove");
    document32.body.addEventListener("mousemove", onMouseMove), channel.on(HIGHLIGHT, addHighlight), channel.on(REMOVE_HIGHLIGHT, removeHighlight), channel.on(RESET_HIGHLIGHT, resetState), channel.on(SCROLL_INTO_VIEW, scrollIntoView), channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
      newPhase === "loading" && resetState();
    });
  }, "useHighlights");
  globalThis?.FEATURES?.highlight && addons?.ready && addons.ready().then(useHighlights);
  var preview_default4 = __name(() => ({}), "default");
  function getDocumentWidthAndHeight() {
    let container = scope.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);
    return { width: Math.max(container.scrollWidth, container.offsetWidth), height };
  }
  __name(getDocumentWidthAndHeight, "getDocumentWidthAndHeight");
  function createCanvas() {
    let canvas = scope.document.createElement("canvas");
    canvas.id = "storybook-addon-measure";
    let context = canvas.getContext("2d");
    invariant(context != null);
    let { width, height } = getDocumentWidthAndHeight();
    return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = "absolute", canvas.style.left = "0", canvas.style.top = "0", canvas.style.zIndex = "2147483647", canvas.style.pointerEvents = "none", scope.document.body.appendChild(canvas), { canvas, context, width, height };
  }
  __name(createCanvas, "createCanvas");
  function setCanvasWidthAndHeight(canvas, context, { width, height }) {
    canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;
    let scale = scope.window.devicePixelRatio;
    canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);
  }
  __name(setCanvasWidthAndHeight, "setCanvasWidthAndHeight");
  var state2 = {};
  function init() {
    state2.canvas || (state2 = createCanvas());
  }
  __name(init, "init");
  function clear() {
    state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
  }
  __name(clear, "clear");
  function draw(callback) {
    clear(), callback(state2.context);
  }
  __name(draw, "draw");
  function rescale() {
    invariant(state2.canvas, "Canvas should exist in the state."), invariant(state2.context, "Context should exist in the state."), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
    let { width, height } = getDocumentWidthAndHeight();
    setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;
  }
  __name(rescale, "rescale");
  function destroy() {
    state2.canvas && (clear(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});
  }
  __name(destroy, "destroy");
  var colors = {
    margin: "#f6b26b",
    border: "#ffe599",
    padding: "#93c47d",
    content: "#6fa8dc",
    text: "#232020"
  }, labelPadding = 6;
  function roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: r2 }) {
    x3 = x3 - w3 / 2, y3 = y3 - h4 / 2, w3 < 2 * r2 && (r2 = w3 / 2), h4 < 2 * r2 && (r2 = h4 / 2), context.beginPath(), context.moveTo(x3 + r2, y3), context.arcTo(x3 + w3, y3, x3 + w3, y3 + h4, r2), context.arcTo(x3 + w3, y3 + h4, x3, y3 + h4, r2), context.arcTo(x3, y3 + h4, x3, y3, r2), context.arcTo(x3, y3, x3 + w3, y3, r2), context.closePath();
  }
  __name(roundedRect, "roundedRect");
  function positionCoordinate(position, { padding, border, width, height, top: top2, left: left2 }) {
    let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x3 = left2 + border.left + padding.left, y3 = top2 + border.top + padding.top;
    return position === "top" ? x3 += contentWidth / 2 : position === "right" ? (x3 += contentWidth, y3 += contentHeight / 2) : position === "bottom" ? (x3 += contentWidth / 2, y3 += contentHeight) : position === "left" ? y3 += contentHeight / 2 : position === "center" && (x3 += contentWidth / 2, y3 += contentHeight / 2), { x: x3, y: y3 };
  }
  __name(positionCoordinate, "positionCoordinate");
  function offset2(type, position, { margin, border, padding }, labelPaddingSize, external) {
    let shift = __name((dir) => 0, "shift"), offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;
    return type === "padding" ? shift = __name((dir) => padding[dir] * locationMultiplier + labelPaddingShift, "shift") : type === "border" ? shift = __name((dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift, "shift") : type === "margin" && (shift = __name((dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift, "shift")), position === "top" ? offsetY = -shift("top") : position === "right" ? offsetX = shift("right") : position === "bottom" ? offsetY = shift("bottom") : position === "left" && (offsetX = -shift("left")), { offsetX, offsetY };
  }
  __name(offset2, "offset");
  function collide(a3, b3) {
    return Math.abs(a3.x - b3.x) < Math.abs(a3.w + b3.w) / 2 && Math.abs(a3.y - b3.y) < Math.abs(a3.h + b3.h) / 2;
  }
  __name(collide, "collide");
  function overlapAdjustment(position, currentRect, prevRect) {
    return position === "top" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === "right" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === "bottom" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === "left" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };
  }
  __name(overlapAdjustment, "overlapAdjustment");
  function textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text) {
    return roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x3, y3), roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x3, y3), { x: x3, y: y3, w: w3, h: h4 };
  }
  __name(textWithRect, "textWithRect");
  function configureText(context, text) {
    context.font = "600 12px monospace", context.textBaseline = "middle", context.textAlign = "center";
    let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w3 = metrics.width + labelPadding * 2, h4 = actualHeight + labelPadding * 2;
    return { w: w3, h: h4 };
  }
  __name(configureText, "configureText");
  function drawLabel(context, measurements, { type, position = "center", text }, prevRect, external = !1) {
    let { x: x3, y: y3 } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset2(type, position, measurements, labelPadding + 1, external);
    x3 += offsetX, y3 += offsetY;
    let { w: w3, h: h4 } = configureText(context, text);
    if (prevRect && collide({ x: x3, y: y3, w: w3, h: h4 }, prevRect)) {
      let adjusted = overlapAdjustment(position, { x: x3, y: y3, w: w3, h: h4 }, prevRect);
      x3 = adjusted.x, y3 = adjusted.y;
    }
    return textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text);
  }
  __name(drawLabel, "drawLabel");
  function floatingOffset(alignment2, { w: w3, h: h4 }) {
    let deltaW = w3 * 0.5 + labelPadding, deltaH = h4 * 0.5 + labelPadding;
    return {
      offsetX: (alignment2.x === "left" ? -1 : 1) * deltaW,
      offsetY: (alignment2.y === "top" ? -1 : 1) * deltaH
    };
  }
  __name(floatingOffset, "floatingOffset");
  function drawFloatingLabel(context, measurements, { type, text }) {
    let { floatingAlignment: floatingAlignment2, extremities } = measurements, x3 = extremities[floatingAlignment2.x], y3 = extremities[floatingAlignment2.y], { w: w3, h: h4 } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
      w: w3,
      h: h4
    });
    return x3 += offsetX, y3 += offsetY, textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text);
  }
  __name(drawFloatingLabel, "drawFloatingLabel");
  function drawStack(context, measurements, stack, external) {
    let rects = [];
    stack.forEach((l2, idx) => {
      let rect = external && l2.position === "center" ? drawFloatingLabel(context, measurements, l2) : drawLabel(context, measurements, l2, rects[idx - 1], external);
      rects[idx] = rect;
    });
  }
  __name(drawStack, "drawStack");
  function labelStacks(context, measurements, labels, externalLabels) {
    let stacks = labels.reduce((acc, l2) => (Object.prototype.hasOwnProperty.call(acc, l2.position) || (acc[l2.position] = []), acc[l2.position]?.push(l2), acc), {});
    stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);
  }
  __name(labelStacks, "labelStacks");
  var colors2 = {
    margin: "#f6b26ba8",
    border: "#ffe599a8",
    padding: "#93c47d8c",
    content: "#6fa8dca8"
  }, SMALL_NODE_SIZE = 30;
  function pxToNumber(px) {
    return parseInt(px.replace("px", ""), 10);
  }
  __name(pxToNumber, "pxToNumber");
  function round2(value2) {
    return Number.isInteger(value2) ? value2 : value2.toFixed(2);
  }
  __name(round2, "round");
  function filterZeroValues(labels) {
    return labels.filter((l2) => l2.text !== 0 && l2.text !== "0");
  }
  __name(filterZeroValues, "filterZeroValues");
  function floatingAlignment(extremities) {
    let windowExtremities = {
      top: scope.window.scrollY,
      bottom: scope.window.scrollY + scope.window.innerHeight,
      left: scope.window.scrollX,
      right: scope.window.scrollX + scope.window.innerWidth
    }, distances = {
      top: Math.abs(windowExtremities.top - extremities.top),
      bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
      left: Math.abs(windowExtremities.left - extremities.left),
      right: Math.abs(windowExtremities.right - extremities.right)
    };
    return {
      x: distances.left > distances.right ? "left" : "right",
      y: distances.top > distances.bottom ? "top" : "bottom"
    };
  }
  __name(floatingAlignment, "floatingAlignment");
  function measureElement(element) {
    let style = scope.getComputedStyle(element), { top: top2, left: left2, right: right2, bottom: bottom2, width, height } = element.getBoundingClientRect(), {
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight,
      borderBottomWidth,
      borderTopWidth,
      borderLeftWidth,
      borderRightWidth
    } = style;
    top2 = top2 + scope.window.scrollY, left2 = left2 + scope.window.scrollX, bottom2 = bottom2 + scope.window.scrollY, right2 = right2 + scope.window.scrollX;
    let margin = {
      top: pxToNumber(marginTop),
      bottom: pxToNumber(marginBottom),
      left: pxToNumber(marginLeft),
      right: pxToNumber(marginRight)
    }, padding = {
      top: pxToNumber(paddingTop),
      bottom: pxToNumber(paddingBottom),
      left: pxToNumber(paddingLeft),
      right: pxToNumber(paddingRight)
    }, border = {
      top: pxToNumber(borderTopWidth),
      bottom: pxToNumber(borderBottomWidth),
      left: pxToNumber(borderLeftWidth),
      right: pxToNumber(borderRightWidth)
    }, extremities = {
      top: top2 - margin.top,
      bottom: bottom2 + margin.bottom,
      left: left2 - margin.left,
      right: right2 + margin.right
    };
    return {
      margin,
      padding,
      border,
      top: top2,
      left: left2,
      bottom: bottom2,
      right: right2,
      width,
      height,
      extremities,
      floatingAlignment: floatingAlignment(extremities)
    };
  }
  __name(measureElement, "measureElement");
  function drawMargin(context, { margin, width, height, top: top2, left: left2, bottom: bottom2, right: right2 }) {
    let marginHeight = height + margin.bottom + margin.top;
    context.fillStyle = colors2.margin, context.fillRect(left2, top2 - margin.top, width, margin.top), context.fillRect(right2, top2 - margin.top, margin.right, marginHeight), context.fillRect(left2, bottom2, width, margin.bottom), context.fillRect(left2 - margin.left, top2 - margin.top, margin.left, marginHeight);
    let marginLabels = [
      {
        type: "margin",
        text: round2(margin.top),
        position: "top"
      },
      {
        type: "margin",
        text: round2(margin.right),
        position: "right"
      },
      {
        type: "margin",
        text: round2(margin.bottom),
        position: "bottom"
      },
      {
        type: "margin",
        text: round2(margin.left),
        position: "left"
      }
    ];
    return filterZeroValues(marginLabels);
  }
  __name(drawMargin, "drawMargin");
  function drawPadding(context, { padding, border, width, height, top: top2, left: left2, bottom: bottom2, right: right2 }) {
    let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
    context.fillStyle = colors2.padding, context.fillRect(left2 + border.left, top2 + border.top, paddingWidth, padding.top), context.fillRect(
      right2 - padding.right - border.right,
      top2 + padding.top + border.top,
      padding.right,
      paddingHeight
    ), context.fillRect(
      left2 + border.left,
      bottom2 - padding.bottom - border.bottom,
      paddingWidth,
      padding.bottom
    ), context.fillRect(left2 + border.left, top2 + padding.top + border.top, padding.left, paddingHeight);
    let paddingLabels = [
      {
        type: "padding",
        text: padding.top,
        position: "top"
      },
      {
        type: "padding",
        text: padding.right,
        position: "right"
      },
      {
        type: "padding",
        text: padding.bottom,
        position: "bottom"
      },
      {
        type: "padding",
        text: padding.left,
        position: "left"
      }
    ];
    return filterZeroValues(paddingLabels);
  }
  __name(drawPadding, "drawPadding");
  function drawBorder(context, { border, width, height, top: top2, left: left2, bottom: bottom2, right: right2 }) {
    let borderHeight = height - border.top - border.bottom;
    context.fillStyle = colors2.border, context.fillRect(left2, top2, width, border.top), context.fillRect(left2, bottom2 - border.bottom, width, border.bottom), context.fillRect(left2, top2 + border.top, border.left, borderHeight), context.fillRect(right2 - border.right, top2 + border.top, border.right, borderHeight);
    let borderLabels = [
      {
        type: "border",
        text: border.top,
        position: "top"
      },
      {
        type: "border",
        text: border.right,
        position: "right"
      },
      {
        type: "border",
        text: border.bottom,
        position: "bottom"
      },
      {
        type: "border",
        text: border.left,
        position: "left"
      }
    ];
    return filterZeroValues(borderLabels);
  }
  __name(drawBorder, "drawBorder");
  function drawContent(context, { padding, border, width, height, top: top2, left: left2 }) {
    let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
    return context.fillStyle = colors2.content, context.fillRect(
      left2 + border.left + padding.left,
      top2 + border.top + padding.top,
      contentWidth,
      contentHeight
    ), [
      {
        type: "content",
        position: "center",
        text: `${round2(contentWidth)} x ${round2(contentHeight)}`
      }
    ];
  }
  __name(drawContent, "drawContent");
  function drawBoxModel(element) {
    return (context) => {
      if (element && context) {
        let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
        labelStacks(
          context,
          measurements,
          [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
          externalLabels
        );
      }
    };
  }
  __name(drawBoxModel, "drawBoxModel");
  function drawSelectedElement(element) {
    draw(drawBoxModel(element));
  }
  __name(drawSelectedElement, "drawSelectedElement");
  var deepElementFromPoint = __name((x3, y3) => {
    let element = scope.document.elementFromPoint(x3, y3), crawlShadows = __name((node) => {
      if (node && node.shadowRoot) {
        let nestedElement = node.shadowRoot.elementFromPoint(x3, y3);
        return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;
      }
      return node;
    }, "crawlShadows");
    return crawlShadows(element) || element;
  }, "deepElementFromPoint"), nodeAtPointerRef, pointer = { x: 0, y: 0 };
  function findAndDrawElement(x3, y3) {
    nodeAtPointerRef = deepElementFromPoint(x3, y3), drawSelectedElement(nodeAtPointerRef);
  }
  __name(findAndDrawElement, "findAndDrawElement");
  var withMeasure = __name((StoryFn, context) => {
    let { measureEnabled } = context.globals || {};
    return useEffect2(() => {
      if (typeof globalThis.document > "u")
        return;
      let onPointerMove = __name((event) => {
        window.requestAnimationFrame(() => {
          event.stopPropagation(), pointer.x = event.clientX, pointer.y = event.clientY;
        });
      }, "onPointerMove");
      return globalThis.document.addEventListener("pointermove", onPointerMove), () => {
        globalThis.document.removeEventListener("pointermove", onPointerMove);
      };
    }, []), useEffect2(() => {
      let onPointerOver = __name((event) => {
        window.requestAnimationFrame(() => {
          event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);
        });
      }, "onPointerOver"), onResize = __name(() => {
        window.requestAnimationFrame(() => {
          rescale();
        });
      }, "onResize");
      return context.viewMode === "story" && measureEnabled && (globalThis.document.addEventListener("pointerover", onPointerOver), init(), globalThis.window.addEventListener("resize", onResize), findAndDrawElement(pointer.x, pointer.y)), () => {
        globalThis.window.removeEventListener("resize", onResize), destroy();
      };
    }, [measureEnabled, context.viewMode]), StoryFn();
  }, "withMeasure"), decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [], initialGlobals2 = {
    [PARAM_KEY2]: !1
  }, preview_default5 = __name(() => ({
    decorators: decorators2,
    initialGlobals: initialGlobals2
  }), "default"), clearStyles2 = __name((selector) => {
    (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);
  }, "clearStyles"), clearStyle2 = __name((input) => {
    let selector = typeof input == "string" ? input : input.join(""), element = scope.document.getElementById(selector);
    element && element.parentElement && element.parentElement.removeChild(element);
  }, "clearStyle"), addOutlineStyles = __name((selector, css2) => {
    let existingStyle = scope.document.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = scope.document.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2, scope.document.head.appendChild(style);
    }
  }, "addOutlineStyles");
  function outlineCSS(selector) {
    return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
  }
  __name(outlineCSS, "outlineCSS");
  var withOutline = __name((StoryFn, context) => {
    let globals = context.globals || {}, isActive = [!0, "true"].includes(globals[PARAM_KEY3]), isInDocs = context.viewMode === "docs", outlineStyles = useMemo2(() => outlineCSS(isInDocs ? '[data-story-block="true"]' : ".sb-show-main"), [context]);
    return useEffect2(() => {
      let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : "addon-outline";
      return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {
        clearStyles2(selectorId);
      };
    }, [isActive, outlineStyles, context]), StoryFn();
  }, "withOutline"), decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [], initialGlobals3 = {
    [PARAM_KEY3]: !1
  }, preview_default6 = __name(() => ({ decorators: decorators3, initialGlobals: initialGlobals3 }), "default"), resetAllMocksLoader = __name(({ parameters: parameters2 }) => {
    parameters2?.test?.mockReset === !0 ? resetAllMocks() : parameters2?.test?.clearMocks === !0 ? clearAllMocks() : parameters2?.test?.restoreMocks !== !1 && restoreAllMocks();
  }, "resetAllMocksLoader"), traverseArgs = __name((value2, depth = 0, key) => {
    if (depth > 5 || value2 == null)
      return value2;
    if (isMockFunction(value2))
      return key && value2.mockName(key), value2;
    if (typeof value2 == "function" && "isAction" in value2 && value2.isAction && !("implicit" in value2 && value2.implicit)) {
      let mock = fn2(value2);
      return key && mock.mockName(key), mock;
    }
    if (Array.isArray(value2)) {
      depth++;
      for (let i3 = 0; i3 < value2.length; i3++)
        Object.getOwnPropertyDescriptor(value2, i3)?.writable && (value2[i3] = traverseArgs(value2[i3], depth));
      return value2;
    }
    if (typeof value2 == "object" && value2.constructor === Object) {
      depth++;
      for (let [k3, v3] of Object.entries(value2))
        Object.getOwnPropertyDescriptor(value2, k3)?.writable && (value2[k3] = traverseArgs(v3, depth, k3));
      return value2;
    }
    return value2;
  }, "traverseArgs"), nameSpiesAndWrapActionsInSpies = __name(({ initialArgs }) => {
    traverseArgs(initialArgs);
  }, "nameSpiesAndWrapActionsInSpies"), patchedFocus = !1, enhanceContext = __name(async (context) => {
    globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within2(context.canvasElement));
    let clipboard = globalThis.window?.navigator?.clipboard;
    if (clipboard) {
      context.userEvent = instrument(
        { userEvent: uninstrumentedUserEvent.setup() },
        {
          intercept: !0,
          getKeys: __name((obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"), "getKeys")
        }
      ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
        get: __name(() => clipboard, "get"),
        configurable: !0
      });
      let currentFocus = HTMLElement.prototype.focus;
      patchedFocus || Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: !0,
          set: __name((newFocus) => {
            currentFocus = newFocus, patchedFocus = !0;
          }, "set"),
          get: __name(() => currentFocus, "get")
        }
      });
    }
  }, "enhanceContext"), preview_default7 = __name(() => ({
    loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
  }), "default"), initialGlobals4 = {
    [PARAM_KEY5]: { value: void 0, isRotated: !1 }
  }, preview_default8 = __name(() => ({
    initialGlobals: initialGlobals4
  }), "default");
  function getCoreAnnotations() {
    return [
      // @ts-expect-error CJS fallback
      (preview_default5.default ?? preview_default5)(),
      // @ts-expect-error CJS fallback
      (preview_default2.default ?? preview_default2)(),
      // @ts-expect-error CJS fallback
      (preview_default4.default ?? preview_default4)(),
      // @ts-expect-error CJS fallback
      (preview_default6.default ?? preview_default6)(),
      // @ts-expect-error CJS fallback
      (preview_default8.default ?? preview_default8)(),
      // @ts-expect-error CJS fallback
      (preview_default.default ?? preview_default)(),
      // @ts-expect-error CJS fallback
      (preview_default3.default ?? preview_default3)(),
      // @ts-expect-error CJS fallback
      (preview_default7.default ?? preview_default7)()
    ];
  }
  __name(getCoreAnnotations, "getCoreAnnotations");
  function definePreview(input) {
    let composed, preview = {
      _tag: "Preview",
      input,
      get composed() {
        if (composed)
          return composed;
        let { addons: addons22, ...rest } = input;
        return composed = normalizeProjectAnnotations(
          composeConfigs([...getCoreAnnotations(), ...addons22 ?? [], rest])
        ), composed;
      },
      meta(meta) {
        return defineMeta(meta, this);
      }
    };
    return globalThis.globalProjectAnnotations = preview.composed, preview;
  }
  __name(definePreview, "definePreview");
  function definePreviewAddon9(preview) {
    return preview;
  }
  __name(definePreviewAddon9, "definePreviewAddon");
  function isPreview(input) {
    return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Preview";
  }
  __name(isPreview, "isPreview");
  function isMeta(input) {
    return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Meta";
  }
  __name(isMeta, "isMeta");
  function defineMeta(input, preview) {
    return {
      _tag: "Meta",
      input,
      preview,
      // @ts-expect-error hard
      story(story = {}) {
        return defineStory(typeof story == "function" ? { render: story } : story, this);
      }
    };
  }
  __name(defineMeta, "defineMeta");
  function isStory(input) {
    return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Story";
  }
  __name(isStory, "isStory");
  function defineStory(input, meta) {
    let composed, compose = __name(() => (composed || (composed = composeStory(
      input,
      meta.input,
      void 0,
      meta.preview.composed
    )), composed), "compose"), __children = [];
    return {
      _tag: "Story",
      input,
      meta,
      // @ts-expect-error this is a private property used only once in renderers/react/src/preview
      __compose: compose,
      __children,
      get composed() {
        let composed2 = compose(), { args, argTypes, parameters: parameters2, id: id2, tags, globals, storyName: name } = composed2;
        return { args, argTypes, parameters: parameters2, id: id2, tags, name, globals };
      },
      get play() {
        return input.play ?? meta.input?.play ?? (async () => {
        });
      },
      async run(context) {
        await compose().run(context);
      },
      test(name, overridesOrTestFn, testFn) {
        let annotations = typeof overridesOrTestFn != "function" ? overridesOrTestFn : {}, testFunction = typeof overridesOrTestFn != "function" ? testFn : overridesOrTestFn, play = mountDestructured(this.play) || mountDestructured(testFunction) ? async ({ context }) => {
          await this.play?.(context), await testFunction(context);
        } : async (context) => {
          await this.play?.(context), await testFunction(context);
        }, test2 = this.extend({
          ...annotations,
          name,
          tags: ["test-fn", "!autodocs", ...annotations.tags ?? []],
          play
        });
        return __children.push(test2), test2;
      },
      extend(input2) {
        return defineStory(
          {
            ...this.input,
            ...input2,
            args: { ...this.input.args || {}, ...input2.args },
            argTypes: combineParameters(this.input.argTypes, input2.argTypes),
            afterEach: [
              ...normalizeArrays(this.input?.afterEach ?? []),
              ...normalizeArrays(input2.afterEach ?? [])
            ],
            beforeEach: [
              ...normalizeArrays(this.input?.beforeEach ?? []),
              ...normalizeArrays(input2.beforeEach ?? [])
            ],
            decorators: [
              ...normalizeArrays(this.input?.decorators ?? []),
              ...normalizeArrays(input2.decorators ?? [])
            ],
            globals: { ...this.input.globals, ...input2.globals },
            loaders: [
              ...normalizeArrays(this.input?.loaders ?? []),
              ...normalizeArrays(input2.loaders ?? [])
            ],
            parameters: combineParameters(this.input.parameters, input2.parameters),
            tags: combineTags2(...this.input.tags ?? [], ...input2.tags ?? [])
          },
          this.meta
        );
      }
    };
  }
  __name(defineStory, "defineStory");
  function getStoryChildren(story) {
    return "__children" in story ? story.__children : [];
  }
  __name(getStoryChildren, "getStoryChildren");
  var sanitize = __name((string) => string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), "sanitize"), sanitizeSafe = __name((string, part) => {
    let sanitized = sanitize(string);
    if (sanitized === "")
      throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
    return sanitized;
  }, "sanitizeSafe"), toId = __name((kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`, "toId"), toTestId = __name((parentId, testName2) => `${parentId}:${sanitizeSafe(testName2, "test")}`, "toTestId"), storyNameFromExport = __name((key) => toStartCaseStr(key), "storyNameFromExport");
  function matches2(storyKey, arrayOrRegex) {
    return Array.isArray(arrayOrRegex) ? arrayOrRegex.includes(storyKey) : storyKey.match(arrayOrRegex);
  }
  __name(matches2, "matches");
  function isExportStory(key, { includeStories, excludeStories }) {
    return (
      // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
      key !== "__esModule" && (!includeStories || matches2(key, includeStories)) && (!excludeStories || !matches2(key, excludeStories))
    );
  }
  __name(isExportStory, "isExportStory");
  var parseKind = __name((kind, { rootSeparator, groupSeparator }) => {
    let [root, remainder] = kind.split(rootSeparator, 2), groups = (remainder || kind).split(groupSeparator).filter((i3) => !!i3);
    return {
      root: remainder ? root : null,
      groups
    };
  }, "parseKind"), combineTags2 = __name((...tags) => {
    let result = tags.reduce((acc, tag) => (tag.startsWith("!") ? acc.delete(tag.slice(1)) : acc.add(tag), acc), /* @__PURE__ */ new Set());
    return Array.from(result);
  }, "combineTags");

  // node_modules/storybook/dist/_browser-chunks/chunk-I74EUU5O.js
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  init_icons();
  init_theming();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_theming();
  var nameSpaceClassNames = __name(({ ...props }, key) => {
    let classes2 = [props.class, props.className];
    return delete props.class, props.className = ["sbdocs", `sbdocs-${key}`, ...classes2].filter(Boolean).join(" "), props;
  }, "nameSpaceClassNames"), headerCommon = __name(({ theme: theme3 }) => ({
    margin: "20px 0 8px",
    padding: 0,
    cursor: "text",
    position: "relative",
    color: theme3.color.defaultText,
    "&:first-of-type": {
      marginTop: 0,
      paddingTop: 0
    },
    "&:hover a.anchor": {
      textDecoration: "none"
    },
    "& tt, & code": {
      fontSize: "inherit"
    }
  }), "headerCommon"), codeCommon = __name(({ theme: theme3 }) => ({
    lineHeight: 1,
    margin: "0 2px",
    padding: "3px 5px",
    whiteSpace: "nowrap",
    borderRadius: 3,
    fontSize: theme3.typography.size.s2 - 1,
    border: theme3.base === "light" ? `1px solid ${theme3.color.mediumlight}` : `1px solid ${theme3.color.darker}`,
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    backgroundColor: theme3.base === "light" ? theme3.color.lighter : theme3.color.border
  }), "codeCommon"), withReset = __name(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base,
    fontSize: theme3.typography.size.s3,
    margin: 0,
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
    WebkitOverflowScrolling: "touch"
  }), "withReset"), withMargin = {
    margin: "16px 0"
  }, ResetWrapper = styled.div(withReset), Link = __name(({
    href: input = "",
    ...props
  }) => {
    let href = /^\//.test(input) ? `./?path=${input}` : input, target = /^#.*/.test(input) ? "_self" : "_top";
    return react_default.createElement("a", { href, target, ...props });
  }, "Link"), A = styled(Link)(withReset, ({ theme: theme3 }) => ({
    fontSize: "inherit",
    lineHeight: "24px",
    color: theme3.color.secondary,
    textDecoration: "none",
    "&.absent": {
      color: "#cc0000"
    },
    "&.anchor": {
      display: "block",
      paddingLeft: 30,
      marginLeft: -30,
      cursor: "pointer",
      position: "absolute",
      top: 0,
      left: 0,
      bottom: 0
    }
  })), Blockquote = styled.blockquote(withReset, withMargin, ({ theme: theme3 }) => ({
    borderLeft: `4px solid ${theme3.color.medium}`,
    padding: "0 15px",
    color: theme3.color.dark,
    "& > :first-of-type": {
      marginTop: 0
    },
    "& > :last-child": {
      marginBottom: 0
    }
  })), languages = [], Comp = null, LazySyntaxHighlighter = lazy(async () => {
    let { SyntaxHighlighter: SyntaxHighlighter22 } = await Promise.resolve().then(() => (init_syntaxhighlighter_DK2ODWXH(), syntaxhighlighter_DK2ODWXH_exports));
    return languages.length > 0 && (languages.forEach((args) => {
      SyntaxHighlighter22.registerLanguage(...args);
    }), languages = []), Comp === null && (Comp = SyntaxHighlighter22), {
      default: __name((props) => react_default.createElement(SyntaxHighlighter22, { ...props }), "default")
    };
  }), LazySyntaxHighlighterWithFormatter = lazy(async () => {
    let [{ SyntaxHighlighter: SyntaxHighlighter22 }, { formatter: formatter2 }] = await Promise.all([
      Promise.resolve().then(() => (init_syntaxhighlighter_DK2ODWXH(), syntaxhighlighter_DK2ODWXH_exports)),
      Promise.resolve().then(() => (init_formatter_OMEEQ6HG(), formatter_OMEEQ6HG_exports))
    ]);
    return languages.length > 0 && (languages.forEach((args) => {
      SyntaxHighlighter22.registerLanguage(...args);
    }), languages = []), Comp === null && (Comp = SyntaxHighlighter22), {
      default: __name((props) => react_default.createElement(SyntaxHighlighter22, { ...props, formatter: formatter2 }), "default")
    };
  }), SyntaxHighlighter3 = __name((props) => react_default.createElement(Suspense, { fallback: react_default.createElement("div", null) }, props.format !== !1 ? react_default.createElement(LazySyntaxHighlighterWithFormatter, { ...props }) : react_default.createElement(LazySyntaxHighlighter, { ...props })), "SyntaxHighlighter");
  SyntaxHighlighter3.registerLanguage = (...args) => {
    if (Comp !== null) {
      Comp.registerLanguage(...args);
      return;
    }
    languages.push(args);
  };
  var isReactChildString = __name((child) => typeof child == "string", "isReactChildString"), isInlineCodeRegex = /[\n\r]/g, DefaultCodeBlock = styled.code(
    ({ theme: theme3 }) => ({
      // from reset
      fontFamily: theme3.typography.fonts.mono,
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      display: "inline-block",
      paddingLeft: 2,
      paddingRight: 2,
      verticalAlign: "baseline",
      color: "inherit"
    }),
    codeCommon
  ), StyledSyntaxHighlighter = styled(SyntaxHighlighter3)(({ theme: theme3 }) => ({
    // DocBlocks-specific styling and overrides
    fontFamily: theme3.typography.fonts.mono,
    fontSize: `${theme3.typography.size.s2 - 1}px`,
    lineHeight: "19px",
    margin: "25px 0 40px",
    borderRadius: theme3.appBorderRadius,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    "pre.prismjs": {
      padding: 20,
      background: "inherit"
    }
  })), Code2 = __name(({
    className,
    children,
    ...props
  }) => {
    let language = (className || "").match(/lang-(\S+)/), childrenArray = Children.toArray(children);
    return childrenArray.filter(isReactChildString).some((child) => child.match(isInlineCodeRegex)) ? react_default.createElement(
      StyledSyntaxHighlighter,
      {
        bordered: !0,
        copyable: !0,
        language: language?.[1] ?? "text",
        format: !1,
        ...props
      },
      children
    ) : react_default.createElement(DefaultCodeBlock, { ...props, className }, childrenArray);
  }, "Code"), DL = styled.dl(withReset, withMargin, {
    padding: 0,
    "& dt": {
      fontSize: "14px",
      fontWeight: "bold",
      fontStyle: "italic",
      padding: 0,
      margin: "16px 0 4px"
    },
    "& dt:first-of-type": {
      padding: 0
    },
    "& dt > :first-of-type": {
      marginTop: 0
    },
    "& dt > :last-child": {
      marginBottom: 0
    },
    "& dd": {
      margin: "0 0 16px",
      padding: "0 15px"
    },
    "& dd > :first-of-type": {
      marginTop: 0
    },
    "& dd > :last-child": {
      marginBottom: 0
    }
  }), Div = styled.div(withReset), H1 = styled.h1(withReset, headerCommon, ({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.l1}px`,
    fontWeight: theme3.typography.weight.bold
  })), H2 = styled.h2(withReset, headerCommon, ({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.m2}px`,
    paddingBottom: 4,
    borderBottom: `1px solid ${theme3.appBorderColor}`
  })), H3 = styled.h3(withReset, headerCommon, ({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.m1}px`
  })), H4 = styled.h4(withReset, headerCommon, ({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.s3}px`
  })), H5 = styled.h5(withReset, headerCommon, ({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.s2}px`
  })), H6 = styled.h6(withReset, headerCommon, ({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.s2}px`,
    color: theme3.color.dark
  })), HR = styled.hr(({ theme: theme3 }) => ({
    border: "0 none",
    borderTop: `1px solid ${theme3.appBorderColor}`,
    height: 4,
    padding: 0
  })), Img = styled.img({
    maxWidth: "100%"
  }), LI = styled.li(withReset, ({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2,
    color: theme3.color.defaultText,
    lineHeight: "24px",
    "& + li": {
      marginTop: ".25em"
    },
    "& ul, & ol": {
      marginTop: ".25em",
      marginBottom: 0
    },
    "& code": codeCommon({ theme: theme3 })
  })), listCommon = {
    paddingLeft: 30,
    "& :first-of-type": {
      marginTop: 0
    },
    "& :last-child": {
      marginBottom: 0
    }
  }, OL = styled.ol(withReset, withMargin, listCommon, {
    listStyle: "decimal"
  }), P = styled.p(withReset, withMargin, ({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2,
    lineHeight: "24px",
    color: theme3.color.defaultText,
    "& code": codeCommon({ theme: theme3 })
  })), Pre2 = styled.pre(withReset, withMargin, ({ theme: theme3 }) => ({
    // reset
    fontFamily: theme3.typography.fonts.mono,
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    lineHeight: "18px",
    padding: "11px 1rem",
    whiteSpace: "pre-wrap",
    color: "inherit",
    borderRadius: 3,
    margin: "1rem 0",
    "&:not(.prismjs)": {
      background: "transparent",
      border: "none",
      borderRadius: 0,
      padding: 0,
      margin: 0
    },
    "& pre, &.prismjs": {
      padding: 15,
      margin: 0,
      whiteSpace: "pre-wrap",
      color: "inherit",
      fontSize: "13px",
      lineHeight: "19px",
      code: {
        color: "inherit",
        fontSize: "inherit"
      }
    },
    "& code": {
      whiteSpace: "pre"
    },
    "& code, & tt": {
      border: "none"
    }
  })), Span = styled.span(withReset, ({ theme: theme3 }) => ({
    "&.frame": {
      display: "block",
      overflow: "hidden",
      "& > span": {
        border: `1px solid ${theme3.color.medium}`,
        display: "block",
        float: "left",
        overflow: "hidden",
        margin: "13px 0 0",
        padding: 7,
        width: "auto"
      },
      "& span img": {
        display: "block",
        float: "left"
      },
      "& span span": {
        clear: "both",
        color: theme3.color.darkest,
        display: "block",
        padding: "5px 0 0"
      }
    },
    "&.align-center": {
      display: "block",
      overflow: "hidden",
      clear: "both",
      "& > span": {
        display: "block",
        overflow: "hidden",
        margin: "13px auto 0",
        textAlign: "center"
      },
      "& span img": {
        margin: "0 auto",
        textAlign: "center"
      }
    },
    "&.align-right": {
      display: "block",
      overflow: "hidden",
      clear: "both",
      "& > span": {
        display: "block",
        overflow: "hidden",
        margin: "13px 0 0",
        textAlign: "right"
      },
      "& span img": {
        margin: 0,
        textAlign: "right"
      }
    },
    "&.float-left": {
      display: "block",
      marginRight: 13,
      overflow: "hidden",
      float: "left",
      "& span": {
        margin: "13px 0 0"
      }
    },
    "&.float-right": {
      display: "block",
      marginLeft: 13,
      overflow: "hidden",
      float: "right",
      "& > span": {
        display: "block",
        overflow: "hidden",
        margin: "13px auto 0",
        textAlign: "right"
      }
    }
  })), TT = styled.title(codeCommon), Table = styled.table(withReset, withMargin, ({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2,
    lineHeight: "24px",
    padding: 0,
    borderCollapse: "collapse",
    "& tr": {
      borderTop: `1px solid ${theme3.appBorderColor}`,
      backgroundColor: theme3.appContentBg,
      margin: 0,
      padding: 0
    },
    "& tr:nth-of-type(2n)": {
      backgroundColor: theme3.base === "dark" ? theme3.color.darker : theme3.color.lighter
    },
    "& tr th": {
      fontWeight: "bold",
      color: theme3.color.defaultText,
      border: `1px solid ${theme3.appBorderColor}`,
      margin: 0,
      padding: "6px 13px"
    },
    "& tr td": {
      border: `1px solid ${theme3.appBorderColor}`,
      color: theme3.color.defaultText,
      margin: 0,
      padding: "6px 13px"
    },
    "& tr th :first-of-type, & tr td :first-of-type": {
      marginTop: 0
    },
    "& tr th :last-child, & tr td :last-child": {
      marginBottom: 0
    }
  })), listCommon2 = {
    paddingLeft: 30,
    "& :first-of-type": {
      marginTop: 0
    },
    "& :last-child": {
      marginBottom: 0
    }
  }, UL = styled.ul(withReset, withMargin, listCommon2, { listStyle: "disc" }), components = {
    h1: __name((props) => react_default.createElement(H1, { ...nameSpaceClassNames(props, "h1") }), "h1"),
    h2: __name((props) => react_default.createElement(H2, { ...nameSpaceClassNames(props, "h2") }), "h2"),
    h3: __name((props) => react_default.createElement(H3, { ...nameSpaceClassNames(props, "h3") }), "h3"),
    h4: __name((props) => react_default.createElement(H4, { ...nameSpaceClassNames(props, "h4") }), "h4"),
    h5: __name((props) => react_default.createElement(H5, { ...nameSpaceClassNames(props, "h5") }), "h5"),
    h6: __name((props) => react_default.createElement(H6, { ...nameSpaceClassNames(props, "h6") }), "h6"),
    pre: __name((props) => react_default.createElement(Pre2, { ...nameSpaceClassNames(props, "pre") }), "pre"),
    a: __name((props) => react_default.createElement(A, { ...nameSpaceClassNames(props, "a") }), "a"),
    hr: __name((props) => react_default.createElement(HR, { ...nameSpaceClassNames(props, "hr") }), "hr"),
    dl: __name((props) => react_default.createElement(DL, { ...nameSpaceClassNames(props, "dl") }), "dl"),
    blockquote: __name((props) => react_default.createElement(Blockquote, { ...nameSpaceClassNames(props, "blockquote") }), "blockquote"),
    table: __name((props) => react_default.createElement(Table, { ...nameSpaceClassNames(props, "table") }), "table"),
    img: __name((props) => react_default.createElement(Img, { ...nameSpaceClassNames(props, "img") }), "img"),
    div: __name((props) => react_default.createElement(Div, { ...nameSpaceClassNames(props, "div") }), "div"),
    span: __name((props) => react_default.createElement(Span, { ...nameSpaceClassNames(props, "span") }), "span"),
    li: __name((props) => react_default.createElement(LI, { ...nameSpaceClassNames(props, "li") }), "li"),
    ul: __name((props) => react_default.createElement(UL, { ...nameSpaceClassNames(props, "ul") }), "ul"),
    ol: __name((props) => react_default.createElement(OL, { ...nameSpaceClassNames(props, "ol") }), "ol"),
    p: __name((props) => react_default.createElement(P, { ...nameSpaceClassNames(props, "p") }), "p"),
    code: __name((props) => react_default.createElement(Code2, { ...nameSpaceClassNames(props, "code") }), "code"),
    tt: __name((props) => react_default.createElement(TT, { ...nameSpaceClassNames(props, "tt") }), "tt"),
    resetwrapper: __name((props) => react_default.createElement(ResetWrapper, { ...nameSpaceClassNames(props, "resetwrapper") }), "resetwrapper")
  }, BadgeWrapper = styled.div(
    ({ theme: theme3, compact }) => ({
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: theme3.typography.size.s1,
      fontWeight: theme3.typography.weight.bold,
      lineHeight: "12px",
      minWidth: 20,
      borderRadius: 20,
      padding: compact ? "4px 7px" : "4px 10px"
    }),
    {
      svg: {
        height: 12,
        width: 12,
        marginRight: 4,
        marginTop: -2,
        path: {
          fill: "currentColor"
        }
      }
    },
    ({ theme: theme3, status }) => {
      switch (status) {
        case "critical":
          return {
            color: theme3.color.critical,
            background: theme3.background.critical
          };
        case "negative":
          return {
            color: theme3.color.negativeText,
            background: theme3.background.negative,
            boxShadow: theme3.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme3.color.negativeText)}` : "none"
          };
        case "warning":
          return {
            color: theme3.color.warningText,
            background: theme3.background.warning,
            boxShadow: theme3.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme3.color.warningText)}` : "none"
          };
        case "neutral":
          return {
            color: theme3.textMutedColor,
            background: theme3.base === "light" ? theme3.background.app : theme3.barBg,
            boxShadow: `inset 0 0 0 1px ${curriedTransparentize$1(0.8, theme3.textMutedColor)}`
          };
        case "positive":
          return {
            color: theme3.color.positiveText,
            background: theme3.background.positive,
            boxShadow: theme3.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme3.color.positiveText)}` : "none"
          };
        case "active":
          return {
            color: theme3.color.secondary,
            background: theme3.background.hoverable,
            boxShadow: `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme3.color.secondary)}`
          };
        default:
          return {};
      }
    }
  ), Badge = __name(({ ...props }) => react_default.createElement(BadgeWrapper, { ...props }), "Badge"), LEFT_BUTTON = 0, isPlainLeftClick = __name((e) => e.button === LEFT_BUTTON && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey, "isPlainLeftClick"), cancelled = __name((e, cb) => {
    isPlainLeftClick(e) && (e.preventDefault(), cb(e));
  }, "cancelled"), LinkInner = styled.span(
    ({ withArrow }) => withArrow ? {
      "> svg:last-of-type": {
        height: "0.7em",
        width: "0.7em",
        marginRight: 0,
        marginLeft: "0.25em",
        bottom: "auto",
        verticalAlign: "inherit"
      }
    } : {},
    ({ containsIcon }) => containsIcon ? {
      svg: {
        height: "1em",
        width: "1em",
        verticalAlign: "middle",
        position: "relative",
        bottom: 0,
        marginRight: 0
      }
    } : {}
  ), A2 = styled.a(
    ({ theme: theme3 }) => ({
      display: "inline-block",
      transition: "all 150ms ease-out",
      textDecoration: "none",
      color: theme3.color.secondary,
      "&:hover, &:focus": {
        cursor: "pointer",
        color: curriedDarken$1(0.07, theme3.color.secondary),
        "svg path:not([fill])": {
          fill: curriedDarken$1(0.07, theme3.color.secondary)
        }
      },
      "&:active": {
        color: curriedDarken$1(0.1, theme3.color.secondary),
        "svg path:not([fill])": {
          fill: curriedDarken$1(0.1, theme3.color.secondary)
        }
      },
      svg: {
        display: "inline-block",
        height: "1em",
        width: "1em",
        verticalAlign: "text-top",
        position: "relative",
        bottom: "-0.125em",
        marginRight: "0.4em",
        "& path": {
          fill: theme3.color.secondary
        }
      }
    }),
    ({ theme: theme3, secondary, tertiary }) => {
      let colors3;
      return secondary && (colors3 = [theme3.textMutedColor, theme3.color.dark, theme3.color.darker]), tertiary && (colors3 = [theme3.color.dark, theme3.color.darkest, theme3.textMutedColor]), colors3 ? {
        color: colors3[0],
        "svg path:not([fill])": {
          fill: colors3[0]
        },
        "&:hover": {
          color: colors3[1],
          "svg path:not([fill])": {
            fill: colors3[1]
          }
        },
        "&:active": {
          color: colors3[2],
          "svg path:not([fill])": {
            fill: colors3[2]
          }
        }
      } : {};
    },
    ({ nochrome }) => nochrome ? {
      color: "inherit",
      "&:hover, &:active": {
        color: "inherit",
        textDecoration: "underline"
      }
    } : {},
    ({ theme: theme3, inverse }) => inverse ? {
      color: theme3.color.lightest,
      ":not([fill])": {
        fill: theme3.color.lightest
      },
      "&:hover": {
        color: theme3.color.lighter,
        "svg path:not([fill])": {
          fill: theme3.color.lighter
        }
      },
      "&:active": {
        color: theme3.color.light,
        "svg path:not([fill])": {
          fill: theme3.color.light
        }
      }
    } : {},
    ({ isButton: isButton2 }) => isButton2 ? {
      border: 0,
      borderRadius: 0,
      background: "none",
      padding: 0,
      fontSize: "inherit"
    } : {}
  ), Link2 = __name(({
    cancel = !0,
    children,
    onClick = void 0,
    withArrow = !1,
    containsIcon = !1,
    className = void 0,
    style = void 0,
    ...rest
  }) => react_default.createElement(
    A2,
    {
      ...rest,
      onClick: onClick && cancel ? (e) => cancelled(e, onClick) : onClick,
      className
    },
    react_default.createElement(LinkInner, { withArrow, containsIcon }, children, withArrow && react_default.createElement(ChevronRightIcon, null))
  ), "Link"), DocumentWrapper = styled.div(({ theme: theme3 }) => ({
    fontSize: `${theme3.typography.size.s2}px`,
    lineHeight: "1.6",
    h1: {
      fontSize: `${theme3.typography.size.l1}px`,
      fontWeight: theme3.typography.weight.bold
    },
    h2: {
      fontSize: `${theme3.typography.size.m2}px`,
      borderBottom: `1px solid ${theme3.appBorderColor}`
    },
    h3: {
      fontSize: `${theme3.typography.size.m1}px`
    },
    h4: {
      fontSize: `${theme3.typography.size.s3}px`
    },
    h5: {
      fontSize: `${theme3.typography.size.s2}px`
    },
    h6: {
      fontSize: `${theme3.typography.size.s2}px`,
      color: theme3.color.dark
    },
    "pre:not(.prismjs)": {
      background: "transparent",
      border: "none",
      borderRadius: 0,
      padding: 0,
      margin: 0
    },
    "pre pre, pre.prismjs": {
      padding: 15,
      margin: 0,
      whiteSpace: "pre-wrap",
      color: "inherit",
      fontSize: "13px",
      lineHeight: "19px"
    },
    "pre pre code, pre.prismjs code": {
      color: "inherit",
      fontSize: "inherit"
    },
    "pre code": {
      margin: 0,
      padding: 0,
      whiteSpace: "pre",
      border: "none",
      background: "transparent"
    },
    "pre code, pre tt": {
      backgroundColor: "transparent",
      border: "none"
    },
    /* GitHub inspired Markdown styles loosely from https://gist.github.com/tuzz/3331384 */
    "body > *:first-of-type": {
      marginTop: "0 !important"
    },
    "body > *:last-child": {
      marginBottom: "0 !important"
    },
    a: {
      color: theme3.color.secondary,
      textDecoration: "none"
    },
    "a.absent": {
      color: "#cc0000"
    },
    "a.anchor": {
      display: "block",
      paddingLeft: 30,
      marginLeft: -30,
      cursor: "pointer",
      position: "absolute",
      top: 0,
      left: 0,
      bottom: 0
    },
    "h1, h2, h3, h4, h5, h6": {
      margin: "20px 0 10px",
      padding: 0,
      cursor: "text",
      position: "relative",
      "&:first-of-type": {
        marginTop: 0,
        paddingTop: 0
      },
      "&:hover a.anchor": {
        textDecoration: "none"
      },
      "& tt, & code": {
        fontSize: "inherit"
      }
    },
    "h1:first-of-type + h2": {
      marginTop: 0,
      paddingTop: 0
    },
    "p, blockquote, ul, ol, dl, li, table, pre": {
      margin: "15px 0"
    },
    hr: {
      border: "0 none",
      borderTop: `1px solid ${theme3.appBorderColor}`,
      height: 4,
      padding: 0
    },
    "body > h1:first-of-type, body > h2:first-of-type, body > h3:first-of-type, body > h4:first-of-type, body > h5:first-of-type, body > h6:first-of-type": {
      marginTop: 0,
      paddingTop: 0
    },
    "body > h1:first-of-type + h2": {
      marginTop: 0,
      paddingTop: 0
    },
    "a:first-of-type h1, a:first-of-type h2, a:first-of-type h3, a:first-of-type h4, a:first-of-type h5, a:first-of-type h6": {
      marginTop: 0,
      paddingTop: 0
    },
    "h1 p, h2 p, h3 p, h4 p, h5 p, h6 p": {
      marginTop: 0
    },
    "li p.first": {
      display: "inline-block"
    },
    "ul, ol": {
      paddingLeft: 30,
      "& :first-of-type": {
        marginTop: 0
      },
      "& :last-child": {
        marginBottom: 0
      }
    },
    dl: {
      padding: 0
    },
    "dl dt": {
      fontSize: "14px",
      fontWeight: "bold",
      fontStyle: "italic",
      margin: "0 0 15px",
      padding: "0 15px",
      "&:first-of-type": {
        padding: 0
      },
      "& > :first-of-type": {
        marginTop: 0
      },
      "& > :last-child": {
        marginBottom: 0
      }
    },
    blockquote: {
      borderLeft: `4px solid ${theme3.color.medium}`,
      padding: "0 15px",
      color: theme3.color.dark,
      "& > :first-of-type": {
        marginTop: 0
      },
      "& > :last-child": {
        marginBottom: 0
      }
    },
    table: {
      padding: 0,
      borderCollapse: "collapse",
      "& tr": {
        borderTop: `1px solid ${theme3.appBorderColor}`,
        backgroundColor: "white",
        margin: 0,
        padding: 0,
        "& th": {
          fontWeight: "bold",
          border: `1px solid ${theme3.appBorderColor}`,
          textAlign: "left",
          margin: 0,
          padding: "6px 13px"
        },
        "& td": {
          border: `1px solid ${theme3.appBorderColor}`,
          textAlign: "left",
          margin: 0,
          padding: "6px 13px"
        },
        "&:nth-of-type(2n)": {
          backgroundColor: theme3.color.lighter
        },
        "& th :first-of-type, & td :first-of-type": {
          marginTop: 0
        },
        "& th :last-child, & td :last-child": {
          marginBottom: 0
        }
      }
    },
    img: {
      maxWidth: "100%"
    },
    "span.frame": {
      display: "block",
      overflow: "hidden",
      "& > span": {
        border: `1px solid ${theme3.color.medium}`,
        display: "block",
        float: "left",
        overflow: "hidden",
        margin: "13px 0 0",
        padding: 7,
        width: "auto"
      },
      "& span img": {
        display: "block",
        float: "left"
      },
      "& span span": {
        clear: "both",
        color: theme3.color.darkest,
        display: "block",
        padding: "5px 0 0"
      }
    },
    "span.align-center": {
      display: "block",
      overflow: "hidden",
      clear: "both",
      "& > span": {
        display: "block",
        overflow: "hidden",
        margin: "13px auto 0",
        textAlign: "center"
      },
      "& span img": {
        margin: "0 auto",
        textAlign: "center"
      }
    },
    "span.align-right": {
      display: "block",
      overflow: "hidden",
      clear: "both",
      "& > span": {
        display: "block",
        overflow: "hidden",
        margin: "13px 0 0",
        textAlign: "right"
      },
      "& span img": {
        margin: 0,
        textAlign: "right"
      }
    },
    "span.float-left": {
      display: "block",
      marginRight: 13,
      overflow: "hidden",
      float: "left",
      "& span": {
        margin: "13px 0 0"
      }
    },
    "span.float-right": {
      display: "block",
      marginLeft: 13,
      overflow: "hidden",
      float: "right",
      "& > span": {
        display: "block",
        overflow: "hidden",
        margin: "13px auto 0",
        textAlign: "right"
      }
    },
    "code, tt": {
      margin: "0 2px",
      padding: "0 5px",
      whiteSpace: "nowrap",
      border: `1px solid ${theme3.color.mediumlight}`,
      backgroundColor: theme3.color.lighter,
      borderRadius: 3,
      color: theme3.base === "dark" ? theme3.color.darkest : theme3.color.dark
    }
  })), dist_exports = {};
  __export2(dist_exports, {
    Close: () => Close,
    Content: () => Content,
    Description: () => Description,
    Dialog: () => Dialog,
    DialogClose: () => DialogClose,
    DialogContent: () => DialogContent,
    DialogDescription: () => DialogDescription,
    DialogOverlay: () => DialogOverlay,
    DialogPortal: () => DialogPortal,
    DialogTitle: () => DialogTitle,
    DialogTrigger: () => DialogTrigger,
    Overlay: () => Overlay,
    Portal: () => Portal2,
    Root: () => Root2,
    Title: () => Title,
    Trigger: () => Trigger,
    WarningProvider: () => WarningProvider,
    createDialogScope: () => createDialogScope
  });
  var canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement);
  function composeEventHandlers2(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
    return __name(function(event) {
      if (originalEventHandler?.(event), checkForDefaultPrevented === !1 || !event.defaultPrevented)
        return ourEventHandler?.(event);
    }, "handleEvent");
  }
  __name(composeEventHandlers2, "composeEventHandlers");
  function setRef2(ref, value2) {
    if (typeof ref == "function")
      return ref(value2);
    ref != null && (ref.current = value2);
  }
  __name(setRef2, "setRef");
  function composeRefs2(...refs) {
    return (node) => {
      let hasCleanup = !1, cleanups2 = refs.map((ref) => {
        let cleanup = setRef2(ref, node);
        return !hasCleanup && typeof cleanup == "function" && (hasCleanup = !0), cleanup;
      });
      if (hasCleanup)
        return () => {
          for (let i3 = 0; i3 < cleanups2.length; i3++) {
            let cleanup = cleanups2[i3];
            typeof cleanup == "function" ? cleanup() : setRef2(refs[i3], null);
          }
        };
    };
  }
  __name(composeRefs2, "composeRefs");
  function useComposedRefs2(...refs) {
    return useCallback(composeRefs2(...refs), refs);
  }
  __name(useComposedRefs2, "useComposedRefs");
  function createContext2(rootComponentName, defaultContext) {
    let Context = createContext(defaultContext), Provider2 = __name((props) => {
      let { children, ...context } = props, value2 = useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime6.jsx)(Context.Provider, { value: value2, children });
    }, "Provider");
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName) {
      let context = useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return __name(useContext22, "useContext2"), [Provider2, useContext22];
  }
  __name(createContext2, "createContext2");
  function createContextScope2(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext32(rootComponentName, defaultContext) {
      let BaseContext = createContext(defaultContext), index3 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      let Provider2 = __name((props) => {
        let { scope: scope2, children, ...context } = props, Context = scope2?.[scopeName]?.[index3] || BaseContext, value2 = useMemo(() => context, Object.values(context));
        return (0, import_jsx_runtime6.jsx)(Context.Provider, { value: value2, children });
      }, "Provider");
      Provider2.displayName = rootComponentName + "Provider";
      function useContext22(consumerName, scope2) {
        let Context = scope2?.[scopeName]?.[index3] || BaseContext, context = useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return __name(useContext22, "useContext2"), [Provider2, useContext22];
    }
    __name(createContext32, "createContext3");
    let createScope = __name(() => {
      let scopeContexts = defaultContexts.map((defaultContext) => createContext(defaultContext));
      return __name(function(scope2) {
        let contexts = scope2?.[scopeName] || scopeContexts;
        return useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope2, [scopeName]: contexts } }),
          [scope2, contexts]
        );
      }, "useScope");
    }, "createScope");
    return createScope.scopeName = scopeName, [createContext32, composeContextScopes2(createScope, ...createContextScopeDeps)];
  }
  __name(createContextScope2, "createContextScope");
  function composeContextScopes2(...scopes) {
    let baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    let createScope = __name(() => {
      let scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return __name(function(overrideScopes) {
        let nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          let currentScope = useScope(overrideScopes)[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      }, "useComposedScopes");
    }, "createScope");
    return createScope.scopeName = baseScope.scopeName, createScope;
  }
  __name(composeContextScopes2, "composeContextScopes");
  var useLayoutEffect22 = globalThis?.document ? useLayoutEffect : () => {
  }, useReactId = react_exports[" useId ".trim().toString()] || (() => {
  }), count2 = 0;
  function useId2(deterministicId) {
    let [id2, setId] = useState(useReactId());
    return useLayoutEffect22(() => {
      deterministicId || setId((reactId) => reactId ?? String(count2++));
    }, [deterministicId]), deterministicId || (id2 ? `radix-${id2}` : "");
  }
  __name(useId2, "useId");
  var useReactEffectEvent = react_exports[" useEffectEvent ".trim().toString()], useReactInsertionEffect = react_exports[" useInsertionEffect ".trim().toString()], useInsertionEffect2 = react_exports[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
  function useControllableState({
    prop,
    defaultProp,
    onChange = __name(() => {
    }, "onChange"),
    caller
  }) {
    let [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
      defaultProp,
      onChange
    }), isControlled = prop !== void 0, value2 = isControlled ? prop : uncontrolledProp;
    {
      let isControlledRef = useRef(prop !== void 0);
      useEffect(() => {
        let wasControlled = isControlledRef.current;
        wasControlled !== isControlled && console.warn(
          `${caller} is changing from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        ), isControlledRef.current = isControlled;
      }, [isControlled, caller]);
    }
    let setValue = useCallback(
      (nextValue) => {
        if (isControlled) {
          let value22 = isFunction2(nextValue) ? nextValue(prop) : nextValue;
          value22 !== prop && onChangeRef.current?.(value22);
        } else
          setUncontrolledProp(nextValue);
      },
      [isControlled, prop, setUncontrolledProp, onChangeRef]
    );
    return [value2, setValue];
  }
  __name(useControllableState, "useControllableState");
  function useUncontrolledState({
    defaultProp,
    onChange
  }) {
    let [value2, setValue] = useState(defaultProp), prevValueRef = useRef(value2), onChangeRef = useRef(onChange);
    return useInsertionEffect2(() => {
      onChangeRef.current = onChange;
    }, [onChange]), useEffect(() => {
      prevValueRef.current !== value2 && (onChangeRef.current?.(value2), prevValueRef.current = value2);
    }, [value2, prevValueRef]), [value2, setValue, onChangeRef];
  }
  __name(useUncontrolledState, "useUncontrolledState");
  function isFunction2(value2) {
    return typeof value2 == "function";
  }
  __name(isFunction2, "isFunction");
  var SYNC_STATE = Symbol("RADIX:SYNC_STATE"), canUseDOM2 = !!(typeof window < "u" && window.document && window.document.createElement);
  function composeEventHandlers22(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
    return __name(function(event) {
      if (originalEventHandler?.(event), checkForDefaultPrevented === !1 || !event.defaultPrevented)
        return ourEventHandler?.(event);
    }, "handleEvent");
  }
  __name(composeEventHandlers22, "composeEventHandlers");
  function createSlot(ownerName) {
    let SlotClone2 = createSlotClone(ownerName), Slot222 = forwardRef((props, forwardedRef) => {
      let { children, ...slotProps } = props, childrenArray = Children.toArray(children), slottable = childrenArray.find(isSlottable2);
      if (slottable) {
        let newElement = slottable.props.children, newChildren = childrenArray.map((child) => child === slottable ? Children.count(newElement) > 1 ? Children.only(null) : isValidElement(newElement) ? newElement.props.children : null : child);
        return (0, import_jsx_runtime7.jsx)(SlotClone2, { ...slotProps, ref: forwardedRef, children: isValidElement(newElement) ? cloneElement(newElement, void 0, newChildren) : null });
      }
      return (0, import_jsx_runtime7.jsx)(SlotClone2, { ...slotProps, ref: forwardedRef, children });
    });
    return Slot222.displayName = `${ownerName}.Slot`, Slot222;
  }
  __name(createSlot, "createSlot");
  var Slot2 = createSlot("Slot");
  function createSlotClone(ownerName) {
    let SlotClone2 = forwardRef((props, forwardedRef) => {
      let { children, ...slotProps } = props;
      if (isValidElement(children)) {
        let childrenRef = getElementRef3(children), props2 = mergeProps2(slotProps, children.props);
        return children.type !== Fragment && (props2.ref = forwardedRef ? composeRefs2(forwardedRef, childrenRef) : childrenRef), cloneElement(children, props2);
      }
      return Children.count(children) > 1 ? Children.only(null) : null;
    });
    return SlotClone2.displayName = `${ownerName}.SlotClone`, SlotClone2;
  }
  __name(createSlotClone, "createSlotClone");
  var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
  function createSlottable(ownerName) {
    let Slottable22 = __name(({ children }) => (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children }), "Slottable2");
    return Slottable22.displayName = `${ownerName}.Slottable`, Slottable22.__radixId = SLOTTABLE_IDENTIFIER, Slottable22;
  }
  __name(createSlottable, "createSlottable");
  var Slottable2 = createSlottable("Slottable");
  function isSlottable2(child) {
    return isValidElement(child) && typeof child.type == "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
  }
  __name(isSlottable2, "isSlottable");
  function mergeProps2(slotProps, childProps) {
    let overrideProps = { ...childProps };
    for (let propName in childProps) {
      let slotPropValue = slotProps[propName], childPropValue = childProps[propName];
      /^on[A-Z]/.test(propName) ? slotPropValue && childPropValue ? overrideProps[propName] = (...args) => {
        let result = childPropValue(...args);
        return slotPropValue(...args), result;
      } : slotPropValue && (overrideProps[propName] = slotPropValue) : propName === "style" ? overrideProps[propName] = { ...slotPropValue, ...childPropValue } : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
    }
    return { ...slotProps, ...overrideProps };
  }
  __name(mergeProps2, "mergeProps");
  function getElementRef3(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    return mayWarn ? element.ref : (getter = Object.getOwnPropertyDescriptor(element, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
  }
  __name(getElementRef3, "getElementRef");
  var NODES2 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ], Primitive2 = NODES2.reduce((primitive, node) => {
    let Slot3 = createSlot(`Primitive.${node}`), Node22 = forwardRef((props, forwardedRef) => {
      let { asChild, ...primitiveProps } = props, Comp2 = asChild ? Slot3 : node;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), (0, import_jsx_runtime8.jsx)(Comp2, { ...primitiveProps, ref: forwardedRef });
    });
    return Node22.displayName = `Primitive.${node}`, { ...primitive, [node]: Node22 };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    target && flushSync(() => target.dispatchEvent(event));
  }
  __name(dispatchDiscreteCustomEvent, "dispatchDiscreteCustomEvent");
  function useCallbackRef2(callback) {
    let callbackRef = useRef(callback);
    return useEffect(() => {
      callbackRef.current = callback;
    }), useMemo(() => (...args) => callbackRef.current?.(...args), []);
  }
  __name(useCallbackRef2, "useCallbackRef");
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
    let onEscapeKeyDown = useCallbackRef2(onEscapeKeyDownProp);
    useEffect(() => {
      let handleKeyDown = __name((event) => {
        event.key === "Escape" && onEscapeKeyDown(event);
      }, "handleKeyDown");
      return ownerDocument.addEventListener("keydown", handleKeyDown, { capture: !0 }), () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: !0 });
    }, [onEscapeKeyDown, ownerDocument]);
  }
  __name(useEscapeKeydown, "useEscapeKeydown");
  var DISMISSABLE_LAYER_NAME = "DismissableLayer", CONTEXT_UPDATE = "dismissableLayer.update", POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", FOCUS_OUTSIDE = "dismissableLayer.focusOutside", originalBodyPointerEvents, DismissableLayerContext = createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), DismissableLayer = forwardRef(
    (props, forwardedRef) => {
      let {
        disableOutsidePointerEvents = !1,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props, context = useContext(DismissableLayerContext), [node, setNode] = useState(null), ownerDocument = node?.ownerDocument ?? globalThis?.document, [, force] = useState({}), composedRefs = useComposedRefs2(forwardedRef, (node2) => setNode(node2)), layers = Array.from(context.layers), [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1), highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled), index3 = node ? layers.indexOf(node) : -1, isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0, isPointerEventsEnabled = index3 >= highestLayerWithOutsidePointerEventsDisabledIndex, pointerDownOutside = usePointerDownOutside((event) => {
        let target = event.target, isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
        !isPointerEventsEnabled || isPointerDownOnBranch || (onPointerDownOutside?.(event), onInteractOutside?.(event), event.defaultPrevented || onDismiss?.());
      }, ownerDocument), focusOutside = useFocusOutside((event) => {
        let target = event.target;
        [...context.branches].some((branch) => branch.contains(target)) || (onFocusOutside?.(event), onInteractOutside?.(event), event.defaultPrevented || onDismiss?.());
      }, ownerDocument);
      return useEscapeKeydown((event) => {
        index3 === context.layers.size - 1 && (onEscapeKeyDown?.(event), !event.defaultPrevented && onDismiss && (event.preventDefault(), onDismiss()));
      }, ownerDocument), useEffect(() => {
        if (node)
          return disableOutsidePointerEvents && (context.layersWithOutsidePointerEventsDisabled.size === 0 && (originalBodyPointerEvents = ownerDocument.body.style.pointerEvents, ownerDocument.body.style.pointerEvents = "none"), context.layersWithOutsidePointerEventsDisabled.add(node)), context.layers.add(node), dispatchUpdate(), () => {
            disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1 && (ownerDocument.body.style.pointerEvents = originalBodyPointerEvents);
          };
      }, [node, ownerDocument, disableOutsidePointerEvents, context]), useEffect(() => () => {
        node && (context.layers.delete(node), context.layersWithOutsidePointerEventsDisabled.delete(node), dispatchUpdate());
      }, [node, context]), useEffect(() => {
        let handleUpdate = __name(() => force({}), "handleUpdate");
        return document.addEventListener(CONTEXT_UPDATE, handleUpdate), () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
      }, []), (0, import_jsx_runtime9.jsx)(
        Primitive2.div,
        {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
            ...props.style
          },
          onFocusCapture: composeEventHandlers22(props.onFocusCapture, focusOutside.onFocusCapture),
          onBlurCapture: composeEventHandlers22(props.onBlurCapture, focusOutside.onBlurCapture),
          onPointerDownCapture: composeEventHandlers22(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture
          )
        }
      );
    }
  );
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch", DismissableLayerBranch = forwardRef((props, forwardedRef) => {
    let context = useContext(DismissableLayerContext), ref = useRef(null), composedRefs = useComposedRefs2(forwardedRef, ref);
    return useEffect(() => {
      let node = ref.current;
      if (node)
        return context.branches.add(node), () => {
          context.branches.delete(node);
        };
    }, [context.branches]), (0, import_jsx_runtime9.jsx)(Primitive2.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
    let handlePointerDownOutside = useCallbackRef2(onPointerDownOutside), isPointerInsideReactTreeRef = useRef(!1), handleClickRef = useRef(() => {
    });
    return useEffect(() => {
      let handlePointerDown = __name((event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = __name(function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: !0 }
            );
          }, "handleAndDispatchPointerDownOutsideEvent2");
          var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
          let eventDetail = { originalEvent: event };
          event.pointerType === "touch" ? (ownerDocument.removeEventListener("click", handleClickRef.current), handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2, ownerDocument.addEventListener("click", handleClickRef.current, { once: !0 })) : handleAndDispatchPointerDownOutsideEvent2();
        } else
          ownerDocument.removeEventListener("click", handleClickRef.current);
        isPointerInsideReactTreeRef.current = !1;
      }, "handlePointerDown"), timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId), ownerDocument.removeEventListener("pointerdown", handlePointerDown), ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [ownerDocument, handlePointerDownOutside]), {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: __name(() => isPointerInsideReactTreeRef.current = !0, "onPointerDownCapture")
    };
  }
  __name(usePointerDownOutside, "usePointerDownOutside");
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
    let handleFocusOutside = useCallbackRef2(onFocusOutside), isFocusInsideReactTreeRef = useRef(!1);
    return useEffect(() => {
      let handleFocus = __name((event) => {
        event.target && !isFocusInsideReactTreeRef.current && handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, { originalEvent: event }, {
          discrete: !1
        });
      }, "handleFocus");
      return ownerDocument.addEventListener("focusin", handleFocus), () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [ownerDocument, handleFocusOutside]), {
      onFocusCapture: __name(() => isFocusInsideReactTreeRef.current = !0, "onFocusCapture"),
      onBlurCapture: __name(() => isFocusInsideReactTreeRef.current = !1, "onBlurCapture")
    };
  }
  __name(useFocusOutside, "useFocusOutside");
  function dispatchUpdate() {
    let event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  __name(dispatchUpdate, "dispatchUpdate");
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    let target = detail.originalEvent.target, event = new CustomEvent(name, { bubbles: !1, cancelable: !0, detail });
    handler && target.addEventListener(name, handler, { once: !0 }), discrete ? dispatchDiscreteCustomEvent(target, event) : target.dispatchEvent(event);
  }
  __name(handleAndDispatchCustomEvent, "handleAndDispatchCustomEvent");
  var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount", AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount", EVENT_OPTIONS = { bubbles: !1, cancelable: !0 }, FOCUS_SCOPE_NAME = "FocusScope", FocusScope = forwardRef((props, forwardedRef) => {
    let {
      loop = !1,
      trapped = !1,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props, [container, setContainer] = useState(null), onMountAutoFocus = useCallbackRef2(onMountAutoFocusProp), onUnmountAutoFocus = useCallbackRef2(onUnmountAutoFocusProp), lastFocusedElementRef = useRef(null), composedRefs = useComposedRefs2(forwardedRef, (node) => setContainer(node)), focusScope = useRef({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }).current;
    useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = __name(function(event) {
          if (focusScope.paused || !container) return;
          let target = event.target;
          container.contains(target) ? lastFocusedElementRef.current = target : focus(lastFocusedElementRef.current, { select: !0 });
        }, "handleFocusIn2"), handleFocusOut2 = __name(function(event) {
          if (focusScope.paused || !container) return;
          let relatedTarget = event.relatedTarget;
          relatedTarget !== null && (container.contains(relatedTarget) || focus(lastFocusedElementRef.current, { select: !0 }));
        }, "handleFocusOut2"), handleMutations2 = __name(function(mutations) {
          if (document.activeElement === document.body)
            for (let mutation of mutations)
              mutation.removedNodes.length > 0 && focus(container);
        }, "handleMutations2");
        var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
        document.addEventListener("focusin", handleFocusIn2), document.addEventListener("focusout", handleFocusOut2);
        let mutationObserver = new MutationObserver(handleMutations2);
        return container && mutationObserver.observe(container, { childList: !0, subtree: !0 }), () => {
          document.removeEventListener("focusin", handleFocusIn2), document.removeEventListener("focusout", handleFocusOut2), mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]), useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        let previouslyFocusedElement = document.activeElement;
        if (!container.contains(previouslyFocusedElement)) {
          let mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus), container.dispatchEvent(mountEvent), mountEvent.defaultPrevented || (focusFirst(removeLinks(getTabbableCandidates(container)), { select: !0 }), document.activeElement === previouslyFocusedElement && focus(container));
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus), setTimeout(() => {
            let unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus), container.dispatchEvent(unmountEvent), unmountEvent.defaultPrevented || focus(previouslyFocusedElement ?? document.body, { select: !0 }), container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus), focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    let handleKeyDown = useCallback(
      (event) => {
        if (!loop && !trapped || focusScope.paused) return;
        let isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey, focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          let container2 = event.currentTarget, [first, last] = getTabbableEdges(container2);
          first && last ? !event.shiftKey && focusedElement === last ? (event.preventDefault(), loop && focus(first, { select: !0 })) : event.shiftKey && focusedElement === first && (event.preventDefault(), loop && focus(last, { select: !0 })) : focusedElement === container2 && event.preventDefault();
        }
      },
      [loop, trapped, focusScope.paused]
    );
    return (0, import_jsx_runtime10.jsx)(Primitive2.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst(candidates, { select = !1 } = {}) {
    let previouslyFocusedElement = document.activeElement;
    for (let candidate of candidates)
      if (focus(candidate, { select }), document.activeElement !== previouslyFocusedElement) return;
  }
  __name(focusFirst, "focusFirst");
  function getTabbableEdges(container) {
    let candidates = getTabbableCandidates(container), first = findVisible(candidates, container), last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  __name(getTabbableEdges, "getTabbableEdges");
  function getTabbableCandidates(container) {
    let nodes = [], walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: __name((node) => {
        let isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        return node.disabled || node.hidden || isHiddenInput ? NodeFilter.FILTER_SKIP : node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }, "acceptNode")
    });
    for (; walker.nextNode(); ) nodes.push(walker.currentNode);
    return nodes;
  }
  __name(getTabbableCandidates, "getTabbableCandidates");
  function findVisible(elements, container) {
    for (let element of elements)
      if (!isHidden(element, { upTo: container })) return element;
  }
  __name(findVisible, "findVisible");
  function isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden") return !0;
    for (; node; ) {
      if (upTo !== void 0 && node === upTo) return !1;
      if (getComputedStyle(node).display === "none") return !0;
      node = node.parentElement;
    }
    return !1;
  }
  __name(isHidden, "isHidden");
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  __name(isSelectableInput, "isSelectableInput");
  function focus(element, { select = !1 } = {}) {
    if (element && element.focus) {
      let previouslyFocusedElement = document.activeElement;
      element.focus({ preventScroll: !0 }), element !== previouslyFocusedElement && isSelectableInput(element) && select && element.select();
    }
  }
  __name(focus, "focus");
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        let activeFocusScope = stack[0];
        focusScope !== activeFocusScope && activeFocusScope?.pause(), stack = arrayRemove(stack, focusScope), stack.unshift(focusScope);
      },
      remove(focusScope) {
        stack = arrayRemove(stack, focusScope), stack[0]?.resume();
      }
    };
  }
  __name(createFocusScopesStack, "createFocusScopesStack");
  function arrayRemove(array2, item) {
    let updatedArray = [...array2], index3 = updatedArray.indexOf(item);
    return index3 !== -1 && updatedArray.splice(index3, 1), updatedArray;
  }
  __name(arrayRemove, "arrayRemove");
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }
  __name(removeLinks, "removeLinks");
  var PORTAL_NAME = "Portal", Portal = forwardRef((props, forwardedRef) => {
    let { container: containerProp, ...portalProps } = props, [mounted, setMounted] = useState(!1);
    useLayoutEffect22(() => setMounted(!0), []);
    let container = containerProp || mounted && globalThis?.document?.body;
    return container ? react_dom_default.createPortal((0, import_jsx_runtime11.jsx)(Primitive2.div, { ...portalProps, ref: forwardedRef }), container) : null;
  });
  Portal.displayName = PORTAL_NAME;
  function useStateMachine3(initialState, machine) {
    return useReducer((state3, event) => machine[state3][event] ?? state3, initialState);
  }
  __name(useStateMachine3, "useStateMachine");
  var Presence2 = __name((props) => {
    let { present, children } = props, presence = usePresence2(present), child = typeof children == "function" ? children({ present: presence.isPresent }) : Children.only(children), ref = useComposedRefs2(presence.ref, getElementRef22(child));
    return typeof children == "function" || presence.isPresent ? cloneElement(child, { ref }) : null;
  }, "Presence");
  Presence2.displayName = "Presence";
  function usePresence2(present) {
    let [node, setNode] = useState(), stylesRef = useRef(null), prevPresentRef = useRef(present), prevAnimationNameRef = useRef("none"), initialState = present ? "mounted" : "unmounted", [state3, send] = useStateMachine3(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    return useEffect(() => {
      let currentAnimationName = getAnimationName2(stylesRef.current);
      prevAnimationNameRef.current = state3 === "mounted" ? currentAnimationName : "none";
    }, [state3]), useLayoutEffect22(() => {
      let styles22 = stylesRef.current, wasPresent = prevPresentRef.current;
      if (wasPresent !== present) {
        let prevAnimationName = prevAnimationNameRef.current, currentAnimationName = getAnimationName2(styles22);
        present ? send("MOUNT") : currentAnimationName === "none" || styles22?.display === "none" ? send("UNMOUNT") : send(wasPresent && prevAnimationName !== currentAnimationName ? "ANIMATION_OUT" : "UNMOUNT"), prevPresentRef.current = present;
      }
    }, [present, send]), useLayoutEffect22(() => {
      if (node) {
        let timeoutId, ownerWindow = node.ownerDocument.defaultView ?? window, handleAnimationEnd = __name((event) => {
          let isCurrentAnimation = getAnimationName2(stylesRef.current).includes(CSS.escape(event.animationName));
          if (event.target === node && isCurrentAnimation && (send("ANIMATION_END"), !prevPresentRef.current)) {
            let currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards", timeoutId = ownerWindow.setTimeout(() => {
              node.style.animationFillMode === "forwards" && (node.style.animationFillMode = currentFillMode);
            });
          }
        }, "handleAnimationEnd"), handleAnimationStart = __name((event) => {
          event.target === node && (prevAnimationNameRef.current = getAnimationName2(stylesRef.current));
        }, "handleAnimationStart");
        return node.addEventListener("animationstart", handleAnimationStart), node.addEventListener("animationcancel", handleAnimationEnd), node.addEventListener("animationend", handleAnimationEnd), () => {
          ownerWindow.clearTimeout(timeoutId), node.removeEventListener("animationstart", handleAnimationStart), node.removeEventListener("animationcancel", handleAnimationEnd), node.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [node, send]), {
      isPresent: ["mounted", "unmountSuspended"].includes(state3),
      ref: useCallback((node2) => {
        stylesRef.current = node2 ? getComputedStyle(node2) : null, setNode(node2);
      }, [])
    };
  }
  __name(usePresence2, "usePresence");
  function getAnimationName2(styles22) {
    return styles22?.animationName || "none";
  }
  __name(getAnimationName2, "getAnimationName");
  function getElementRef22(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    return mayWarn ? element.ref : (getter = Object.getOwnPropertyDescriptor(element, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
  }
  __name(getElementRef22, "getElementRef");
  var count22 = 0;
  function useFocusGuards() {
    useEffect(() => {
      let edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      return document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard()), document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard()), count22++, () => {
        count22 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove()), count22--;
      };
    }, []);
  }
  __name(useFocusGuards, "useFocusGuards");
  function createFocusGuard() {
    let element = document.createElement("span");
    return element.setAttribute("data-radix-focus-guard", ""), element.tabIndex = 0, element.style.outline = "none", element.style.opacity = "0", element.style.position = "fixed", element.style.pointerEvents = "none", element;
  }
  __name(createFocusGuard, "createFocusGuard");
  var __assign = __name(function() {
    return __assign = Object.assign || __name(function(t) {
      for (var s4, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
        s4 = arguments[i3];
        for (var p4 in s4) Object.prototype.hasOwnProperty.call(s4, p4) && (t[p4] = s4[p4]);
      }
      return t;
    }, "__assign"), __assign.apply(this, arguments);
  }, "__assign");
  function __rest(s4, e) {
    var t = {};
    for (var p4 in s4) Object.prototype.hasOwnProperty.call(s4, p4) && e.indexOf(p4) < 0 && (t[p4] = s4[p4]);
    if (s4 != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i3 = 0, p4 = Object.getOwnPropertySymbols(s4); i3 < p4.length; i3++)
        e.indexOf(p4[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p4[i3]) && (t[p4[i3]] = s4[p4[i3]]);
    return t;
  }
  __name(__rest, "__rest");
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++)
      (ar || !(i3 in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i3)), ar[i3] = from[i3]);
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  __name(__spreadArray, "__spreadArray");
  var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
  function assignRef(ref, value2) {
    return typeof ref == "function" ? ref(value2) : ref && (ref.current = value2), ref;
  }
  __name(assignRef, "assignRef");
  function useCallbackRef22(initialValue, callback) {
    var ref = useState(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value2) {
            var last = ref.value;
            last !== value2 && (ref.value = value2, ref.callback(value2, last));
          }
        }
      };
    })[0];
    return ref.callback = callback, ref.facade;
  }
  __name(useCallbackRef22, "useCallbackRef");
  var useIsomorphicLayoutEffect2 = typeof window < "u" ? useLayoutEffect : useEffect, currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef22(defaultValue || null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    return useIsomorphicLayoutEffect2(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          nextRefs_1.has(ref) || assignRef(ref, null);
        }), nextRefs_1.forEach(function(ref) {
          prevRefs_1.has(ref) || assignRef(ref, current_1);
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]), callbackRef;
  }
  __name(useMergeRefs, "useMergeRefs");
  function ItoI(a3) {
    return a3;
  }
  __name(ItoI, "ItoI");
  function innerCreateMedium(defaults, middleware) {
    middleware === void 0 && (middleware = ItoI);
    var buffer = [], assigned = !1, medium = {
      read: __name(function() {
        if (assigned)
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return buffer.length ? buffer[buffer.length - 1] : defaults;
      }, "read"),
      useMedium: __name(function(data) {
        var item = middleware(data, assigned);
        return buffer.push(item), function() {
          buffer = buffer.filter(function(x3) {
            return x3 !== item;
          });
        };
      }, "useMedium"),
      assignSyncMedium: __name(function(cb) {
        for (assigned = !0; buffer.length; ) {
          var cbs = buffer;
          buffer = [], cbs.forEach(cb);
        }
        buffer = {
          push: __name(function(x3) {
            return cb(x3);
          }, "push"),
          filter: __name(function() {
            return buffer;
          }, "filter")
        };
      }, "assignSyncMedium"),
      assignMedium: __name(function(cb) {
        assigned = !0;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [], cbs.forEach(cb), pendingQueue = buffer;
        }
        var executeQueue = __name(function() {
          var cbs2 = pendingQueue;
          pendingQueue = [], cbs2.forEach(cb);
        }, "executeQueue"), cycle = __name(function() {
          return Promise.resolve().then(executeQueue);
        }, "cycle");
        cycle(), buffer = {
          push: __name(function(x3) {
            pendingQueue.push(x3), cycle();
          }, "push"),
          filter: __name(function(filter) {
            return pendingQueue = pendingQueue.filter(filter), buffer;
          }, "filter")
        };
      }, "assignMedium")
    };
    return medium;
  }
  __name(innerCreateMedium, "innerCreateMedium");
  function createSidecarMedium(options2) {
    options2 === void 0 && (options2 = {});
    var medium = innerCreateMedium(null);
    return medium.options = __assign({ async: !0, ssr: !1 }, options2), medium;
  }
  __name(createSidecarMedium, "createSidecarMedium");
  var SideCar = __name(function(_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar)
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var Target = sideCar.read();
    if (!Target)
      throw new Error("Sidecar medium not found");
    return createElement(Target, __assign({}, rest));
  }, "SideCar");
  SideCar.isSideCarExport = !0;
  function exportSidecar(medium, exported) {
    return medium.useMedium(exported), SideCar;
  }
  __name(exportSidecar, "exportSidecar");
  var effectCar = createSidecarMedium(), nothing = __name(function() {
  }, "nothing"), RemoveScroll = forwardRef(function(props, parentRef) {
    var ref = useRef(null), _a = useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1], forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container33 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), SideCar2 = sideCar, containerRef = useMergeRefs([ref, parentRef]), containerProps = __assign(__assign({}, rest), callbacks);
    return createElement(
      Fragment,
      null,
      enabled && createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
      forwardProps ? cloneElement(Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : createElement(Container33, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };
  var currentNonce, getNonce = __name(function() {
    if (currentNonce)
      return currentNonce;
    if (typeof __webpack_nonce__ < "u")
      return __webpack_nonce__;
  }, "getNonce");
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    return nonce && tag.setAttribute("nonce", nonce), tag;
  }
  __name(makeStyleTag, "makeStyleTag");
  function injectStyles(tag, css2) {
    tag.styleSheet ? tag.styleSheet.cssText = css2 : tag.appendChild(document.createTextNode(css2));
  }
  __name(injectStyles, "injectStyles");
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  __name(insertStyleTag, "insertStyleTag");
  var stylesheetSingleton = __name(function() {
    var counter = 0, stylesheet = null;
    return {
      add: __name(function(style) {
        counter == 0 && (stylesheet = makeStyleTag()) && (injectStyles(stylesheet, style), insertStyleTag(stylesheet)), counter++;
      }, "add"),
      remove: __name(function() {
        counter--, !counter && stylesheet && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null);
      }, "remove")
    };
  }, "stylesheetSingleton"), styleHookSingleton = __name(function() {
    var sheet = stylesheetSingleton();
    return function(styles22, isDynamic) {
      useEffect(function() {
        return sheet.add(styles22), function() {
          sheet.remove();
        };
      }, [styles22 && isDynamic]);
    };
  }, "styleHookSingleton"), styleSingleton = __name(function() {
    var useStyle = styleHookSingleton(), Sheet = __name(function(_a) {
      var styles22 = _a.styles, dynamic = _a.dynamic;
      return useStyle(styles22, dynamic), null;
    }, "Sheet");
    return Sheet;
  }, "styleSingleton"), zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  }, parse3 = __name(function(x3) {
    return parseInt(x3 || "", 10) || 0;
  }, "parse"), getOffset = __name(function(gapMode) {
    var cs = window.getComputedStyle(document.body), left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"], top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"], right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse3(left2), parse3(top2), parse3(right2)];
  }, "getOffset"), getGapWidth = __name(function(gapMode) {
    if (gapMode === void 0 && (gapMode = "margin"), typeof window > "u")
      return zeroGap;
    var offsets = getOffset(gapMode), documentWidth = document.documentElement.clientWidth, windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  }, "getGapWidth"), Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = __name(function(_a, allowRelative, gapMode, important) {
    var left2 = _a.left, top2 = _a.top, right2 = _a.right, gap = _a.gap;
    return gapMode === void 0 && (gapMode = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && `
    padding-left: `.concat(left2, `px;
    padding-top: `).concat(top2, `px;
    padding-right: `).concat(right2, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
  }, "getStyles"), getCurrentUseCounter = __name(function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(counter) ? counter : 0;
  }, "getCurrentUseCounter"), useLockAttribute = __name(function() {
    useEffect(function() {
      return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
        var newCounter = getCurrentUseCounter() - 1;
        newCounter <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, newCounter.toString());
      };
    }, []);
  }, "useLockAttribute"), RemoveScrollBar = __name(function(_a) {
    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
    useLockAttribute();
    var gap = useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, noImportant ? "" : "!important") });
  }, "RemoveScrollBar"), passiveSupported = !1;
  if (typeof window < "u")
    try {
      options = Object.defineProperty({}, "passive", {
        get: __name(function() {
          return passiveSupported = !0, !0;
        }, "get")
      }), window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
    } catch {
      passiveSupported = !1;
    }
  var options, nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = __name(function(node) {
    return node.tagName === "TEXTAREA";
  }, "alwaysContainsScroll"), elementCanBeScrolled = __name(function(node, overflow) {
    if (!(node instanceof Element))
      return !1;
    var styles22 = window.getComputedStyle(node);
    return (
      // not-not-scrollable
      styles22[overflow] !== "hidden" && // contains scroll inside self
      !(styles22.overflowY === styles22.overflowX && !alwaysContainsScroll(node) && styles22[overflow] === "visible")
    );
  }, "elementCanBeScrolled"), elementCouldBeVScrolled = __name(function(node) {
    return elementCanBeScrolled(node, "overflowY");
  }, "elementCouldBeVScrolled"), elementCouldBeHScrolled = __name(function(node) {
    return elementCanBeScrolled(node, "overflowX");
  }, "elementCouldBeHScrolled"), locationCouldBeScrolled = __name(function(axis, node) {
    var ownerDocument = node.ownerDocument, current = node;
    do {
      typeof ShadowRoot < "u" && current instanceof ShadowRoot && (current = current.host);
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
        if (scrollHeight > clientHeight)
          return !0;
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument.body);
    return !1;
  }, "locationCouldBeScrolled"), getVScrollVariables = __name(function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  }, "getVScrollVariables"), getHScrollVariables = __name(function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  }, "getHScrollVariables"), elementCouldBeScrolled = __name(function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  }, "elementCouldBeScrolled"), getScrollVariables = __name(function(axis, node) {
    return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
  }, "getScrollVariables"), getDirectionFactor = __name(function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  }, "getDirectionFactor"), handleScroll = __name(function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction), delta = directionFactor * sourceDelta, target = event.target, targetInLock = endTarget.contains(target), shouldCancelScroll = !1, isDeltaPositive = delta > 0, availableScroll = 0, availableScrollTop = 0;
    do {
      if (!target)
        break;
      var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2], elementScroll = scroll_1 - capacity - directionFactor * position;
      (position || elementScroll) && elementCouldBeScrolled(axis, target) && (availableScroll += elementScroll, availableScrollTop += position);
      var parent_1 = target.parentNode;
      target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    return (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll) || !isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) && (shouldCancelScroll = !0), shouldCancelScroll;
  }, "handleScroll"), getTouchXY = __name(function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  }, "getTouchXY"), getDeltaXY = __name(function(event) {
    return [event.deltaX, event.deltaY];
  }, "getDeltaXY"), extractRef = __name(function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  }, "extractRef"), deltaCompare = __name(function(x3, y3) {
    return x3[0] === y3[0] && x3[1] === y3[1];
  }, "deltaCompare"), generateStyle = __name(function(id2) {
    return `
  .block-interactivity-`.concat(id2, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id2, ` {pointer-events: all;}
`);
  }, "generateStyle"), idCounter = 0, lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = useRef([]), touchStartRef = useRef([0, 0]), activeAxis = useRef(), id2 = useState(idCounter++)[0], Style2 = useState(styleSingleton)[0], lastProps = useRef(props);
    useEffect(function() {
      lastProps.current = props;
    }, [props]), useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id2));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean);
        return allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id2));
        }), function() {
          document.body.classList.remove("block-interactivity-".concat(id2)), allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id2));
          });
        };
      }
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey)
        return !lastProps.current.allowPinchZoom;
      var touch = getTouchXY(event), touchStart = touchStartRef.current, deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0], deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1], currentAxis, target = event.target, moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range")
        return !1;
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection)
        return !0;
      if (canBeScrolledInMainDirection ? currentAxis = moveDirection : (currentAxis = moveDirection === "v" ? "h" : "v", canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)), !canBeScrolledInMainDirection)
        return !1;
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY) && (activeAxis.current = currentAxis), !currentAxis)
        return !0;
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, !0);
    }, []), shouldPrevent = useCallback(function(_event) {
      var event = _event;
      if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style2)) {
        var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event), sourceEvent = shouldPreventQueue.current.filter(function(e) {
          return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
        })[0];
        if (sourceEvent && sourceEvent.should) {
          event.cancelable && event.preventDefault();
          return;
        }
        if (!sourceEvent) {
          var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
            return node.contains(event.target);
          }), shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
          shouldStop && event.cancelable && event.preventDefault();
        }
      }
    }, []), shouldCancel = useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
      shouldPreventQueue.current.push(event), setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
          return e !== event;
        });
      }, 1);
    }, []), scrollTouchStart = useCallback(function(event) {
      touchStartRef.current = getTouchXY(event), activeAxis.current = void 0;
    }, []), scrollWheel = useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []), scrollTouchMove = useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    useEffect(function() {
      return lockStack.push(Style2), props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      }), document.addEventListener("wheel", shouldPrevent, nonPassive), document.addEventListener("touchmove", shouldPrevent, nonPassive), document.addEventListener("touchstart", scrollTouchStart, nonPassive), function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        }), document.removeEventListener("wheel", shouldPrevent, nonPassive), document.removeEventListener("touchmove", shouldPrevent, nonPassive), document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return createElement(
      Fragment,
      null,
      inert ? createElement(Style2, { styles: generateStyle(id2) }) : null,
      removeScrollBar ? createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
    );
  }
  __name(RemoveScrollSideCar, "RemoveScrollSideCar");
  function getOutermostShadowParent(node) {
    for (var shadowParent = null; node !== null; )
      node instanceof ShadowRoot && (shadowParent = node.host, node = node.host), node = node.parentNode;
    return shadowParent;
  }
  __name(getOutermostShadowParent, "getOutermostShadowParent");
  var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar), ReactRemoveScroll = forwardRef(function(props, ref) {
    return createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var Combination_default = ReactRemoveScroll, getDefaultParent = __name(function(originalTarget) {
    if (typeof document > "u")
      return null;
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  }, "getDefaultParent"), counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {}, lockCount = 0, unwrapHost = __name(function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
  }, "unwrapHost"), correctTargets = __name(function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target))
        return target;
      var correctedTarget = unwrapHost(target);
      return correctedTarget && parent.contains(correctedTarget) ? correctedTarget : (console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing"), null);
    }).filter(function(x3) {
      return !!x3;
    });
  }, "correctTargets"), applyAttributeToOthers = __name(function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
    var markerCounter = markerMap[markerName], hiddenNodes = [], elementsToKeep = /* @__PURE__ */ new Set(), elementsToStop = new Set(targets), keep = __name(function(el) {
      !el || elementsToKeep.has(el) || (elementsToKeep.add(el), keep(el.parentNode));
    }, "keep");
    targets.forEach(keep);
    var deep = __name(function(parent) {
      !parent || elementsToStop.has(parent) || Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node))
          deep(node);
        else
          try {
            var attr = node.getAttribute(controlAttribute), alreadyHidden = attr !== null && attr !== "false", counterValue = (counterMap.get(node) || 0) + 1, markerValue = (markerCounter.get(node) || 0) + 1;
            counterMap.set(node, counterValue), markerCounter.set(node, markerValue), hiddenNodes.push(node), counterValue === 1 && alreadyHidden && uncontrolledNodes.set(node, !0), markerValue === 1 && node.setAttribute(markerName, "true"), alreadyHidden || node.setAttribute(controlAttribute, "true");
          } catch (e) {
            console.error("aria-hidden: cannot operate on ", node, e);
          }
      });
    }, "deep");
    return deep(parentNode), elementsToKeep.clear(), lockCount++, function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1, markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue), markerCounter.set(node, markerValue), counterValue || (uncontrolledNodes.has(node) || node.removeAttribute(controlAttribute), uncontrolledNodes.delete(node)), markerValue || node.removeAttribute(markerName);
      }), lockCount--, lockCount || (counterMap = /* @__PURE__ */ new WeakMap(), counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {});
    };
  }, "applyAttributeToOthers"), hideOthers = __name(function(originalTarget, parentNode, markerName) {
    markerName === void 0 && (markerName = "data-aria-hidden");
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]), activeParentNode = parentNode || getDefaultParent(originalTarget);
    return activeParentNode ? (targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script"))), applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden")) : function() {
      return null;
    };
  }, "hideOthers"), DIALOG_NAME = "Dialog", [createDialogContext, createDialogScope] = createContextScope2(DIALOG_NAME), [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME), Dialog = __name((props) => {
    let {
      __scopeDialog,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      modal = !0
    } = props, triggerRef = useRef(null), contentRef = useRef(null), [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? !1,
      onChange: onOpenChange,
      caller: DIALOG_NAME
    });
    return (0, import_jsx_runtime12.jsx)(
      DialogProvider,
      {
        scope: __scopeDialog,
        triggerRef,
        contentRef,
        contentId: useId2(),
        titleId: useId2(),
        descriptionId: useId2(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        modal,
        children
      }
    );
  }, "Dialog");
  Dialog.displayName = DIALOG_NAME;
  var TRIGGER_NAME = "DialogTrigger", DialogTrigger = forwardRef(
    (props, forwardedRef) => {
      let { __scopeDialog, ...triggerProps } = props, context = useDialogContext(TRIGGER_NAME, __scopeDialog), composedTriggerRef = useComposedRefs2(forwardedRef, context.triggerRef);
      return (0, import_jsx_runtime12.jsx)(
        Primitive2.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": context.open,
          "aria-controls": context.contentId,
          "data-state": getState(context.open),
          ...triggerProps,
          ref: composedTriggerRef,
          onClick: composeEventHandlers2(props.onClick, context.onOpenToggle)
        }
      );
    }
  );
  DialogTrigger.displayName = TRIGGER_NAME;
  var PORTAL_NAME2 = "DialogPortal", [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
    forceMount: void 0
  }), DialogPortal = __name((props) => {
    let { __scopeDialog, forceMount, children, container } = props, context = useDialogContext(PORTAL_NAME2, __scopeDialog);
    return (0, import_jsx_runtime12.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: Children.map(children, (child) => (0, import_jsx_runtime12.jsx)(Presence2, { present: forceMount || context.open, children: (0, import_jsx_runtime12.jsx)(Portal, { asChild: !0, container, children: child }) })) });
  }, "DialogPortal");
  DialogPortal.displayName = PORTAL_NAME2;
  var OVERLAY_NAME = "DialogOverlay", DialogOverlay = forwardRef(
    (props, forwardedRef) => {
      let portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog), { forceMount = portalContext.forceMount, ...overlayProps } = props, context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
      return context.modal ? (0, import_jsx_runtime12.jsx)(Presence2, { present: forceMount || context.open, children: (0, import_jsx_runtime12.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
    }
  );
  DialogOverlay.displayName = OVERLAY_NAME;
  var Slot22 = createSlot("DialogOverlay.RemoveScroll"), DialogOverlayImpl = forwardRef(
    (props, forwardedRef) => {
      let { __scopeDialog, ...overlayProps } = props, context = useDialogContext(OVERLAY_NAME, __scopeDialog);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        (0, import_jsx_runtime12.jsx)(Combination_default, { as: Slot22, allowPinchZoom: !0, shards: [context.contentRef], children: (0, import_jsx_runtime12.jsx)(
          Primitive2.div,
          {
            "data-state": getState(context.open),
            ...overlayProps,
            ref: forwardedRef,
            style: { pointerEvents: "auto", ...overlayProps.style }
          }
        ) })
      );
    }
  ), CONTENT_NAME = "DialogContent", DialogContent = forwardRef(
    (props, forwardedRef) => {
      let portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog), { forceMount = portalContext.forceMount, ...contentProps } = props, context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      return (0, import_jsx_runtime12.jsx)(Presence2, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime12.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime12.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
    }
  );
  DialogContent.displayName = CONTENT_NAME;
  var DialogContentModal = forwardRef(
    (props, forwardedRef) => {
      let context = useDialogContext(CONTENT_NAME, props.__scopeDialog), contentRef = useRef(null), composedRefs = useComposedRefs2(forwardedRef, context.contentRef, contentRef);
      return useEffect(() => {
        let content = contentRef.current;
        if (content) return hideOthers(content);
      }, []), (0, import_jsx_runtime12.jsx)(
        DialogContentImpl,
        {
          ...props,
          ref: composedRefs,
          trapFocus: context.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: composeEventHandlers2(props.onCloseAutoFocus, (event) => {
            event.preventDefault(), context.triggerRef.current?.focus();
          }),
          onPointerDownOutside: composeEventHandlers2(props.onPointerDownOutside, (event) => {
            let originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0;
            (originalEvent.button === 2 || ctrlLeftClick) && event.preventDefault();
          }),
          onFocusOutside: composeEventHandlers2(
            props.onFocusOutside,
            (event) => event.preventDefault()
          )
        }
      );
    }
  ), DialogContentNonModal = forwardRef(
    (props, forwardedRef) => {
      let context = useDialogContext(CONTENT_NAME, props.__scopeDialog), hasInteractedOutsideRef = useRef(!1), hasPointerDownOutsideRef = useRef(!1);
      return (0, import_jsx_runtime12.jsx)(
        DialogContentImpl,
        {
          ...props,
          ref: forwardedRef,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: __name((event) => {
            props.onCloseAutoFocus?.(event), event.defaultPrevented || (hasInteractedOutsideRef.current || context.triggerRef.current?.focus(), event.preventDefault()), hasInteractedOutsideRef.current = !1, hasPointerDownOutsideRef.current = !1;
          }, "onCloseAutoFocus"),
          onInteractOutside: __name((event) => {
            props.onInteractOutside?.(event), event.defaultPrevented || (hasInteractedOutsideRef.current = !0, event.detail.originalEvent.type === "pointerdown" && (hasPointerDownOutsideRef.current = !0));
            let target = event.target;
            context.triggerRef.current?.contains(target) && event.preventDefault(), event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current && event.preventDefault();
          }, "onInteractOutside")
        }
      );
    }
  ), DialogContentImpl = forwardRef(
    (props, forwardedRef) => {
      let { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props, context = useDialogContext(CONTENT_NAME, __scopeDialog), contentRef = useRef(null), composedRefs = useComposedRefs2(forwardedRef, contentRef);
      return useFocusGuards(), (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
        (0, import_jsx_runtime12.jsx)(
          FocusScope,
          {
            asChild: !0,
            loop: !0,
            trapped: trapFocus,
            onMountAutoFocus: onOpenAutoFocus,
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime12.jsx)(
              DismissableLayer,
              {
                role: "dialog",
                id: context.contentId,
                "aria-describedby": context.descriptionId,
                "aria-labelledby": context.titleId,
                "data-state": getState(context.open),
                ...contentProps,
                ref: composedRefs,
                onDismiss: __name(() => context.onOpenChange(!1), "onDismiss")
              }
            )
          }
        ),
        (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
          (0, import_jsx_runtime12.jsx)(TitleWarning, { titleId: context.titleId }),
          (0, import_jsx_runtime12.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
        ] })
      ] });
    }
  ), TITLE_NAME = "DialogTitle", DialogTitle = forwardRef(
    (props, forwardedRef) => {
      let { __scopeDialog, ...titleProps } = props, context = useDialogContext(TITLE_NAME, __scopeDialog);
      return (0, import_jsx_runtime12.jsx)(Primitive2.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
    }
  );
  DialogTitle.displayName = TITLE_NAME;
  var DESCRIPTION_NAME = "DialogDescription", DialogDescription = forwardRef(
    (props, forwardedRef) => {
      let { __scopeDialog, ...descriptionProps } = props, context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
      return (0, import_jsx_runtime12.jsx)(Primitive2.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
    }
  );
  DialogDescription.displayName = DESCRIPTION_NAME;
  var CLOSE_NAME = "DialogClose", DialogClose = forwardRef(
    (props, forwardedRef) => {
      let { __scopeDialog, ...closeProps } = props, context = useDialogContext(CLOSE_NAME, __scopeDialog);
      return (0, import_jsx_runtime12.jsx)(
        Primitive2.button,
        {
          type: "button",
          ...closeProps,
          ref: forwardedRef,
          onClick: composeEventHandlers2(props.onClick, () => context.onOpenChange(!1))
        }
      );
    }
  );
  DialogClose.displayName = CLOSE_NAME;
  function getState(open) {
    return open ? "open" : "closed";
  }
  __name(getState, "getState");
  var TITLE_WARNING_NAME = "DialogTitleWarning", [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME,
    titleName: TITLE_NAME,
    docsSlug: "dialog"
  }), TitleWarning = __name(({ titleId }) => {
    let titleWarningContext = useWarningContext(TITLE_WARNING_NAME), MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
    return useEffect(() => {
      titleId && (document.getElementById(titleId) || console.error(MESSAGE));
    }, [MESSAGE, titleId]), null;
  }, "TitleWarning"), DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning", DescriptionWarning = __name(({ contentRef, descriptionId }) => {
    let MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${useWarningContext(DESCRIPTION_WARNING_NAME).contentName}}.`;
    return useEffect(() => {
      let describedById = contentRef.current?.getAttribute("aria-describedby");
      descriptionId && describedById && (document.getElementById(descriptionId) || console.warn(MESSAGE));
    }, [MESSAGE, contentRef, descriptionId]), null;
  }, "DescriptionWarning"), Root2 = Dialog, Trigger = DialogTrigger, Portal2 = DialogPortal, Overlay = DialogOverlay, Content = DialogContent, Title = DialogTitle, Description = DialogDescription, Close = DialogClose, Modal_styled_exports = {};
  __export2(Modal_styled_exports, {
    Actions: () => Actions,
    CloseButton: () => CloseButton,
    Col: () => Col,
    Container: () => Container2,
    Content: () => Content2,
    Description: () => Description2,
    Error: () => Error2,
    ErrorWrapper: () => ErrorWrapper,
    Header: () => Header,
    Overlay: () => Overlay2,
    Row: () => Row,
    Title: () => Title2
  });
  var Button = forwardRef(
    ({
      asChild = !1,
      animation = "none",
      size = "small",
      variant = "outline",
      padding = "medium",
      disabled = !1,
      active = !1,
      onClick,
      ...props
    }, ref) => {
      let Comp2 = "button";
      asChild && (Comp2 = Slot2);
      let [isAnimating, setIsAnimating] = useState(!1), handleClick = __name((event) => {
        onClick && onClick(event), animation !== "none" && setIsAnimating(!0);
      }, "handleClick");
      return useEffect(() => {
        let timer = setTimeout(() => {
          isAnimating && setIsAnimating(!1);
        }, 1e3);
        return () => clearTimeout(timer);
      }, [isAnimating]), react_default.createElement(
        StyledButton,
        {
          as: Comp2,
          ref,
          variant,
          size,
          padding,
          disabled,
          active,
          animating: isAnimating,
          animation,
          onClick: handleClick,
          ...props
        }
      );
    }
  );
  Button.displayName = "Button";
  var StyledButton = styled("button", {
    shouldForwardProp: __name((prop) => isPropValid(prop), "shouldForwardProp")
  })(({ theme: theme3, variant, size, disabled, active, animating, animation = "none", padding }) => ({
    border: 0,
    cursor: disabled ? "not-allowed" : "pointer",
    display: "inline-flex",
    gap: "6px",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    padding: padding === "none" ? 0 : padding === "small" && size === "small" ? "0 7px" : padding === "small" && size === "medium" ? "0 9px" : size === "small" ? "0 10px" : size === "medium" ? "0 12px" : 0,
    height: size === "small" ? "28px" : "32px",
    position: "relative",
    textAlign: "center",
    textDecoration: "none",
    transitionProperty: "background, box-shadow",
    transitionDuration: "150ms",
    transitionTimingFunction: "ease-out",
    verticalAlign: "top",
    whiteSpace: "nowrap",
    userSelect: "none",
    opacity: disabled ? 0.5 : 1,
    margin: 0,
    fontSize: `${theme3.typography.size.s1}px`,
    fontWeight: theme3.typography.weight.bold,
    lineHeight: "1",
    background: variant === "solid" ? theme3.color.secondary : variant === "outline" ? theme3.button.background : variant === "ghost" && active ? theme3.background.hoverable : "transparent",
    ...variant === "ghost" ? {
      // This is a hack to apply bar styles to the button as soon as it is part of a bar
      // It is a temporary solution until we have implemented Theming 2.0.
      ".sb-bar &": {
        background: active ? curriedTransparentize$1(0.9, theme3.barTextColor) : "transparent",
        color: active ? theme3.barSelectedColor : theme3.barTextColor,
        "&:hover": {
          color: theme3.barHoverColor,
          background: curriedTransparentize$1(0.86, theme3.barHoverColor)
        },
        "&:active": {
          color: theme3.barSelectedColor,
          background: curriedTransparentize$1(0.9, theme3.barSelectedColor)
        },
        "&:focus": {
          boxShadow: `${rgba(theme3.barHoverColor, 1)} 0 0 0 1px inset`,
          outline: "none"
        }
      }
    } : {},
    color: variant === "solid" ? theme3.color.lightest : variant === "outline" ? theme3.input.color : variant === "ghost" && active ? theme3.color.secondary : variant === "ghost" ? theme3.color.mediumdark : theme3.input.color,
    boxShadow: variant === "outline" ? `${theme3.button.border} 0 0 0 1px inset` : "none",
    borderRadius: theme3.input.borderRadius,
    // Making sure that the button never shrinks below its minimum size
    flexShrink: 0,
    "&:hover": {
      color: variant === "ghost" ? theme3.color.secondary : void 0,
      background: (() => {
        let bgColor = theme3.color.secondary;
        return variant === "solid" && (bgColor = theme3.color.secondary), variant === "outline" && (bgColor = theme3.button.background), variant === "ghost" ? curriedTransparentize$1(0.86, theme3.color.secondary) : theme3.base === "light" ? curriedDarken$1(0.02, bgColor) : curriedLighten$1(0.03, bgColor);
      })()
    },
    "&:active": {
      color: variant === "ghost" ? theme3.color.secondary : void 0,
      background: (() => {
        let bgColor = theme3.color.secondary;
        return variant === "solid" && (bgColor = theme3.color.secondary), variant === "outline" && (bgColor = theme3.button.background), variant === "ghost" ? theme3.background.hoverable : theme3.base === "light" ? curriedDarken$1(0.02, bgColor) : curriedLighten$1(0.03, bgColor);
      })()
    },
    "&:focus": {
      boxShadow: `${rgba(theme3.color.secondary, 1)} 0 0 0 1px inset`,
      outline: "none"
    },
    "> svg": {
      animation: animating && animation !== "none" ? `${theme3.animation[animation]} 1000ms ease-out` : ""
    }
  })), IconButton = forwardRef(
    ({ padding = "small", variant = "ghost", ...props }, ref) => react_default.createElement(Button, { padding, variant, ref, ...props })
  );
  IconButton.displayName = "IconButton";
  var fadeIn = keyframes({
    from: { opacity: 0 },
    to: { opacity: 1 }
  }), expand = keyframes({
    from: { maxHeight: 0 },
    to: {}
  }), zoomIn = keyframes({
    from: {
      opacity: 0,
      transform: "translate(-50%, -50%) scale(0.9)"
    },
    to: {
      opacity: 1,
      transform: "translate(-50%, -50%) scale(1)"
    }
  }), Overlay2 = styled.div({
    backdropFilter: "blur(24px)",
    position: "fixed",
    inset: 0,
    width: "100%",
    height: "100%",
    zIndex: 10,
    animation: `${fadeIn} 200ms`
  }), Container2 = styled.div(
    ({ theme: theme3, width, height }) => ({
      backgroundColor: theme3.background.bar,
      borderRadius: 6,
      boxShadow: "0px 4px 67px 0px #00000040",
      position: "fixed",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: width ?? 740,
      height: height ?? "auto",
      maxWidth: "calc(100% - 40px)",
      maxHeight: "85vh",
      overflow: "auto",
      zIndex: 11,
      animation: `${zoomIn} 200ms`,
      "&:focus-visible": {
        outline: "none"
      }
    })
  ), CloseButton = __name((props) => react_default.createElement(Close, { asChild: !0 }, react_default.createElement(IconButton, { "aria-label": "Close", ...props }, react_default.createElement(CrossIcon, null))), "CloseButton"), Content2 = styled.div({
    display: "flex",
    flexDirection: "column",
    margin: 16,
    gap: 16
  }), Row = styled.div({
    display: "flex",
    justifyContent: "space-between",
    gap: 16
  }), Col = styled.div({
    display: "flex",
    flexDirection: "column",
    gap: 4
  }), Header = __name((props) => react_default.createElement(Row, null, react_default.createElement(Col, { ...props }), react_default.createElement(CloseButton, null)), "Header"), Title2 = styled(Title)(({ theme: theme3 }) => ({
    margin: 0,
    fontSize: theme3.typography.size.s3,
    fontWeight: theme3.typography.weight.bold
  })), Description2 = styled(Description)(({ theme: theme3 }) => ({
    position: "relative",
    zIndex: 1,
    margin: 0,
    fontSize: theme3.typography.size.s2
  })), Actions = styled.div({
    display: "flex",
    flexDirection: "row-reverse",
    gap: 8
  }), ErrorWrapper = styled.div(({ theme: theme3 }) => ({
    maxHeight: 100,
    overflow: "auto",
    animation: `${expand} 300ms, ${fadeIn} 300ms`,
    backgroundColor: theme3.background.critical,
    color: theme3.color.lightest,
    fontSize: theme3.typography.size.s2,
    "& > div": {
      position: "relative",
      padding: "8px 16px"
    }
  })), Error2 = __name(({
    children,
    ...props
  }) => react_default.createElement(ErrorWrapper, { ...props }, react_default.createElement("div", null, children)), "Error");
  function BaseModal({
    children,
    width,
    height,
    onEscapeKeyDown,
    onInteractOutside = __name((ev) => ev.preventDefault(), "onInteractOutside"),
    className,
    container,
    portalSelector,
    ...rootProps
  }) {
    let containerElement = container ?? (portalSelector ? document.querySelector(portalSelector) : null) ?? document.body;
    return react_default.createElement(Root2, { ...rootProps }, react_default.createElement(Portal2, { container: containerElement }, react_default.createElement(Overlay, { asChild: !0 }, react_default.createElement(Overlay2, null)), react_default.createElement(
      Content,
      {
        asChild: !0,
        onInteractOutside,
        onEscapeKeyDown
      },
      react_default.createElement(Container2, { className, width, height }, children)
    )));
  }
  __name(BaseModal, "BaseModal");
  var Modal = Object.assign(BaseModal, Modal_styled_exports, { Dialog: dist_exports }), toNumber = __name((input) => typeof input == "number" ? input : Number(input), "toNumber"), Container22 = styled.div(
    ({ theme: theme3, col, row = 1 }) => col ? {
      display: "inline-block",
      verticalAlign: "inherit",
      "& > *": {
        marginLeft: col * theme3.layoutMargin,
        verticalAlign: "inherit"
      },
      [`& > *:first-child${ignoreSsrWarning}`]: {
        marginLeft: 0
      }
    } : {
      "& > *": {
        marginTop: row * theme3.layoutMargin
      },
      [`& > *:first-child${ignoreSsrWarning}`]: {
        marginTop: 0
      }
    },
    ({ theme: theme3, outer, col, row }) => {
      switch (!0) {
        case !!(outer && col):
          return {
            marginLeft: outer * theme3.layoutMargin,
            marginRight: outer * theme3.layoutMargin
          };
        case !!(outer && row):
          return {
            marginTop: outer * theme3.layoutMargin,
            marginBottom: outer * theme3.layoutMargin
          };
        default:
          return {};
      }
    }
  ), Spaced = __name(({ col, row, outer, children, ...rest }) => {
    let outerAmount = toNumber(typeof outer == "number" || !outer ? outer : col || row);
    return react_default.createElement(Container22, { col, row, outer: outerAmount, ...rest }, children);
  }, "Spaced"), Title3 = styled.div(({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.bold
  })), Desc = styled.div(), Message = styled.div(({ theme: theme3 }) => ({
    padding: 30,
    textAlign: "center",
    color: theme3.color.defaultText,
    fontSize: theme3.typography.size.s2 - 1
  })), Placeholder = __name(({ children, ...props }) => {
    let [title, desc] = Children.toArray(children);
    return react_default.createElement(Message, { ...props }, react_default.createElement(Title3, null, title), desc && react_default.createElement(Desc, null, desc));
  }, "Placeholder");
  function useResolvedElement(subscriber, refOrElement) {
    var lastReportRef = useRef(null), refOrElementRef = useRef(null);
    refOrElementRef.current = refOrElement;
    var cbElementRef = useRef(null);
    useEffect(function() {
      evaluateSubscription();
    });
    var evaluateSubscription = useCallback(function() {
      var cbElement = cbElementRef.current, refOrElement2 = refOrElementRef.current, element = cbElement || (refOrElement2 ? refOrElement2 instanceof Element ? refOrElement2 : refOrElement2.current : null);
      lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.subscriber === subscriber || (lastReportRef.current && lastReportRef.current.cleanup && lastReportRef.current.cleanup(), lastReportRef.current = {
        element,
        subscriber,
        // Only calling the subscriber, if there's an actual element to report.
        // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.
        cleanup: element ? subscriber(element) : void 0
      });
    }, [subscriber]);
    return useEffect(function() {
      return function() {
        lastReportRef.current && lastReportRef.current.cleanup && (lastReportRef.current.cleanup(), lastReportRef.current = null);
      };
    }, []), useCallback(function(element) {
      cbElementRef.current = element, evaluateSubscription();
    }, [evaluateSubscription]);
  }
  __name(useResolvedElement, "useResolvedElement");
  function extractSize(entry, boxProp, sizeType) {
    return entry[boxProp] ? entry[boxProp][0] ? entry[boxProp][0][sizeType] : (
      // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current
      // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.
      // @ts-ignore
      entry[boxProp][sizeType]
    ) : boxProp === "contentBoxSize" ? entry.contentRect[sizeType === "inlineSize" ? "width" : "height"] : void 0;
  }
  __name(extractSize, "extractSize");
  function useResizeObserver2(opts) {
    opts === void 0 && (opts = {});
    var onResize = opts.onResize, onResizeRef = useRef(void 0);
    onResizeRef.current = onResize;
    var round3 = opts.round || Math.round, resizeObserverRef = useRef(), _useState = useState({
      width: void 0,
      height: void 0
    }), size = _useState[0], setSize = _useState[1], didUnmount = useRef(!1);
    useEffect(function() {
      return didUnmount.current = !1, function() {
        didUnmount.current = !0;
      };
    }, []);
    var previous = useRef({
      width: void 0,
      height: void 0
    }), refCallback = useResolvedElement(useCallback(function(element) {
      return (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round3) && (resizeObserverRef.current = {
        box: opts.box,
        round: round3,
        instance: new ResizeObserver(function(entries) {
          var entry = entries[0], boxProp = opts.box === "border-box" ? "borderBoxSize" : opts.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize", reportedWidth = extractSize(entry, boxProp, "inlineSize"), reportedHeight = extractSize(entry, boxProp, "blockSize"), newWidth = reportedWidth ? round3(reportedWidth) : void 0, newHeight = reportedHeight ? round3(reportedHeight) : void 0;
          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
            var newSize = {
              width: newWidth,
              height: newHeight
            };
            previous.current.width = newWidth, previous.current.height = newHeight, onResizeRef.current ? onResizeRef.current(newSize) : didUnmount.current || setSize(newSize);
          }
        })
      }), resizeObserverRef.current.instance.observe(element, {
        box: opts.box
      }), function() {
        resizeObserverRef.current && resizeObserverRef.current.instance.unobserve(element);
      };
    }, [opts.box, round3]), opts.ref);
    return useMemo(function() {
      return {
        ref: refCallback,
        width: size.width,
        height: size.height
      };
    }, [refCallback, size.width, size.height]);
  }
  __name(useResizeObserver2, "useResizeObserver");
  var ZoomElementWrapper = styled.div(
    ({ centered = !1, scale = 1, elementHeight }) => ({
      height: elementHeight || "auto",
      transformOrigin: centered ? "center top" : "left top",
      transform: `scale(${1 / scale})`
    })
  );
  function ZoomElement({ centered, scale, children }) {
    let componentWrapperRef = useRef(null), [elementHeight, setElementHeight] = useState(0), onResize = useCallback(
      ({ height }) => {
        height && setElementHeight(height / scale);
      },
      [scale]
    );
    return useEffect(() => {
      componentWrapperRef.current && setElementHeight(componentWrapperRef.current.getBoundingClientRect().height);
    }, [scale]), useResizeObserver2({
      ref: componentWrapperRef,
      onResize
    }), react_default.createElement(ZoomElementWrapper, { centered, scale, elementHeight }, react_default.createElement("div", { ref: componentWrapperRef, className: "innerZoomElementWrapper" }, children));
  }
  __name(ZoomElement, "ZoomElement");
  var _ZoomIFrame = class extends Component {
    constructor() {
      super(...arguments), this.iframe = null;
    }
    componentDidMount() {
      let { iFrameRef } = this.props;
      this.iframe = iFrameRef.current;
    }
    shouldComponentUpdate(nextProps) {
      let { scale, active } = this.props;
      return scale !== nextProps.scale && this.setIframeInnerZoom(nextProps.scale), active !== nextProps.active && this.iframe.setAttribute("data-is-storybook", nextProps.active ? "true" : "false"), nextProps.children.props.src !== this.props.children.props.src;
    }
    setIframeInnerZoom(scale) {
      try {
        Object.assign(this.iframe.contentDocument.body.style, {
          width: `${scale * 100}%`,
          height: `${scale * 100}%`,
          transform: `scale(${1 / scale})`,
          transformOrigin: "top left"
        });
      } catch {
        this.setIframeZoom(scale);
      }
    }
    setIframeZoom(scale) {
      Object.assign(this.iframe.style, {
        width: `${scale * 100}%`,
        height: `${scale * 100}%`,
        transform: `scale(${1 / scale})`,
        transformOrigin: "top left"
      });
    }
    render() {
      let { children } = this.props;
      return react_default.createElement(react_default.Fragment, null, children);
    }
  };
  __name(_ZoomIFrame, "ZoomIFrame");
  var { document: document25 } = scope, ErrorName = styled.strong(({ theme: theme3 }) => ({
    color: theme3.color.orange
  })), ErrorImportant = styled.strong(({ theme: theme3 }) => ({
    color: theme3.color.ancillary,
    textDecoration: "underline"
  })), ErrorDetail = styled.em(({ theme: theme3 }) => ({
    color: theme3.textMutedColor
  })), firstLineRegex = /(Error): (.*)\n/, linesRegexChromium = /at (?:(.*) )?\(?(.+)\)?/, linesRegexFirefox = /([^@]+)?(?:\/<)?@(.+)?/, linesRegexSafari = /([^@]+)?@(.+)?/, ErrorFormatter = __name(({ error }) => {
    if (!error)
      return react_default.createElement(Fragment, null, "This error has no stack or message");
    if (!error.stack)
      return react_default.createElement(Fragment, null, error.message || "This error has no stack or message");
    let input = error.stack.toString();
    input && error.message && !input.includes(error.message) && (input = `Error: ${error.message}

${input}`);
    let match2 = input.match(firstLineRegex);
    if (!match2)
      return react_default.createElement(Fragment, null, input);
    let [, type, name] = match2, rawLines = input.split(/\n/).slice(1), [, ...lines] = rawLines.map((line) => {
      let result = line.match(linesRegexChromium) || line.match(linesRegexFirefox) || line.match(linesRegexSafari);
      return result ? {
        name: (result[1] || "").replace("/<", ""),
        location: result[2].replace(document25.location.origin, "")
      } : null;
    }).filter(Boolean);
    return react_default.createElement(Fragment, null, react_default.createElement("span", null, type), ": ", react_default.createElement(ErrorName, null, name), react_default.createElement("br", null), lines.map(
      (l2, i3) => l2?.name ? react_default.createElement(Fragment, { key: i3 }, "  ", "at ", react_default.createElement(ErrorImportant, null, l2.name), " (", react_default.createElement(ErrorDetail, null, l2.location), ")", react_default.createElement("br", null)) : react_default.createElement(Fragment, { key: i3 }, "  ", "at ", react_default.createElement(ErrorDetail, null, l2?.location), react_default.createElement("br", null))
    ));
  }, "ErrorFormatter"), Input = styled.input({
    appearance: "none",
    display: "grid",
    placeContent: "center",
    width: 14,
    height: 14,
    flexShrink: 0,
    margin: 0,
    border: `1px solid ${color.border}`,
    borderRadius: 2,
    backgroundColor: "white",
    transition: "background-color 0.1s",
    "&:enabled": {
      cursor: "pointer"
    },
    "&:disabled": {
      backgroundColor: color.medium
    },
    "&:disabled:checked, &:disabled:indeterminate": {
      backgroundColor: color.mediumdark
    },
    "&:checked, &:indeterminate": {
      backgroundColor: color.secondary
    },
    "&:checked::before": {
      content: '""',
      width: 14,
      height: 14,
      background: `no-repeat center url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14'%3E%3Cpath fill='none' stroke='%23fff' stroke-width='2' d='m3 7 2.5 2.5L11 4'/%3E%3C/svg%3E")`
    },
    "&:indeterminate::before": {
      content: '""',
      width: 8,
      height: 2,
      background: "white"
    },
    "&:enabled:focus-visible": {
      outline: `1px solid ${color.secondary}`,
      outlineOffset: 1
    }
  }), Checkbox = __name((props) => react_default.createElement(Input, { ...props, type: "checkbox" }), "Checkbox"), Wrapper3 = styled.label(({ theme: theme3 }) => ({
    display: "flex",
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    margin: "0 15px",
    padding: "8px 0",
    "&:last-child": {
      marginBottom: "3rem"
    }
  })), Label = styled.span(({ theme: theme3 }) => ({
    minWidth: 100,
    fontWeight: theme3.typography.weight.bold,
    marginRight: 15,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    lineHeight: "16px"
  })), Field = __name(({ label, children, ...props }) => react_default.createElement(Wrapper3, { ...props }, label ? react_default.createElement(Label, null, react_default.createElement("span", null, label)) : null, children), "Field"), sizes = __name(({ size }) => {
    switch (size) {
      case "100%":
        return { width: "100%" };
      case "flex":
        return { flex: 1 };
      case "auto":
      default:
        return { display: "inline" };
    }
  }, "sizes"), alignment = __name(({
    align
  }) => {
    switch (align) {
      case "end":
        return { textAlign: "right" };
      case "center":
        return { textAlign: "center" };
      case "start":
      default:
        return { textAlign: "left" };
    }
  }, "alignment"), validation = __name(({
    valid,
    theme: theme3
  }) => {
    switch (valid) {
      case "valid":
        return { boxShadow: `${theme3.color.positive} 0 0 0 1px inset !important` };
      case "error":
        return { boxShadow: `${theme3.color.negative} 0 0 0 1px inset !important` };
      case "warn":
        return {
          boxShadow: `${theme3.color.warning} 0 0 0 1px inset`
        };
      case void 0:
      case null:
      default:
        return {};
    }
  }, "validation"), styleResets = {
    // resets
    appearance: "none",
    border: "0 none",
    boxSizing: "inherit",
    display: " block",
    margin: " 0",
    background: "transparent",
    padding: 0,
    fontSize: "inherit",
    position: "relative"
  }, styles2 = __name(({ theme: theme3 }) => ({
    ...styleResets,
    transition: "box-shadow 200ms ease-out, opacity 200ms ease-out",
    color: theme3.input.color || "inherit",
    background: theme3.input.background,
    boxShadow: `${theme3.input.border} 0 0 0 1px inset`,
    borderRadius: theme3.input.borderRadius,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "20px",
    padding: "6px 10px",
    // 32
    boxSizing: "border-box",
    height: 32,
    '&[type="file"]': {
      height: "auto"
    },
    "&:focus": {
      boxShadow: `${theme3.color.secondary} 0 0 0 1px inset`,
      outline: "none",
      "@media (forced-colors: active)": {
        outline: "1px solid highlight"
      }
    },
    "&[disabled]": {
      cursor: "not-allowed",
      opacity: 0.5
    },
    "&:-webkit-autofill": { WebkitBoxShadow: `0 0 0 3em ${theme3.color.lightest} inset` },
    "&::placeholder": {
      color: theme3.textMutedColor,
      opacity: 1
    }
  }), "styles"), Input2 = Object.assign(
    styled(
      forwardRef(__name(function({ size, valid, align, ...props }, ref) {
        return react_default.createElement("input", { ...props, ref });
      }, "Input"))
    )(styles2, sizes, alignment, validation, {
      minHeight: 32
    }),
    {
      displayName: "Input"
    }
  ), Input4 = styled.input({
    appearance: "none",
    display: "grid",
    placeContent: "center",
    width: 16,
    height: 16,
    flexShrink: 0,
    margin: -1,
    border: `1px solid ${color.border}`,
    borderRadius: 8,
    backgroundColor: "white",
    transition: "background-color 0.1s",
    "&:enabled": {
      cursor: "pointer"
    },
    "&:disabled": {
      backgroundColor: color.medium
    },
    "&:disabled:checked": {
      backgroundColor: color.mediumdark
    },
    "&:checked": {
      backgroundColor: color.secondary,
      boxShadow: "inset 0 0 0 2px white"
    },
    "&:enabled:focus-visible": {
      outline: `1px solid ${color.secondary}`,
      outlineOffset: 1
    }
  }), Radio = __name((props) => react_default.createElement(Input4, { ...props, type: "radio" }), "Radio"), BaseSelect = styled.select(sizes, ({ theme: theme3 }) => ({
    appearance: "none",
    background: `calc(100% - 12px) center no-repeat url("data:image/svg+xml,%3Csvg width='8' height='4' viewBox='0 0 8 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.30303 0.196815C1.13566 0.0294472 0.864304 0.0294472 0.696937 0.196815C0.529569 0.364182 0.529569 0.635539 0.696937 0.802906L3.69694 3.80291C3.8643 3.97027 4.13566 3.97027 4.30303 3.80291L7.30303 0.802906C7.4704 0.635539 7.4704 0.364182 7.30303 0.196815C7.13566 0.0294473 6.8643 0.0294473 6.69694 0.196815L3.99998 2.89377L1.30303 0.196815Z' fill='%2373828C'/%3E%3C/svg%3E%0A")`,
    backgroundSize: 10,
    padding: "6px 30px 6px 10px",
    "@supports (appearance: base-select)": {
      appearance: "base-select",
      background: theme3.input.background,
      padding: "6px 10px"
    },
    transition: "box-shadow 200ms ease-out, opacity 200ms ease-out",
    color: theme3.input.color || "inherit",
    boxShadow: `${theme3.input.border} 0 0 0 1px inset`,
    borderRadius: theme3.input.borderRadius,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "20px",
    boxSizing: "border-box",
    border: "none",
    cursor: "pointer",
    "& > button": {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "100%",
      gap: 8,
      "& > svg": {
        width: 14,
        height: 14,
        color: theme3.color.mediumdark
      }
    },
    "&:has(option:not([hidden]):checked)": {
      color: theme3.color.defaultText
    },
    "&:focus-visible, &:focus-within": {
      outline: "none",
      boxShadow: `${theme3.color.secondary} 0 0 0 1px inset`
    },
    "&::picker-icon": {
      display: "none"
    },
    "&::picker(select)": {
      appearance: "base-select",
      border: "1px solid #e4e4e7",
      padding: 4,
      marginTop: 4,
      background: theme3.base === "light" ? lighten(theme3.background.app) : theme3.background.app,
      filter: `
      drop-shadow(0 5px 5px rgba(0,0,0,0.05))
      drop-shadow(0 0 3px rgba(0,0,0,0.1))
    `,
      borderRadius: theme3.appBorderRadius + 2,
      fontSize: theme3.typography.size.s1,
      cursor: "default",
      transition: "opacity 100ms ease-in-out, transform 100ms ease-in-out",
      transformOrigin: "top",
      transform: "translateY(0)",
      opacity: 1,
      "@starting-style": {
        transform: "translateY(-0.25rem) scale(0.95)",
        opacity: 0
      }
    },
    "& optgroup label": {
      display: "block",
      padding: "3px 6px"
    },
    "& option": {
      lineHeight: "18px",
      padding: "7px 10px",
      borderRadius: 4,
      outline: "none",
      cursor: "pointer",
      color: theme3.color.defaultText,
      "&::checkmark": {
        display: "none"
      },
      "&:hover, &:focus-visible": {
        backgroundColor: theme3.background.hoverable
      },
      "&:checked": {
        color: theme3.color.secondary,
        fontWeight: theme3.typography.weight.bold
      },
      "&:disabled": {
        backgroundColor: "transparent",
        cursor: "default",
        color: theme3.color.defaultText
      }
    }
  })), Select = __name(({ children, ...props }) => (
    // @ts-expect-error Weird props mismatch
    react_default.createElement(BaseSelect, { ...props }, !isTestEnvironment() && react_default.createElement("button", null, react_default.createElement("selectedcontent", null), react_default.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        "aria-hidden": "true"
      },
      react_default.createElement("path", { d: "m6 9 6 6 6-6" })
    )), react_default.createElement("optgroup", null, children))
  ), "Select"), index2 = useLayoutEffect, useLatest = __name(function(value2) {
    var ref = react_default.useRef(value2);
    return index2(function() {
      ref.current = value2;
    }), ref;
  }, "useLatest"), updateRef = __name(function(ref, value2) {
    if (typeof ref == "function") {
      ref(value2);
      return;
    }
    ref.current = value2;
  }, "updateRef"), useComposedRef = __name(function(libRef, userRef) {
    var prevUserRef = react_default.useRef();
    return react_default.useCallback(function(instance) {
      libRef.current = instance, prevUserRef.current && updateRef(prevUserRef.current, null), prevUserRef.current = userRef, userRef && updateRef(userRef, instance);
    }, [userRef]);
  }, "useComposedRef"), HIDDEN_TEXTAREA_STYLE = {
    "min-height": "0",
    "max-height": "none",
    height: "0",
    visibility: "hidden",
    overflow: "hidden",
    position: "absolute",
    "z-index": "-1000",
    top: "0",
    right: "0",
    display: "block"
  }, forceHiddenStyles = __name(function(node) {
    Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
      node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
    });
  }, "forceHiddenStyles"), forceHiddenStyles$1 = forceHiddenStyles, hiddenTextarea = null, getHeight = __name(function(node, sizingData) {
    var height = node.scrollHeight;
    return sizingData.sizingStyle.boxSizing === "border-box" ? height + sizingData.borderSize : height - sizingData.paddingSize;
  }, "getHeight");
  function calculateNodeHeight(sizingData, value2, minRows, maxRows) {
    minRows === void 0 && (minRows = 1), maxRows === void 0 && (maxRows = 1 / 0), hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tabindex", "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), forceHiddenStyles$1(hiddenTextarea)), hiddenTextarea.parentNode === null && document.body.appendChild(hiddenTextarea);
    var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle, boxSizing = sizingStyle.boxSizing;
    Object.keys(sizingStyle).forEach(function(_key) {
      var key = _key;
      hiddenTextarea.style[key] = sizingStyle[key];
    }), forceHiddenStyles$1(hiddenTextarea), hiddenTextarea.value = value2;
    var height = getHeight(hiddenTextarea, sizingData);
    hiddenTextarea.value = value2, height = getHeight(hiddenTextarea, sizingData), hiddenTextarea.value = "x";
    var rowHeight = hiddenTextarea.scrollHeight - paddingSize, minHeight = rowHeight * minRows;
    boxSizing === "border-box" && (minHeight = minHeight + paddingSize + borderSize), height = Math.max(minHeight, height);
    var maxHeight = rowHeight * maxRows;
    return boxSizing === "border-box" && (maxHeight = maxHeight + paddingSize + borderSize), height = Math.min(maxHeight, height), [height, rowHeight];
  }
  __name(calculateNodeHeight, "calculateNodeHeight");
  var noop5 = __name(function() {
  }, "noop"), pick2 = __name(function(props, obj) {
    return props.reduce(function(acc, prop) {
      return acc[prop] = obj[prop], acc;
    }, {});
  }, "pick"), SIZING_STYLE = [
    "borderBottomWidth",
    "borderLeftWidth",
    "borderRightWidth",
    "borderTopWidth",
    "boxSizing",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "letterSpacing",
    "lineHeight",
    "paddingBottom",
    "paddingLeft",
    "paddingRight",
    "paddingTop",
    // non-standard
    "tabSize",
    "textIndent",
    // non-standard
    "textRendering",
    "textTransform",
    "width",
    "wordBreak",
    "wordSpacing",
    "scrollbarGutter"
  ], isIE = !!document.documentElement.currentStyle, getSizingData = __name(function(node) {
    var style = window.getComputedStyle(node);
    if (style === null)
      return null;
    var sizingStyle = pick2(SIZING_STYLE, style), boxSizing = sizingStyle.boxSizing;
    if (boxSizing === "")
      return null;
    isIE && boxSizing === "border-box" && (sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px");
    var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop), borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
    return {
      sizingStyle,
      paddingSize,
      borderSize
    };
  }, "getSizingData"), getSizingData$1 = getSizingData;
  function useListener(target, type, listener) {
    var latestListener = useLatest(listener);
    useLayoutEffect(function() {
      var handler = __name(function(ev) {
        return latestListener.current(ev);
      }, "handler");
      if (target)
        return target.addEventListener(type, handler), function() {
          return target.removeEventListener(type, handler);
        };
    }, []);
  }
  __name(useListener, "useListener");
  var useFormResetListener = __name(function(libRef, listener) {
    useListener(document.body, "reset", function(ev) {
      libRef.current.form === ev.target && listener(ev);
    });
  }, "useFormResetListener"), useWindowResizeListener = __name(function(listener) {
    useListener(window, "resize", listener);
  }, "useWindowResizeListener"), useFontsLoadedListener = __name(function(listener) {
    useListener(document.fonts, "loadingdone", listener);
  }, "useFontsLoadedListener"), _excluded3 = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], TextareaAutosize = __name(function(_ref, userRef) {
    var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop5 : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop5 : _ref$onHeightChange, props = _objectWithoutPropertiesLoose(_ref, _excluded3), isControlled = props.value !== void 0, libRef = useRef(null), ref = useComposedRef(libRef, userRef), heightRef = useRef(0), measurementsCacheRef = useRef(), resizeTextarea = __name(function() {
      var node = libRef.current, nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
      if (nodeSizingData) {
        measurementsCacheRef.current = nodeSizingData;
        var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
        heightRef.current !== height && (heightRef.current = height, node.style.setProperty("height", height + "px", "important"), onHeightChange(height, {
          rowHeight
        }));
      }
    }, "resizeTextarea"), handleChange = __name(function(event) {
      isControlled || resizeTextarea(), onChange(event);
    }, "handleChange");
    return useLayoutEffect(resizeTextarea), useFormResetListener(libRef, function() {
      if (!isControlled) {
        var currentValue = libRef.current.value;
        requestAnimationFrame(function() {
          var node = libRef.current;
          node && currentValue !== node.value && resizeTextarea();
        });
      }
    }), useWindowResizeListener(resizeTextarea), useFontsLoadedListener(resizeTextarea), createElement("textarea", _extends({}, props, {
      onChange: handleChange,
      ref
    }));
  }, "TextareaAutosize"), index22 = forwardRef(TextareaAutosize), Textarea = Object.assign(
    styled(
      forwardRef(__name(function({ size, valid, align, ...props }, ref) {
        return react_default.createElement(index22, { ...props, ref });
      }, "Textarea"))
    )(styles2, sizes, alignment, validation, ({ height = 400 }) => ({
      overflow: "visible",
      maxHeight: height
    })),
    {
      displayName: "Textarea"
    }
  ), Form = Object.assign(
    styled.form({
      boxSizing: "border-box",
      width: "100%"
    }),
    {
      Field,
      Input: Input2,
      Select,
      Textarea,
      Button,
      Checkbox,
      Radio
    }
  ), LazyWithTooltip = lazy(
    () => Promise.resolve().then(() => (init_WithTooltip_SK46ZJ2J(), WithTooltip_SK46ZJ2J_exports)).then((mod) => ({ default: mod.WithTooltip }))
  ), WithTooltip = __name((props) => react_default.createElement(Suspense, { fallback: react_default.createElement("div", null) }, react_default.createElement(LazyWithTooltip, { ...props })), "WithTooltip"), LazyWithTooltipPure = lazy(
    () => Promise.resolve().then(() => (init_WithTooltip_SK46ZJ2J(), WithTooltip_SK46ZJ2J_exports)).then((mod) => ({ default: mod.WithTooltipPure }))
  ), WithTooltipPure2 = __name((props) => react_default.createElement(Suspense, { fallback: react_default.createElement("div", null) }, react_default.createElement(LazyWithTooltipPure, { ...props })), "WithTooltipPure"), Title4 = styled.div(({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.bold
  })), Desc2 = styled.span(), Links = styled.div(({ theme: theme3 }) => ({
    marginTop: 8,
    textAlign: "center",
    "> *": {
      margin: "0 8px",
      fontWeight: theme3.typography.weight.bold
    }
  })), Message2 = styled.div(({ theme: theme3 }) => ({
    color: theme3.color.defaultText,
    lineHeight: "18px"
  })), MessageWrapper = styled.div({
    padding: 15,
    width: 280,
    boxSizing: "border-box"
  }), TooltipMessage = __name(({ title, desc, links }) => react_default.createElement(MessageWrapper, null, react_default.createElement(Message2, null, title && react_default.createElement(Title4, null, title), desc && react_default.createElement(Desc2, null, desc)), links && react_default.createElement(Links, null, links.map(({ title: linkTitle, ...other }) => react_default.createElement(Link2, { ...other, key: linkTitle }, linkTitle)))), "TooltipMessage"), Note = styled.div(({ theme: theme3 }) => ({
    padding: "2px 6px",
    lineHeight: "16px",
    fontSize: 10,
    fontWeight: theme3.typography.weight.bold,
    color: theme3.color.lightest,
    boxShadow: "0 0 5px 0 rgba(0, 0, 0, 0.3)",
    borderRadius: 4,
    whiteSpace: "nowrap",
    pointerEvents: "none",
    zIndex: -1,
    background: theme3.base === "light" ? "rgba(60, 60, 60, 0.9)" : "rgba(0, 0, 0, 0.95)",
    margin: 6
  })), TooltipNote = __name(({ note, ...props }) => react_default.createElement(Note, { ...props }, note), "TooltipNote"), import_memoizerific6 = __toESM2(require_memoizerific(), 1), Title5 = styled(({ active, loading, disabled, ...rest }) => react_default.createElement("span", { ...rest }))(
    ({ theme: theme3 }) => ({
      color: theme3.color.defaultText,
      // Previously was theme.typography.weight.normal but this weight does not exists in Theme
      fontWeight: theme3.typography.weight.regular
    }),
    ({ active, theme: theme3 }) => active ? {
      color: theme3.color.secondary,
      fontWeight: theme3.typography.weight.bold
    } : {},
    ({ loading, theme: theme3 }) => loading ? {
      display: "inline-block",
      flex: "none",
      ...theme3.animation.inlineGlow
    } : {},
    ({ disabled, theme: theme3 }) => disabled ? {
      color: theme3.textMutedColor
    } : {}
  ), Right = styled.span({
    display: "flex",
    "& svg": {
      height: 12,
      width: 12,
      margin: "3px 0",
      verticalAlign: "top"
    }
  }), Center = styled.span(
    {
      flex: 1,
      textAlign: "left",
      display: "flex",
      flexDirection: "column",
      minWidth: 0
      // required for overflow
    },
    ({ isIndented }) => isIndented ? { marginLeft: 24 } : {}
  ), CenterText = styled.span(
    ({ theme: theme3 }) => ({
      fontSize: "11px",
      lineHeight: "14px"
    }),
    ({ active, theme: theme3 }) => active ? {
      color: theme3.color.secondary
    } : {},
    ({ theme: theme3, disabled }) => disabled ? {
      color: theme3.textMutedColor
    } : {}
  ), Left = styled.span(
    ({ active, theme: theme3 }) => active ? {
      color: theme3.color.secondary
    } : {},
    () => ({
      display: "flex",
      maxWidth: 14
    })
  ), Item = styled.div(
    ({ theme: theme3 }) => ({
      width: "100%",
      minWidth: 0,
      // required for overflow
      border: "none",
      borderRadius: theme3.appBorderRadius,
      background: "none",
      fontSize: theme3.typography.size.s1,
      transition: "all 150ms ease-out",
      color: theme3.color.dark,
      textDecoration: "none",
      justifyContent: "space-between",
      lineHeight: "18px",
      padding: "7px 10px",
      display: "flex",
      alignItems: "center",
      "& > * + *": {
        paddingLeft: 10
      }
    }),
    ({ theme: theme3, href, onClick }) => (href || onClick) && {
      cursor: "pointer",
      "&:hover": {
        background: theme3.background.hoverable
      },
      "&:hover svg": {
        opacity: 1
      }
    },
    ({ theme: theme3, as }) => as === "label" && {
      "&:has(input:not(:disabled))": {
        cursor: "pointer",
        "&:hover": {
          background: theme3.background.hoverable
        }
      }
    },
    ({ disabled }) => disabled && { cursor: "not-allowed" }
  ), getItemProps = (0, import_memoizerific6.default)(100)(({ onClick, input, href, LinkWrapper }) => ({
    ...onClick && {
      as: "button",
      onClick
    },
    ...input && {
      as: "label"
    },
    ...href && {
      as: "a",
      href,
      ...LinkWrapper && {
        as: LinkWrapper,
        to: href
      }
    }
  })), ListItem = __name((props) => {
    let {
      loading = !1,
      title = react_default.createElement("span", null, "Loading state"),
      center = null,
      right: right2 = null,
      active = !1,
      disabled = !1,
      isIndented = !1,
      href = void 0,
      onClick = void 0,
      icon,
      input,
      LinkWrapper = void 0,
      ...rest
    } = props, commonProps = { active, disabled }, itemProps = getItemProps(props), left2 = icon || input;
    return react_default.createElement(Item, { ...rest, ...commonProps, ...itemProps }, react_default.createElement(react_default.Fragment, null, left2 && react_default.createElement(Left, { ...commonProps }, left2), title || center ? react_default.createElement(Center, { isIndented: isIndented && !left2 }, title && react_default.createElement(Title5, { ...commonProps, loading }, title), center && react_default.createElement(CenterText, { ...commonProps }, center)) : null, right2 && react_default.createElement(Right, { ...commonProps }, right2)));
  }, "ListItem"), ListItem_default = ListItem, List = styled.div(
    {
      minWidth: 180,
      overflow: "hidden",
      overflowY: "auto",
      maxHeight: 15.5 * 32 + 8
      // 15.5 items at 32px each + 8px padding
    },
    ({ theme: theme3 }) => ({
      borderRadius: theme3.appBorderRadius + 2
    }),
    ({ theme: theme3 }) => theme3.base === "dark" ? { background: theme3.background.content } : {}
  ), Group = styled.div(({ theme: theme3 }) => ({
    padding: 4,
    "& + &": {
      borderTop: `1px solid ${theme3.appBorderColor}`
    }
  })), Item2 = __name(({ id: id2, onClick, ...rest }) => {
    let { active, disabled, title, href } = rest, handleClick = useCallback(
      (event) => onClick?.(event, { id: id2, active, disabled, title, href }),
      [onClick, id2, active, disabled, title, href]
    );
    return react_default.createElement(ListItem_default, { id: `list-item-${id2}`, ...rest, ...onClick && { onClick: handleClick } });
  }, "Item"), TooltipLinkList = __name(({ links, LinkWrapper, ...props }) => {
    let groups = Array.isArray(links[0]) ? links : [links], isIndented = groups.some(
      (group) => group.some((link) => "icon" in link && link.icon || "input" in link && link.input)
    );
    return react_default.createElement(List, { ...props }, groups.filter((group) => group.length).map((group, index3) => react_default.createElement(Group, { key: group.map((link) => link.id).join(`~${index3}~`) }, group.map((link) => "content" in link ? react_default.createElement(Fragment, { key: link.id }, link.content) : react_default.createElement(Item2, { key: link.id, isIndented, LinkWrapper, ...link })))));
  }, "TooltipLinkList"), Side = styled.div(
    {
      display: "flex",
      whiteSpace: "nowrap",
      flexBasis: "auto",
      marginLeft: 3,
      marginRight: 10
    },
    ({ scrollable }) => scrollable ? { flexShrink: 0 } : {},
    ({ left: left2 }) => left2 ? {
      "& > *": {
        marginLeft: 4
      }
    } : {},
    ({ right: right2 }) => right2 ? {
      gap: 6
    } : {}
  );
  Side.displayName = "Side";
  var UnstyledBar = __name(({ children, className, scrollable }) => scrollable ? react_default.createElement(ScrollArea2, { vertical: !1, className }, children) : react_default.createElement("div", { className }, children), "UnstyledBar"), Bar = styled(UnstyledBar)(
    ({ backgroundColor, theme: theme3, scrollable = !0 }) => ({
      color: theme3.barTextColor,
      width: "100%",
      minHeight: 40,
      flexShrink: 0,
      scrollbarColor: `${theme3.barTextColor} ${backgroundColor || theme3.barBg}`,
      scrollbarWidth: "thin",
      overflow: scrollable ? "auto" : "hidden",
      overflowY: "hidden"
    }),
    ({ theme: theme3, border = !1 }) => border ? {
      boxShadow: `${theme3.appBorderColor}  0 -1px 0 0 inset`,
      background: theme3.barBg
    } : {}
  );
  Bar.displayName = "Bar";
  var BarInner = styled.div(({ bgColor }) => ({
    display: "flex",
    justifyContent: "space-between",
    position: "relative",
    flexWrap: "nowrap",
    flexShrink: 0,
    height: 40,
    backgroundColor: bgColor || ""
  })), FlexBar = __name(({ children, backgroundColor, className, ...rest }) => {
    let [left2, right2] = Children.toArray(children);
    return react_default.createElement(Bar, { backgroundColor, className: `sb-bar ${className}`, ...rest }, react_default.createElement(BarInner, { bgColor: backgroundColor }, react_default.createElement(Side, { scrollable: rest.scrollable, left: !0 }, left2), right2 ? react_default.createElement(Side, { right: !0 }, right2) : null));
  }, "FlexBar");
  FlexBar.displayName = "FlexBar";
  var isLink = __name((obj) => typeof obj.props.href == "string", "isLink"), isButton = __name((obj) => typeof obj.props.href != "string", "isButton");
  function ForwardRefFunction({ children, ...rest }, ref) {
    let o2 = { props: rest, ref };
    if (isLink(o2))
      return react_default.createElement("a", { ref: o2.ref, ...o2.props }, children);
    if (isButton(o2))
      return react_default.createElement("button", { ref: o2.ref, type: "button", ...o2.props }, children);
    throw new Error("invalid props");
  }
  __name(ForwardRefFunction, "ForwardRefFunction");
  var ButtonOrLink = forwardRef(ForwardRefFunction);
  ButtonOrLink.displayName = "ButtonOrLink";
  var TabButton = styled(ButtonOrLink, { shouldForwardProp: isPropValid })(
    {
      whiteSpace: "normal",
      display: "inline-flex",
      overflow: "hidden",
      verticalAlign: "top",
      justifyContent: "center",
      alignItems: "center",
      textAlign: "center",
      textDecoration: "none",
      "&:empty": {
        display: "none"
      },
      "&[hidden]": {
        display: "none"
      }
    },
    ({ theme: theme3 }) => ({
      padding: "0 15px",
      transition: "color 0.2s linear, border-bottom-color 0.2s linear",
      height: 40,
      lineHeight: "12px",
      cursor: "pointer",
      background: "transparent",
      border: "0 solid transparent",
      borderTop: "3px solid transparent",
      borderBottom: "3px solid transparent",
      fontWeight: "bold",
      fontSize: 13,
      "&:focus": {
        outline: "0 none",
        borderBottomColor: theme3.barSelectedColor
      }
    }),
    ({ active, textColor, theme: theme3 }) => active ? {
      color: textColor || theme3.barSelectedColor,
      borderBottomColor: theme3.barSelectedColor
    } : {
      color: textColor || theme3.barTextColor,
      borderBottomColor: "transparent",
      "&:hover": {
        color: theme3.barHoverColor
      }
    }
  );
  TabButton.displayName = "TabButton";
  var Wrapper22 = styled.div(({ theme: theme3 }) => ({
    height: "100%",
    display: "flex",
    padding: 30,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    gap: 15,
    background: theme3.background.content
  })), Content3 = styled.div({
    display: "flex",
    flexDirection: "column",
    gap: 4,
    maxWidth: 415
  }), Title6 = styled.div(({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s2 - 1,
    textAlign: "center",
    color: theme3.textColor
  })), Description3 = styled.div(({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.regular,
    fontSize: theme3.typography.size.s2 - 1,
    textAlign: "center",
    color: theme3.textMutedColor
  })), EmptyTabContent = __name(({ title, description, footer }) => react_default.createElement(Wrapper22, null, react_default.createElement(Content3, null, react_default.createElement(Title6, null, title), description && react_default.createElement(Description3, null, description)), footer), "EmptyTabContent"), VisuallyHidden = styled.div(
    ({ active }) => active ? { display: "block" } : { display: "none" }
  ), childrenToList = __name((children) => Children.toArray(children).map(
    // @ts-expect-error (non strict)
    ({
      props: { title, id: id2, color: color4, children: childrenOfChild }
    }) => {
      let content = Array.isArray(
        childrenOfChild
      ) ? childrenOfChild[0] : childrenOfChild;
      return {
        title,
        id: id2,
        ...color4 ? { color: color4 } : {},
        render: typeof content == "function" ? content : ({ active }) => react_default.createElement(VisuallyHidden, { active, role: "tabpanel" }, content)
      };
    }
  ), "childrenToList"), CollapseIcon2 = styled.span(({ theme: theme3, isActive }) => ({
    display: "inline-block",
    width: 0,
    height: 0,
    marginLeft: 8,
    color: isActive ? theme3.color.secondary : theme3.color.mediumdark,
    borderRight: "3px solid transparent",
    borderLeft: "3px solid transparent",
    borderTop: "3px solid",
    transition: "transform .1s ease-out"
  })), AddonButton = styled(TabButton)(({ active, theme: theme3, preActive }) => `
    color: ${preActive || active ? theme3.barSelectedColor : theme3.barTextColor};
    .addon-collapsible-icon {
      color: ${preActive || active ? theme3.barSelectedColor : theme3.barTextColor};
    }
    &:hover {
      color: ${theme3.barHoverColor};
      .addon-collapsible-icon {
        color: ${theme3.barHoverColor};
      }
    }
  `);
  function useList(list) {
    let tabBarRef = useRef(), addonsRef = useRef(), tabRefs = useRef(/* @__PURE__ */ new Map()), { width: tabBarWidth = 1 } = useResizeObserver2({
      // @ts-expect-error (non strict)
      ref: tabBarRef
    }), [visibleList, setVisibleList] = useState(list), [invisibleList, setInvisibleList] = useState([]), previousList = useRef(list), AddonTab = useCallback(
      ({
        menuName,
        actions: actions2
      }) => {
        let isAddonsActive = invisibleList.some(({ active }) => active), [isTooltipVisible, setTooltipVisible] = useState(!1);
        return react_default.createElement(react_default.Fragment, null, react_default.createElement(
          WithToolTipState,
          {
            interactive: !0,
            visible: isTooltipVisible,
            onVisibleChange: setTooltipVisible,
            placement: "bottom",
            delayHide: 100,
            tooltip: react_default.createElement(
              TooltipLinkList,
              {
                links: invisibleList.map(({ title, id: id2, color: color4, active }) => ({
                  id: id2,
                  title,
                  color: color4,
                  active,
                  onClick: __name((e) => {
                    e.preventDefault(), actions2.onSelect(id2);
                  }, "onClick")
                }))
              }
            )
          },
          react_default.createElement(
            AddonButton,
            {
              id: "addons-menu-button",
              ref: addonsRef,
              active: isAddonsActive,
              preActive: isTooltipVisible,
              style: { visibility: invisibleList.length ? "visible" : "hidden" },
              "aria-hidden": !invisibleList.length,
              className: "tabbutton",
              type: "button",
              role: "tab"
            },
            menuName,
            react_default.createElement(
              CollapseIcon2,
              {
                className: "addon-collapsible-icon",
                isActive: isAddonsActive || isTooltipVisible
              }
            )
          )
        ), invisibleList.map(({ title, id: id2, color: color4 }, index3) => {
          let indexId = `index-${index3}`;
          return react_default.createElement(
            TabButton,
            {
              id: `tabbutton-${sanitize(id2) ?? indexId}`,
              style: { visibility: "hidden" },
              "aria-hidden": !0,
              tabIndex: -1,
              ref: (ref) => {
                tabRefs.current.set(id2, ref);
              },
              className: "tabbutton",
              type: "button",
              key: id2,
              textColor: color4,
              role: "tab"
            },
            title
          );
        }));
      },
      [invisibleList]
    ), setTabLists = useCallback(() => {
      if (!tabBarRef.current || !addonsRef.current)
        return;
      let { x: x3, width } = tabBarRef.current.getBoundingClientRect(), { width: widthAddonsTab } = addonsRef.current.getBoundingClientRect(), rightBorder = invisibleList.length ? x3 + width - widthAddonsTab : x3 + width, newVisibleList = [], widthSum = 0, newInvisibleList = list.filter((item) => {
        let { id: id2 } = item, tabButton = tabRefs.current.get(id2), { width: tabWidth = 0 } = tabButton?.getBoundingClientRect() || {}, crossBorder = x3 + widthSum + tabWidth > rightBorder;
        return (!crossBorder || !tabButton) && newVisibleList.push(item), widthSum += tabWidth, crossBorder;
      });
      (newVisibleList.length !== visibleList.length || previousList.current !== list) && (setVisibleList(newVisibleList), setInvisibleList(newInvisibleList), previousList.current = list);
    }, [invisibleList.length, list, visibleList]);
    return useLayoutEffect(setTabLists, [setTabLists, tabBarWidth]), {
      tabRefs,
      addonsRef,
      tabBarRef,
      visibleList,
      invisibleList,
      AddonTab
    };
  }
  __name(useList, "useList");
  var ignoreSsrWarning2 = "/* emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason */", Wrapper32 = styled.div(
    ({ theme: theme3, bordered }) => bordered ? {
      backgroundClip: "padding-box",
      border: `1px solid ${theme3.appBorderColor}`,
      borderRadius: theme3.appBorderRadius,
      overflow: "hidden",
      boxSizing: "border-box"
    } : {},
    ({ absolute }) => absolute ? {
      width: "100%",
      height: "100%",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column"
    } : {
      display: "block"
    }
  ), TabBar = styled.div({
    overflow: "hidden",
    "&:first-of-type": {
      marginLeft: -3
    },
    whiteSpace: "nowrap",
    flexGrow: 1
  });
  TabBar.displayName = "TabBar";
  var Content4 = styled.div(
    {
      display: "block",
      position: "relative",
      container: "tab-content / inline-size"
    },
    ({ theme: theme3 }) => ({
      fontSize: theme3.typography.size.s2 - 1,
      background: theme3.background.content
    }),
    ({ bordered, theme: theme3 }) => bordered ? {
      borderRadius: `0 0 ${theme3.appBorderRadius - 1}px ${theme3.appBorderRadius - 1}px`
    } : {},
    ({ absolute, bordered }) => absolute ? {
      height: `calc(100% - ${bordered ? 42 : 40}px)`,
      position: "absolute",
      left: 0 + (bordered ? 1 : 0),
      right: 0 + (bordered ? 1 : 0),
      bottom: 0 + (bordered ? 1 : 0),
      top: 40 + (bordered ? 1 : 0),
      overflow: "auto",
      [`& > *:first-child${ignoreSsrWarning2}`]: {
        position: "absolute",
        left: 0 + (bordered ? 1 : 0),
        right: 0 + (bordered ? 1 : 0),
        bottom: 0 + (bordered ? 1 : 0),
        top: 0 + (bordered ? 1 : 0),
        height: `calc(100% - ${bordered ? 2 : 0}px)`,
        overflow: "auto"
      }
    } : {}
  ), TabWrapper = __name(({ active, render: render2, children }) => react_default.createElement(VisuallyHidden, { active }, render2 ? render2() : children), "TabWrapper"), _TabErrorBoundary = class extends Component {
    constructor(props) {
      super(props), this.state = { hasError: !1 };
    }
    static getDerivedStateFromError() {
      return { hasError: !0 };
    }
    componentDidCatch(error, info) {
      console.error("Error rendering addon panel"), console.error(error), console.error(info.componentStack);
    }
    render() {
      return this.state.hasError && this.props.active ? react_default.createElement(
        EmptyTabContent,
        {
          title: "This addon has errors",
          description: "Check your browser logs and addon code to pinpoint what went wrong. This issue was not caused by Storybook."
        }
      ) : this.props.children;
    }
  };
  __name(_TabErrorBoundary, "TabErrorBoundary");
  var TabErrorBoundary = _TabErrorBoundary, Tabs = memo(
    ({
      children,
      selected = null,
      actions: actions2,
      absolute = !1,
      bordered = !1,
      tools = null,
      backgroundColor,
      id: htmlId = null,
      menuName = "Tabs",
      emptyState,
      showToolsWhenEmpty
    }) => {
      let list = useMemo(
        () => childrenToList(children).map((i3, index3) => ({
          ...i3,
          active: selected ? i3.id === selected : index3 === 0
        })),
        [children, selected]
      ), { visibleList, tabBarRef, tabRefs, AddonTab } = useList(list), EmptyContent = emptyState ?? react_default.createElement(EmptyTabContent, { title: "Nothing found" });
      return !showToolsWhenEmpty && list.length === 0 ? EmptyContent : (
        // @ts-expect-error (non strict)
        react_default.createElement(Wrapper32, { absolute, bordered, id: htmlId }, react_default.createElement(FlexBar, { scrollable: !1, border: !0, backgroundColor }, react_default.createElement(TabBar, { style: { whiteSpace: "normal" }, ref: tabBarRef, role: "tablist" }, visibleList.map(({ title, id: id2, active, color: color4 }, index3) => {
          let indexId = `index-${index3}`;
          return react_default.createElement(
            TabButton,
            {
              id: `tabbutton-${sanitize(id2) ?? indexId}`,
              ref: (ref) => {
                tabRefs.current.set(id2, ref);
              },
              className: `tabbutton ${active ? "tabbutton-active" : ""}`,
              type: "button",
              key: id2,
              active,
              textColor: color4,
              onClick: (e) => {
                e.preventDefault(), actions2.onSelect(id2);
              },
              role: "tab"
            },
            typeof title == "function" ? react_default.createElement("title", null) : title
          );
        }), react_default.createElement(AddonTab, { menuName, actions: actions2 })), tools), react_default.createElement(Content4, { id: "panel-tab-content", bordered, absolute }, list.length ? list.map(({ id: id2, active, render: render2 }) => react_default.createElement(TabErrorBoundary, { key: id2, active }, react_default.createElement(render2, { active }, null))) : EmptyContent))
      );
    }
  );
  Tabs.displayName = "Tabs";
  var _TabsState = class extends Component {
    constructor(props) {
      super(props), this.handlers = {
        onSelect: __name((id2) => this.setState({ selected: id2 }), "onSelect")
      }, this.state = {
        selected: props.initial
      };
    }
    render() {
      let { bordered = !1, absolute = !1, children, backgroundColor, menuName } = this.props, { selected } = this.state;
      return react_default.createElement(
        Tabs,
        {
          bordered,
          absolute,
          selected,
          backgroundColor,
          menuName,
          actions: this.handlers
        },
        children
      );
    }
  };
  __name(_TabsState, "TabsState");
  _TabsState.defaultProps = {
    children: [],
    // @ts-expect-error (non strict)
    initial: null,
    absolute: !1,
    bordered: !1,
    backgroundColor: "",
    // @ts-expect-error (non strict)
    menuName: void 0
  };
  var Separator = styled.span(
    ({ theme: theme3 }) => ({
      width: 1,
      height: 20,
      background: theme3.appBorderColor,
      marginLeft: 2,
      marginRight: 2
    }),
    ({ force }) => force ? {} : {
      "& + &": {
        display: "none"
      }
    }
  );
  Separator.displayName = "Separator";
  var interleaveSeparators = __name((list) => list.reduce(
    (acc, item, index3) => item ? react_default.createElement(Fragment, { key: item.id || item.key || `f-${index3}` }, acc, index3 > 0 ? react_default.createElement(Separator, { key: `s-${index3}` }) : null, item.render() || item) : acc,
    null
  ), "interleaveSeparators"), usePrevious = __name((value2) => {
    let ref = useRef();
    return useEffect(() => {
      ref.current = value2;
    }, [value2]), ref.current;
  }, "usePrevious"), useUpdate = __name((update, value2) => {
    let previousValue = usePrevious(value2);
    return update ? value2 : previousValue;
  }, "useUpdate"), AddonPanel = __name(({ active, children }) => (
    // the hidden attribute is an valid html element that's both accessible and works to visually hide content
    react_default.createElement("div", { hidden: !active }, useUpdate(active, children))
  ), "AddonPanel"), StorybookLogo = __name(({ alt, ...props }) => react_default.createElement("svg", { width: "200px", height: "40px", viewBox: "0 0 200 40", ...props, role: "img" }, alt ? react_default.createElement("title", null, alt) : null, react_default.createElement("defs", null, react_default.createElement(
    "path",
    {
      d: "M1.2 36.9L0 3.9c0-1.1.8-2 1.9-2.1l28-1.8a2 2 0 0 1 2.2 1.9 2 2 0 0 1 0 .1v36a2 2 0 0 1-2 2 2 2 0 0 1-.1 0L3.2 38.8a2 2 0 0 1-2-2z",
      id: "a"
    }
  )), react_default.createElement("g", { fill: "none", fillRule: "evenodd" }, react_default.createElement(
    "path",
    {
      d: "M53.3 31.7c-1.7 0-3.4-.3-5-.7-1.5-.5-2.8-1.1-3.9-2l1.6-3.5c2.2 1.5 4.6 2.3 7.3 2.3 1.5 0 2.5-.2 3.3-.7.7-.5 1.1-1 1.1-1.9 0-.7-.3-1.3-1-1.7s-2-.8-3.7-1.2c-2-.4-3.6-.9-4.8-1.5-1.1-.5-2-1.2-2.6-2-.5-1-.8-2-.8-3.2 0-1.4.4-2.6 1.2-3.6.7-1.1 1.8-2 3.2-2.6 1.3-.6 2.9-.9 4.7-.9 1.6 0 3.1.3 4.6.7 1.5.5 2.7 1.1 3.5 2l-1.6 3.5c-2-1.5-4.2-2.3-6.5-2.3-1.3 0-2.3.2-3 .8-.8.5-1.2 1.1-1.2 2 0 .5.2 1 .5 1.3.2.3.7.6 1.4.9l2.9.8c2.9.6 5 1.4 6.2 2.4a5 5 0 0 1 2 4.2 6 6 0 0 1-2.5 5c-1.7 1.2-4 1.9-7 1.9zm21-3.6l1.4-.1-.2 3.5-1.9.1c-2.4 0-4.1-.5-5.2-1.5-1.1-1-1.6-2.7-1.6-4.8v-6h-3v-3.6h3V11h4.8v4.6h4v3.6h-4v6c0 1.8.9 2.8 2.6 2.8zm11.1 3.5c-1.6 0-3-.3-4.3-1a7 7 0 0 1-3-2.8c-.6-1.3-1-2.7-1-4.4 0-1.6.4-3 1-4.3a7 7 0 0 1 3-2.8c1.2-.7 2.7-1 4.3-1 1.7 0 3.2.3 4.4 1a7 7 0 0 1 3 2.8c.6 1.2 1 2.7 1 4.3 0 1.7-.4 3.1-1 4.4a7 7 0 0 1-3 2.8c-1.2.7-2.7 1-4.4 1zm0-3.6c2.4 0 3.6-1.6 3.6-4.6 0-1.5-.3-2.6-1-3.4a3.2 3.2 0 0 0-2.6-1c-2.3 0-3.5 1.4-3.5 4.4 0 3 1.2 4.6 3.5 4.6zm21.7-8.8l-2.7.3c-1.3.2-2.3.5-2.8 1.2-.6.6-.9 1.4-.9 2.5v8.2H96V15.7h4.6v2.6c.8-1.8 2.5-2.8 5-3h1.3l.3 4zm14-3.5h4.8L116.4 37h-4.9l3-6.6-6.4-14.8h5l4 10 4-10zm16-.4c1.4 0 2.6.3 3.6 1 1 .6 1.9 1.6 2.5 2.8.6 1.2.9 2.7.9 4.3 0 1.6-.3 3-1 4.3a6.9 6.9 0 0 1-2.4 2.9c-1 .7-2.2 1-3.6 1-1 0-2-.2-3-.7-.8-.4-1.5-1-2-1.9v2.4h-4.7V8.8h4.8v9c.5-.8 1.2-1.4 2-1.9.9-.4 1.8-.6 3-.6zM135.7 28c1.1 0 2-.4 2.6-1.2.6-.8 1-2 1-3.4 0-1.5-.4-2.5-1-3.3s-1.5-1.1-2.6-1.1-2 .3-2.6 1.1c-.6.8-1 2-1 3.3 0 1.5.4 2.6 1 3.4.6.8 1.5 1.2 2.6 1.2zm18.9 3.6c-1.7 0-3.2-.3-4.4-1a7 7 0 0 1-3-2.8c-.6-1.3-1-2.7-1-4.4 0-1.6.4-3 1-4.3a7 7 0 0 1 3-2.8c1.2-.7 2.7-1 4.4-1 1.6 0 3 .3 4.3 1a7 7 0 0 1 3 2.8c.6 1.2 1 2.7 1 4.3 0 1.7-.4 3.1-1 4.4a7 7 0 0 1-3 2.8c-1.2.7-2.7 1-4.3 1zm0-3.6c2.3 0 3.5-1.6 3.5-4.6 0-1.5-.3-2.6-1-3.4a3.2 3.2 0 0 0-2.5-1c-2.4 0-3.6 1.4-3.6 4.4 0 3 1.2 4.6 3.6 4.6zm18 3.6c-1.7 0-3.2-.3-4.4-1a7 7 0 0 1-3-2.8c-.6-1.3-1-2.7-1-4.4 0-1.6.4-3 1-4.3a7 7 0 0 1 3-2.8c1.2-.7 2.7-1 4.4-1 1.6 0 3 .3 4.4 1a7 7 0 0 1 2.9 2.8c.6 1.2 1 2.7 1 4.3 0 1.7-.4 3.1-1 4.4a7 7 0 0 1-3 2.8c-1.2.7-2.7 1-4.3 1zm0-3.6c2.3 0 3.5-1.6 3.5-4.6 0-1.5-.3-2.6-1-3.4a3.2 3.2 0 0 0-2.5-1c-2.4 0-3.6 1.4-3.6 4.4 0 3 1.2 4.6 3.6 4.6zm27.4 3.4h-6l-6-7v7h-4.8V8.8h4.9v13.6l5.8-6.7h5.7l-6.6 7.5 7 8.2z",
      fill: "currentColor"
    }
  ), react_default.createElement("mask", { id: "b", fill: "#fff" }, react_default.createElement("use", { xlinkHref: "#a" })), react_default.createElement("use", { fill: "#FF4785", fillRule: "nonzero", xlinkHref: "#a" }), react_default.createElement(
    "path",
    {
      d: "M23.7 5L24 .2l3.9-.3.1 4.8a.3.3 0 0 1-.5.2L26 3.8l-1.7 1.4a.3.3 0 0 1-.5-.3zm-5 10c0 .9 5.3.5 6 0 0-5.4-2.8-8.2-8-8.2-5.3 0-8.2 2.8-8.2 7.1 0 7.4 10 7.6 10 11.6 0 1.2-.5 1.9-1.8 1.9-1.6 0-2.2-.9-2.1-3.6 0-.6-6.1-.8-6.3 0-.5 6.7 3.7 8.6 8.5 8.6 4.6 0 8.3-2.5 8.3-7 0-7.9-10.2-7.7-10.2-11.6 0-1.6 1.2-1.8 2-1.8.6 0 2 0 1.9 3z",
      fill: "#FFF",
      fillRule: "nonzero",
      mask: "url(#b)"
    }
  ))), "StorybookLogo"), StorybookIcon2 = __name((props) => react_default.createElement("svg", { viewBox: "0 0 64 64", ...props }, react_default.createElement("title", null, "Storybook icon"), react_default.createElement("g", { id: "Artboard", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" }, react_default.createElement(
    "path",
    {
      d: "M8.04798541,58.7875918 L6.07908839,6.32540407 C6.01406344,4.5927838 7.34257463,3.12440831 9.07303814,3.01625434 L53.6958037,0.227331489 C55.457209,0.117243658 56.974354,1.45590096 57.0844418,3.21730626 C57.0885895,3.28366922 57.0906648,3.35014546 57.0906648,3.41663791 L57.0906648,60.5834697 C57.0906648,62.3483119 55.6599776,63.7789992 53.8951354,63.7789992 C53.847325,63.7789992 53.7995207,63.7779262 53.7517585,63.775781 L11.0978899,61.8600599 C9.43669044,61.7854501 8.11034889,60.4492961 8.04798541,58.7875918 Z",
      id: "path-1",
      fill: "#FF4785",
      fillRule: "nonzero"
    }
  ), react_default.createElement(
    "path",
    {
      d: "M35.9095005,24.1768792 C35.9095005,25.420127 44.2838488,24.8242707 45.4080313,23.9509748 C45.4080313,15.4847538 40.8652557,11.0358878 32.5466666,11.0358878 C24.2280775,11.0358878 19.5673077,15.553972 19.5673077,22.3311017 C19.5673077,34.1346028 35.4965208,34.3605071 35.4965208,40.7987804 C35.4965208,42.606015 34.6115646,43.6790606 32.6646607,43.6790606 C30.127786,43.6790606 29.1248356,42.3834613 29.2428298,37.9783269 C29.2428298,37.0226907 19.5673077,36.7247626 19.2723223,37.9783269 C18.5211693,48.6535354 25.1720308,51.7326752 32.7826549,51.7326752 C40.1572906,51.7326752 45.939005,47.8018145 45.939005,40.6858282 C45.939005,28.035186 29.7738035,28.3740425 29.7738035,22.1051974 C29.7738035,19.5637737 31.6617103,19.2249173 32.7826549,19.2249173 C33.9625966,19.2249173 36.0864917,19.4328883 35.9095005,24.1768792 Z",
      id: "path9_fill-path",
      fill: "#FFFFFF",
      fillRule: "nonzero"
    }
  ), react_default.createElement(
    "path",
    {
      d: "M44.0461638,0.830433986 L50.1874092,0.446606143 L50.443532,7.7810017 C50.4527198,8.04410717 50.2468789,8.26484453 49.9837734,8.27403237 C49.871115,8.27796649 49.7607078,8.24184808 49.6721567,8.17209069 L47.3089847,6.3104681 L44.5110468,8.43287463 C44.3012992,8.591981 44.0022839,8.55092814 43.8431776,8.34118051 C43.7762017,8.25288717 43.742082,8.14401677 43.7466857,8.03329059 L44.0461638,0.830433986 Z",
      id: "Path",
      fill: "#FFFFFF"
    }
  ))), "StorybookIcon"), rotate360 = keyframes`
	from {
		transform: rotate(0deg);
	}
	to {
		transform: rotate(360deg);
	}
`, LoaderWrapper = styled.div(({ size = 32 }) => ({
    borderRadius: "50%",
    cursor: "progress",
    display: "inline-block",
    overflow: "hidden",
    position: "absolute",
    transition: "all 200ms ease-out",
    verticalAlign: "top",
    top: "50%",
    left: "50%",
    marginTop: -(size / 2),
    marginLeft: -(size / 2),
    height: size,
    width: size,
    zIndex: 4,
    borderWidth: 2,
    borderStyle: "solid",
    borderColor: "rgba(97, 97, 97, 0.29)",
    borderTopColor: "rgb(100,100,100)",
    animation: `${rotate360} 0.7s linear infinite`,
    mixBlendMode: "difference"
  })), ProgressWrapper = styled.div({
    position: "absolute",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    width: "100%",
    height: "100%"
  }), ProgressTrack = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    width: "80%",
    marginBottom: "0.75rem",
    maxWidth: 300,
    height: 5,
    borderRadius: 5,
    background: curriedTransparentize$1(0.8, theme3.color.secondary),
    overflow: "hidden",
    cursor: "progress"
  })), ProgressBar = styled.div(({ theme: theme3 }) => ({
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    background: theme3.color.secondary
  })), ProgressMessage = styled.div(({ theme: theme3 }) => ({
    minHeight: "2em",
    fontSize: `${theme3.typography.size.s1}px`,
    color: theme3.textMutedColor
  })), ErrorIcon = styled(LightningOffIcon)(({ theme: theme3 }) => ({
    width: 20,
    height: 20,
    marginBottom: "0.5rem",
    color: theme3.textMutedColor
  })), ellipsis = keyframes`
  from { content: "..." }
  33% { content: "." }
  66% { content: ".." }
  to { content: "..." }
`, Ellipsis = styled.span({
    "&::after": {
      content: "'...'",
      animation: `${ellipsis} 1s linear infinite`,
      animationDelay: "1s",
      display: "inline-block",
      width: "1em",
      height: "auto"
    }
  }), Loader = __name(({ progress, error, size, ...props }) => {
    if (error)
      return react_default.createElement(ProgressWrapper, { "aria-label": error.toString(), "aria-live": "polite", role: "status", ...props }, react_default.createElement(ErrorIcon, null), react_default.createElement(ProgressMessage, null, error.message));
    if (progress) {
      let { value: value2, modules } = progress, { message } = progress;
      return modules && (message += ` ${modules.complete} / ${modules.total} modules`), react_default.createElement(
        ProgressWrapper,
        {
          "aria-label": "Content is loading...",
          "aria-live": "polite",
          "aria-valuemin": 0,
          "aria-valuemax": 100,
          "aria-valuenow": value2 * 100,
          "aria-valuetext": message,
          role: "progressbar",
          ...props
        },
        react_default.createElement(ProgressTrack, null, react_default.createElement(ProgressBar, { style: { width: `${value2 * 100}%` } })),
        react_default.createElement(ProgressMessage, null, message, value2 < 1 && react_default.createElement(Ellipsis, { key: message }))
      );
    }
    return react_default.createElement(
      LoaderWrapper,
      {
        "aria-label": "Content is loading...",
        "aria-live": "polite",
        role: "status",
        size,
        ...props
      }
    );
  }, "Loader"), XMLNS = "http://www.w3.org/2000/svg", rotate = keyframes({
    "0%": {
      transform: "rotate(0deg)"
    },
    "100%": {
      transform: "rotate(360deg)"
    }
  }), Wrapper4 = styled.div(({ size }) => ({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    minWidth: size,
    minHeight: size
  })), Circle = styled.svg(
    ({ size, width }) => ({
      position: "absolute",
      width: `${size}px!important`,
      height: `${size}px!important`,
      transform: "rotate(-90deg)",
      circle: {
        r: (size - Math.ceil(width)) / 2,
        cx: size / 2,
        cy: size / 2,
        opacity: 0.15,
        fill: "transparent",
        stroke: "currentColor",
        strokeWidth: width,
        strokeLinecap: "round",
        strokeDasharray: Math.PI * (size - Math.ceil(width))
      }
    }),
    ({ progress }) => progress && {
      circle: {
        opacity: 0.75
      }
    },
    ({ spinner }) => spinner && {
      animation: `${rotate} 1s linear infinite`,
      circle: {
        opacity: 0.25
      }
    }
  ), ProgressSpinner = __name(({
    percentage = void 0,
    running = !0,
    size = 24,
    width = 1.5,
    children = null,
    ...props
  }) => typeof percentage == "number" ? react_default.createElement(Wrapper4, { size, ...props }, children, react_default.createElement(Circle, { size, width, xmlns: XMLNS }, react_default.createElement("circle", null)), running && react_default.createElement(Circle, { size, width, xmlns: XMLNS, spinner: !0 }, react_default.createElement("circle", { strokeDashoffset: Math.PI * (size - Math.ceil(width)) * (1 - percentage / 100) })), react_default.createElement(Circle, { size, width, xmlns: XMLNS, progress: !0 }, react_default.createElement("circle", { strokeDashoffset: Math.PI * (size - Math.ceil(width)) * (1 - percentage / 100) }))) : react_default.createElement(Wrapper4, { size, ...props }, children), "ProgressSpinner");
  function parseQuery(queryString) {
    let query = {}, pairs = queryString.split("&");
    for (let i3 = 0; i3 < pairs.length; i3++) {
      let pair = pairs[i3].split("=");
      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || "");
    }
    return query;
  }
  __name(parseQuery, "parseQuery");
  var getStoryHref = __name((baseUrl, storyId, additionalParams = {}) => {
    let [url, paramsStr] = baseUrl.split("?"), params = paramsStr ? {
      ...parseQuery(paramsStr),
      ...additionalParams,
      id: storyId
    } : {
      ...additionalParams,
      id: storyId
    };
    return `${url}?${Object.entries(params).map((item) => `${item[0]}=${item[1]}`).join("&")}`;
  }, "getStoryHref"), Code22 = styled.pre`
  line-height: 18px;
  padding: 11px 1rem;
  white-space: pre-wrap;
  background: rgba(0, 0, 0, 0.05);
  color: ${color.darkest};
  border-radius: 3px;
  margin: 1rem 0;
  width: 100%;
  display: block;
  overflow: hidden;
  font-family: ${typography.fonts.mono};
  font-size: ${typography.size.s2 - 1}px;
`, ClipboardCode = __name(({ code, ...props }) => react_default.createElement(Code22, { id: "clipboard-code", ...props }, code), "ClipboardCode");
  var resetComponents = {};
  Object.keys(components).forEach((key) => {
    resetComponents[key] = forwardRef((props, ref) => createElement(key, { ...props, ref }));
  });

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_chunk_RNE2IUTB();
  init_chunk_BOOOPFZF();
  init_chunk_VAMFPZY3();

  // node_modules/storybook/dist/_browser-chunks/chunk-SYS437NN.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var has = Object.prototype.hasOwnProperty;
  function find(iter, tar, key) {
    for (key of iter.keys())
      if (dequal(key, tar)) return key;
  }
  __name(find, "find");
  function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar) return !0;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date) return foo.getTime() === bar.getTime();
      if (ctor === RegExp) return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len = foo.length) === bar.length)
          for (; len-- && dequal(foo[len], bar[len]); ) ;
        return len === -1;
      }
      if (ctor === Set) {
        if (foo.size !== bar.size)
          return !1;
        for (len of foo)
          if (tmp = len, tmp && typeof tmp == "object" && (tmp = find(bar, tmp), !tmp) || !bar.has(tmp)) return !1;
        return !0;
      }
      if (ctor === Map) {
        if (foo.size !== bar.size)
          return !1;
        for (len of foo)
          if (tmp = len[0], tmp && typeof tmp == "object" && (tmp = find(bar, tmp), !tmp) || !dequal(len[1], bar.get(tmp)))
            return !1;
        return !0;
      }
      if (ctor === ArrayBuffer)
        foo = new Uint8Array(foo), bar = new Uint8Array(bar);
      else if (ctor === DataView) {
        if ((len = foo.byteLength) === bar.byteLength)
          for (; len-- && foo.getInt8(len) === bar.getInt8(len); ) ;
        return len === -1;
      }
      if (ArrayBuffer.isView(foo)) {
        if ((len = foo.byteLength) === bar.byteLength)
          for (; len-- && foo[len] === bar[len]; ) ;
        return len === -1;
      }
      if (!ctor || typeof foo == "object") {
        len = 0;
        for (ctor in foo)
          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor) || !(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return !1;
        return Object.keys(bar).length === len;
      }
    }
    return foo !== foo && bar !== bar;
  }
  __name(dequal, "dequal");
  function partition(arr, isInTruthy) {
    let truthy = [], falsy = [];
    for (let i3 = 0; i3 < arr.length; i3++) {
      let item = arr[i3];
      isInTruthy(item) ? truthy.push(item) : falsy.push(item);
    }
    return [truthy, falsy];
  }
  __name(partition, "partition");
  function countBy(arr, mapper) {
    let result = {};
    for (let i3 = 0; i3 < arr.length; i3++) {
      let item = arr[i3], key = mapper(item);
      result[key] = (result[key] ?? 0) + 1;
    }
    return result;
  }
  __name(countBy, "countBy");
  function uniq(arr) {
    return Array.from(new Set(arr));
  }
  __name(uniq, "uniq");

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_chunk_U46RQHA4();
  init_chunk_MH6AXFXB();
  init_chunk_NVV6MIOE();

  // node_modules/storybook/dist/_browser-chunks/chunk-TMDZCWME.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var MINIMAL_VIEWPORTS = {
    mobile1: {
      name: "Small mobile",
      styles: {
        height: "568px",
        width: "320px"
      },
      type: "mobile"
    },
    mobile2: {
      name: "Large mobile",
      styles: {
        height: "896px",
        width: "414px"
      },
      type: "mobile"
    },
    tablet: {
      name: "Tablet",
      styles: {
        height: "1112px",
        width: "834px"
      },
      type: "tablet"
    },
    desktop: {
      name: "Desktop",
      styles: {
        height: "1024px",
        width: "1280px"
      },
      type: "desktop"
    }
  }, responsiveViewport = {
    name: "Reset viewport",
    styles: {
      height: "100%",
      width: "100%"
    },
    type: "desktop"
  };

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_chunk_MM7DTO55();
  init_dist();

  // global-externals:storybook/manager-api
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var manager_api_default = __STORYBOOK_API__, { ActiveTabs, Consumer, ManagerContext, Provider, RequestResponseError, addons: addons3, combineParameters: combineParameters2, controlOrMetaKey, controlOrMetaSymbol, eventMatchesShortcut, eventToShortcut, experimental_MockUniversalStore, experimental_UniversalStore, experimental_getStatusStore, experimental_getTestProviderStore, experimental_requestResponse, experimental_useStatusStore, experimental_useTestProviderStore, experimental_useUniversalStore, internal_fullStatusStore, internal_fullTestProviderStore, internal_universalStatusStore, internal_universalTestProviderStore, isMacLike, isShortcutTaken, keyToSymbol, merge: merge2, mockChannel: mockChannel2, optionOrAltSymbol, shortcutMatchesShortcut, shortcutToHumanString, types, useAddonState, useArgTypes, useArgs: useArgs2, useChannel: useChannel2, useGlobalTypes, useGlobals: useGlobals2, useParameter: useParameter2, useSharedState, useStoryPrepared, useStorybookApi, useStorybookState } = __STORYBOOK_API__;

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_dist();
  init_theming();
  init_react();
  init_client_logger();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_client_logger();
  init_theming();
  init_react();
  init_client_logger();
  init_theming();
  init_react();
  init_client_logger();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_dist();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_client_logger();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  var Wrapper6 = styled.div(withReset2, ({ theme: theme3 }) => ({
    backgroundColor: theme3.base === "light" ? "rgba(0,0,0,.01)" : "rgba(255,255,255,.01)",
    borderRadius: theme3.appBorderRadius,
    border: `1px dashed ${theme3.appBorderColor}`,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 20,
    margin: "25px 0 40px",
    color: curriedTransparentize$1(0.3, theme3.color.defaultText),
    fontSize: theme3.typography.size.s2
  })), EmptyBlock = __name((props) => react_default.createElement(Wrapper6, { ...props, className: "docblock-emptyblock sb-unstyled" }), "EmptyBlock"), StyledSyntaxHighlighter2 = styled(
    SyntaxHighlighter4
  )(({ theme: theme3 }) => ({
    // DocBlocks-specific styling and overrides
    fontSize: `${theme3.typography.size.s2 - 1}px`,
    lineHeight: "19px",
    margin: "25px 0 40px",
    borderRadius: theme3.appBorderRadius,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    "pre.prismjs": {
      padding: 20,
      background: "inherit"
    }
  })), SourceSkeletonWrapper = styled.div(({ theme: theme3 }) => ({
    background: theme3.background.content,
    borderRadius: theme3.appBorderRadius,
    border: `1px solid ${theme3.appBorderColor}`,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    margin: "25px 0 40px",
    padding: "20px 20px 20px 22px"
  })), SourceSkeletonPlaceholder = styled.div(({ theme: theme3 }) => ({
    animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`,
    background: theme3.appBorderColor,
    height: 17,
    marginTop: 1,
    width: "60%",
    [`&:first-child${ignoreSsrWarning}`]: {
      margin: 0
    }
  })), SourceSkeleton = __name(() => react_default.createElement(SourceSkeletonWrapper, null, react_default.createElement(SourceSkeletonPlaceholder, null), react_default.createElement(SourceSkeletonPlaceholder, { style: { width: "80%" } }), react_default.createElement(SourceSkeletonPlaceholder, { style: { width: "30%" } }), react_default.createElement(SourceSkeletonPlaceholder, { style: { width: "80%" } })), "SourceSkeleton"), Source = __name(({
    isLoading,
    error,
    language,
    code,
    dark,
    format: format3 = !0,
    ...rest
  }) => {
    let { typography: typography4 } = useTheme();
    if (isLoading)
      return react_default.createElement(SourceSkeleton, null);
    if (error)
      return react_default.createElement(EmptyBlock, null, error);
    let syntaxHighlighter = react_default.createElement(
      StyledSyntaxHighlighter2,
      {
        bordered: !0,
        copyable: !0,
        format: format3,
        language: language ?? "jsx",
        className: "docblock-source sb-unstyled",
        ...rest
      },
      code
    );
    if (typeof dark > "u")
      return syntaxHighlighter;
    let overrideTheme = dark ? themes.dark : themes.light;
    return react_default.createElement(
      ThemeProvider,
      {
        theme: convert({
          ...overrideTheme,
          fontCode: typography4.fonts.mono,
          fontBase: typography4.fonts.base
        })
      },
      syntaxHighlighter
    );
  }, "Source"), toGlobalSelector = __name((element) => `& :where(${element}:not(.sb-anchor, .sb-unstyled, .sb-unstyled ${element}))`, "toGlobalSelector"), breakpoint = 600, Title7 = styled.h1(withReset2, ({ theme: theme3 }) => ({
    color: theme3.color.defaultText,
    fontSize: theme3.typography.size.m3,
    fontWeight: theme3.typography.weight.bold,
    lineHeight: "32px",
    [`@media (min-width: ${breakpoint}px)`]: {
      fontSize: theme3.typography.size.l1,
      lineHeight: "36px",
      marginBottom: "16px"
    }
  })), Subtitle = styled.h2(withReset2, ({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.regular,
    fontSize: theme3.typography.size.s3,
    lineHeight: "20px",
    borderBottom: "none",
    marginBottom: 15,
    [`@media (min-width: ${breakpoint}px)`]: {
      fontSize: theme3.typography.size.m1,
      lineHeight: "28px",
      marginBottom: 24
    },
    color: curriedTransparentize$1(0.25, theme3.color.defaultText)
  })), DocsContent = styled.div(({ theme: theme3 }) => {
    let reset = {
      fontFamily: theme3.typography.fonts.base,
      fontSize: theme3.typography.size.s3,
      margin: 0,
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
      WebkitOverflowScrolling: "touch"
    }, headers = {
      margin: "20px 0 8px",
      padding: 0,
      cursor: "text",
      position: "relative",
      color: theme3.color.defaultText,
      "&:first-of-type": {
        marginTop: 0,
        paddingTop: 0
      },
      "&:hover a.anchor": {
        textDecoration: "none"
      },
      "& code": {
        fontSize: "inherit"
      }
    }, code = {
      lineHeight: 1,
      margin: "0 2px",
      padding: "3px 5px",
      whiteSpace: "nowrap",
      borderRadius: 3,
      fontSize: theme3.typography.size.s2 - 1,
      border: theme3.base === "light" ? `1px solid ${theme3.color.mediumlight}` : `1px solid ${theme3.color.darker}`,
      color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
      backgroundColor: theme3.base === "light" ? theme3.color.lighter : theme3.color.border
    };
    return {
      maxWidth: 1e3,
      width: "100%",
      minWidth: 0,
      [toGlobalSelector("a")]: {
        ...reset,
        fontSize: "inherit",
        lineHeight: "24px",
        color: theme3.color.secondary,
        textDecoration: "none",
        "&.absent": {
          color: "#cc0000"
        },
        "&.anchor": {
          display: "block",
          paddingLeft: 30,
          marginLeft: -30,
          cursor: "pointer",
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0
        }
      },
      [toGlobalSelector("blockquote")]: {
        ...reset,
        margin: "16px 0",
        borderLeft: `4px solid ${theme3.color.medium}`,
        padding: "0 15px",
        color: theme3.color.dark,
        "& > :first-of-type": {
          marginTop: 0
        },
        "& > :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("div")]: reset,
      [toGlobalSelector("dl")]: {
        ...reset,
        margin: "16px 0",
        padding: 0,
        "& dt": {
          fontSize: "14px",
          fontWeight: "bold",
          fontStyle: "italic",
          padding: 0,
          margin: "16px 0 4px"
        },
        "& dt:first-of-type": {
          padding: 0
        },
        "& dt > :first-of-type": {
          marginTop: 0
        },
        "& dt > :last-child": {
          marginBottom: 0
        },
        "& dd": {
          margin: "0 0 16px",
          padding: "0 15px"
        },
        "& dd > :first-of-type": {
          marginTop: 0
        },
        "& dd > :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("h1")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.l1}px`,
        fontWeight: theme3.typography.weight.bold
      },
      [toGlobalSelector("h2")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.m2}px`,
        paddingBottom: 4,
        borderBottom: `1px solid ${theme3.appBorderColor}`
      },
      [toGlobalSelector("h3")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.m1}px`,
        fontWeight: theme3.typography.weight.bold
      },
      [toGlobalSelector("h4")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.s3}px`
      },
      [toGlobalSelector("h5")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.s2}px`
      },
      [toGlobalSelector("h6")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.s2}px`,
        color: theme3.color.dark
      },
      [toGlobalSelector("hr")]: {
        border: "0 none",
        borderTop: `1px solid ${theme3.appBorderColor}`,
        height: 4,
        padding: 0
      },
      [toGlobalSelector("img")]: {
        maxWidth: "100%"
      },
      [toGlobalSelector("li")]: {
        ...reset,
        fontSize: theme3.typography.size.s2,
        color: theme3.color.defaultText,
        lineHeight: "24px",
        "& + li": {
          marginTop: ".25em"
        },
        "& ul, & ol": {
          marginTop: ".25em",
          marginBottom: 0
        },
        "& code": code
      },
      [toGlobalSelector("ol")]: {
        ...reset,
        margin: "16px 0",
        paddingLeft: 30,
        "& :first-of-type": {
          marginTop: 0
        },
        "& :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("p")]: {
        ...reset,
        margin: "16px 0",
        fontSize: theme3.typography.size.s2,
        lineHeight: "24px",
        color: theme3.color.defaultText,
        "& code": code
      },
      [toGlobalSelector("pre")]: {
        ...reset,
        // reset
        fontFamily: theme3.typography.fonts.mono,
        WebkitFontSmoothing: "antialiased",
        MozOsxFontSmoothing: "grayscale",
        lineHeight: "18px",
        padding: "11px 1rem",
        whiteSpace: "pre-wrap",
        color: "inherit",
        borderRadius: 3,
        margin: "1rem 0",
        "&:not(.prismjs)": {
          background: "transparent",
          border: "none",
          borderRadius: 0,
          padding: 0,
          margin: 0
        },
        "& pre, &.prismjs": {
          padding: 15,
          margin: 0,
          whiteSpace: "pre-wrap",
          color: "inherit",
          fontSize: "13px",
          lineHeight: "19px",
          code: {
            color: "inherit",
            fontSize: "inherit"
          }
        },
        "& code": {
          whiteSpace: "pre"
        },
        "& code, & tt": {
          border: "none"
        }
      },
      [toGlobalSelector("span")]: {
        ...reset,
        "&.frame": {
          display: "block",
          overflow: "hidden",
          "& > span": {
            border: `1px solid ${theme3.color.medium}`,
            display: "block",
            float: "left",
            overflow: "hidden",
            margin: "13px 0 0",
            padding: 7,
            width: "auto"
          },
          "& span img": {
            display: "block",
            float: "left"
          },
          "& span span": {
            clear: "both",
            color: theme3.color.darkest,
            display: "block",
            padding: "5px 0 0"
          }
        },
        "&.align-center": {
          display: "block",
          overflow: "hidden",
          clear: "both",
          "& > span": {
            display: "block",
            overflow: "hidden",
            margin: "13px auto 0",
            textAlign: "center"
          },
          "& span img": {
            margin: "0 auto",
            textAlign: "center"
          }
        },
        "&.align-right": {
          display: "block",
          overflow: "hidden",
          clear: "both",
          "& > span": {
            display: "block",
            overflow: "hidden",
            margin: "13px 0 0",
            textAlign: "right"
          },
          "& span img": {
            margin: 0,
            textAlign: "right"
          }
        },
        "&.float-left": {
          display: "block",
          marginRight: 13,
          overflow: "hidden",
          float: "left",
          "& span": {
            margin: "13px 0 0"
          }
        },
        "&.float-right": {
          display: "block",
          marginLeft: 13,
          overflow: "hidden",
          float: "right",
          "& > span": {
            display: "block",
            overflow: "hidden",
            margin: "13px auto 0",
            textAlign: "right"
          }
        }
      },
      [toGlobalSelector("table")]: {
        ...reset,
        margin: "16px 0",
        fontSize: theme3.typography.size.s2,
        lineHeight: "24px",
        padding: 0,
        borderCollapse: "collapse",
        "& tr": {
          borderTop: `1px solid ${theme3.appBorderColor}`,
          backgroundColor: theme3.appContentBg,
          margin: 0,
          padding: 0
        },
        "& tr:nth-of-type(2n)": {
          backgroundColor: theme3.base === "dark" ? theme3.color.darker : theme3.color.lighter
        },
        "& tr th": {
          fontWeight: "bold",
          color: theme3.color.defaultText,
          border: `1px solid ${theme3.appBorderColor}`,
          margin: 0,
          padding: "6px 13px"
        },
        "& tr td": {
          border: `1px solid ${theme3.appBorderColor}`,
          color: theme3.color.defaultText,
          margin: 0,
          padding: "6px 13px"
        },
        "& tr th :first-of-type, & tr td :first-of-type": {
          marginTop: 0
        },
        "& tr th :last-child, & tr td :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("ul")]: {
        ...reset,
        margin: "16px 0",
        paddingLeft: 30,
        "& :first-of-type": {
          marginTop: 0
        },
        "& :last-child": {
          marginBottom: 0
        },
        listStyle: "disc"
      }
    };
  }), DocsWrapper = styled.div(({ theme: theme3 }) => ({
    background: theme3.background.content,
    display: "flex",
    flexDirection: "row-reverse",
    justifyContent: "center",
    padding: "4rem 20px",
    minHeight: "100vh",
    boxSizing: "border-box",
    gap: "3rem",
    [`@media (min-width: ${breakpoint}px)`]: {}
  }));
  globalThis && globalThis.__DOCS_CONTEXT__ === void 0 && (globalThis.__DOCS_CONTEXT__ = createContext(null), globalThis.__DOCS_CONTEXT__.displayName = "DocsContext");
  var DocsContext2 = globalThis ? globalThis.__DOCS_CONTEXT__ : createContext(null), getStoryId = __name((props, context) => {
    let { of, meta } = props;
    if ("of" in props && of === void 0)
      throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
    return meta && context.referenceMeta(meta, !1), context.resolveOf(of || "story", ["story"]).story.id;
  }, "getStoryId"), getBlockBackgroundStyle = __name((theme3) => ({
    borderRadius: theme3.appBorderRadius,
    background: theme3.background.content,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    border: `1px solid ${theme3.appBorderColor}`
  }), "getBlockBackgroundStyle"), { window: globalWindow4 } = globalThis, ZoomContext = createContext({
    scale: 1
  }), { PREVIEW_URL } = globalThis, ErrorMessage = styled.strong(({ theme: theme3 }) => ({
    color: theme3.color.orange
  })), Bar3 = styled(FlexBar2)({
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    transition: "transform .2s linear"
  }), Wrapper23 = styled.div({
    display: "flex",
    alignItems: "center",
    gap: 4
  }), IconPlaceholder = styled.div(({ theme: theme3 }) => ({
    width: 14,
    height: 14,
    borderRadius: 2,
    margin: "0 7px",
    backgroundColor: theme3.appBorderColor,
    animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`
  })), Toolbar = __name(({
    isLoading,
    storyId,
    baseUrl,
    zoom,
    resetZoom,
    ...rest
  }) => react_default.createElement(Bar3, { ...rest }, react_default.createElement(Wrapper23, { key: "left" }, isLoading ? [1, 2, 3].map((key) => react_default.createElement(IconPlaceholder, { key })) : react_default.createElement(react_default.Fragment, null, react_default.createElement(
    IconButton2,
    {
      key: "zoomin",
      onClick: (e2) => {
        e2.preventDefault(), zoom(0.8);
      },
      title: "Zoom in"
    },
    react_default.createElement(ZoomIcon, null)
  ), react_default.createElement(
    IconButton2,
    {
      key: "zoomout",
      onClick: (e2) => {
        e2.preventDefault(), zoom(1.25);
      },
      title: "Zoom out"
    },
    react_default.createElement(ZoomOutIcon, null)
  ), react_default.createElement(
    IconButton2,
    {
      key: "zoomreset",
      onClick: (e2) => {
        e2.preventDefault(), resetZoom();
      },
      title: "Reset zoom"
    },
    react_default.createElement(ZoomResetIcon, null)
  ))), isLoading ? react_default.createElement(Wrapper23, { key: "right" }, react_default.createElement(IconPlaceholder, null)) : baseUrl && storyId && react_default.createElement(Wrapper23, { key: "right" }, react_default.createElement(IconButton2, { key: "opener", asChild: !0 }, react_default.createElement(
    "a",
    {
      href: getStoryHref2(baseUrl, storyId),
      target: "_blank",
      rel: "noopener noreferrer",
      "aria-label": "Open canvas in new tab"
    },
    react_default.createElement(ShareAltIcon, null)
  )))), "Toolbar"), ChildrenContainer = styled.div(
    ({ isColumn, columns, layout }) => ({
      display: isColumn || !columns ? "block" : "flex",
      position: "relative",
      flexWrap: "wrap",
      overflow: "auto",
      flexDirection: isColumn ? "column" : "row",
      "& .innerZoomElementWrapper > *": isColumn ? {
        width: layout !== "fullscreen" ? "calc(100% - 20px)" : "100%",
        display: "block"
      } : {
        maxWidth: layout !== "fullscreen" ? "calc(100% - 20px)" : "100%",
        display: "inline-block"
      }
    }),
    ({ layout = "padded", inline }) => layout === "centered" || layout === "padded" ? {
      padding: inline ? "32px 22px" : "0px",
      "& .innerZoomElementWrapper > *": {
        width: "auto",
        border: "8px solid transparent!important"
      }
    } : {},
    ({ layout = "padded", inline }) => layout === "centered" && inline ? {
      display: "flex",
      justifyContent: "center",
      justifyItems: "center",
      alignContent: "center",
      alignItems: "center"
    } : {},
    ({ columns }) => columns && columns > 1 ? { ".innerZoomElementWrapper > *": { minWidth: `calc(100% / ${columns} - 20px)` } } : {}
  ), StyledSource = styled(Source)(({ theme: theme3 }) => ({
    margin: 0,
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    borderBottomLeftRadius: theme3.appBorderRadius,
    borderBottomRightRadius: theme3.appBorderRadius,
    border: "none",
    background: theme3.base === "light" ? "rgba(0, 0, 0, 0.85)" : curriedDarken$1(0.05, theme3.background.content),
    color: theme3.color.lightest,
    button: {
      background: theme3.base === "light" ? "rgba(0, 0, 0, 0.85)" : curriedDarken$1(0.05, theme3.background.content)
    }
  })), PreviewContainer = styled.div(
    ({ theme: theme3, withSource, isExpanded }) => ({
      position: "relative",
      overflow: "hidden",
      margin: "25px 0 40px",
      ...getBlockBackgroundStyle(theme3),
      borderBottomLeftRadius: withSource && isExpanded && 0,
      borderBottomRightRadius: withSource && isExpanded && 0,
      borderBottomWidth: isExpanded && 0,
      "h3 + &": {
        marginTop: "16px"
      }
    }),
    ({ withToolbar }) => withToolbar && { paddingTop: 40 }
  ), getSource = __name((withSource, expanded, setExpanded) => {
    switch (!0) {
      case !!(withSource && withSource.error):
        return {
          source: null,
          actionItem: {
            title: "No code available",
            className: "docblock-code-toggle docblock-code-toggle--disabled",
            disabled: !0,
            onClick: __name(() => setExpanded(!1), "onClick")
          }
        };
      case expanded:
        return {
          source: react_default.createElement(StyledSource, { ...withSource, dark: !0 }),
          actionItem: {
            title: "Hide code",
            className: "docblock-code-toggle docblock-code-toggle--expanded",
            onClick: __name(() => setExpanded(!1), "onClick")
          }
        };
      default:
        return {
          source: react_default.createElement(StyledSource, { ...withSource, dark: !0 }),
          actionItem: {
            title: "Show code",
            className: "docblock-code-toggle",
            onClick: __name(() => setExpanded(!0), "onClick")
          }
        };
    }
  }, "getSource");
  function getChildProps(children) {
    if (Children.count(children) === 1) {
      let elt = children;
      if (elt.props)
        return elt.props;
    }
    return null;
  }
  __name(getChildProps, "getChildProps");
  var PositionedToolbar = styled(Toolbar)({
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 40
  }), Relative = styled.div({
    overflow: "hidden",
    position: "relative"
  }), Preview2 = __name(({
    isLoading,
    isColumn,
    columns,
    children,
    withSource,
    withToolbar = !1,
    isExpanded = !1,
    additionalActions,
    className,
    layout = "padded",
    inline = !1,
    ...props
  }) => {
    let [expanded, setExpanded] = useState(isExpanded), { source, actionItem } = getSource(withSource, expanded, setExpanded), [scale, setScale] = useState(1), previewClasses = [className].concat(["sbdocs", "sbdocs-preview", "sb-unstyled"]), defaultActionItems = withSource ? [actionItem] : [], [additionalActionItems, setAdditionalActionItems] = useState(
      additionalActions ? [...additionalActions] : []
    ), actionItems = [...defaultActionItems, ...additionalActionItems], { window: globalWindow32 } = globalThis, context = useContext(DocsContext2), copyToClipboard2 = useCallback(async (text) => {
      let { createCopyToClipboardFunction: createCopyToClipboardFunction3 } = await Promise.resolve().then(() => (init_components(), components_exports));
      createCopyToClipboardFunction3();
    }, []), onCopyCapture = __name((e2) => {
      let selection = globalWindow32.getSelection();
      selection && selection.type === "Range" || (e2.preventDefault(), additionalActionItems.filter((item) => item.title === "Copied").length === 0 && copyToClipboard2(source?.props.code ?? "").then(() => {
        setAdditionalActionItems([
          ...additionalActionItems,
          {
            title: "Copied",
            onClick: __name(() => {
            }, "onClick")
          }
        ]), globalWindow32.setTimeout(
          () => setAdditionalActionItems(
            additionalActionItems.filter((item) => item.title !== "Copied")
          ),
          1500
        );
      }));
    }, "onCopyCapture"), childProps = getChildProps(children);
    return react_default.createElement(
      PreviewContainer,
      {
        withSource,
        withToolbar,
        ...props,
        className: previewClasses.join(" ")
      },
      withToolbar && react_default.createElement(
        PositionedToolbar,
        {
          isLoading,
          border: !0,
          zoom: (z22) => setScale(scale * z22),
          resetZoom: () => setScale(1),
          storyId: !isLoading && childProps ? getStoryId(childProps, context) : void 0,
          baseUrl: "./iframe.html"
        }
      ),
      react_default.createElement(ZoomContext.Provider, { value: { scale } }, react_default.createElement(Relative, { className: "docs-story", onCopyCapture: withSource && onCopyCapture }, react_default.createElement(
        ChildrenContainer,
        {
          isColumn: isColumn || !Array.isArray(children),
          columns,
          layout,
          inline
        },
        react_default.createElement(Zoom.Element, { centered: layout === "centered", scale: inline ? scale : 1 }, Array.isArray(children) ? children.map((child, i22) => react_default.createElement("div", { key: i22 }, child)) : react_default.createElement("div", null, children))
      ), react_default.createElement(ActionBar2, { actionItems }))),
      withSource && expanded && source
    );
  }, "Preview"), StyledPreview = styled(Preview2)(() => ({
    ".docs-story": {
      paddingTop: 32,
      paddingBottom: 40
    }
  })), Label2 = styled.div(({ theme: theme3 }) => ({
    marginRight: 30,
    fontSize: `${theme3.typography.size.s1}px`,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText)
  })), Sample = styled.div({
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  }), TypeSpecimen = styled.div({
    display: "flex",
    flexDirection: "row",
    alignItems: "baseline",
    "&:not(:last-child)": { marginBottom: "1rem" }
  }), Wrapper33 = styled.div(withReset2, ({ theme: theme3 }) => ({
    ...getBlockBackgroundStyle(theme3),
    margin: "25px 0 40px",
    padding: "30px 20px"
  })), ItemTitle = styled.div(({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.bold,
    color: theme3.color.defaultText
  })), ItemSubtitle = styled.div(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.2, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText)
  })), ItemDescription = styled.div({
    flex: "0 0 30%",
    lineHeight: "20px",
    marginTop: 5
  }), SwatchLabel = styled.div(({ theme: theme3 }) => ({
    flex: 1,
    textAlign: "center",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    lineHeight: 1,
    overflow: "hidden",
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText),
    "> div": {
      display: "inline-block",
      overflow: "hidden",
      maxWidth: "100%",
      textOverflow: "ellipsis"
    },
    span: {
      display: "block",
      marginTop: 2
    }
  })), SwatchLabels = styled.div({
    display: "flex",
    flexDirection: "row"
  }), Swatch2 = styled.div(({ background: background2 }) => ({
    position: "relative",
    flex: 1,
    "&::before": {
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      background: background2,
      content: '""'
    }
  })), SwatchColors = styled.div(({ theme: theme3 }) => ({
    ...getBlockBackgroundStyle(theme3),
    display: "flex",
    flexDirection: "row",
    height: 50,
    marginBottom: 5,
    overflow: "hidden",
    backgroundColor: "white",
    backgroundImage: "repeating-linear-gradient(-45deg, #ccc, #ccc 1px, #fff 1px, #fff 16px)",
    backgroundClip: "padding-box"
  })), SwatchSpecimen = styled.div({
    display: "flex",
    flexDirection: "column",
    flex: 1,
    position: "relative",
    marginBottom: 30
  }), Swatches2 = styled.div({
    flex: 1,
    display: "flex",
    flexDirection: "row"
  }), Item3 = styled.div({
    display: "flex",
    alignItems: "flex-start"
  }), ListName = styled.div({
    flex: "0 0 30%"
  }), ListSwatches = styled.div({
    flex: 1
  }), ListHeading = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    paddingBottom: 20,
    fontWeight: theme3.typography.weight.bold,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText)
  })), List2 = styled.div(({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2,
    lineHeight: "20px",
    display: "flex",
    flexDirection: "column"
  })), ItemLabel = styled.div(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base,
    fontSize: theme3.typography.size.s1,
    color: theme3.color.defaultText,
    marginLeft: 10,
    lineHeight: 1.2,
    display: "-webkit-box",
    overflow: "hidden",
    wordBreak: "break-word",
    textOverflow: "ellipsis",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical"
  })), ItemSpecimen = styled.div(({ theme: theme3 }) => ({
    ...getBlockBackgroundStyle(theme3),
    overflow: "hidden",
    height: 40,
    width: 40,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flex: "none",
    "> img, > svg": {
      width: 20,
      height: 20
    }
  })), Item22 = styled.div({
    display: "inline-flex",
    flexDirection: "row",
    alignItems: "center",
    width: "100%"
  }), List22 = styled.div({
    display: "grid",
    gridTemplateColumns: "repeat(auto-fill, minmax(140px, 1fr))",
    gridGap: "8px 16px",
    gridAutoFlow: "row dense",
    gridAutoRows: 50
  }), Aside = styled.aside(() => ({
    width: "10rem",
    "@media (max-width: 768px)": {
      display: "none"
    }
  })), Nav = styled.nav(({ theme: theme3 }) => ({
    position: "fixed",
    bottom: 0,
    top: 0,
    width: "10rem",
    paddingTop: "4rem",
    paddingBottom: "2rem",
    overflowY: "auto",
    fontFamily: theme3.typography.fonts.base,
    fontSize: theme3.typography.size.s2,
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
    WebkitOverflowScrolling: "touch",
    "& *": {
      boxSizing: "border-box"
    },
    "& > .toc-wrapper > .toc-list": {
      paddingLeft: 0,
      borderLeft: `solid 2px ${theme3.color.mediumlight}`,
      ".toc-list": {
        paddingLeft: 0,
        borderLeft: `solid 2px ${theme3.color.mediumlight}`,
        ".toc-list": {
          paddingLeft: 0,
          borderLeft: `solid 2px ${theme3.color.mediumlight}`
        }
      }
    },
    "& .toc-list-item": {
      position: "relative",
      listStyleType: "none",
      marginLeft: 20,
      paddingTop: 3,
      paddingBottom: 3
    },
    "& .toc-list-item::before": {
      content: '""',
      position: "absolute",
      height: "100%",
      top: 0,
      left: 0,
      transform: "translateX(calc(-2px - 20px))",
      borderLeft: `solid 2px ${theme3.color.mediumdark}`,
      opacity: 0,
      transition: "opacity 0.2s"
    },
    "& .toc-list-item.is-active-li::before": {
      opacity: 1
    },
    "& .toc-list-item > a": {
      color: theme3.color.defaultText,
      textDecoration: "none"
    },
    "& .toc-list-item.is-active-li > a": {
      fontWeight: 600,
      color: theme3.color.secondary,
      textDecoration: "none"
    }
  })), Heading = styled.p(({ theme: theme3 }) => ({
    fontWeight: 600,
    fontSize: "0.875em",
    color: theme3.textColor,
    textTransform: "uppercase",
    marginBottom: 10
  }));
  function n() {
    return n = Object.assign ? Object.assign.bind() : function(e2) {
      for (var n2 = 1; n2 < arguments.length; n2++) {
        var r2 = arguments[n2];
        for (var t in r2) Object.prototype.hasOwnProperty.call(r2, t) && (e2[t] = r2[t]);
      }
      return e2;
    }, n.apply(this, arguments);
  }
  __name(n, "n");
  var r = ["children", "options"], o = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e2, n2) => (e2[n2.toLowerCase()] = n2, e2), { class: "className", for: "htmlFor" }), a2 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "\xA0", quot: "\u201C" }, c2 = ["style", "script", "pre"], i2 = ["src", "href", "data", "formAction", "srcDoc", "action"], u2 = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, l = /mailto:/i, s3 = /\n{2,}$/, f3 = /^(\s*>[\s\S]*?)(?=\n\n|$)/, _2 = /^ *> ?/gm, d2 = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, p3 = /^ {2,}\n/, y2 = /^(?:( *[-*_])){3,} *(?:\n *)+\n/, h3 = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, g2 = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, m2 = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, k2 = /^(?:\n *)*\n/, x2 = /\r\n?/g, v2 = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, q2 = /^\[\^([^\]]+)]/, $2 = /\f/g, b2 = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, S2 = /^\s*?\[(x|\s)\]/, z2 = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, E2 = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, A4 = /^([^\n]+)\n *(=|-){3,} *\n/, R2 = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i, B2 = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, L2 = /^<!--[\s\S]*?(?:-->)/, O = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, j = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, C3 = /^\{.*\}$/, I2 = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, T2 = /^<([^ >]+@[^ >]+)>/, M = /^<([^ >]+:\/[^ >]+)>/, w2 = /-([a-z])?/gi, D2 = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, F2 = /^[^\n]+(?:  \n|\n{2,})/, P4 = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, Z2 = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, N2 = /^\[([^\]]*)\] ?\[([^\]]*)\]/, G = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, U2 = /\t/g, V2 = /(^ *\||\| *$)/g, H7 = /^ *:-+: *$/, Q2 = /^ *:-+ *$/, W2 = /^ *-+: *$/, J2 = __name((e2) => `(?=[\\s\\S]+?\\1${e2 ? "\\1" : ""})`, "J"), K2 = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|\\\\\\1|[\\s\\S])+?)", X2 = RegExp(`^([*_])\\1${J2(1)}${K2}\\1\\1(?!\\1)`), Y2 = RegExp(`^([*_])${J2(0)}${K2}\\1(?!\\1)`), ee2 = RegExp(`^(==)${J2(0)}${K2}\\1`), ne = RegExp(`^(~~)${J2(0)}${K2}\\1`), re2 = /^(:[a-zA-Z0-9-_]+:)/, te = /^\\([^0-9A-Za-z\s])/, oe = /\\([^0-9A-Za-z\s])/g, ae = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, ce = /^\n+/, ie = /^([ \t]*)/, ue2 = /(?:^|\n)( *)$/, le2 = "(?:\\d+\\.)", se = "(?:[*+-])";
  function fe(e2) {
    return "( *)(" + (e2 === 1 ? le2 : se) + ") +";
  }
  __name(fe, "fe");
  var _e = fe(1), de = fe(2);
  function pe(e2) {
    return RegExp("^" + (e2 === 1 ? _e : de));
  }
  __name(pe, "pe");
  var ye = pe(1), he = pe(2);
  function ge(e2) {
    return RegExp("^" + (e2 === 1 ? _e : de) + "[^\\n]*(?:\\n(?!\\1" + (e2 === 1 ? le2 : se) + " )[^\\n]*)*(\\n|$)", "gm");
  }
  __name(ge, "ge");
  var me = ge(1), ke = ge(2);
  function xe(e2) {
    let n2 = e2 === 1 ? le2 : se;
    return RegExp("^( *)(" + n2 + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + n2 + " (?!" + n2 + " ))\\n*|\\s*\\n*$)");
  }
  __name(xe, "xe");
  var ve = xe(1), qe = xe(2);
  function $e(e2, n2) {
    let r2 = n2 === 1, t = r2 ? ve : qe, o2 = r2 ? me : ke, a22 = r2 ? ye : he;
    return { t: __name((e3) => a22.test(e3), "t"), o: Ce(function(e3, n3) {
      let r3 = ue2.exec(n3.prevCapture);
      return r3 && (n3.list || !n3.inline && !n3.simple) ? t.exec(e3 = r3[1] + e3) : null;
    }), i: 1, u(e3, n3, t2) {
      let c22 = r2 ? +e3[2] : void 0, i22 = e3[0].replace(s3, `
`).match(o2), u22 = !1;
      return { items: i22.map(function(e4, r3) {
        let o3 = a22.exec(e4)[0].length, c3 = RegExp("^ {1," + o3 + "}", "gm"), l2 = e4.replace(c3, "").replace(a22, ""), s22 = r3 === i22.length - 1, f22 = l2.indexOf(`

`) !== -1 || s22 && u22;
        u22 = f22;
        let _22 = t2.inline, d22 = t2.list, p22;
        t2.list = !0, f22 ? (t2.inline = !1, p22 = ze(l2) + `

`) : (t2.inline = !0, p22 = ze(l2));
        let y22 = n3(p22, t2);
        return t2.inline = _22, t2.list = d22, y22;
      }), ordered: r2, start: c22 };
    }, l: __name((n3, r3, t2) => e2(n3.ordered ? "ol" : "ul", { key: t2.key, start: n3.type === "20" ? n3.start : void 0 }, n3.items.map(function(n4, o3) {
      return e2("li", { key: o3 }, r3(n4, t2));
    })), "l") };
  }
  __name($e, "$e");
  var be = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), Se = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
  function ze(e2) {
    let n2 = e2.length;
    for (; n2 > 0 && e2[n2 - 1] <= " "; ) n2--;
    return e2.slice(0, n2);
  }
  __name(ze, "ze");
  function Ee2(e2, n2) {
    return e2.startsWith(n2);
  }
  __name(Ee2, "Ee");
  function Ae(e2, n2, r2) {
    if (Array.isArray(r2)) {
      for (let n3 = 0; n3 < r2.length; n3++) if (Ee2(e2, r2[n3])) return !0;
      return !1;
    }
    return r2(e2, n2);
  }
  __name(Ae, "Ae");
  function Re(e2) {
    return e2.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
  }
  __name(Re, "Re");
  function Be(e2) {
    return W2.test(e2) ? "right" : H7.test(e2) ? "center" : Q2.test(e2) ? "left" : null;
  }
  __name(Be, "Be");
  function Le(e2, n2, r2, t) {
    let o2 = r2.inTable;
    r2.inTable = !0;
    let a22 = [[]], c22 = "";
    function i22() {
      if (!c22) return;
      let e3 = a22[a22.length - 1];
      e3.push.apply(e3, n2(c22, r2)), c22 = "";
    }
    return __name(i22, "i"), e2.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((e3, n3, r3) => {
      e3.trim() === "|" && (i22(), t) ? n3 !== 0 && n3 !== r3.length - 1 && a22.push([]) : c22 += e3;
    }), i22(), r2.inTable = o2, a22;
  }
  __name(Le, "Le");
  function Oe(e2, n2, r2) {
    r2.inline = !0;
    let t = e2[2] ? e2[2].replace(V2, "").split("|").map(Be) : [], o2 = e2[3] ? (function(e3, n3, r3) {
      return e3.trim().split(`
`).map(function(e4) {
        return Le(e4, n3, r3, !0);
      });
    })(e2[3], n2, r2) : [], a22 = Le(e2[1], n2, r2, !!o2.length);
    return r2.inline = !1, o2.length ? { align: t, cells: o2, header: a22, type: "25" } : { children: a22, type: "21" };
  }
  __name(Oe, "Oe");
  function je(e2, n2) {
    return e2.align[n2] == null ? {} : { textAlign: e2.align[n2] };
  }
  __name(je, "je");
  function Ce(e2) {
    return e2.inline = 1, e2;
  }
  __name(Ce, "Ce");
  function Ie(e2) {
    return Ce(function(n2, r2) {
      return r2.inline ? e2.exec(n2) : null;
    });
  }
  __name(Ie, "Ie");
  function Te(e2) {
    return Ce(function(n2, r2) {
      return r2.inline || r2.simple ? e2.exec(n2) : null;
    });
  }
  __name(Te, "Te");
  function Me(e2) {
    return function(n2, r2) {
      return r2.inline || r2.simple ? null : e2.exec(n2);
    };
  }
  __name(Me, "Me");
  function we(e2) {
    return Ce(function(n2) {
      return e2.exec(n2);
    });
  }
  __name(we, "we");
  var De = /(javascript|vbscript|data(?!:image)):/i;
  function Fe(e2) {
    try {
      let n2 = decodeURIComponent(e2).replace(/[^A-Za-z0-9/:]/g, "");
      if (De.test(n2)) return null;
    } catch {
      return null;
    }
    return e2;
  }
  __name(Fe, "Fe");
  function Pe(e2) {
    return e2 && e2.replace(oe, "$1");
  }
  __name(Pe, "Pe");
  function Ze(e2, n2, r2) {
    let t = r2.inline || !1, o2 = r2.simple || !1;
    r2.inline = !0, r2.simple = !0;
    let a22 = e2(n2, r2);
    return r2.inline = t, r2.simple = o2, a22;
  }
  __name(Ze, "Ze");
  function Ne(e2, n2, r2) {
    let t = r2.inline || !1, o2 = r2.simple || !1;
    r2.inline = !1, r2.simple = !0;
    let a22 = e2(n2, r2);
    return r2.inline = t, r2.simple = o2, a22;
  }
  __name(Ne, "Ne");
  function Ge(e2, n2, r2) {
    let t = r2.inline || !1;
    r2.inline = !1;
    let o2 = e2(n2, r2);
    return r2.inline = t, o2;
  }
  __name(Ge, "Ge");
  var Ue = __name((e2, n2, r2) => ({ children: Ze(n2, e2[2], r2) }), "Ue");
  function Ve() {
    return {};
  }
  __name(Ve, "Ve");
  function He2() {
    return null;
  }
  __name(He2, "He");
  function Qe(...e2) {
    return e2.filter(Boolean).join(" ");
  }
  __name(Qe, "Qe");
  function We(e2, n2, r2) {
    let t = e2, o2 = n2.split(".");
    for (; o2.length && (t = t[o2[0]], t !== void 0); ) o2.shift();
    return t || r2;
  }
  __name(We, "We");
  function Je(r2 = "", t = {}) {
    t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? n({}, a2, t.namedCodesToUnicode) : a2;
    let s22 = t.slugify || Re, V22 = t.sanitizer || Fe, H23 = t.createElement || createElement, Q22 = [f3, h3, g2, t.enforceAtxHeadings ? E2 : z2, A4, D2, ve, qe], W22 = [...Q22, F2, R2, L2, j];
    function J22(e2, r3, ...o2) {
      let a22 = We(t.overrides, e2 + ".props", {});
      return H23((function(e3, n2) {
        let r4 = We(n2, e3);
        return r4 ? typeof r4 == "function" || typeof r4 == "object" && "render" in r4 ? r4 : We(n2, e3 + ".component", e3) : e3;
      })(e2, t.overrides), n({}, r3, a22, { className: Qe(r3?.className, a22.className) || void 0 }), ...o2);
    }
    __name(J22, "J");
    function K22(e2) {
      e2 = e2.replace(b2, "");
      let n2 = !1;
      t.forceInline ? n2 = !0 : t.forceBlock || (n2 = G.test(e2) === !1);
      let r3 = _e2(fe2(n2 ? e2 : ze(e2).replace(ce, "") + `

`, { inline: n2 }));
      for (; typeof r3[r3.length - 1] == "string" && !r3[r3.length - 1].trim(); ) r3.pop();
      if (t.wrapper === null) return r3;
      let o2 = t.wrapper || (n2 ? "span" : "div"), a22;
      if (r3.length > 1 || t.forceWrapper) a22 = r3;
      else {
        if (r3.length === 1) return a22 = r3[0], typeof a22 == "string" ? J22("span", { key: "outer" }, a22) : a22;
        a22 = null;
      }
      return H23(o2, { key: "outer" }, a22);
    }
    __name(K22, "K");
    function oe2(e2, n2) {
      if (!n2 || !n2.trim()) return null;
      let r3 = n2.match(u2);
      return r3 ? r3.reduce(function(n3, r4) {
        let t2 = r4.indexOf("=");
        if (t2 !== -1) {
          let a22 = (function(e3) {
            return e3.indexOf("-") !== -1 && e3.match(O) === null && (e3 = e3.replace(w2, function(e4, n4) {
              return n4.toUpperCase();
            })), e3;
          })(r4.slice(0, t2)).trim(), c22 = (function(e3) {
            let n4 = e3[0];
            return (n4 === '"' || n4 === "'") && e3.length >= 2 && e3[e3.length - 1] === n4 ? e3.slice(1, -1) : e3;
          })(r4.slice(t2 + 1).trim()), u22 = o[a22] || a22;
          if (u22 === "ref") return n3;
          let l2 = n3[u22] = (function(e3, n4, r5, t3) {
            return n4 === "style" ? (function(e4) {
              let n5 = [], r6 = "", t4 = !1, o2 = !1, a3 = "";
              if (!e4) return n5;
              for (let c4 = 0; c4 < e4.length; c4++) {
                let i22 = e4[c4];
                if (i22 !== '"' && i22 !== "'" || t4 || (o2 ? i22 === a3 && (o2 = !1, a3 = "") : (o2 = !0, a3 = i22)), i22 === "(" && r6.endsWith("url") ? t4 = !0 : i22 === ")" && t4 && (t4 = !1), i22 !== ";" || o2 || t4) r6 += i22;
                else {
                  let e5 = r6.trim();
                  if (e5) {
                    let r7 = e5.indexOf(":");
                    if (r7 > 0) {
                      let t5 = e5.slice(0, r7).trim(), o3 = e5.slice(r7 + 1).trim();
                      n5.push([t5, o3]);
                    }
                  }
                  r6 = "";
                }
              }
              let c3 = r6.trim();
              if (c3) {
                let e5 = c3.indexOf(":");
                if (e5 > 0) {
                  let r7 = c3.slice(0, e5).trim(), t5 = c3.slice(e5 + 1).trim();
                  n5.push([r7, t5]);
                }
              }
              return n5;
            })(r5).reduce(function(n5, [r6, o2]) {
              return n5[r6.replace(/(-[a-z])/g, (e4) => e4[1].toUpperCase())] = t3(o2, e3, r6), n5;
            }, {}) : i2.indexOf(n4) !== -1 ? t3(Pe(r5), e3, n4) : (r5.match(C3) && (r5 = Pe(r5.slice(1, r5.length - 1))), r5 === "true" || r5 !== "false" && r5);
          })(e2, a22, c22, V22);
          typeof l2 == "string" && (R2.test(l2) || j.test(l2)) && (n3[u22] = K22(l2.trim()));
        } else r4 !== "style" && (n3[o[r4] || r4] = !0);
        return n3;
      }, {}) : null;
    }
    __name(oe2, "oe");
    let ue22 = [], le22 = {}, se2 = { 0: { t: [">"], o: Me(f3), i: 1, u(e2, n2, r3) {
      let [, t2, o2] = e2[0].replace(_2, "").match(d2);
      return { alert: t2, children: n2(o2, r3) };
    }, l(e2, n2, r3) {
      let t2 = { key: r3.key };
      return e2.alert && (t2.className = "markdown-alert-" + s22(e2.alert.toLowerCase(), Re), e2.children.unshift({ attrs: {}, children: [{ type: "27", text: e2.alert }], noInnerParse: !0, type: "11", tag: "header" })), J22("blockquote", t2, n2(e2.children, r3));
    } }, 1: { o: we(p3), i: 1, u: Ve, l: __name((e2, n2, r3) => J22("br", { key: r3.key }), "l") }, 2: { t: __name((e2) => {
      let n2 = e2[0];
      return n2 === "-" || n2 === "*" || n2 === "_";
    }, "t"), o: Me(y2), i: 1, u: Ve, l: __name((e2, n2, r3) => J22("hr", { key: r3.key }), "l") }, 3: { t: ["    "], o: Me(g2), i: 0, u: __name((e2) => ({ lang: void 0, text: Pe(ze(e2[0].replace(/^ {4}/gm, ""))) }), "u"), l: __name((e2, r3, t2) => J22("pre", { key: t2.key }, J22("code", n({}, e2.attrs, { className: e2.lang ? "lang-" + e2.lang : "" }), e2.text)), "l") }, 4: { t: ["```", "~~~"], o: Me(h3), i: 0, u: __name((e2) => ({ attrs: oe2("code", e2[3] || ""), lang: e2[2] || void 0, text: e2[4], type: "3" }), "u") }, 5: { t: ["`"], o: Te(m2), i: 3, u: __name((e2) => ({ text: Pe(e2[2]) }), "u"), l: __name((e2, n2, r3) => J22("code", { key: r3.key }, e2.text), "l") }, 6: { t: ["[^"], o: Me(v2), i: 0, u: __name((e2) => (ue22.push({ footnote: e2[2], identifier: e2[1] }), {}), "u"), l: He2 }, 7: { t: ["[^"], o: Ie(q2), i: 1, u: __name((e2) => ({ target: "#" + s22(e2[1], Re), text: e2[1] }), "u"), l: __name((e2, n2, r3) => J22("a", { key: r3.key, href: V22(e2.target, "a", "href") }, J22("sup", { key: r3.key }, e2.text)), "l") }, 8: { t: ["[ ]", "[x]"], o: Ie(S2), i: 1, u: __name((e2) => ({ completed: e2[1].toLowerCase() === "x" }), "u"), l: __name((e2, n2, r3) => J22("input", { checked: e2.completed, key: r3.key, readOnly: !0, type: "checkbox" }), "l") }, 9: { t: ["#"], o: Me(t.enforceAtxHeadings ? E2 : z2), i: 1, u: __name((e2, n2, r3) => ({ children: Ze(n2, e2[2], r3), id: s22(e2[2], Re), level: e2[1].length }), "u"), l: __name((e2, n2, r3) => J22("h" + e2.level, { id: e2.id, key: r3.key }, n2(e2.children, r3)), "l") }, 10: { o: Me(A4), i: 0, u: __name((e2, n2, r3) => ({ children: Ze(n2, e2[1], r3), level: e2[2] === "=" ? 1 : 2, type: "9" }), "u") }, 11: { t: ["<"], o: we(R2), i: 1, u(e2, n2, r3) {
      let [, t2] = e2[3].match(ie), o2 = RegExp("^" + t2, "gm"), a22 = e2[3].replace(o2, ""), i22 = (u22 = a22, W22.some((e3) => e3.test(u22)) ? Ge : Ze);
      var u22;
      let l2 = e2[1].toLowerCase(), s32 = c2.indexOf(l2) !== -1, f22 = (s32 ? l2 : e2[1]).trim(), _22 = { attrs: oe2(f22, e2[2]), noInnerParse: s32, tag: f22 };
      if (r3.inAnchor = r3.inAnchor || l2 === "a", s32) _22.text = e2[3];
      else {
        let e3 = r3.inHTML;
        r3.inHTML = !0, _22.children = i22(n2, a22, r3), r3.inHTML = e3;
      }
      return r3.inAnchor = !1, _22;
    }, l: __name((e2, r3, t2) => J22(e2.tag, n({ key: t2.key }, e2.attrs), e2.text || (e2.children ? r3(e2.children, t2) : "")), "l") }, 13: { t: ["<"], o: we(j), i: 1, u(e2) {
      let n2 = e2[1].trim();
      return { attrs: oe2(n2, e2[2] || ""), tag: n2 };
    }, l: __name((e2, r3, t2) => J22(e2.tag, n({}, e2.attrs, { key: t2.key })), "l") }, 12: { t: ["<!--"], o: we(L2), i: 1, u: __name(() => ({}), "u"), l: He2 }, 14: { t: ["!["], o: Te(Se), i: 1, u: __name((e2) => ({ alt: Pe(e2[1]), target: Pe(e2[2]), title: Pe(e2[3]) }), "u"), l: __name((e2, n2, r3) => J22("img", { key: r3.key, alt: e2.alt || void 0, title: e2.title || void 0, src: V22(e2.target, "img", "src") }), "l") }, 15: { t: ["["], o: Ie(be), i: 3, u: __name((e2, n2, r3) => ({ children: Ne(n2, e2[1], r3), target: Pe(e2[2]), title: Pe(e2[3]) }), "u"), l: __name((e2, n2, r3) => J22("a", { key: r3.key, href: V22(e2.target, "a", "href"), title: e2.title }, n2(e2.children, r3)), "l") }, 16: { t: ["<"], o: Ie(M), i: 0, u: __name((e2) => ({ children: [{ text: e2[1], type: "27" }], target: e2[1], type: "15" }), "u") }, 17: { t: __name((e2, n2) => !n2.inAnchor && !t.disableAutoLink && (Ee2(e2, "http://") || Ee2(e2, "https://")), "t"), o: Ie(I2), i: 0, u: __name((e2) => ({ children: [{ text: e2[1], type: "27" }], target: e2[1], title: void 0, type: "15" }), "u") }, 18: { t: ["<"], o: Ie(T2), i: 0, u(e2) {
      let n2 = e2[1], r3 = e2[1];
      return l.test(r3) || (r3 = "mailto:" + r3), { children: [{ text: n2.replace("mailto:", ""), type: "27" }], target: r3, type: "15" };
    } }, 20: $e(J22, 1), 33: $e(J22, 2), 19: { o: Me(k2), i: 3, u: Ve, l: __name(() => `
`, "l") }, 21: { o: Ce(function(e2, n2) {
      if (n2.inline || n2.simple || n2.inHTML && e2.indexOf(`

`) === -1 && n2.prevCapture.indexOf(`

`) === -1) return null;
      let r3 = "";
      e2.split(`
`).every((e3) => (e3 += `
`, !Q22.some((n3) => n3.test(e3)) && (r3 += e3, !!e3.trim())));
      let t2 = ze(r3);
      return t2 === "" ? null : [r3, , t2];
    }), i: 3, u: Ue, l: __name((e2, n2, r3) => J22("p", { key: r3.key }, n2(e2.children, r3)), "l") }, 22: { t: ["["], o: Ie(P4), i: 0, u: __name((e2) => (le22[e2[1]] = { target: e2[2], title: e2[4] }, {}), "u"), l: He2 }, 23: { t: ["!["], o: Te(Z2), i: 0, u: __name((e2) => ({ alt: e2[1] ? Pe(e2[1]) : void 0, ref: e2[2] }), "u"), l: __name((e2, n2, r3) => le22[e2.ref] ? J22("img", { key: r3.key, alt: e2.alt, src: V22(le22[e2.ref].target, "img", "src"), title: le22[e2.ref].title }) : null, "l") }, 24: { t: __name((e2) => e2[0] === "[" && e2.indexOf("](") === -1, "t"), o: Ie(N2), i: 0, u: __name((e2, n2, r3) => ({ children: n2(e2[1], r3), fallbackChildren: e2[0], ref: e2[2] }), "u"), l: __name((e2, n2, r3) => le22[e2.ref] ? J22("a", { key: r3.key, href: V22(le22[e2.ref].target, "a", "href"), title: le22[e2.ref].title }, n2(e2.children, r3)) : J22("span", { key: r3.key }, e2.fallbackChildren), "l") }, 25: { t: ["|"], o: Me(D2), i: 1, u: Oe, l(e2, n2, r3) {
      let t2 = e2;
      return J22("table", { key: r3.key }, J22("thead", null, J22("tr", null, t2.header.map(function(e3, o2) {
        return J22("th", { key: o2, style: je(t2, o2) }, n2(e3, r3));
      }))), J22("tbody", null, t2.cells.map(function(e3, o2) {
        return J22("tr", { key: o2 }, e3.map(function(e4, o3) {
          return J22("td", { key: o3, style: je(t2, o3) }, n2(e4, r3));
        }));
      })));
    } }, 27: { o: Ce(function(e2, n2) {
      let r3;
      return Ee2(e2, ":") && (r3 = re2.exec(e2)), r3 || ae.exec(e2);
    }), i: 4, u(e2) {
      let n2 = e2[0];
      return { text: n2.indexOf("&") === -1 ? n2 : n2.replace(B2, (e3, n3) => t.namedCodesToUnicode[n3] || e3) };
    }, l: __name((e2) => e2.text, "l") }, 28: { t: ["**", "__"], o: Te(X2), i: 2, u: __name((e2, n2, r3) => ({ children: n2(e2[2], r3) }), "u"), l: __name((e2, n2, r3) => J22("strong", { key: r3.key }, n2(e2.children, r3)), "l") }, 29: { t: __name((e2) => {
      let n2 = e2[0];
      return (n2 === "*" || n2 === "_") && e2[1] !== n2;
    }, "t"), o: Te(Y2), i: 3, u: __name((e2, n2, r3) => ({ children: n2(e2[2], r3) }), "u"), l: __name((e2, n2, r3) => J22("em", { key: r3.key }, n2(e2.children, r3)), "l") }, 30: { t: ["\\"], o: Te(te), i: 1, u: __name((e2) => ({ text: e2[1], type: "27" }), "u") }, 31: { t: ["=="], o: Te(ee2), i: 3, u: Ue, l: __name((e2, n2, r3) => J22("mark", { key: r3.key }, n2(e2.children, r3)), "l") }, 32: { t: ["~~"], o: Te(ne), i: 3, u: Ue, l: __name((e2, n2, r3) => J22("del", { key: r3.key }, n2(e2.children, r3)), "l") } };
    t.disableParsingRawHTML === !0 && (delete se2[11], delete se2[13]);
    let fe2 = (function(e2) {
      var n2 = Object.keys(e2);
      function r3(t2, o2) {
        var a22 = [];
        if (o2.prevCapture = o2.prevCapture || "", t2.trim()) for (; t2; ) for (var c22 = 0; c22 < n2.length; ) {
          var i22 = n2[c22], u22 = e2[i22];
          if (!u22.t || Ae(t2, o2, u22.t)) {
            var l2 = u22.o(t2, o2);
            if (l2 && l2[0]) {
              t2 = t2.substring(l2[0].length);
              var s32 = u22.u(l2, r3, o2);
              o2.prevCapture += l2[0], s32.type || (s32.type = i22), a22.push(s32);
              break;
            }
            c22++;
          } else c22++;
        }
        return o2.prevCapture = "", a22;
      }
      return __name(r3, "r"), n2.sort(function(n3, r4) {
        return e2[n3].i - e2[r4].i || (n3 < r4 ? -1 : 1);
      }), function(e3, n3) {
        return r3((function(e4) {
          return e4.replace(x2, `
`).replace($2, "").replace(U2, "    ");
        })(e3), n3);
      };
    })(se2), _e2 = (de2 = /* @__PURE__ */ (function(e2, n2) {
      return function(r3, t2, o2) {
        let a22 = e2[r3.type].l;
        return n2 ? n2(() => a22(r3, t2, o2), r3, t2, o2) : a22(r3, t2, o2);
      };
    })(se2, t.renderRule), __name(function e2(n2, r3 = {}) {
      if (Array.isArray(n2)) {
        let t2 = r3.key, o2 = [], a22 = !1;
        for (let t3 = 0; t3 < n2.length; t3++) {
          r3.key = t3;
          let c22 = e2(n2[t3], r3), i22 = typeof c22 == "string";
          i22 && a22 ? o2[o2.length - 1] += c22 : c22 !== null && o2.push(c22), a22 = i22;
        }
        return r3.key = t2, o2;
      }
      return de2(n2, e2, r3);
    }, "e"));
    var de2;
    let pe2 = K22(r2);
    return ue22.length ? J22("div", null, pe2, J22("footer", { key: "footer" }, ue22.map(function(e2) {
      return J22("div", { id: s22(e2.identifier, Re), key: e2.identifier }, e2.identifier, _e2(fe2(e2.footnote, { inline: !0 })));
    }))) : pe2;
  }
  __name(Je, "Je");
  var index_modern_default = __name((n2) => {
    let { children: t = "", options: o2 } = n2, a22 = (function(e2, n3) {
      if (e2 == null) return {};
      var r2, t2, o3 = {}, a3 = Object.keys(e2);
      for (t2 = 0; t2 < a3.length; t2++) n3.indexOf(r2 = a3[t2]) >= 0 || (o3[r2] = e2[r2]);
      return o3;
    })(n2, r);
    return cloneElement(Je(t, o2), a22);
  }, "default"), Label22 = styled.label(({ theme: theme3 }) => ({
    lineHeight: "18px",
    alignItems: "center",
    marginBottom: 8,
    display: "inline-block",
    position: "relative",
    whiteSpace: "nowrap",
    background: theme3.boolean.background,
    borderRadius: "3em",
    padding: 1,
    '&[aria-disabled="true"]': {
      opacity: 0.5,
      input: {
        cursor: "not-allowed"
      }
    },
    input: {
      appearance: "none",
      width: "100%",
      height: "100%",
      position: "absolute",
      left: 0,
      top: 0,
      margin: 0,
      padding: 0,
      border: "none",
      background: "transparent",
      cursor: "pointer",
      borderRadius: "3em",
      "&:focus": {
        outline: "none",
        boxShadow: `${theme3.color.secondary} 0 0 0 1px inset !important`
      },
      "@media (forced-colors: active)": {
        "&:focus": {
          outline: "1px solid highlight"
        }
      }
    },
    span: {
      textAlign: "center",
      fontSize: theme3.typography.size.s1,
      fontWeight: theme3.typography.weight.bold,
      lineHeight: "1",
      cursor: "pointer",
      display: "inline-block",
      padding: "7px 15px",
      transition: "all 100ms ease-out",
      userSelect: "none",
      borderRadius: "3em",
      color: curriedTransparentize$1(0.5, theme3.color.defaultText),
      background: "transparent",
      "&:hover": {
        boxShadow: `${curriedOpacify$1(0.3, theme3.appBorderColor)} 0 0 0 1px inset`
      },
      "&:active": {
        boxShadow: `${curriedOpacify$1(0.05, theme3.appBorderColor)} 0 0 0 2px inset`,
        color: curriedOpacify$1(1, theme3.appBorderColor)
      },
      "&:first-of-type": {
        paddingRight: 8
      },
      "&:last-of-type": {
        paddingLeft: 8
      }
    },
    "input:checked ~ span:last-of-type, input:not(:checked) ~ span:first-of-type": {
      background: theme3.boolean.selectedBackground,
      boxShadow: theme3.base === "light" ? `${curriedOpacify$1(0.1, theme3.appBorderColor)} 0 0 2px` : `${theme3.appBorderColor} 0 0 0 1px`,
      color: theme3.color.defaultText,
      padding: "7px 15px",
      "@media (forced-colors: active)": {
        textDecoration: "underline"
      }
    }
  })), parse4 = __name((value2) => value2 === "true", "parse"), BooleanControl = __name(({
    name,
    value: value2,
    onChange,
    onBlur,
    onFocus,
    argType
  }) => {
    let onSetFalse = useCallback(() => onChange(!1), [onChange]), readonly = !!argType?.table?.readonly;
    if (value2 === void 0)
      return react_default.createElement(
        Button2,
        {
          variant: "outline",
          size: "medium",
          id: getControlSetterButtonId(name),
          onClick: onSetFalse,
          disabled: readonly
        },
        "Set boolean"
      );
    let controlId = getControlId(name), parsedValue = typeof value2 == "string" ? parse4(value2) : value2;
    return react_default.createElement(Label22, { "aria-disabled": readonly, htmlFor: controlId, "aria-label": name }, react_default.createElement(
      "input",
      {
        id: controlId,
        type: "checkbox",
        onChange: (e2) => onChange(e2.target.checked),
        checked: parsedValue,
        role: "switch",
        disabled: readonly,
        name,
        onBlur,
        onFocus
      }
    ), react_default.createElement("span", { "aria-hidden": "true" }, "False"), react_default.createElement("span", { "aria-hidden": "true" }, "True"));
  }, "BooleanControl"), parseDate = __name((value2) => {
    let [year, month, day] = value2.split("-"), result = /* @__PURE__ */ new Date();
    return result.setFullYear(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10)), result;
  }, "parseDate"), parseTime = __name((value2) => {
    let [hours, minutes] = value2.split(":"), result = /* @__PURE__ */ new Date();
    return result.setHours(parseInt(hours, 10)), result.setMinutes(parseInt(minutes, 10)), result;
  }, "parseTime"), formatDate = __name((value2) => {
    let date = new Date(value2), year = `000${date.getFullYear()}`.slice(-4), month = `0${date.getMonth() + 1}`.slice(-2), day = `0${date.getDate()}`.slice(-2);
    return `${year}-${month}-${day}`;
  }, "formatDate"), formatTime = __name((value2) => {
    let date = new Date(value2), hours = `0${date.getHours()}`.slice(-2), minutes = `0${date.getMinutes()}`.slice(-2);
    return `${hours}:${minutes}`;
  }, "formatTime"), FormInput = styled(Form2.Input)(({ readOnly }) => ({
    opacity: readOnly ? 0.5 : 1
  })), FlexSpaced = styled.div(({ theme: theme3 }) => ({
    flex: 1,
    display: "flex",
    input: {
      marginLeft: 10,
      flex: 1,
      height: 32,
      // hardcode height bc Chromium bug https://bugs.chromium.org/p/chromium/issues/detail?id=417606
      "&::-webkit-calendar-picker-indicator": {
        opacity: 0.5,
        height: 12,
        filter: theme3.base === "light" ? void 0 : "invert(1)"
      }
    },
    "input:first-of-type": {
      marginLeft: 0,
      flexGrow: 4
    },
    "input:last-of-type": {
      flexGrow: 3
    }
  })), DateControl = __name(({ name, value: value2, onChange, onFocus, onBlur, argType }) => {
    let [valid, setValid] = useState(!0), dateRef = useRef(), timeRef = useRef(), readonly = !!argType?.table?.readonly;
    useEffect(() => {
      valid !== !1 && (dateRef && dateRef.current && (dateRef.current.value = value2 ? formatDate(value2) : ""), timeRef && timeRef.current && (timeRef.current.value = value2 ? formatTime(value2) : ""));
    }, [value2]);
    let onDateChange = __name((e2) => {
      if (!e2.target.value)
        return onChange();
      let parsed = parseDate(e2.target.value), result = new Date(value2 ?? "");
      result.setFullYear(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
      let time = result.getTime();
      time && onChange(time), setValid(!!time);
    }, "onDateChange"), onTimeChange = __name((e2) => {
      if (!e2.target.value)
        return onChange();
      let parsed = parseTime(e2.target.value), result = new Date(value2 ?? "");
      result.setHours(parsed.getHours()), result.setMinutes(parsed.getMinutes());
      let time = result.getTime();
      time && onChange(time), setValid(!!time);
    }, "onTimeChange"), controlId = getControlId(name);
    return react_default.createElement(FlexSpaced, null, react_default.createElement(
      FormInput,
      {
        type: "date",
        max: "9999-12-31",
        ref: dateRef,
        id: `${controlId}-date`,
        name: `${controlId}-date`,
        readOnly: readonly,
        onChange: onDateChange,
        onFocus,
        onBlur
      }
    ), react_default.createElement(
      FormInput,
      {
        type: "time",
        id: `${controlId}-time`,
        name: `${controlId}-time`,
        ref: timeRef,
        onChange: onTimeChange,
        readOnly: readonly,
        onFocus,
        onBlur
      }
    ), valid ? null : react_default.createElement("div", null, "invalid"));
  }, "DateControl"), Wrapper42 = styled.label({
    display: "flex"
  }), parse22 = __name((value2) => {
    let result = parseFloat(value2);
    return Number.isNaN(result) ? void 0 : result;
  }, "parse"), FormInput2 = styled(Form2.Input)(({ readOnly }) => ({
    opacity: readOnly ? 0.5 : 1
  })), NumberControl = __name(({
    name,
    value: value2,
    onChange,
    min: min2,
    max: max2,
    step: step2,
    onBlur,
    onFocus,
    argType
  }) => {
    let [inputValue, setInputValue] = useState(typeof value2 == "number" ? value2 : ""), [forceVisible, setForceVisible] = useState(!1), [parseError, setParseError] = useState(null), readonly = !!argType?.table?.readonly, handleChange = useCallback(
      (event) => {
        setInputValue(event.target.value);
        let result = parseFloat(event.target.value);
        Number.isNaN(result) ? setParseError(new Error(`'${event.target.value}' is not a number`)) : (onChange(result), setParseError(null));
      },
      [onChange, setParseError]
    ), onForceVisible = useCallback(() => {
      setInputValue("0"), onChange(0), setForceVisible(!0);
    }, [setForceVisible]), htmlElRef = useRef(null);
    return useEffect(() => {
      forceVisible && htmlElRef.current && htmlElRef.current.select();
    }, [forceVisible]), useEffect(() => {
      let newInputValue = typeof value2 == "number" ? value2 : "";
      inputValue !== newInputValue && setInputValue(newInputValue);
    }, [value2]), value2 === void 0 ? react_default.createElement(
      Button2,
      {
        variant: "outline",
        size: "medium",
        id: getControlSetterButtonId(name),
        onClick: onForceVisible,
        disabled: readonly
      },
      "Set number"
    ) : react_default.createElement(Wrapper42, null, react_default.createElement(
      FormInput2,
      {
        ref: htmlElRef,
        id: getControlId(name),
        type: "number",
        onChange: handleChange,
        size: "flex",
        placeholder: "Edit number...",
        value: inputValue,
        valid: parseError ? "error" : void 0,
        autoFocus: forceVisible,
        readOnly: readonly,
        name,
        min: min2,
        max: max2,
        step: step2,
        onFocus,
        onBlur
      }
    ));
  }, "NumberControl"), selectedKey = __name((value2, options2) => {
    let entry = options2 && Object.entries(options2).find(([_key, val]) => val === value2);
    return entry ? entry[0] : void 0;
  }, "selectedKey"), selectedKeys = __name((value2, options2) => value2 && options2 ? Object.entries(options2).filter((entry) => value2.includes(entry[1])).map((entry) => entry[0]) : [], "selectedKeys"), selectedValues = __name((keys, options2) => keys && options2 && keys.map((key) => options2[key]), "selectedValues"), Wrapper52 = styled.div(
    ({ isInline }) => isInline ? {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "flex-start",
      label: {
        display: "inline-flex",
        marginRight: 15
      }
    } : {
      label: {
        display: "flex"
      }
    },
    (props) => {
      if (props["aria-readonly"] === "true")
        return {
          input: {
            cursor: "not-allowed"
          }
        };
    }
  ), Text = styled.span({
    "[aria-readonly=true] &": {
      opacity: 0.5
    }
  }), Label3 = styled.label({
    lineHeight: "20px",
    alignItems: "center",
    marginBottom: 8,
    "&:last-child": {
      marginBottom: 0
    },
    input: {
      margin: 0,
      marginRight: 6
    }
  }), CheckboxControl = __name(({
    name,
    options: options2,
    value: value2,
    onChange,
    isInline,
    argType
  }) => {
    if (!options2)
      return logger.warn(`Checkbox with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-");
    let initial = selectedKeys(value2 || [], options2), [selected, setSelected] = useState(initial), readonly = !!argType?.table?.readonly, handleChange = __name((e2) => {
      let option = e2.target.value, updated = [...selected];
      updated.includes(option) ? updated.splice(updated.indexOf(option), 1) : updated.push(option), onChange(selectedValues(updated, options2)), setSelected(updated);
    }, "handleChange");
    useEffect(() => {
      setSelected(selectedKeys(value2 || [], options2));
    }, [value2]);
    let controlId = getControlId(name);
    return react_default.createElement(Wrapper52, { "aria-readonly": readonly, isInline }, Object.keys(options2).map((key, index3) => {
      let id2 = `${controlId}-${index3}`;
      return react_default.createElement(Label3, { key: id2, htmlFor: id2 }, react_default.createElement(
        "input",
        {
          type: "checkbox",
          disabled: readonly,
          id: id2,
          name: id2,
          value: key,
          onChange: handleChange,
          checked: selected?.includes(key)
        }
      ), react_default.createElement(Text, null, key));
    }));
  }, "CheckboxControl"), Wrapper62 = styled.div(
    ({ isInline }) => isInline ? {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "flex-start",
      label: {
        display: "inline-flex",
        marginRight: 15
      }
    } : {
      label: {
        display: "flex"
      }
    },
    (props) => {
      if (props["aria-readonly"] === "true")
        return {
          input: {
            cursor: "not-allowed"
          }
        };
    }
  ), Text2 = styled.span({
    "[aria-readonly=true] &": {
      opacity: 0.5
    }
  }), Label4 = styled.label({
    lineHeight: "20px",
    alignItems: "center",
    marginBottom: 8,
    "&:last-child": {
      marginBottom: 0
    },
    input: {
      margin: 0,
      marginRight: 6
    }
  }), RadioControl = __name(({
    name,
    options: options2,
    value: value2,
    onChange,
    isInline,
    argType
  }) => {
    if (!options2)
      return logger.warn(`Radio with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-");
    let selection = selectedKey(value2, options2), controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(Wrapper62, { "aria-readonly": readonly, isInline }, Object.keys(options2).map((key, index3) => {
      let id2 = `${controlId}-${index3}`;
      return react_default.createElement(Label4, { key: id2, htmlFor: id2 }, react_default.createElement(
        "input",
        {
          type: "radio",
          id: id2,
          name: controlId,
          disabled: readonly,
          value: key,
          onChange: (e2) => onChange(options2[e2.currentTarget.value]),
          checked: key === selection
        }
      ), react_default.createElement(Text2, null, key));
    }));
  }, "RadioControl"), styleResets2 = {
    // resets
    appearance: "none",
    border: "0 none",
    boxSizing: "inherit",
    display: " block",
    margin: " 0",
    background: "transparent",
    padding: 0,
    fontSize: "inherit",
    position: "relative"
  }, OptionsSelect = styled.select(styleResets2, ({ theme: theme3 }) => ({
    boxSizing: "border-box",
    position: "relative",
    padding: "6px 10px",
    width: "100%",
    color: theme3.input.color || "inherit",
    background: theme3.input.background,
    borderRadius: theme3.input.borderRadius,
    boxShadow: `${theme3.input.border} 0 0 0 1px inset`,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "20px",
    "&:focus": {
      boxShadow: `${theme3.color.secondary} 0 0 0 1px inset`,
      outline: "none"
    },
    "&[disabled]": {
      cursor: "not-allowed",
      opacity: 0.5
    },
    "::placeholder": {
      color: theme3.textMutedColor
    },
    "&[multiple]": {
      overflow: "auto",
      padding: 0,
      option: {
        display: "block",
        padding: "6px 10px",
        marginLeft: 1,
        marginRight: 1
      }
    }
  })), SelectWrapper = styled.span(({ theme: theme3 }) => ({
    display: "inline-block",
    lineHeight: "normal",
    overflow: "hidden",
    position: "relative",
    verticalAlign: "top",
    width: "100%",
    svg: {
      position: "absolute",
      zIndex: 1,
      pointerEvents: "none",
      height: "12px",
      marginTop: "-6px",
      right: "12px",
      top: "50%",
      fill: theme3.textMutedColor,
      path: {
        fill: theme3.textMutedColor
      }
    }
  })), NO_SELECTION = "Choose option...", SingleSelect = __name(({ name, value: value2, options: options2, onChange, argType }) => {
    let handleChange = __name((e2) => {
      onChange(options2[e2.currentTarget.value]);
    }, "handleChange"), selection = selectedKey(value2, options2) || NO_SELECTION, controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(SelectWrapper, null, react_default.createElement(ChevronSmallDownIcon, null), react_default.createElement(OptionsSelect, { disabled: readonly, id: controlId, value: selection, onChange: handleChange }, react_default.createElement("option", { key: "no-selection", disabled: !0 }, NO_SELECTION), Object.keys(options2).map((key) => react_default.createElement("option", { key, value: key }, key))));
  }, "SingleSelect"), MultiSelect = __name(({ name, value: value2, options: options2, onChange, argType }) => {
    let handleChange = __name((e2) => {
      let selection2 = Array.from(e2.currentTarget.options).filter((option) => option.selected).map((option) => option.value);
      onChange(selectedValues(selection2, options2));
    }, "handleChange"), selection = selectedKeys(value2, options2), controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(SelectWrapper, null, react_default.createElement(
      OptionsSelect,
      {
        disabled: readonly,
        id: controlId,
        multiple: !0,
        value: selection,
        onChange: handleChange
      },
      Object.keys(options2).map((key) => react_default.createElement("option", { key, value: key }, key))
    ));
  }, "MultiSelect"), SelectControl = __name((props) => {
    let { name, options: options2 } = props;
    return options2 ? props.isMulti ? react_default.createElement(MultiSelect, { ...props }) : react_default.createElement(SingleSelect, { ...props }) : (logger.warn(`Select with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-"));
  }, "SelectControl"), normalizeOptions2 = __name((options2, labels) => Array.isArray(options2) ? options2.reduce((acc, item) => (acc[labels?.[item] || String(item)] = item, acc), {}) : options2, "normalizeOptions"), Controls = {
    check: CheckboxControl,
    "inline-check": CheckboxControl,
    radio: RadioControl,
    "inline-radio": RadioControl,
    select: SelectControl,
    "multi-select": SelectControl
  }, OptionsControl = __name((props) => {
    let { type = "select", labels, argType } = props, normalized = {
      ...props,
      argType,
      options: argType ? normalizeOptions2(argType.options, labels) : {},
      isInline: type.includes("inline"),
      isMulti: type.includes("multi")
    }, Control = Controls[type];
    if (Control)
      return react_default.createElement(Control, { ...normalized });
    throw new Error(`Unknown options type: ${type}`);
  }, "OptionsControl"), Container3 = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    ":hover": {
      "& > .rejt-accordion-button::after": {
        background: theme3.color.secondary
      },
      "& > .rejt-accordion-region > :is(.rejt-plus-menu, .rejt-minus-menu)": {
        opacity: 1
      }
    }
  })), Trigger2 = styled.button(({ theme: theme3 }) => ({
    padding: 0,
    background: "transparent",
    border: "none",
    marginRight: "3px",
    lineHeight: "22px",
    color: theme3.color.secondary,
    "::after": {
      content: '""',
      position: "absolute",
      top: 0,
      display: "block",
      width: "100%",
      marginLeft: "-1rem",
      height: "22px",
      background: "transparent",
      borderRadius: 4,
      transition: "background 0.2s",
      opacity: 0.1,
      paddingRight: "20px"
    },
    "::before": {
      content: '""',
      position: "absolute"
    },
    '&[aria-expanded="true"]::before': {
      left: -10,
      top: 10,
      borderTop: "3px solid rgba(153,153,153,0.6)",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent"
    },
    '&[aria-expanded="false"]::before': {
      left: -8,
      top: 8,
      borderTop: "3px solid transparent",
      borderBottom: "3px solid transparent",
      borderLeft: "3px solid rgba(153,153,153,0.6)"
    }
  })), Region = styled.div({
    display: "inline"
  });
  function JsonNodeAccordion({
    children,
    name,
    collapsed,
    keyPath,
    deep,
    ...props
  }) {
    let accordionKey = `${keyPath.at(-1) ?? "root"}-${name}-${deep}`, ids = {
      trigger: `${accordionKey}-trigger`,
      region: `${accordionKey}-region`
    }, containerTag = keyPath.length > 0 ? "li" : "div";
    return react_default.createElement(Container3, { as: containerTag }, react_default.createElement(
      Trigger2,
      {
        type: "button",
        "aria-expanded": !collapsed,
        id: ids.trigger,
        "aria-controls": ids.region,
        className: "rejt-accordion-button",
        ...props
      },
      name,
      " :"
    ), react_default.createElement(
      Region,
      {
        role: "region",
        id: ids.region,
        "aria-labelledby": ids.trigger,
        className: "rejt-accordion-region"
      },
      children
    ));
  }
  __name(JsonNodeAccordion, "JsonNodeAccordion");
  var ERROR = "Error", OBJECT = "Object", ARRAY = "Array", STRING = "String", NUMBER = "Number", BOOLEAN = "Boolean", DATE = "Date", NULL = "Null", UNDEFINED = "Undefined", FUNCTION = "Function", SYMBOL = "Symbol", ADD_DELTA_TYPE = "ADD_DELTA_TYPE", REMOVE_DELTA_TYPE = "REMOVE_DELTA_TYPE", UPDATE_DELTA_TYPE = "UPDATE_DELTA_TYPE", VALUE = "value", KEY2 = "key";
  function getObjectType(obj) {
    return obj !== null && typeof obj == "object" && !Array.isArray(obj) && typeof obj[Symbol.iterator] == "function" ? "Iterable" : Object.prototype.toString.call(obj).slice(8, -1);
  }
  __name(getObjectType, "getObjectType");
  function isComponentWillChange(oldValue, newValue) {
    let oldType = getObjectType(oldValue), newType = getObjectType(newValue);
    return (oldType === "Function" || newType === "Function") && newType !== oldType;
  }
  __name(isComponentWillChange, "isComponentWillChange");
  var _JsonAddValue = class extends Component {
    constructor(props) {
      super(props), this.state = {
        inputRefKey: null,
        inputRefValue: null
      }, this.refInputValue = this.refInputValue.bind(this), this.refInputKey = this.refInputKey.bind(this), this.onKeydown = this.onKeydown.bind(this), this.onSubmit = this.onSubmit.bind(this);
    }
    componentDidMount() {
      let { inputRefKey, inputRefValue } = this.state, { onlyValue } = this.props;
      inputRefKey && typeof inputRefKey.focus == "function" && inputRefKey.focus(), onlyValue && inputRefValue && typeof inputRefValue.focus == "function" && inputRefValue.focus();
    }
    onKeydown(event) {
      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat)
        return;
      let { inputRefKey, inputRefValue } = this.state, { addButtonElement, handleCancel } = this.props;
      [inputRefKey, inputRefValue, addButtonElement].some(
        (elm) => elm === event.target
      ) && ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.onSubmit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), handleCancel()));
    }
    onSubmit() {
      let { handleAdd, onlyValue, onSubmitValueParser, keyPath, deep } = this.props, { inputRefKey, inputRefValue } = this.state, result = {};
      if (!onlyValue) {
        if (!inputRefKey.value)
          return;
        result.key = inputRefKey.value;
      }
      result.newValue = onSubmitValueParser(!1, keyPath, deep, result.key, inputRefValue.value), handleAdd(result);
    }
    refInputKey(node) {
      this.state.inputRefKey = node;
    }
    refInputValue(node) {
      this.state.inputRefValue = node;
    }
    render() {
      let {
        handleCancel,
        onlyValue,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        keyPath,
        deep
      } = this.props, addButtonElementLayout = addButtonElement && cloneElement(addButtonElement, {
        onClick: this.onSubmit
      }), cancelButtonElementLayout = cancelButtonElement && cloneElement(cancelButtonElement, {
        onClick: handleCancel
      }), inputElementValue = inputElementGenerator(VALUE, keyPath, deep), inputElementValueLayout = cloneElement(inputElementValue, {
        placeholder: "Value",
        ref: this.refInputValue,
        onKeyDown: this.onKeydown
      }), inputElementKeyLayout = null;
      if (!onlyValue) {
        let inputElementKey = inputElementGenerator(KEY2, keyPath, deep);
        inputElementKeyLayout = cloneElement(inputElementKey, {
          placeholder: "Key",
          ref: this.refInputKey,
          onKeyDown: this.onKeydown
        });
      }
      return react_default.createElement("span", { className: "rejt-add-value-node" }, inputElementKeyLayout, inputElementValueLayout, addButtonElementLayout, cancelButtonElementLayout);
    }
  };
  __name(_JsonAddValue, "JsonAddValue");
  var JsonAddValue = _JsonAddValue;
  JsonAddValue.defaultProps = {
    onlyValue: !1,
    addButtonElement: react_default.createElement("button", null, "+"),
    cancelButtonElement: react_default.createElement("button", null, "c")
  };
  var _JsonArray = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        data: props.data,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        nextDeep: (props.deep ?? 0) + 1,
        collapsed: props.isCollapsed(keyPath, props.deep ?? 0, props.data),
        addFormVisible: !1
      }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveItem = this.handleRemoveItem.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    onChildUpdate(childKey, childData) {
      let { data, keyPath = [] } = this.state;
      data[childKey] = childData, this.setState({
        data
      });
      let { onUpdate } = this.props, size = keyPath.length;
      onUpdate(keyPath[size - 1], data);
    }
    handleAddMode() {
      this.setState({
        addFormVisible: !0
      });
    }
    handleCollapseMode() {
      this.setState((state3) => ({
        collapsed: !state3.collapsed
      }));
    }
    handleRemoveItem(index3) {
      return () => {
        let { beforeRemoveAction, logger: logger5 } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[index3];
        (beforeRemoveAction || Promise.resolve.bind(Promise))(index3, keyPath, deep, oldValue).then(() => {
          let deltaUpdateResult = {
            keyPath,
            deep,
            key: index3,
            oldValue,
            type: REMOVE_DELTA_TYPE
          };
          data.splice(index3, 1), this.setState({ data });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
        }).catch(logger5.error);
      };
    }
    handleAddValueAdd({ newValue }) {
      let { data, keyPath = [], nextDeep: deep } = this.state, { beforeAddAction, logger: logger5 } = this.props, key = data.length;
      (beforeAddAction || Promise.resolve.bind(Promise))(key, keyPath, deep, newValue).then(() => {
        data[key] = newValue, this.setState({
          data
        }), this.handleAddValueCancel();
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
          type: ADD_DELTA_TYPE,
          keyPath,
          deep,
          key,
          newValue
        });
      }).catch(logger5.error);
    }
    handleAddValueCancel() {
      this.setState({
        addFormVisible: !1
      });
    }
    handleEditValue({ key, value: value2 }) {
      return new Promise((resolve, reject) => {
        let { beforeUpdateAction } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[key];
        (beforeUpdateAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue, value2).then(() => {
          data[key] = value2, this.setState({
            data
          });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
            type: UPDATE_DELTA_TYPE,
            keyPath,
            deep,
            key,
            newValue: value2,
            oldValue
          }), resolve(void 0);
        }).catch(reject);
      });
    }
    renderCollapsed() {
      let { name, data, keyPath, deep } = this.state, { handleRemove, readOnly, getStyle, dataType, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the array '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: collapsed }, "[...] ", data.length, " ", data.length === 1 ? "item" : "items"), !isReadOnly && removeItemButton);
    }
    renderNotCollapsed() {
      let { name, data, keyPath, deep, addFormVisible, nextDeep } = this.state, {
        isCollapsed,
        handleRemove,
        onDeltaUpdate,
        readOnly,
        getStyle,
        dataType,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, { minus, plus, delimiter, ul, addForm } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = plusMenuElement && cloneElement(plusMenuElement, {
        onClick: this.handleAddMode,
        className: "rejt-plus-menu",
        style: plus,
        "aria-label": `add a new item to the '${String(name)}' array`
      }), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the array '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "["), !addFormVisible && addItemButton, react_default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, data.map((item, index3) => react_default.createElement(
        JsonNode,
        {
          key: index3,
          name: index3.toString(),
          data: item,
          keyPath,
          deep: nextDeep,
          isCollapsed,
          handleRemove: this.handleRemoveItem(index3),
          handleUpdateValue: this.handleEditValue,
          onUpdate: this.onChildUpdate,
          onDeltaUpdate,
          readOnly,
          getStyle,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          textareaElementGenerator,
          minusMenuElement,
          plusMenuElement,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5,
          onSubmitValueParser
        }
      ))), !isReadOnly && addFormVisible && react_default.createElement("div", { className: "rejt-add-form", style: addForm }, react_default.createElement(
        JsonAddValue,
        {
          handleAdd: this.handleAddValueAdd,
          handleCancel: this.handleAddValueCancel,
          onlyValue: !0,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          keyPath,
          deep,
          onSubmitValueParser
        }
      )), react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "]"), !isReadOnly && removeItemButton);
    }
    render() {
      let { name, collapsed, keyPath, deep } = this.state, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed();
      return react_default.createElement(
        JsonNodeAccordion,
        {
          name,
          collapsed,
          deep,
          keyPath,
          onClick: this.handleCollapseMode
        },
        value2
      );
    }
  };
  __name(_JsonArray, "JsonArray");
  var JsonArray = _JsonArray;
  JsonArray.defaultProps = {
    keyPath: [],
    deep: 0,
    minusMenuElement: react_default.createElement("span", null, " - "),
    plusMenuElement: react_default.createElement("span", null, " + ")
  };
  var _JsonFunctionValue = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        value: props.value,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        editEnabled: !1,
        inputRef: null
      }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.value !== state3.value ? { value: props.value } : null;
    }
    componentDidUpdate() {
      let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, readOnlyResult = readOnly(name, value2, keyPath, deep, dataType);
      editEnabled && !readOnlyResult && typeof inputRef.focus == "function" && inputRef.focus();
    }
    onKeydown(event) {
      let { inputRef } = this.state;
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || inputRef !== event.target || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
    }
    handleEdit() {
      let { handleUpdateValue, originalValue, logger: logger5, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
      if (!inputRef)
        return;
      let newValue = onSubmitValueParser(!0, keyPath, deep, name, inputRef.value), result = {
        value: newValue,
        key: name
      };
      (handleUpdateValue || Promise.resolve.bind(Promise))(result).then(() => {
        isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
      }).catch(logger5.error);
    }
    handleEditMode() {
      this.setState({
        editEnabled: !0
      });
    }
    refInput(node) {
      this.state.inputRef = node;
    }
    handleCancelEdit() {
      this.setState({
        editEnabled: !1
      });
    }
    render() {
      let { name, value: value2, editEnabled, keyPath, deep } = this.state, {
        handleRemove,
        originalValue,
        readOnly,
        dataType,
        getStyle,
        textareaElementGenerator,
        minusMenuElement,
        keyPath: comeFromKeyPath = []
      } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), result = null, minusElement = null, resultOnlyResult = readOnly(name, originalValue, keyPath, deep, dataType);
      if (editEnabled && !resultOnlyResult) {
        let textareaElement = textareaElementGenerator(
          VALUE,
          comeFromKeyPath,
          deep,
          name,
          originalValue,
          dataType
        ), textareaElementLayout = cloneElement(textareaElement, {
          ref: this.refInput,
          defaultValue: value2,
          onKeyDown: this.onKeydown
        });
        result = react_default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, textareaElementLayout), minusElement = null;
      } else {
        result = react_default.createElement(
          "span",
          {
            className: "rejt-value",
            style: style.value,
            onClick: resultOnlyResult ? void 0 : this.handleEditMode
          },
          value2
        );
        let parentPropertyName = comeFromKeyPath.at(-1), minusMenuLayout = minusMenuElement && cloneElement(minusMenuElement, {
          onClick: handleRemove,
          className: "rejt-minus-menu",
          style: style.minus,
          "aria-label": `remove the function '${String(name)}'${String(parentPropertyName) ? ` from '${String(parentPropertyName)}'` : ""}`
        });
        minusElement = resultOnlyResult ? null : minusMenuLayout;
      }
      return react_default.createElement("li", { className: "rejt-value-node", style: style.li }, react_default.createElement("span", { className: "rejt-name", style: style.name }, name, " :", " "), result, minusElement);
    }
  };
  __name(_JsonFunctionValue, "JsonFunctionValue");
  var JsonFunctionValue = _JsonFunctionValue;
  JsonFunctionValue.defaultProps = {
    keyPath: [],
    deep: 0,
    handleUpdateValue: __name(() => {
    }, "handleUpdateValue"),
    cancelButtonElement: react_default.createElement("button", null, "c"),
    minusMenuElement: react_default.createElement("span", null, " - ")
  };
  var _JsonNode = class extends Component {
    constructor(props) {
      super(props), this.state = {
        data: props.data,
        name: props.name,
        keyPath: props.keyPath ?? [],
        deep: props.deep ?? 0
      };
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    render() {
      let { data, name, keyPath, deep } = this.state, {
        isCollapsed,
        handleRemove,
        handleUpdateValue,
        onUpdate,
        onDeltaUpdate,
        readOnly,
        getStyle,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, readOnlyTrue = __name(() => !0, "readOnlyTrue"), dataType = getObjectType(data);
      switch (dataType) {
        case ERROR:
          return react_default.createElement(
            JsonObject,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case OBJECT:
          return react_default.createElement(
            JsonObject,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case ARRAY:
          return react_default.createElement(
            JsonArray,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case STRING:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: `"${data}"`,
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case NUMBER:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data,
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case BOOLEAN:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data ? "true" : "false",
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case DATE:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data.toISOString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case NULL:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: "null",
              originalValue: "null",
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case UNDEFINED:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: "undefined",
              originalValue: "undefined",
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case FUNCTION:
          return react_default.createElement(
            JsonFunctionValue,
            {
              name,
              value: data.toString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              textareaElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case SYMBOL:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data.toString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        default:
          return null;
      }
    }
  };
  __name(_JsonNode, "JsonNode");
  var JsonNode = _JsonNode;
  JsonNode.defaultProps = {
    keyPath: [],
    deep: 0
  };
  var _JsonObject = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = props.deep === -1 ? [] : [...props.keyPath || [], props.name];
      this.state = {
        name: props.name,
        data: props.data,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        nextDeep: (props.deep ?? 0) + 1,
        collapsed: props.isCollapsed(keyPath, props.deep ?? 0, props.data),
        addFormVisible: !1
      }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveValue = this.handleRemoveValue.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    onChildUpdate(childKey, childData) {
      let { data, keyPath = [] } = this.state;
      data[childKey] = childData, this.setState({
        data
      });
      let { onUpdate } = this.props, size = keyPath.length;
      onUpdate(keyPath[size - 1], data);
    }
    handleAddMode() {
      this.setState({
        addFormVisible: !0
      });
    }
    handleAddValueCancel() {
      this.setState({
        addFormVisible: !1
      });
    }
    handleAddValueAdd({ key, newValue }) {
      let { data, keyPath = [], nextDeep: deep } = this.state, { beforeAddAction, logger: logger5 } = this.props;
      (beforeAddAction || Promise.resolve.bind(Promise))(key, keyPath, deep, newValue).then(() => {
        data[key] = newValue, this.setState({
          data
        }), this.handleAddValueCancel();
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
          type: ADD_DELTA_TYPE,
          keyPath,
          deep,
          key,
          newValue
        });
      }).catch(logger5.error);
    }
    handleRemoveValue(key) {
      return () => {
        let { beforeRemoveAction, logger: logger5 } = this.props, { data, keyPath = [], nextDeep: deep } = this.state, oldValue = data[key];
        (beforeRemoveAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue).then(() => {
          let deltaUpdateResult = {
            keyPath,
            deep,
            key,
            oldValue,
            type: REMOVE_DELTA_TYPE
          };
          delete data[key], this.setState({ data });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
        }).catch(logger5.error);
      };
    }
    handleCollapseMode() {
      this.setState((state3) => ({
        collapsed: !state3.collapsed
      }));
    }
    handleEditValue({ key, value: value2 }) {
      return new Promise((resolve, reject) => {
        let { beforeUpdateAction } = this.props, { data, keyPath = [], nextDeep: deep } = this.state, oldValue = data[key];
        (beforeUpdateAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue, value2).then(() => {
          data[key] = value2, this.setState({
            data
          });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
            type: UPDATE_DELTA_TYPE,
            keyPath,
            deep,
            key,
            newValue: value2,
            oldValue
          }), resolve();
        }).catch(reject);
      });
    }
    renderCollapsed() {
      let { name, keyPath, deep, data } = this.state, { handleRemove, readOnly, dataType, getStyle, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the object '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: collapsed }, "{...}", " ", keyList.length, " ", keyList.length === 1 ? "key" : "keys"), !isReadOnly && removeItemButton);
    }
    renderNotCollapsed() {
      let { name, data, keyPath, deep, nextDeep, addFormVisible } = this.state, {
        isCollapsed,
        handleRemove,
        onDeltaUpdate,
        readOnly,
        getStyle,
        dataType,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, { minus, plus, addForm, ul, delimiter } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = plusMenuElement && cloneElement(plusMenuElement, {
        onClick: this.handleAddMode,
        className: "rejt-plus-menu",
        style: plus,
        "aria-label": `add a new property to the object '${String(name)}'`
      }), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the object '${String(name)}'`
      }), list = keyList.map((key) => react_default.createElement(
        JsonNode,
        {
          key,
          name: key,
          data: data[key],
          keyPath,
          deep: nextDeep,
          isCollapsed,
          handleRemove: this.handleRemoveValue(key),
          handleUpdateValue: this.handleEditValue,
          onUpdate: this.onChildUpdate,
          onDeltaUpdate,
          readOnly,
          getStyle,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          textareaElementGenerator,
          minusMenuElement,
          plusMenuElement,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5,
          onSubmitValueParser
        }
      ));
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "{"), !isReadOnly && addItemButton, react_default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, list), !isReadOnly && addFormVisible && react_default.createElement("div", { className: "rejt-add-form", style: addForm }, react_default.createElement(
        JsonAddValue,
        {
          handleAdd: this.handleAddValueAdd,
          handleCancel: this.handleAddValueCancel,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          keyPath,
          deep,
          onSubmitValueParser
        }
      )), react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "}"), !isReadOnly && removeItemButton);
    }
    render() {
      let { name, collapsed, keyPath, deep = 0 } = this.state, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed();
      return react_default.createElement(
        JsonNodeAccordion,
        {
          name,
          collapsed,
          deep,
          keyPath,
          onClick: this.handleCollapseMode
        },
        value2
      );
    }
  };
  __name(_JsonObject, "JsonObject");
  var JsonObject = _JsonObject;
  JsonObject.defaultProps = {
    keyPath: [],
    deep: 0,
    minusMenuElement: react_default.createElement("span", null, " - "),
    plusMenuElement: react_default.createElement("span", null, " + ")
  };
  var _JsonValue = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        value: props.value,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        editEnabled: !1,
        inputRef: null
      }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.value !== state3.value ? { value: props.value } : null;
    }
    componentDidUpdate() {
      let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, isReadOnly = readOnly(name, value2, keyPath, deep, dataType);
      editEnabled && !isReadOnly && typeof inputRef.focus == "function" && inputRef.focus();
    }
    onKeydown(event) {
      let { inputRef } = this.state;
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || inputRef !== event.target || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
    }
    handleEdit() {
      let { handleUpdateValue, originalValue, logger: logger5, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
      if (!inputRef)
        return;
      let newValue = onSubmitValueParser(!0, keyPath, deep, name, inputRef.value), result = {
        value: newValue,
        key: name
      };
      (handleUpdateValue || Promise.resolve.bind(Promise))(result).then(() => {
        isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
      }).catch(logger5.error);
    }
    handleEditMode() {
      this.setState({
        editEnabled: !0
      });
    }
    refInput(node) {
      this.state.inputRef = node;
    }
    handleCancelEdit() {
      this.setState({
        editEnabled: !1
      });
    }
    render() {
      let { name, value: value2, editEnabled, keyPath, deep } = this.state, {
        handleRemove,
        originalValue,
        readOnly,
        dataType,
        getStyle,
        inputElementGenerator,
        minusMenuElement,
        keyPath: comeFromKeyPath
      } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), isReadOnly = readOnly(name, originalValue, keyPath, deep, dataType), isEditing = editEnabled && !isReadOnly, inputElement = inputElementGenerator(
        VALUE,
        comeFromKeyPath,
        deep,
        name,
        originalValue,
        dataType
      ), inputElementLayout = cloneElement(inputElement, {
        ref: this.refInput,
        defaultValue: JSON.stringify(originalValue),
        onKeyDown: this.onKeydown
      }), parentPropertyName = keyPath.at(-2), minusMenuLayout = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: style.minus,
        "aria-label": `remove the property '${String(name)}' with value '${String(originalValue)}'${String(parentPropertyName) ? ` from '${String(parentPropertyName)}'` : ""}`
      });
      return react_default.createElement("li", { className: "rejt-value-node", style: style.li }, react_default.createElement("span", { className: "rejt-name", style: style.name }, name, " : "), isEditing ? react_default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, inputElementLayout) : react_default.createElement(
        "span",
        {
          className: "rejt-value",
          style: style.value,
          onClick: isReadOnly ? void 0 : this.handleEditMode
        },
        String(value2)
      ), !isReadOnly && !isEditing && minusMenuLayout);
    }
  };
  __name(_JsonValue, "JsonValue");
  var JsonValue = _JsonValue;
  JsonValue.defaultProps = {
    keyPath: [],
    deep: 0,
    handleUpdateValue: __name(() => Promise.resolve(), "handleUpdateValue"),
    cancelButtonElement: react_default.createElement("button", null, "c"),
    minusMenuElement: react_default.createElement("span", null, " - ")
  };
  function parse32(string) {
    let result = string;
    if (result.indexOf("function") === 0)
      return (0, eval)(`(${result})`);
    try {
      result = JSON.parse(string);
    } catch {
    }
    return result;
  }
  __name(parse32, "parse");
  var object = {
    minus: {
      color: "red"
    },
    plus: {
      color: "green"
    },
    collapsed: {
      color: "grey"
    },
    delimiter: {},
    ul: {
      padding: "0px",
      margin: "0 0 0 25px",
      listStyle: "none"
    },
    name: {
      color: "#2287CD"
    },
    addForm: {}
  }, array = {
    minus: {
      color: "red"
    },
    plus: {
      color: "green"
    },
    collapsed: {
      color: "grey"
    },
    delimiter: {},
    ul: {
      padding: "0px",
      margin: "0 0 0 25px",
      listStyle: "none"
    },
    name: {
      color: "#2287CD"
    },
    addForm: {}
  }, value = {
    minus: {
      color: "red"
    },
    editForm: {},
    value: {
      color: "#7bba3d"
    },
    li: {
      minHeight: "22px",
      lineHeight: "22px",
      outline: "0px"
    },
    name: {
      color: "#2287CD"
    }
  }, _JsonTree = class extends Component {
    constructor(props) {
      super(props), this.state = {
        data: props.data,
        rootName: props.rootName
      }, this.onUpdate = this.onUpdate.bind(this), this.removeRoot = this.removeRoot.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data || props.rootName !== state3.rootName ? {
        data: props.data,
        rootName: props.rootName
      } : null;
    }
    onUpdate(key, data) {
      this.setState({ data }), this.props.onFullyUpdate?.(data);
    }
    removeRoot() {
      this.onUpdate(null, null);
    }
    render() {
      let { data, rootName } = this.state, {
        isCollapsed,
        onDeltaUpdate,
        readOnly,
        getStyle,
        addButtonElement,
        cancelButtonElement,
        inputElement,
        textareaElement,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser,
        fallback = null
      } = this.props, dataType = getObjectType(data), readOnlyFunction = readOnly;
      getObjectType(readOnly) === "Boolean" && (readOnlyFunction = __name(() => readOnly, "readOnlyFunction"));
      let inputElementFunction = inputElement;
      inputElement && getObjectType(inputElement) !== "Function" && (inputElementFunction = __name(() => inputElement, "inputElementFunction"));
      let textareaElementFunction = textareaElement;
      return textareaElement && getObjectType(textareaElement) !== "Function" && (textareaElementFunction = __name(() => textareaElement, "textareaElementFunction")), dataType === "Object" || dataType === "Array" ? react_default.createElement("div", { className: "rejt-tree" }, react_default.createElement(
        JsonNode,
        {
          data,
          name: rootName || "root",
          deep: -1,
          isCollapsed: isCollapsed ?? (() => !1),
          onUpdate: this.onUpdate,
          onDeltaUpdate: onDeltaUpdate ?? (() => {
          }),
          readOnly: readOnlyFunction,
          getStyle: getStyle ?? (() => ({})),
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator: inputElementFunction,
          textareaElementGenerator: textareaElementFunction,
          minusMenuElement,
          plusMenuElement,
          handleRemove: this.removeRoot,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5 ?? {},
          onSubmitValueParser: onSubmitValueParser ?? ((val) => val)
        }
      )) : fallback;
    }
  };
  __name(_JsonTree, "JsonTree");
  var JsonTree = _JsonTree;
  JsonTree.defaultProps = {
    rootName: "root",
    isCollapsed: __name((keyPath, deep) => deep !== -1, "isCollapsed"),
    getStyle: __name((keyName, data, keyPath, deep, dataType) => {
      switch (dataType) {
        case "Object":
        case "Error":
          return object;
        case "Array":
          return array;
        default:
          return value;
      }
    }, "getStyle"),
    readOnly: __name(() => !1, "readOnly"),
    onFullyUpdate: __name(() => {
    }, "onFullyUpdate"),
    onDeltaUpdate: __name(() => {
    }, "onDeltaUpdate"),
    beforeRemoveAction: __name(() => Promise.resolve(), "beforeRemoveAction"),
    beforeAddAction: __name(() => Promise.resolve(), "beforeAddAction"),
    beforeUpdateAction: __name(() => Promise.resolve(), "beforeUpdateAction"),
    logger: { error: __name(() => {
    }, "error") },
    onSubmitValueParser: __name((isEditMode, keyPath, deep, name, rawValue) => parse32(rawValue), "onSubmitValueParser"),
    inputElement: __name(() => react_default.createElement("input", null), "inputElement"),
    textareaElement: __name(() => react_default.createElement("textarea", null), "textareaElement"),
    fallback: null
  };
  var { window: globalWindow22 } = globalThis, Wrapper7 = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    display: "flex",
    '&[aria-readonly="true"]': {
      opacity: 0.5
    },
    ".rejt-tree": {
      marginLeft: "1rem",
      fontSize: "13px",
      listStyleType: "none"
    },
    ".rejt-value-node:hover": {
      "& > button": {
        opacity: 1
      }
    },
    ".rejt-add-form": {
      marginLeft: 10
    },
    ".rejt-add-value-node": {
      display: "inline-flex",
      alignItems: "center"
    },
    ".rejt-name": {
      lineHeight: "22px"
    },
    ".rejt-not-collapsed-delimiter": {
      lineHeight: "22px"
    },
    ".rejt-value": {
      display: "inline-block",
      border: "1px solid transparent",
      borderRadius: 4,
      margin: "1px 0",
      padding: "0 4px",
      cursor: "text",
      color: theme3.color.defaultText
    },
    ".rejt-value-node:hover > .rejt-value": {
      background: theme3.color.lighter,
      borderColor: theme3.appBorderColor
    }
  })), ButtonInline = styled.button(({ theme: theme3, primary }) => ({
    border: 0,
    height: 20,
    margin: 1,
    borderRadius: 4,
    background: primary ? theme3.color.secondary : "transparent",
    color: primary ? theme3.color.lightest : theme3.color.dark,
    fontWeight: primary ? "bold" : "normal",
    cursor: "pointer"
  })), ActionButton2 = styled.button(({ theme: theme3 }) => ({
    background: "none",
    border: 0,
    display: "inline-flex",
    verticalAlign: "middle",
    padding: 3,
    marginLeft: 5,
    color: theme3.textMutedColor,
    opacity: 0,
    transition: "opacity 0.2s",
    cursor: "pointer",
    position: "relative",
    svg: {
      width: 9,
      height: 9
    },
    ":disabled": {
      cursor: "not-allowed"
    },
    ":hover, :focus-visible": {
      opacity: 1
    },
    "&:hover:not(:disabled), &:focus-visible:not(:disabled)": {
      "&.rejt-plus-menu": {
        color: theme3.color.ancillary
      },
      "&.rejt-minus-menu": {
        color: theme3.color.negative
      }
    }
  })), Input6 = styled.input(({ theme: theme3, placeholder }) => ({
    outline: 0,
    margin: placeholder ? 1 : "1px 0",
    padding: "3px 4px",
    color: theme3.color.defaultText,
    background: theme3.background.app,
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 4,
    lineHeight: "14px",
    width: placeholder === "Key" ? 80 : 120,
    "&:focus": {
      border: `1px solid ${theme3.color.secondary}`
    }
  })), RawButton = styled(IconButton2)(({ theme: theme3 }) => ({
    position: "absolute",
    zIndex: 2,
    top: 2,
    right: 2,
    height: 21,
    padding: "0 3px",
    background: theme3.background.bar,
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 3,
    color: theme3.textMutedColor,
    fontSize: "9px",
    fontWeight: "bold",
    textDecoration: "none",
    span: {
      marginLeft: 3,
      marginTop: 1
    }
  })), RawInput = styled(Form2.Textarea)(({ theme: theme3 }) => ({
    flex: 1,
    padding: "7px 6px",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: "12px",
    lineHeight: "18px",
    "&::placeholder": {
      fontFamily: theme3.typography.fonts.base,
      fontSize: "13px"
    },
    "&:placeholder-shown": {
      padding: "7px 10px"
    }
  })), ENTER_EVENT = {
    bubbles: !0,
    cancelable: !0,
    key: "Enter",
    code: "Enter",
    keyCode: 13
  }, dispatchEnterKey = __name((event) => {
    event.currentTarget.dispatchEvent(new globalWindow22.KeyboardEvent("keydown", ENTER_EVENT));
  }, "dispatchEnterKey"), selectValue = __name((event) => {
    event.currentTarget.select();
  }, "selectValue"), getCustomStyleFunction = __name((theme3) => () => ({
    name: {
      color: theme3.color.secondary
    },
    collapsed: {
      color: theme3.color.dark
    },
    ul: {
      listStyle: "none",
      margin: "0 0 0 1rem",
      padding: 0
    },
    li: {
      outline: 0
    }
  }), "getCustomStyleFunction"), ObjectControl = __name(({ name, value: value2, onChange, argType }) => {
    let theme3 = useTheme(), data = useMemo(() => value2 && cloneDeep(value2), [value2]), hasData = data != null, [showRaw, setShowRaw] = useState(!hasData), [parseError, setParseError] = useState(null), readonly = !!argType?.table?.readonly, updateRaw = useCallback(
      (raw) => {
        try {
          raw && onChange(JSON.parse(raw)), setParseError(null);
        } catch (e2) {
          setParseError(e2);
        }
      },
      [onChange]
    ), [forceVisible, setForceVisible] = useState(!1), onForceVisible = useCallback(() => {
      onChange({}), setForceVisible(!0);
    }, [setForceVisible]), htmlElRef = useRef(null);
    if (useEffect(() => {
      forceVisible && htmlElRef.current && htmlElRef.current.select();
    }, [forceVisible]), !hasData)
      return react_default.createElement(Button2, { disabled: readonly, id: getControlSetterButtonId(name), onClick: onForceVisible }, "Set object");
    let rawJSONForm = react_default.createElement(
      RawInput,
      {
        ref: htmlElRef,
        id: getControlId(name),
        name,
        defaultValue: value2 === null ? "" : JSON.stringify(value2, null, 2),
        onBlur: (event) => updateRaw(event.target.value),
        placeholder: "Edit JSON string...",
        autoFocus: forceVisible,
        valid: parseError ? "error" : void 0,
        readOnly: readonly
      }
    ), isObjectOrArray = Array.isArray(value2) || typeof value2 == "object" && value2?.constructor === Object;
    return react_default.createElement(Wrapper7, { "aria-readonly": readonly }, isObjectOrArray && react_default.createElement(
      RawButton,
      {
        role: "switch",
        "aria-checked": showRaw,
        "aria-label": `Edit the ${name} properties in text format`,
        onClick: (e2) => {
          e2.preventDefault(), setShowRaw((isRaw) => !isRaw);
        }
      },
      showRaw ? react_default.createElement(EyeCloseIcon, null) : react_default.createElement(EyeIcon, null),
      react_default.createElement("span", null, "RAW")
    ), showRaw ? rawJSONForm : react_default.createElement(
      JsonTree,
      {
        readOnly: readonly || !isObjectOrArray,
        isCollapsed: isObjectOrArray ? (
          /* default value */
          void 0
        ) : () => !0,
        data,
        rootName: name,
        onFullyUpdate: onChange,
        getStyle: getCustomStyleFunction(theme3),
        cancelButtonElement: react_default.createElement(ButtonInline, { type: "button" }, "Cancel"),
        addButtonElement: react_default.createElement(ButtonInline, { type: "submit", primary: !0 }, "Save"),
        plusMenuElement: react_default.createElement(ActionButton2, { type: "button" }, react_default.createElement(AddIcon, null)),
        minusMenuElement: react_default.createElement(ActionButton2, { type: "button" }, react_default.createElement(SubtractIcon, null)),
        inputElement: (_22, __, ___, key) => key ? react_default.createElement(Input6, { onFocus: selectValue, onBlur: dispatchEnterKey }) : react_default.createElement(Input6, null),
        fallback: rawJSONForm
      }
    ));
  }, "ObjectControl"), RangeInput = styled.input(
    ({ theme: theme3, min: min2, max: max2, value: value2, disabled }) => ({
      // Resytled using http://danielstern.ca/range.css/#/
      "&": {
        width: "100%",
        backgroundColor: "transparent",
        appearance: "none"
      },
      "&::-webkit-slider-runnable-track": {
        background: theme3.base === "light" ? `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        boxShadow: `${theme3.appBorderColor} 0 0 0 1px inset`,
        borderRadius: 6,
        width: "100%",
        height: 6,
        cursor: disabled ? "not-allowed" : "pointer"
      },
      "&::-webkit-slider-thumb": {
        marginTop: "-6px",
        width: 16,
        height: 16,
        border: `1px solid ${rgba(theme3.appBorderColor, 0.2)}`,
        borderRadius: "50px",
        boxShadow: `0 1px 3px 0px ${rgba(theme3.appBorderColor, 0.2)}`,
        cursor: disabled ? "not-allowed" : "grab",
        appearance: "none",
        background: `${theme3.input.background}`,
        transition: "all 150ms ease-out",
        "&:hover": {
          background: `${curriedDarken$1(0.05, theme3.input.background)}`,
          transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)",
          transition: "all 50ms ease-out"
        },
        "&:active": {
          background: `${theme3.input.background}`,
          transform: "scale3d(1, 1, 1) translateY(0px)",
          cursor: disabled ? "not-allowed" : "grab"
        }
      },
      "&:focus": {
        outline: "none",
        "&::-webkit-slider-runnable-track": {
          borderColor: rgba(theme3.color.secondary, 0.4)
        },
        "&::-webkit-slider-thumb": {
          borderColor: theme3.color.secondary,
          boxShadow: `0 0px 5px 0px ${theme3.color.secondary}`
        }
      },
      "&::-moz-range-track": {
        background: theme3.base === "light" ? `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        boxShadow: `${theme3.appBorderColor} 0 0 0 1px inset`,
        borderRadius: 6,
        width: "100%",
        height: 6,
        cursor: disabled ? "not-allowed" : "pointer",
        outline: "none"
      },
      "&::-moz-range-thumb": {
        width: 16,
        height: 16,
        border: `1px solid ${rgba(theme3.appBorderColor, 0.2)}`,
        borderRadius: "50px",
        boxShadow: `0 1px 3px 0px ${rgba(theme3.appBorderColor, 0.2)}`,
        cursor: disabled ? "not-allowed" : "grap",
        background: `${theme3.input.background}`,
        transition: "all 150ms ease-out",
        "&:hover": {
          background: `${curriedDarken$1(0.05, theme3.input.background)}`,
          transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)",
          transition: "all 50ms ease-out"
        },
        "&:active": {
          background: `${theme3.input.background}`,
          transform: "scale3d(1, 1, 1) translateY(0px)",
          cursor: "grabbing"
        }
      },
      "&::-ms-track": {
        background: theme3.base === "light" ? `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min2) / (max2 - min2) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        boxShadow: `${theme3.appBorderColor} 0 0 0 1px inset`,
        color: "transparent",
        width: "100%",
        height: "6px",
        cursor: "pointer"
      },
      "&::-ms-fill-lower": {
        borderRadius: 6
      },
      "&::-ms-fill-upper": {
        borderRadius: 6
      },
      "&::-ms-thumb": {
        width: 16,
        height: 16,
        background: `${theme3.input.background}`,
        border: `1px solid ${rgba(theme3.appBorderColor, 0.2)}`,
        borderRadius: 50,
        cursor: "grab",
        marginTop: 0
      },
      "@supports (-ms-ime-align:auto)": { "input[type=range]": { margin: "0" } }
    })
  ), RangeLabel = styled.span({
    paddingLeft: 5,
    paddingRight: 5,
    fontSize: 12,
    whiteSpace: "nowrap",
    fontFeatureSettings: "tnum",
    fontVariantNumeric: "tabular-nums",
    "[aria-readonly=true] &": {
      opacity: 0.5
    }
  }), RangeCurrentAndMaxLabel = styled(RangeLabel)(({ numberOFDecimalsPlaces, max: max2 }) => ({
    // Fixed width of "current / max" label to avoid slider width changes
    // 3 = size of separator " / "
    width: `${numberOFDecimalsPlaces + max2.toString().length * 2 + 3}ch`,
    textAlign: "right",
    flexShrink: 0
  })), RangeWrapper = styled.div({
    display: "flex",
    alignItems: "center",
    width: "100%"
  });
  function getNumberOfDecimalPlaces(number) {
    let match2 = number.toString().match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    return match2 ? Math.max(
      0,
      // Number of digits right of decimal point.
      (match2[1] ? match2[1].length : 0) - // Adjust for scientific notation.
      (match2[2] ? +match2[2] : 0)
    ) : 0;
  }
  __name(getNumberOfDecimalPlaces, "getNumberOfDecimalPlaces");
  var RangeControl = __name(({
    name,
    value: value2,
    onChange,
    min: min2 = 0,
    max: max2 = 100,
    step: step2 = 1,
    onBlur,
    onFocus,
    argType
  }) => {
    let handleChange = __name((event) => {
      onChange(parse22(event.target.value));
    }, "handleChange"), hasValue = value2 !== void 0, numberOFDecimalsPlaces = useMemo(() => getNumberOfDecimalPlaces(step2), [step2]), readonly = !!argType?.table?.readonly;
    return react_default.createElement(RangeWrapper, { "aria-readonly": readonly }, react_default.createElement(RangeLabel, null, min2), react_default.createElement(
      RangeInput,
      {
        id: getControlId(name),
        type: "range",
        disabled: readonly,
        onChange: handleChange,
        name,
        min: min2,
        max: max2,
        step: step2,
        onFocus,
        onBlur,
        value: value2 ?? min2
      }
    ), react_default.createElement(RangeCurrentAndMaxLabel, { numberOFDecimalsPlaces, max: max2 }, hasValue ? value2.toFixed(numberOFDecimalsPlaces) : "--", " / ", max2));
  }, "RangeControl"), Wrapper8 = styled.label({
    display: "flex"
  }), MaxLength = styled.div(({ isMaxed }) => ({
    marginLeft: "0.75rem",
    paddingTop: "0.35rem",
    color: isMaxed ? "red" : void 0
  })), TextControl = __name(({
    name,
    value: value2,
    onChange,
    onFocus,
    onBlur,
    maxLength,
    argType
  }) => {
    let handleChange = __name((event) => {
      onChange(event.target.value);
    }, "handleChange"), readonly = !!argType?.table?.readonly, [forceVisible, setForceVisible] = useState(!1), onForceVisible = useCallback(() => {
      onChange(""), setForceVisible(!0);
    }, [setForceVisible]);
    if (value2 === void 0)
      return react_default.createElement(
        Button2,
        {
          variant: "outline",
          size: "medium",
          disabled: readonly,
          id: getControlSetterButtonId(name),
          onClick: onForceVisible
        },
        "Set string"
      );
    let isValid = typeof value2 == "string";
    return react_default.createElement(Wrapper8, null, react_default.createElement(
      Form2.Textarea,
      {
        id: getControlId(name),
        maxLength,
        onChange: handleChange,
        disabled: readonly,
        size: "flex",
        placeholder: "Edit string...",
        autoFocus: forceVisible,
        valid: isValid ? void 0 : "error",
        name,
        value: isValid ? value2 : "",
        onFocus,
        onBlur
      }
    ), maxLength && react_default.createElement(MaxLength, { isMaxed: value2?.length === maxLength }, value2?.length ?? 0, " / ", maxLength));
  }, "TextControl"), FileInput = styled(Form2.Input)({
    padding: 10
  });
  function revokeOldUrls(urls) {
    urls.forEach((url) => {
      url.startsWith("blob:") && URL.revokeObjectURL(url);
    });
  }
  __name(revokeOldUrls, "revokeOldUrls");
  var FilesControl = __name(({
    onChange,
    name,
    accept = "image/*",
    value: value2,
    argType
  }) => {
    let inputElement = useRef(null), readonly = argType?.control?.readOnly;
    function handleFileChange(e2) {
      if (!e2.target.files)
        return;
      let fileUrls = Array.from(e2.target.files).map((file) => URL.createObjectURL(file));
      onChange(fileUrls), revokeOldUrls(value2 || []);
    }
    return __name(handleFileChange, "handleFileChange"), useEffect(() => {
      value2 == null && inputElement.current && (inputElement.current.value = "");
    }, [value2, name]), react_default.createElement(
      FileInput,
      {
        ref: inputElement,
        id: getControlId(name),
        type: "file",
        name,
        multiple: !0,
        disabled: readonly,
        onChange: handleFileChange,
        accept,
        size: "flex"
      }
    );
  }, "FilesControl"), LazyColorControl = lazy(() => Promise.resolve().then(() => (init_Color_7ZNS6F6B(), Color_7ZNS6F6B_exports))), ColorControl2 = __name((props) => react_default.createElement(Suspense, { fallback: react_default.createElement("div", null) }, react_default.createElement(LazyColorControl, { ...props })), "ColorControl"), Controls2 = {
    array: ObjectControl,
    object: ObjectControl,
    boolean: BooleanControl,
    color: ColorControl2,
    date: DateControl,
    number: NumberControl,
    check: OptionsControl,
    "inline-check": OptionsControl,
    radio: OptionsControl,
    "inline-radio": OptionsControl,
    select: OptionsControl,
    "multi-select": OptionsControl,
    range: RangeControl,
    text: TextControl,
    file: FilesControl
  }, NoControl = __name(() => react_default.createElement(react_default.Fragment, null, "-"), "NoControl"), ArgControl = __name(({ row, arg, updateArgs, isHovered }) => {
    let { key, control } = row, [isFocused, setFocused] = useState(!1), [boxedValue, setBoxedValue] = useState({ value: arg });
    useEffect(() => {
      isFocused || setBoxedValue({ value: arg });
    }, [isFocused, arg]);
    let onChange = useCallback(
      (argVal) => (setBoxedValue({ value: argVal }), updateArgs({ [key]: argVal }), argVal),
      [updateArgs, key]
    ), onBlur = useCallback(() => setFocused(!1), []), onFocus = useCallback(() => setFocused(!0), []);
    if (!control || control.disable) {
      let canBeSetup = control?.disable !== !0 && row?.type?.name !== "function";
      return isHovered && canBeSetup ? react_default.createElement(
        Link3,
        {
          href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
          target: "_blank",
          withArrow: !0
        },
        "Setup controls"
      ) : react_default.createElement(NoControl, null);
    }
    let props = { name: key, argType: row, value: boxedValue.value, onChange, onBlur, onFocus }, Control = Controls2[control.type] || NoControl;
    return react_default.createElement(Control, { ...props, ...control, controlType: control.type });
  }, "ArgControl"), Table3 = styled.table(({ theme: theme3 }) => ({
    "&&": {
      // Escape default table styles
      borderCollapse: "collapse",
      borderSpacing: 0,
      border: "none",
      tr: {
        border: "none !important",
        background: "none"
      },
      "td, th": {
        padding: 0,
        border: "none",
        width: "auto!important"
      },
      // End escape
      marginTop: 0,
      marginBottom: 0,
      "th:first-of-type, td:first-of-type": {
        paddingLeft: 0
      },
      "th:last-of-type, td:last-of-type": {
        paddingRight: 0
      },
      td: {
        paddingTop: 0,
        paddingBottom: 4,
        "&:not(:first-of-type)": {
          paddingLeft: 10,
          paddingRight: 0
        }
      },
      tbody: {
        boxShadow: "none",
        border: "none"
      },
      code: codeCommon2({ theme: theme3 }),
      div: {
        span: {
          fontWeight: "bold"
        }
      },
      "& code": {
        margin: 0,
        display: "inline-block",
        fontSize: theme3.typography.size.s1
      }
    }
  })), ArgJsDoc = __name(({ tags }) => {
    let params = (tags.params || []).filter((x22) => x22.description), hasDisplayableParams = params.length !== 0, hasDisplayableDeprecated = tags.deprecated != null, hasDisplayableReturns = tags.returns != null && tags.returns.description != null;
    return !hasDisplayableParams && !hasDisplayableReturns && !hasDisplayableDeprecated ? null : react_default.createElement(react_default.Fragment, null, react_default.createElement(Table3, null, react_default.createElement("tbody", null, hasDisplayableDeprecated && react_default.createElement("tr", { key: "deprecated" }, react_default.createElement("td", { colSpan: 2 }, react_default.createElement("strong", null, "Deprecated"), ": ", tags.deprecated?.toString())), hasDisplayableParams && params.map((x22) => react_default.createElement("tr", { key: x22.name }, react_default.createElement("td", null, react_default.createElement("code", null, x22.name)), react_default.createElement("td", null, x22.description))), hasDisplayableReturns && react_default.createElement("tr", { key: "returns" }, react_default.createElement("td", null, react_default.createElement("code", null, "Returns")), react_default.createElement("td", null, tags.returns?.description)))));
  }, "ArgJsDoc"), import_memoizerific7 = __toESM2(require_memoizerific(), 1), ITEMS_BEFORE_EXPANSION = 8, Summary = styled.div(({ isExpanded }) => ({
    display: "flex",
    flexDirection: isExpanded ? "column" : "row",
    flexWrap: "wrap",
    alignItems: "flex-start",
    marginBottom: "-4px",
    minWidth: 100
  })), Text3 = styled.span(codeCommon2, ({ theme: theme3, simple = !1 }) => ({
    flex: "0 0 auto",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    wordBreak: "break-word",
    whiteSpace: "normal",
    maxWidth: "100%",
    margin: 0,
    marginRight: "4px",
    marginBottom: "4px",
    paddingTop: "2px",
    paddingBottom: "2px",
    lineHeight: "13px",
    ...simple && {
      background: "transparent",
      border: "0 none",
      paddingLeft: 0
    }
  })), ExpandButton = styled.button(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.mono,
    color: theme3.color.secondary,
    marginBottom: "4px",
    background: "none",
    border: "none"
  })), Expandable = styled.div(codeCommon2, ({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.mono,
    color: theme3.color.secondary,
    fontSize: theme3.typography.size.s1,
    // overrides codeCommon
    margin: 0,
    whiteSpace: "nowrap",
    display: "flex",
    alignItems: "center"
  })), Detail = styled.div(({ theme: theme3, width }) => ({
    width,
    minWidth: 200,
    maxWidth: 800,
    padding: 15,
    // Don't remove the mono fontFamily here even if it seems useless, this is used by the browser to calculate the length of a "ch" unit.
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    // Most custom stylesheet will reset the box-sizing to "border-box" and will break the tooltip.
    boxSizing: "content-box",
    "& code": {
      padding: "0 !important"
    }
  })), ChevronUpIcon2 = styled(ChevronSmallUpIcon)({
    marginLeft: 4
  }), ChevronDownIcon2 = styled(ChevronSmallDownIcon)({
    marginLeft: 4
  }), EmptyArg = __name(() => react_default.createElement("span", null, "-"), "EmptyArg"), ArgText = __name(({ text, simple }) => react_default.createElement(Text3, { simple }, text), "ArgText"), calculateDetailWidth = (0, import_memoizerific7.default)(1e3)((detail) => {
    let lines = detail.split(/\r?\n/);
    return `${Math.max(...lines.map((x22) => x22.length))}ch`;
  }), getSummaryItems = __name((summary) => {
    if (!summary)
      return [summary];
    let summaryItems = summary.split("|").map((value2) => value2.trim());
    return uniq(summaryItems);
  }, "getSummaryItems"), renderSummaryItems = __name((summaryItems, isExpanded = !0) => {
    let items = summaryItems;
    return isExpanded || (items = summaryItems.slice(0, ITEMS_BEFORE_EXPANSION)), items.map((item) => react_default.createElement(ArgText, { key: item, text: item === "" ? '""' : item }));
  }, "renderSummaryItems"), ArgSummary = __name(({ value: value2, initialExpandedArgs }) => {
    let { summary, detail } = value2, [isOpen, setIsOpen] = useState(!1), [isExpanded, setIsExpanded] = useState(initialExpandedArgs || !1);
    if (summary == null)
      return null;
    let summaryAsString = typeof summary.toString == "function" ? summary.toString() : summary;
    if (detail == null) {
      if (/[(){}[\]<>]/.test(summaryAsString))
        return react_default.createElement(ArgText, { text: summaryAsString });
      let summaryItems = getSummaryItems(summaryAsString), itemsCount = summaryItems.length;
      return itemsCount > ITEMS_BEFORE_EXPANSION ? react_default.createElement(Summary, { isExpanded }, renderSummaryItems(summaryItems, isExpanded), react_default.createElement(ExpandButton, { onClick: () => setIsExpanded(!isExpanded) }, isExpanded ? "Show less..." : `Show ${itemsCount - ITEMS_BEFORE_EXPANSION} more...`)) : react_default.createElement(Summary, null, renderSummaryItems(summaryItems));
    }
    return react_default.createElement(
      WithTooltipPure3,
      {
        closeOnOutsideClick: !0,
        placement: "bottom",
        visible: isOpen,
        onVisibleChange: (isVisible) => {
          setIsOpen(isVisible);
        },
        tooltip: react_default.createElement(Detail, { width: calculateDetailWidth(detail) }, react_default.createElement(SyntaxHighlighter4, { language: "jsx", format: !1 }, detail))
      },
      react_default.createElement(Expandable, { className: "sbdocs-expandable" }, react_default.createElement("span", null, summaryAsString), isOpen ? react_default.createElement(ChevronUpIcon2, null) : react_default.createElement(ChevronDownIcon2, null))
    );
  }, "ArgSummary"), ArgValue = __name(({ value: value2, initialExpandedArgs }) => value2 == null ? react_default.createElement(EmptyArg, null) : react_default.createElement(ArgSummary, { value: value2, initialExpandedArgs }), "ArgValue"), Name = styled.span({ fontWeight: "bold" }), Required = styled.span(({ theme: theme3 }) => ({
    color: theme3.color.negative,
    fontFamily: theme3.typography.fonts.mono,
    cursor: "help"
  })), Description4 = styled.div(({ theme: theme3 }) => ({
    "&&": {
      p: {
        margin: "0 0 10px 0"
      },
      a: {
        color: theme3.color.secondary
      }
    },
    code: {
      ...codeCommon2({ theme: theme3 }),
      fontSize: 12,
      fontFamily: theme3.typography.fonts.mono
    },
    "& code": {
      margin: 0,
      display: "inline-block"
    },
    "& pre > code": {
      whiteSpace: "pre-wrap"
    }
  })), Type = styled.div(({ theme: theme3, hasDescription }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.2, theme3.color.defaultText),
    marginTop: hasDescription ? 4 : 0
  })), TypeWithJsDoc = styled.div(({ theme: theme3, hasDescription }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.2, theme3.color.defaultText),
    marginTop: hasDescription ? 12 : 0,
    marginBottom: 12
  })), StyledTd = styled.td(({ expandable }) => ({
    paddingLeft: expandable ? "40px !important" : "20px !important"
  })), toSummary = __name((value2) => value2 && { summary: typeof value2 == "string" ? value2 : value2.name }, "toSummary"), ArgRow = __name((props) => {
    let [isHovered, setIsHovered] = useState(!1), { row, updateArgs, compact, expandable, initialExpandedArgs } = props, { name, description } = row, table = row.table || {}, type = table.type || toSummary(row.type), defaultValue = table.defaultValue || row.defaultValue, required = row.type?.required, hasDescription = description != null && description !== "";
    return react_default.createElement("tr", { onMouseEnter: () => setIsHovered(!0), onMouseLeave: () => setIsHovered(!1) }, react_default.createElement(StyledTd, { expandable: expandable ?? !1 }, react_default.createElement(Name, null, name), required ? react_default.createElement(Required, { title: "Required" }, "*") : null), compact ? null : react_default.createElement("td", null, hasDescription && react_default.createElement(Description4, null, react_default.createElement(index_modern_default, null, description)), table.jsDocTags != null ? react_default.createElement(react_default.Fragment, null, react_default.createElement(TypeWithJsDoc, { hasDescription }, react_default.createElement(ArgValue, { value: type, initialExpandedArgs })), react_default.createElement(ArgJsDoc, { tags: table.jsDocTags })) : react_default.createElement(Type, { hasDescription }, react_default.createElement(ArgValue, { value: type, initialExpandedArgs }))), compact ? null : react_default.createElement("td", null, react_default.createElement(ArgValue, { value: defaultValue, initialExpandedArgs })), updateArgs ? react_default.createElement("td", null, react_default.createElement(ArgControl, { ...props, isHovered })) : null);
  }, "ArgRow"), Wrapper9 = styled.div(({ inAddonPanel, theme: theme3 }) => ({
    height: inAddonPanel ? "100%" : "auto",
    display: "flex",
    border: inAddonPanel ? "none" : `1px solid ${theme3.appBorderColor}`,
    borderRadius: inAddonPanel ? 0 : theme3.appBorderRadius,
    padding: inAddonPanel ? 0 : 40,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    gap: 15,
    background: theme3.background.content
  })), Links2 = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    fontSize: theme3.typography.size.s2 - 1,
    gap: 25
  })), Empty = __name(({ inAddonPanel }) => {
    let [isLoading, setIsLoading] = useState(!0);
    return useEffect(() => {
      let load = setTimeout(() => {
        setIsLoading(!1);
      }, 100);
      return () => clearTimeout(load);
    }, []), isLoading ? null : react_default.createElement(Wrapper9, { inAddonPanel }, react_default.createElement(
      EmptyTabContent2,
      {
        title: inAddonPanel ? "Interactive story playground" : "Args table with interactive controls couldn't be auto-generated",
        description: react_default.createElement(react_default.Fragment, null, "Controls give you an easy to use interface to test your components. Set your story args and you'll see controls appearing here automatically."),
        footer: react_default.createElement(Links2, null, inAddonPanel && react_default.createElement(react_default.Fragment, null, react_default.createElement(
          Link3,
          {
            href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
            target: "_blank",
            withArrow: !0
          },
          react_default.createElement(DocumentIcon, null),
          " Read docs"
        )), !inAddonPanel && react_default.createElement(
          Link3,
          {
            href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
            target: "_blank",
            withArrow: !0
          },
          react_default.createElement(DocumentIcon, null),
          " Learn how to set that up"
        ))
      }
    ));
  }, "Empty"), ExpanderIconDown = styled(ChevronDownIcon)(({ theme: theme3 }) => ({
    marginRight: 8,
    marginLeft: -10,
    marginTop: -2,
    // optical alignment
    height: 12,
    width: 12,
    color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    border: "none",
    display: "inline-block"
  })), ExpanderIconRight = styled(ChevronRightIcon)(({ theme: theme3 }) => ({
    marginRight: 8,
    marginLeft: -10,
    marginTop: -2,
    // optical alignment
    height: 12,
    width: 12,
    color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    border: "none",
    display: "inline-block"
  })), FlexWrapper = styled.span(({ theme: theme3 }) => ({
    display: "flex",
    lineHeight: "20px",
    alignItems: "center"
  })), Section = styled.td(({ theme: theme3 }) => ({
    position: "relative",
    letterSpacing: "0.35em",
    textTransform: "uppercase",
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s1 - 1,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText),
    background: `${theme3.background.app} !important`,
    "& ~ td": {
      background: `${theme3.background.app} !important`
    }
  })), Subsection = styled.td(({ theme: theme3 }) => ({
    position: "relative",
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s2 - 1,
    background: theme3.background.app
  })), StyledTd2 = styled.td({
    position: "relative"
  }), StyledTr = styled.tr(({ theme: theme3 }) => ({
    "&:hover > td": {
      backgroundColor: `${curriedLighten$1(5e-3, theme3.background.app)} !important`,
      boxShadow: `${theme3.color.mediumlight} 0 - 1px 0 0 inset`,
      cursor: "row-resize"
    }
  })), ClickIntercept = styled.button({
    // reset button style
    background: "none",
    border: "none",
    padding: "0",
    font: "inherit",
    // add custom style
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    height: "100%",
    width: "100%",
    color: "transparent",
    cursor: "row-resize !important"
  }), SectionRow = __name(({
    level = "section",
    label,
    children,
    initialExpanded = !0,
    colSpan = 3
  }) => {
    let [expanded, setExpanded] = useState(initialExpanded), Level = level === "subsection" ? Subsection : Section, itemCount = children?.length || 0, caption = level === "subsection" ? `${itemCount} item${itemCount !== 1 ? "s" : ""}` : "", helperText = `${expanded ? "Hide" : "Show"} ${level === "subsection" ? itemCount : label} item${itemCount !== 1 ? "s" : ""}`;
    return react_default.createElement(react_default.Fragment, null, react_default.createElement(StyledTr, { title: helperText }, react_default.createElement(Level, { colSpan: 1 }, react_default.createElement(ClickIntercept, { onClick: (e2) => setExpanded(!expanded), tabIndex: 0 }, helperText), react_default.createElement(FlexWrapper, null, expanded ? react_default.createElement(ExpanderIconDown, null) : react_default.createElement(ExpanderIconRight, null), label)), react_default.createElement(StyledTd2, { colSpan: colSpan - 1 }, react_default.createElement(
      ClickIntercept,
      {
        onClick: (e2) => setExpanded(!expanded),
        tabIndex: -1,
        style: { outline: "none" }
      },
      helperText
    ), expanded ? null : caption)), expanded ? children : null);
  }, "SectionRow"), TableWrapper = styled.div(({ theme: theme3 }) => ({
    width: "100%",
    borderSpacing: 0,
    color: theme3.color.defaultText
  })), Row2 = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    "&:last-child": {
      borderBottom: 0
    }
  })), Column = styled.div(
    ({ position, theme: theme3 }) => {
      let baseStyles = {
        display: "flex",
        flexDirection: "column",
        gap: 5,
        padding: "10px 15px",
        alignItems: "flex-start"
      };
      switch (position) {
        case "first":
          return {
            ...baseStyles,
            width: "25%",
            paddingLeft: 20
          };
        case "second":
          return {
            ...baseStyles,
            width: "35%"
          };
        case "third":
          return {
            ...baseStyles,
            width: "15%"
          };
        case "last":
          return {
            ...baseStyles,
            width: "25%",
            paddingRight: 20
          };
      }
    }
  ), SkeletonText = styled.div(
    ({ theme: theme3, width, height }) => ({
      animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`,
      background: theme3.appBorderColor,
      width: width || "100%",
      height: height || 16,
      borderRadius: 3
    })
  ), Skeleton = __name(() => react_default.createElement(TableWrapper, null, react_default.createElement(Row2, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row2, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row2, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row2, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" })))), "Skeleton"), TableWrapper2 = styled.table(({ theme: theme3, compact, inAddonPanel }) => ({
    "&&": {
      // Resets for cascading/system styles
      borderSpacing: 0,
      color: theme3.color.defaultText,
      "td, th": {
        padding: 0,
        border: "none",
        verticalAlign: "top",
        textOverflow: "ellipsis"
      },
      // End Resets
      fontSize: theme3.typography.size.s2 - 1,
      lineHeight: "20px",
      textAlign: "left",
      width: "100%",
      // Margin collapse
      marginTop: inAddonPanel ? 0 : 25,
      marginBottom: inAddonPanel ? 0 : 40,
      "thead th:first-of-type, td:first-of-type": {
        // intentionally specify thead here
        width: "25%"
      },
      "th:first-of-type, td:first-of-type": {
        paddingLeft: 20
      },
      "th:nth-of-type(2), td:nth-of-type(2)": {
        ...compact ? null : {
          // Description column
          width: "35%"
        }
      },
      "td:nth-of-type(3)": {
        ...compact ? null : {
          // Defaults column
          width: "15%"
        }
      },
      "th:last-of-type, td:last-of-type": {
        paddingRight: 20,
        ...compact ? null : {
          // Controls column
          width: "25%"
        }
      },
      th: {
        color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.45, theme3.color.defaultText),
        paddingTop: 10,
        paddingBottom: 10,
        paddingLeft: 15,
        paddingRight: 15
      },
      td: {
        paddingTop: "10px",
        paddingBottom: "10px",
        "&:not(:first-of-type)": {
          paddingLeft: 15,
          paddingRight: 15
        },
        "&:last-of-type": {
          paddingRight: 20
        }
      },
      // Makes border alignment consistent w/other DocBlocks
      marginLeft: inAddonPanel ? 0 : 1,
      marginRight: inAddonPanel ? 0 : 1,
      tbody: {
        // Safari doesn't love shadows on tbody so we need to use a shadow filter. In order to do this,
        // the table cells all need to be solid so they have a background color applied.
        // I wasn't sure what kinds of content go in these tables so I was extra specific with selectors
        // to avoid unexpected surprises.
        ...inAddonPanel ? null : {
          filter: theme3.base === "light" ? "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.10))" : "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.20))"
        },
        "> tr > *": {
          // For filter to work properly, the table cells all need to be opaque.
          background: theme3.background.content,
          borderTop: `1px solid ${theme3.appBorderColor}`
        },
        ...inAddonPanel ? null : {
          // This works and I don't know why. :)
          "> tr:first-of-type > *": {
            borderBlockStart: `1px solid ${theme3.appBorderColor}`
          },
          "> tr:last-of-type > *": {
            borderBlockEnd: `1px solid ${theme3.appBorderColor}`
          },
          "> tr > *:first-of-type": {
            borderInlineStart: `1px solid ${theme3.appBorderColor}`
          },
          "> tr > *:last-of-type": {
            borderInlineEnd: `1px solid ${theme3.appBorderColor}`
          },
          // Thank you, Safari, for making me write code like this.
          "> tr:first-of-type > td:first-of-type": {
            borderTopLeftRadius: theme3.appBorderRadius
          },
          "> tr:first-of-type > td:last-of-type": {
            borderTopRightRadius: theme3.appBorderRadius
          },
          "> tr:last-of-type > td:first-of-type": {
            borderBottomLeftRadius: theme3.appBorderRadius
          },
          "> tr:last-of-type > td:last-of-type": {
            borderBottomRightRadius: theme3.appBorderRadius
          }
        }
      }
      // End awesome table styling
    }
  })), TablePositionWrapper = styled.div({
    position: "relative"
  }), ButtonPositionWrapper = styled.div({
    position: "absolute",
    right: 8,
    top: 6
  }), sortFns = {
    alpha: __name((a22, b22) => (a22.name ?? "").localeCompare(b22.name ?? ""), "alpha"),
    requiredFirst: __name((a22, b22) => +!!b22.type?.required - +!!a22.type?.required || (a22.name ?? "").localeCompare(b22.name ?? ""), "requiredFirst"),
    none: null
  }, groupRows = __name((rows, sort) => {
    let sections = { ungrouped: [], ungroupedSubsections: {}, sections: {} };
    if (!rows)
      return sections;
    Object.entries(rows).forEach(([key, row]) => {
      let { category, subcategory } = row?.table || {};
      if (category) {
        let section = sections.sections[category] || { ungrouped: [], subsections: {} };
        if (!subcategory)
          section.ungrouped.push({ key, ...row });
        else {
          let subsection = section.subsections[subcategory] || [];
          subsection.push({ key, ...row }), section.subsections[subcategory] = subsection;
        }
        sections.sections[category] = section;
      } else if (subcategory) {
        let subsection = sections.ungroupedSubsections[subcategory] || [];
        subsection.push({ key, ...row }), sections.ungroupedSubsections[subcategory] = subsection;
      } else
        sections.ungrouped.push({ key, ...row });
    });
    let sortFn = sortFns[sort], sortSubsection = __name((record) => sortFn ? Object.keys(record).reduce(
      (acc, cur) => ({
        ...acc,
        [cur]: record[cur].sort(sortFn)
      }),
      {}
    ) : record, "sortSubsection");
    return {
      ungrouped: sortFn ? sections.ungrouped.sort(sortFn) : sections.ungrouped,
      ungroupedSubsections: sortSubsection(sections.ungroupedSubsections),
      sections: Object.keys(sections.sections).reduce(
        (acc, cur) => ({
          ...acc,
          [cur]: {
            ungrouped: sortFn ? sections.sections[cur].ungrouped.sort(sortFn) : sections.sections[cur].ungrouped,
            subsections: sortSubsection(sections.sections[cur].subsections)
          }
        }),
        {}
      )
    };
  }, "groupRows"), safeIncludeConditionalArg = __name((row, args, globals) => {
    try {
      return includeConditionalArg(row, args, globals);
    } catch (err) {
      return once.warn(err.message), !1;
    }
  }, "safeIncludeConditionalArg"), ArgsTable = __name((props) => {
    let {
      updateArgs,
      resetArgs,
      compact,
      inAddonPanel,
      initialExpandedArgs,
      sort = "none",
      isLoading
    } = props;
    if ("error" in props) {
      let { error } = props;
      return react_default.createElement(EmptyBlock, null, error, "\xA0", react_default.createElement(Link3, { href: "http://storybook.js.org/docs/?ref=ui", target: "_blank", withArrow: !0 }, react_default.createElement(DocumentIcon, null), " Read the docs"));
    }
    if (isLoading)
      return react_default.createElement(Skeleton, null);
    let { rows, args, globals } = "rows" in props ? props : { rows: void 0, args: void 0, globals: void 0 }, groups = groupRows(
      pickBy(
        rows || {},
        (row) => !row?.table?.disable && safeIncludeConditionalArg(row, args || {}, globals || {})
      ),
      sort
    ), hasNoUngrouped = groups.ungrouped.length === 0, hasNoSections = Object.entries(groups.sections).length === 0, hasNoUngroupedSubsections = Object.entries(groups.ungroupedSubsections).length === 0;
    if (hasNoUngrouped && hasNoSections && hasNoUngroupedSubsections)
      return react_default.createElement(Empty, { inAddonPanel });
    let colSpan = 1;
    updateArgs && (colSpan += 1), compact || (colSpan += 2);
    let expandable = Object.keys(groups.sections).length > 0, common = { updateArgs, compact, inAddonPanel, initialExpandedArgs };
    return react_default.createElement(ResetWrapper2, null, react_default.createElement(TablePositionWrapper, null, updateArgs && !isLoading && resetArgs && react_default.createElement(ButtonPositionWrapper, null, react_default.createElement(
      IconButton2,
      {
        onClick: () => resetArgs(),
        "aria-label": "Reset controls",
        title: "Reset controls"
      },
      react_default.createElement(UndoIcon, null)
    )), react_default.createElement(TableWrapper2, { compact, inAddonPanel, className: "docblock-argstable sb-unstyled" }, react_default.createElement("thead", { className: "docblock-argstable-head" }, react_default.createElement("tr", null, react_default.createElement("th", null, react_default.createElement("span", null, "Name")), compact ? null : react_default.createElement("th", null, react_default.createElement("span", null, "Description")), compact ? null : react_default.createElement("th", null, react_default.createElement("span", null, "Default")), updateArgs ? react_default.createElement("th", null, react_default.createElement("span", null, "Control")) : null)), react_default.createElement("tbody", { className: "docblock-argstable-body" }, groups.ungrouped.map((row) => react_default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(groups.ungroupedSubsections).map(([subcategory, subsection]) => react_default.createElement(
      SectionRow,
      {
        key: subcategory,
        label: subcategory,
        level: "subsection",
        colSpan
      },
      subsection.map((row) => react_default.createElement(
        ArgRow,
        {
          key: row.key,
          row,
          arg: args && args[row.key],
          expandable,
          ...common
        }
      ))
    )), Object.entries(groups.sections).map(([category, section]) => react_default.createElement(SectionRow, { key: category, label: category, level: "section", colSpan }, section.ungrouped.map((row) => react_default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(section.subsections).map(([subcategory, subsection]) => react_default.createElement(
      SectionRow,
      {
        key: subcategory,
        label: subcategory,
        level: "subsection",
        colSpan
      },
      subsection.map((row) => react_default.createElement(
        ArgRow,
        {
          key: row.key,
          row,
          arg: args && args[row.key],
          expandable,
          ...common
        }
      ))
    ))))))));
  }, "ArgsTable"), ADDON_ID62 = "addon-controls", PARAM_KEY52 = "controls", slideIn = keyframes({
    from: { transform: "translateY(40px)" },
    to: { transform: "translateY(0)" }
  }), highlight = keyframes({
    from: { background: "var(--highlight-bg-color)" },
    to: {}
  }), Container23 = styled.div({
    containerType: "size",
    position: "sticky",
    bottom: 0,
    height: 39,
    overflow: "hidden",
    zIndex: 1
  }), Bar22 = styled(Bar2)(({ theme: theme3 }) => ({
    "--highlight-bg-color": theme3.base === "dark" ? "#153B5B" : "#E0F0FF",
    display: "flex",
    flexDirection: "row-reverse",
    // hide Info rather than Actions on overflow
    alignItems: "center",
    justifyContent: "space-between",
    flexWrap: "wrap",
    gap: 6,
    padding: "6px 10px",
    animation: `${slideIn} 300ms, ${highlight} 2s`,
    background: theme3.background.bar,
    borderTop: `1px solid ${theme3.appBorderColor}`,
    fontSize: theme3.typography.size.s2,
    "@container (max-width: 799px)": {
      flexDirection: "row",
      justifyContent: "flex-end"
    }
  })), Info = styled.div({
    display: "flex",
    flex: "99 0 auto",
    alignItems: "center",
    marginLeft: 10,
    gap: 6
  }), Actions2 = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    flex: "1 0 0",
    alignItems: "center",
    gap: 2,
    color: theme3.color.mediumdark,
    fontSize: theme3.typography.size.s2
  })), Label5 = styled.div({
    "@container (max-width: 799px)": {
      lineHeight: 0,
      textIndent: "-9999px",
      "&::after": {
        content: "attr(data-short-label)",
        display: "block",
        lineHeight: "initial",
        textIndent: "0"
      }
    }
  }), ModalInput = styled(Form2.Input)(({ theme: theme3 }) => ({
    "::placeholder": {
      color: theme3.color.mediumdark
    },
    "&:invalid:not(:placeholder-shown)": {
      boxShadow: `${theme3.color.negative} 0 0 0 1px inset`
    }
  })), SaveStory = __name(({
    saveStory,
    createStory,
    resetArgs,
    portalSelector
  }) => {
    let inputRef = react_default.useRef(null), [saving, setSaving] = react_default.useState(!1), [creating, setCreating] = react_default.useState(!1), [storyName, setStoryName] = react_default.useState(""), [errorMessage, setErrorMessage] = react_default.useState(null), onSaveStory = __name(async () => {
      saving || (setSaving(!0), await saveStory().catch(() => {
      }), setSaving(!1));
    }, "onSaveStory"), onShowForm = __name(() => {
      setCreating(!0), setStoryName(""), setTimeout(() => inputRef.current?.focus(), 0);
    }, "onShowForm"), onChange = __name((e2) => {
      let value2 = e2.target.value.replace(/^[^a-z]/i, "").replace(/[^a-z0-9-_ ]/gi, "").replaceAll(/([-_ ]+[a-z0-9])/gi, (match2) => match2.toUpperCase().replace(/[-_ ]/g, ""));
      setStoryName(value2.charAt(0).toUpperCase() + value2.slice(1));
    }, "onChange"), onSubmitForm = __name(async (event) => {
      if (event.preventDefault(), !saving)
        try {
          setErrorMessage(null), setSaving(!0), await createStory(storyName.replace(/^[^a-z]/i, "").replaceAll(/[^a-z0-9]/gi, "")), setCreating(!1), setSaving(!1);
        } catch (e2) {
          setErrorMessage(e2.message), setSaving(!1);
        }
    }, "onSubmitForm");
    return react_default.createElement(Container23, { id: "save-from-controls" }, react_default.createElement(Bar22, null, react_default.createElement(Actions2, null, react_default.createElement(
      WithTooltip2,
      {
        as: "div",
        hasChrome: !1,
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote2, { note: "Save changes to story" })
      },
      react_default.createElement(IconButton2, { "aria-label": "Save changes to story", disabled: saving, onClick: onSaveStory }, react_default.createElement(CheckIcon, null), react_default.createElement(Label5, { "data-short-label": "Save" }, "Update story"))
    ), react_default.createElement(
      WithTooltip2,
      {
        as: "div",
        hasChrome: !1,
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote2, { note: "Create new story with these settings" })
      },
      react_default.createElement(IconButton2, { "aria-label": "Create new story with these settings", onClick: onShowForm }, react_default.createElement(AddIcon, null), react_default.createElement(Label5, { "data-short-label": "New" }, "Create new story"))
    ), react_default.createElement(
      WithTooltip2,
      {
        as: "div",
        hasChrome: !1,
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote2, { note: "Reset changes" })
      },
      react_default.createElement(IconButton2, { "aria-label": "Reset changes", onClick: () => resetArgs() }, react_default.createElement(UndoIcon, null), react_default.createElement("span", null, "Reset"))
    )), react_default.createElement(Info, null, react_default.createElement(Label5, { "data-short-label": "Unsaved changes" }, "You modified this story. Do you want to save your changes?")), react_default.createElement(
      Modal2,
      {
        width: 350,
        open: creating,
        onOpenChange: setCreating,
        portalSelector
      },
      react_default.createElement(Form2, { onSubmit: onSubmitForm, id: "create-new-story-form" }, react_default.createElement(Modal2.Content, null, react_default.createElement(Modal2.Header, null, react_default.createElement(Modal2.Title, null, "Create new story"), react_default.createElement(Modal2.Description, null, "This will add a new story to your existing stories file.")), react_default.createElement(
        ModalInput,
        {
          onChange,
          placeholder: "Story export name",
          readOnly: saving,
          ref: inputRef,
          value: storyName
        }
      ), react_default.createElement(Modal2.Actions, null, react_default.createElement(Button2, { disabled: saving || !storyName, size: "medium", type: "submit", variant: "solid" }, "Create"), react_default.createElement(Modal2.Dialog.Close, { asChild: !0 }, react_default.createElement(Button2, { disabled: saving, size: "medium", type: "reset" }, "Cancel"))))),
      errorMessage && react_default.createElement(Modal2.Error, null, errorMessage)
    )));
  }, "SaveStory"), clean = __name((obj) => Object.entries(obj).reduce(
    (acc, [key, value2]) => value2 !== void 0 ? Object.assign(acc, { [key]: value2 }) : acc,
    {}
  ), "clean"), AddonWrapper = styled.div({
    display: "grid",
    gridTemplateRows: "1fr 39px",
    height: "100%",
    maxHeight: "100vh",
    overflowY: "auto"
  }), ControlsPanel = __name(({ saveStory, createStory }) => {
    let api = useStorybookApi(), [isLoading, setIsLoading] = useState(!0), [args, updateArgs, resetArgs, initialArgs] = useArgs2(), [globals] = useGlobals2(), rows = useArgTypes(), {
      expanded,
      sort,
      presetColors,
      disableSaveFromUI = !1
    } = useParameter2(PARAM_KEY52, {}), { path, previewInitialized } = useStorybookState(), storyData = api.getCurrentStoryData();
    useEffect(() => {
      previewInitialized && setIsLoading(!1);
    }, [previewInitialized]);
    let hasControls = Object.values(rows).some((arg) => arg?.control), withPresetColors = Object.entries(rows).reduce((acc, [key, arg]) => {
      let control = arg?.control;
      return typeof control != "object" || control?.type !== "color" || control?.presetColors ? acc[key] = arg : acc[key] = { ...arg, control: { ...control, presetColors } }, acc;
    }, {}), hasUpdatedArgs = useMemo(
      () => !!args && !!initialArgs && !dequal(clean(args), clean(initialArgs)),
      [args, initialArgs]
    );
    return react_default.createElement(AddonWrapper, null, react_default.createElement(
      ArgsTable,
      {
        key: path,
        compact: !expanded && hasControls,
        rows: withPresetColors,
        args,
        globals,
        updateArgs,
        resetArgs,
        inAddonPanel: !0,
        sort,
        isLoading
      }
    ), hasControls && storyData.type === "story" && storyData.subtype !== "test" && hasUpdatedArgs && scope.CONFIG_TYPE === "DEVELOPMENT" && disableSaveFromUI !== !0 && react_default.createElement(SaveStory, { resetArgs, saveStory, createStory }));
  }, "ControlsPanel");
  function Title22() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), rows = useArgTypes(), controlsCount = Object.values(rows).filter(
      (argType) => argType?.control && !argType?.table?.disable
    ).length, suffix = controlsCount === 0 ? null : react_default.createElement(Badge2, { compact: !0, status: selectedPanel === ADDON_ID62 ? "active" : "neutral" }, controlsCount);
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Controls"), suffix);
  }
  __name(Title22, "Title");
  var stringifyArgs = __name((args) => JSON.stringify(args, (_22, value2) => typeof value2 == "function" ? "__sb_empty_function_arg__" : value2), "stringifyArgs"), manager_default = addons3.register(ADDON_ID62, (api) => {
    if (globalThis?.FEATURES?.controls) {
      let channel = addons3.getChannel(), saveStory = __name(async () => {
        let data = api.getCurrentStoryData();
        if (data.type !== "story")
          throw new Error("Not a story");
        try {
          let response = await experimental_requestResponse(channel, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, {
            // Only send updated args
            args: stringifyArgs(
              Object.entries(data.args || {}).reduce((acc, [key, value2]) => (dequal(value2, data.initialArgs?.[key]) || (acc[key] = value2), acc), {})
            ),
            csfId: data.id,
            importPath: data.importPath
          });
          api.addNotification({
            id: "save-story-success",
            icon: react_default.createElement(PassedIcon, { color: color.positive }),
            content: {
              headline: "Story saved",
              subHeadline: react_default.createElement(react_default.Fragment, null, "Updated story ", react_default.createElement("b", null, response.sourceStoryName), ".")
            },
            duration: 8e3
          });
        } catch (error) {
          throw api.addNotification({
            id: "save-story-error",
            icon: react_default.createElement(FailedIcon, { color: color.negative }),
            content: {
              headline: "Failed to save story",
              subHeadline: error?.message || "Check the Storybook process on the command line for more details."
            },
            duration: 8e3
          }), error;
        }
      }, "saveStory"), createStory = __name(async (name) => {
        let data = api.getCurrentStoryData();
        if (data.type !== "story")
          throw new Error("Not a story");
        let response = await experimental_requestResponse(channel, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, {
          args: data.args && stringifyArgs(data.args),
          csfId: data.id,
          importPath: data.importPath,
          name
        });
        api.addNotification({
          id: "save-story-success",
          icon: react_default.createElement(PassedIcon, { color: color.positive }),
          content: {
            headline: "Story created",
            subHeadline: react_default.createElement(react_default.Fragment, null, "Added story ", react_default.createElement("b", null, response.newStoryName), " based on ", react_default.createElement("b", null, response.sourceStoryName), ".")
          },
          duration: 8e3,
          onClick: __name(({ onDismiss }) => {
            onDismiss(), api.selectStory(response.newStoryId);
          }, "onClick")
        });
      }, "createStory");
      addons3.add(ADDON_ID62, {
        title: Title22,
        type: types.PANEL,
        paramKey: PARAM_KEY52,
        render: __name(({ active }) => !active || !api.getCurrentStoryData() ? null : react_default.createElement(AddonPanel2, { active }, react_default.createElement(ControlsPanel, { saveStory, createStory })), "render")
      }), channel.on(SAVE_STORY_RESPONSE, (data) => {
        if (!data.success)
          return;
        let story = api.getCurrentStoryData();
        story.type === "story" && (api.resetStoryArgs(story), data.payload.newStoryId && api.selectStory(data.payload.newStoryId));
      });
    }
  });
  function Title32() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), [{ count: count3 }, setCount] = useAddonState(ADDON_ID6, { count: 0 });
    useChannel2({
      [EVENT_ID]: () => {
        setCount((c22) => ({ ...c22, count: c22.count + 1 }));
      },
      [STORY_CHANGED]: () => {
        setCount((c22) => ({ ...c22, count: 0 }));
      },
      [CLEAR_ID]: () => {
        setCount((c22) => ({ ...c22, count: 0 }));
      }
    });
    let suffix = count3 === 0 ? null : react_default.createElement(Badge2, { compact: !0, status: selectedPanel === PANEL_ID2 ? "active" : "neutral" }, count3);
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Actions"), suffix);
  }
  __name(Title32, "Title");
  var __create3 = Object.create, __defProp3 = Object.defineProperty, __getOwnPropDesc3 = Object.getOwnPropertyDescriptor, __getOwnPropNames3 = Object.getOwnPropertyNames, __getProtoOf3 = Object.getPrototypeOf, __hasOwnProp3 = Object.prototype.hasOwnProperty, __commonJS3 = __name((cb, mod) => __name(function() {
    return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  }, "__require"), "__commonJS"), __export3 = __name((target, all2) => {
    for (var name in all2)
      __defProp3(target, name, { get: all2[name], enumerable: !0 });
  }, "__export"), __copyProps3 = __name((to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function")
      for (let key of __getOwnPropNames3(from))
        !__hasOwnProp3.call(to, key) && key !== except && __defProp3(to, key, { get: __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
    return to;
  }, "__copyProps"), __toESM22 = __name((mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: !0 }) : target, mod)), "__toESM"), require_is_object = __commonJS3({
    "node_modules/is-object/index.js"(exports, module) {
      "use strict";
      module.exports = __name(function(x22) {
        return typeof x22 == "object" && x22 !== null;
      }, "isObject");
    }
  }), require_is_window = __commonJS3({
    "node_modules/is-window/index.js"(exports, module) {
      "use strict";
      module.exports = function(obj) {
        if (obj == null)
          return !1;
        var o2 = Object(obj);
        return o2 === o2.window;
      };
    }
  }), require_is_dom = __commonJS3({
    "node_modules/is-dom/index.js"(exports, module) {
      var isObject22 = require_is_object(), isWindow2 = require_is_window();
      function isNode(val) {
        return !isObject22(val) || !isWindow2(window) || typeof window.Node != "function" ? !1 : typeof val.nodeType == "number" && typeof val.nodeName == "string";
      }
      __name(isNode, "isNode"), module.exports = isNode;
    }
  }), themes_exports = {};
  __export3(themes_exports, {
    chromeDark: __name(() => theme, "chromeDark"),
    chromeLight: __name(() => theme2, "chromeLight")
  });
  var theme = {
    BASE_FONT_FAMILY: "Menlo, monospace",
    BASE_FONT_SIZE: "11px",
    BASE_LINE_HEIGHT: 1.2,
    BASE_BACKGROUND_COLOR: "rgb(36, 36, 36)",
    BASE_COLOR: "rgb(213, 213, 213)",
    OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
    OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
    OBJECT_NAME_COLOR: "rgb(227, 110, 236)",
    OBJECT_VALUE_NULL_COLOR: "rgb(127, 127, 127)",
    OBJECT_VALUE_UNDEFINED_COLOR: "rgb(127, 127, 127)",
    OBJECT_VALUE_REGEXP_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_STRING_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_SYMBOL_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_NUMBER_COLOR: "hsl(252, 100%, 75%)",
    OBJECT_VALUE_BOOLEAN_COLOR: "hsl(252, 100%, 75%)",
    OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(85, 106, 242)",
    HTML_TAG_COLOR: "rgb(93, 176, 215)",
    HTML_TAGNAME_COLOR: "rgb(93, 176, 215)",
    HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
    HTML_ATTRIBUTE_NAME_COLOR: "rgb(155, 187, 220)",
    HTML_ATTRIBUTE_VALUE_COLOR: "rgb(242, 151, 102)",
    HTML_COMMENT_COLOR: "rgb(137, 137, 137)",
    HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
    ARROW_COLOR: "rgb(145, 145, 145)",
    ARROW_MARGIN_RIGHT: 3,
    ARROW_FONT_SIZE: 12,
    ARROW_ANIMATION_DURATION: "0",
    TREENODE_FONT_FAMILY: "Menlo, monospace",
    TREENODE_FONT_SIZE: "11px",
    TREENODE_LINE_HEIGHT: 1.2,
    TREENODE_PADDING_LEFT: 12,
    TABLE_BORDER_COLOR: "rgb(85, 85, 85)",
    TABLE_TH_BACKGROUND_COLOR: "rgb(44, 44, 44)",
    TABLE_TH_HOVER_COLOR: "rgb(48, 48, 48)",
    TABLE_SORT_ICON_COLOR: "black",
    TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(51, 139, 255, 0.0980392) 50%, rgba(51, 139, 255, 0.0980392))",
    TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
  }, theme2 = {
    BASE_FONT_FAMILY: "Menlo, monospace",
    BASE_FONT_SIZE: "11px",
    BASE_LINE_HEIGHT: 1.2,
    BASE_BACKGROUND_COLOR: "white",
    BASE_COLOR: "black",
    OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
    OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
    OBJECT_NAME_COLOR: "rgb(136, 19, 145)",
    OBJECT_VALUE_NULL_COLOR: "rgb(128, 128, 128)",
    OBJECT_VALUE_UNDEFINED_COLOR: "rgb(128, 128, 128)",
    OBJECT_VALUE_REGEXP_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_STRING_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_SYMBOL_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_NUMBER_COLOR: "rgb(28, 0, 207)",
    OBJECT_VALUE_BOOLEAN_COLOR: "rgb(28, 0, 207)",
    OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(13, 34, 170)",
    HTML_TAG_COLOR: "rgb(168, 148, 166)",
    HTML_TAGNAME_COLOR: "rgb(136, 18, 128)",
    HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
    HTML_ATTRIBUTE_NAME_COLOR: "rgb(153, 69, 0)",
    HTML_ATTRIBUTE_VALUE_COLOR: "rgb(26, 26, 166)",
    HTML_COMMENT_COLOR: "rgb(35, 110, 37)",
    HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
    ARROW_COLOR: "#6e6e6e",
    ARROW_MARGIN_RIGHT: 3,
    ARROW_FONT_SIZE: 12,
    ARROW_ANIMATION_DURATION: "0",
    TREENODE_FONT_FAMILY: "Menlo, monospace",
    TREENODE_FONT_SIZE: "11px",
    TREENODE_LINE_HEIGHT: 1.2,
    TREENODE_PADDING_LEFT: 12,
    TABLE_BORDER_COLOR: "#aaa",
    TABLE_TH_BACKGROUND_COLOR: "#eee",
    TABLE_TH_HOVER_COLOR: "hsla(0, 0%, 90%, 1)",
    TABLE_SORT_ICON_COLOR: "#6e6e6e",
    TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(to bottom, white, white 50%, rgb(234, 243, 255) 50%, rgb(234, 243, 255))",
    TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
  }, ExpandedPathsContext = createContext([{}, () => {
  }]), unselectable = {
    WebkitTouchCallout: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
    msUserSelect: "none",
    OUserSelect: "none",
    userSelect: "none"
  }, createTheme = __name((theme3) => ({
    DOMNodePreview: {
      htmlOpenTag: {
        base: {
          color: theme3.HTML_TAG_COLOR
        },
        tagName: {
          color: theme3.HTML_TAGNAME_COLOR,
          textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
        },
        htmlAttributeName: {
          color: theme3.HTML_ATTRIBUTE_NAME_COLOR
        },
        htmlAttributeValue: {
          color: theme3.HTML_ATTRIBUTE_VALUE_COLOR
        }
      },
      htmlCloseTag: {
        base: {
          color: theme3.HTML_TAG_COLOR
        },
        offsetLeft: {
          marginLeft: -theme3.TREENODE_PADDING_LEFT
        },
        tagName: {
          color: theme3.HTML_TAGNAME_COLOR,
          textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
        }
      },
      htmlComment: {
        color: theme3.HTML_COMMENT_COLOR
      },
      htmlDoctype: {
        color: theme3.HTML_DOCTYPE_COLOR
      }
    },
    ObjectPreview: {
      objectDescription: {
        fontStyle: "italic"
      },
      preview: {
        fontStyle: "italic"
      },
      arrayMaxProperties: theme3.OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES,
      objectMaxProperties: theme3.OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES
    },
    ObjectName: {
      base: {
        color: theme3.OBJECT_NAME_COLOR
      },
      dimmed: {
        opacity: 0.6
      }
    },
    ObjectValue: {
      objectValueNull: {
        color: theme3.OBJECT_VALUE_NULL_COLOR
      },
      objectValueUndefined: {
        color: theme3.OBJECT_VALUE_UNDEFINED_COLOR
      },
      objectValueRegExp: {
        color: theme3.OBJECT_VALUE_REGEXP_COLOR
      },
      objectValueString: {
        color: theme3.OBJECT_VALUE_STRING_COLOR
      },
      objectValueSymbol: {
        color: theme3.OBJECT_VALUE_SYMBOL_COLOR
      },
      objectValueNumber: {
        color: theme3.OBJECT_VALUE_NUMBER_COLOR
      },
      objectValueBoolean: {
        color: theme3.OBJECT_VALUE_BOOLEAN_COLOR
      },
      objectValueFunctionPrefix: {
        color: theme3.OBJECT_VALUE_FUNCTION_PREFIX_COLOR,
        fontStyle: "italic"
      },
      objectValueFunctionName: {
        fontStyle: "italic"
      }
    },
    TreeView: {
      treeViewOutline: {
        padding: 0,
        margin: 0,
        listStyleType: "none"
      }
    },
    TreeNode: {
      treeNodeBase: {
        color: theme3.BASE_COLOR,
        backgroundColor: theme3.BASE_BACKGROUND_COLOR,
        lineHeight: theme3.TREENODE_LINE_HEIGHT,
        cursor: "default",
        boxSizing: "border-box",
        listStyle: "none",
        fontFamily: theme3.TREENODE_FONT_FAMILY,
        fontSize: theme3.TREENODE_FONT_SIZE
      },
      treeNodePreviewContainer: {},
      treeNodePlaceholder: {
        whiteSpace: "pre",
        fontSize: theme3.ARROW_FONT_SIZE,
        marginRight: theme3.ARROW_MARGIN_RIGHT,
        ...unselectable
      },
      treeNodeArrow: {
        base: {
          color: theme3.ARROW_COLOR,
          display: "inline-block",
          fontSize: theme3.ARROW_FONT_SIZE,
          marginRight: theme3.ARROW_MARGIN_RIGHT,
          ...parseFloat(theme3.ARROW_ANIMATION_DURATION) > 0 ? {
            transition: `transform ${theme3.ARROW_ANIMATION_DURATION} ease 0s`
          } : {},
          ...unselectable
        },
        expanded: {
          WebkitTransform: "rotateZ(90deg)",
          MozTransform: "rotateZ(90deg)",
          transform: "rotateZ(90deg)"
        },
        collapsed: {
          WebkitTransform: "rotateZ(0deg)",
          MozTransform: "rotateZ(0deg)",
          transform: "rotateZ(0deg)"
        }
      },
      treeNodeChildNodesContainer: {
        margin: 0,
        paddingLeft: theme3.TREENODE_PADDING_LEFT
      }
    },
    TableInspector: {
      base: {
        color: theme3.BASE_COLOR,
        position: "relative",
        border: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
        fontFamily: theme3.BASE_FONT_FAMILY,
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%",
        boxSizing: "border-box",
        cursor: "default"
      }
    },
    TableInspectorHeaderContainer: {
      base: {
        top: 0,
        height: "17px",
        left: 0,
        right: 0,
        overflowX: "hidden"
      },
      table: {
        tableLayout: "fixed",
        borderSpacing: 0,
        borderCollapse: "separate",
        height: "100%",
        width: "100%",
        margin: 0
      }
    },
    TableInspectorDataContainer: {
      tr: {
        display: "table-row"
      },
      td: {
        boxSizing: "border-box",
        border: "none",
        height: "16px",
        verticalAlign: "top",
        padding: "1px 4px",
        WebkitUserSelect: "text",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        lineHeight: "14px"
      },
      div: {
        position: "static",
        top: "17px",
        bottom: 0,
        overflowY: "overlay",
        transform: "translateZ(0)",
        left: 0,
        right: 0,
        overflowX: "hidden"
      },
      table: {
        positon: "static",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        borderTop: "0 none transparent",
        margin: 0,
        backgroundImage: theme3.TABLE_DATA_BACKGROUND_IMAGE,
        backgroundSize: theme3.TABLE_DATA_BACKGROUND_SIZE,
        tableLayout: "fixed",
        borderSpacing: 0,
        borderCollapse: "separate",
        width: "100%",
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%"
      }
    },
    TableInspectorTH: {
      base: {
        position: "relative",
        height: "auto",
        textAlign: "left",
        backgroundColor: theme3.TABLE_TH_BACKGROUND_COLOR,
        borderBottom: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
        fontWeight: "normal",
        verticalAlign: "middle",
        padding: "0 4px",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        lineHeight: "14px",
        ":hover": {
          backgroundColor: theme3.TABLE_TH_HOVER_COLOR
        }
      },
      div: {
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%"
      }
    },
    TableInspectorLeftBorder: {
      none: {
        borderLeft: "none"
      },
      solid: {
        borderLeft: `1px solid ${theme3.TABLE_BORDER_COLOR}`
      }
    },
    TableInspectorSortIcon: {
      display: "block",
      marginRight: 3,
      width: 8,
      height: 7,
      marginTop: -7,
      color: theme3.TABLE_SORT_ICON_COLOR,
      fontSize: 12,
      ...unselectable
    }
  }), "createTheme"), DEFAULT_THEME_NAME = "chromeLight", ThemeContext = createContext(createTheme(themes_exports[DEFAULT_THEME_NAME])), useStyles = __name((baseStylesKey) => useContext(ThemeContext)[baseStylesKey], "useStyles"), themeAcceptor = __name((WrappedComponent) => __name(({ theme: theme3 = DEFAULT_THEME_NAME, ...restProps }) => {
    let themeStyles = useMemo(() => {
      switch (Object.prototype.toString.call(theme3)) {
        case "[object String]":
          return createTheme(themes_exports[theme3]);
        case "[object Object]":
          return createTheme(theme3);
        default:
          return createTheme(themes_exports[DEFAULT_THEME_NAME]);
      }
    }, [theme3]);
    return react_default.createElement(ThemeContext.Provider, {
      value: themeStyles
    }, react_default.createElement(WrappedComponent, {
      ...restProps
    }));
  }, "ThemeAcceptor"), "themeAcceptor"), Arrow2 = __name(({ expanded, styles: styles3 }) => react_default.createElement("span", {
    style: {
      ...styles3.base,
      ...expanded ? styles3.expanded : styles3.collapsed
    }
  }, "\u25B6"), "Arrow"), TreeNode = memo((props) => {
    props = {
      expanded: !0,
      nodeRenderer: __name(({ name }) => react_default.createElement("span", null, name), "nodeRenderer"),
      onClick: __name(() => {
      }, "onClick"),
      shouldShowArrow: !1,
      shouldShowPlaceholder: !0,
      ...props
    };
    let { expanded, onClick, children, nodeRenderer, title, shouldShowArrow, shouldShowPlaceholder } = props, styles3 = useStyles("TreeNode"), NodeRenderer = nodeRenderer;
    return react_default.createElement("li", {
      "aria-expanded": expanded,
      role: "treeitem",
      style: styles3.treeNodeBase,
      title
    }, react_default.createElement("div", {
      style: styles3.treeNodePreviewContainer,
      onClick
    }, shouldShowArrow || Children.count(children) > 0 ? react_default.createElement(Arrow2, {
      expanded,
      styles: styles3.treeNodeArrow
    }) : shouldShowPlaceholder && react_default.createElement("span", {
      style: styles3.treeNodePlaceholder
    }, "\xA0"), react_default.createElement(NodeRenderer, {
      ...props
    })), react_default.createElement("ol", {
      role: "group",
      style: styles3.treeNodeChildNodesContainer
    }, expanded ? children : void 0));
  }), DEFAULT_ROOT_PATH = "$", WILDCARD = "*";
  function hasChildNodes(data, dataIterator) {
    return !dataIterator(data).next().done;
  }
  __name(hasChildNodes, "hasChildNodes");
  var wildcardPathsFromLevel = __name((level) => Array.from({ length: level }, (_22, i22) => [DEFAULT_ROOT_PATH].concat(Array.from({ length: i22 }, () => "*")).join(".")), "wildcardPathsFromLevel"), getExpandedPaths = __name((data, dataIterator, expandPaths, expandLevel, prevExpandedPaths) => {
    let wildcardPaths = [].concat(wildcardPathsFromLevel(expandLevel)).concat(expandPaths).filter((path) => typeof path == "string"), expandedPaths = [];
    return wildcardPaths.forEach((wildcardPath) => {
      let keyPaths = wildcardPath.split("."), populatePaths = __name((curData, curPath, depth) => {
        if (depth === keyPaths.length) {
          expandedPaths.push(curPath);
          return;
        }
        let key = keyPaths[depth];
        if (depth === 0)
          hasChildNodes(curData, dataIterator) && (key === DEFAULT_ROOT_PATH || key === WILDCARD) && populatePaths(curData, DEFAULT_ROOT_PATH, depth + 1);
        else if (key === WILDCARD)
          for (let { name, data: data2 } of dataIterator(curData))
            hasChildNodes(data2, dataIterator) && populatePaths(data2, `${curPath}.${name}`, depth + 1);
        else {
          let value2 = curData[key];
          hasChildNodes(value2, dataIterator) && populatePaths(value2, `${curPath}.${key}`, depth + 1);
        }
      }, "populatePaths");
      populatePaths(data, "", 0);
    }), expandedPaths.reduce((obj, path) => (obj[path] = !0, obj), { ...prevExpandedPaths });
  }, "getExpandedPaths"), ConnectedTreeNode = memo((props) => {
    let { data, dataIterator, path, depth, nodeRenderer } = props, [expandedPaths, setExpandedPaths] = useContext(ExpandedPathsContext), nodeHasChildNodes = hasChildNodes(data, dataIterator), expanded = !!expandedPaths[path], handleClick = useCallback(() => nodeHasChildNodes && setExpandedPaths((prevExpandedPaths) => ({
      ...prevExpandedPaths,
      [path]: !expanded
    })), [nodeHasChildNodes, setExpandedPaths, path, expanded]);
    return react_default.createElement(TreeNode, {
      expanded,
      onClick: handleClick,
      shouldShowArrow: nodeHasChildNodes,
      shouldShowPlaceholder: depth > 0,
      nodeRenderer,
      ...props
    }, expanded ? [...dataIterator(data)].map(({ name, data: data2, ...renderNodeProps }) => react_default.createElement(ConnectedTreeNode, {
      name,
      data: data2,
      depth: depth + 1,
      path: `${path}.${name}`,
      key: name,
      dataIterator,
      nodeRenderer,
      ...renderNodeProps
    })) : null);
  }), TreeView = memo(({ name, data, dataIterator, nodeRenderer, expandPaths, expandLevel }) => {
    let styles3 = useStyles("TreeView"), stateAndSetter = useState({}), [, setExpandedPaths] = stateAndSetter;
    return useLayoutEffect(() => setExpandedPaths((prevExpandedPaths) => getExpandedPaths(data, dataIterator, expandPaths, expandLevel, prevExpandedPaths)), [data, dataIterator, expandPaths, expandLevel]), react_default.createElement(ExpandedPathsContext.Provider, {
      value: stateAndSetter
    }, react_default.createElement("ol", {
      role: "tree",
      style: styles3.treeViewOutline
    }, react_default.createElement(ConnectedTreeNode, {
      name,
      data,
      dataIterator,
      depth: 0,
      path: DEFAULT_ROOT_PATH,
      nodeRenderer
    })));
  }), ObjectName = __name(({ name, dimmed = !1, styles: styles3 = {} }) => {
    let themeStyles = useStyles("ObjectName"), appliedStyles = {
      ...themeStyles.base,
      ...dimmed ? themeStyles.dimmed : {},
      ...styles3
    };
    return react_default.createElement("span", {
      style: appliedStyles
    }, name);
  }, "ObjectName"), ObjectValue = __name(({ object: object2, styles: styles3 }) => {
    let themeStyles = useStyles("ObjectValue"), mkStyle = __name((key) => ({ ...themeStyles[key], ...styles3 }), "mkStyle");
    switch (typeof object2) {
      case "bigint":
        return react_default.createElement("span", {
          style: mkStyle("objectValueNumber")
        }, String(object2), "n");
      case "number":
        return react_default.createElement("span", {
          style: mkStyle("objectValueNumber")
        }, String(object2));
      case "string":
        return react_default.createElement("span", {
          style: mkStyle("objectValueString")
        }, '"', object2, '"');
      case "boolean":
        return react_default.createElement("span", {
          style: mkStyle("objectValueBoolean")
        }, String(object2));
      case "undefined":
        return react_default.createElement("span", {
          style: mkStyle("objectValueUndefined")
        }, "undefined");
      case "object":
        return object2 === null ? react_default.createElement("span", {
          style: mkStyle("objectValueNull")
        }, "null") : object2 instanceof Date ? react_default.createElement("span", null, object2.toString()) : object2 instanceof RegExp ? react_default.createElement("span", {
          style: mkStyle("objectValueRegExp")
        }, object2.toString()) : Array.isArray(object2) ? react_default.createElement("span", null, `Array(${object2.length})`) : object2.constructor ? typeof object2.constructor.isBuffer == "function" && object2.constructor.isBuffer(object2) ? react_default.createElement("span", null, `Buffer[${object2.length}]`) : react_default.createElement("span", null, object2.constructor.name) : react_default.createElement("span", null, "Object");
      case "function":
        return react_default.createElement("span", null, react_default.createElement("span", {
          style: mkStyle("objectValueFunctionPrefix")
        }, "\u0192\xA0"), react_default.createElement("span", {
          style: mkStyle("objectValueFunctionName")
        }, object2.name, "()"));
      case "symbol":
        return react_default.createElement("span", {
          style: mkStyle("objectValueSymbol")
        }, object2.toString());
      default:
        return react_default.createElement("span", null);
    }
  }, "ObjectValue"), hasOwnProperty = Object.prototype.hasOwnProperty, propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
  function getPropertyValue(object2, propertyName) {
    let propertyDescriptor = Object.getOwnPropertyDescriptor(object2, propertyName);
    if (propertyDescriptor.get)
      try {
        return propertyDescriptor.get();
      } catch {
        return propertyDescriptor.get;
      }
    return object2[propertyName];
  }
  __name(getPropertyValue, "getPropertyValue");
  function intersperse(arr, sep) {
    return arr.length === 0 ? [] : arr.slice(1).reduce((xs, x22) => xs.concat([sep, x22]), [arr[0]]);
  }
  __name(intersperse, "intersperse");
  var ObjectPreview = __name(({ data }) => {
    let styles3 = useStyles("ObjectPreview"), object2 = data;
    if (typeof object2 != "object" || object2 === null || object2 instanceof Date || object2 instanceof RegExp)
      return react_default.createElement(ObjectValue, {
        object: object2
      });
    if (Array.isArray(object2)) {
      let maxProperties = styles3.arrayMaxProperties, previewArray = object2.slice(0, maxProperties).map((element, index3) => react_default.createElement(ObjectValue, {
        key: index3,
        object: element
      }));
      object2.length > maxProperties && previewArray.push(react_default.createElement("span", {
        key: "ellipsis"
      }, "\u2026"));
      let arrayLength = object2.length;
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
        style: styles3.objectDescription
      }, arrayLength === 0 ? "" : `(${arrayLength})\xA0`), react_default.createElement("span", {
        style: styles3.preview
      }, "[", intersperse(previewArray, ", "), "]"));
    } else {
      let maxProperties = styles3.objectMaxProperties, propertyNodes = [];
      for (let propertyName in object2)
        if (hasOwnProperty.call(object2, propertyName)) {
          let ellipsis2;
          propertyNodes.length === maxProperties - 1 && Object.keys(object2).length > maxProperties && (ellipsis2 = react_default.createElement("span", {
            key: "ellipsis"
          }, "\u2026"));
          let propertyValue = getPropertyValue(object2, propertyName);
          if (propertyNodes.push(react_default.createElement("span", {
            key: propertyName
          }, react_default.createElement(ObjectName, {
            name: propertyName || '""'
          }), ":\xA0", react_default.createElement(ObjectValue, {
            object: propertyValue
          }), ellipsis2)), ellipsis2)
            break;
        }
      let objectConstructorName = object2.constructor ? object2.constructor.name : "Object";
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
        style: styles3.objectDescription
      }, objectConstructorName === "Object" ? "" : `${objectConstructorName} `), react_default.createElement("span", {
        style: styles3.preview
      }, "{", intersperse(propertyNodes, ", "), "}"));
    }
  }, "ObjectPreview"), ObjectRootLabel = __name(({ name, data }) => typeof name == "string" ? react_default.createElement("span", null, react_default.createElement(ObjectName, {
    name
  }), react_default.createElement("span", null, ": "), react_default.createElement(ObjectPreview, {
    data
  })) : react_default.createElement(ObjectPreview, {
    data
  }), "ObjectRootLabel"), ObjectLabel = __name(({ name, data, isNonenumerable = !1 }) => {
    let object2 = data;
    return react_default.createElement("span", null, typeof name == "string" ? react_default.createElement(ObjectName, {
      name,
      dimmed: isNonenumerable
    }) : react_default.createElement(ObjectPreview, {
      data: name
    }), react_default.createElement("span", null, ": "), react_default.createElement(ObjectValue, {
      object: object2
    }));
  }, "ObjectLabel"), createIterator = __name((showNonenumerable, sortObjectKeys) => __name(function* (data) {
    if (!(typeof data == "object" && data !== null || typeof data == "function"))
      return;
    let dataIsArray = Array.isArray(data);
    if (!dataIsArray && data[Symbol.iterator]) {
      let i22 = 0;
      for (let entry of data) {
        if (Array.isArray(entry) && entry.length === 2) {
          let [k22, v22] = entry;
          yield {
            name: k22,
            data: v22
          };
        } else
          yield {
            name: i22.toString(),
            data: entry
          };
        i22++;
      }
    } else {
      let keys = Object.getOwnPropertyNames(data);
      sortObjectKeys === !0 && !dataIsArray ? keys.sort() : typeof sortObjectKeys == "function" && keys.sort(sortObjectKeys);
      for (let propertyName of keys)
        if (propertyIsEnumerable.call(data, propertyName)) {
          let propertyValue = getPropertyValue(data, propertyName);
          yield {
            name: propertyName || '""',
            data: propertyValue
          };
        } else if (showNonenumerable) {
          let propertyValue;
          try {
            propertyValue = getPropertyValue(data, propertyName);
          } catch {
          }
          propertyValue !== void 0 && (yield {
            name: propertyName,
            data: propertyValue,
            isNonenumerable: !0
          });
        }
      showNonenumerable && data !== Object.prototype && (yield {
        name: "__proto__",
        data: Object.getPrototypeOf(data),
        isNonenumerable: !0
      });
    }
  }, "objectIterator"), "createIterator"), defaultNodeRenderer = __name(({ depth, name, data, isNonenumerable }) => depth === 0 ? react_default.createElement(ObjectRootLabel, {
    name,
    data
  }) : react_default.createElement(ObjectLabel, {
    name,
    data,
    isNonenumerable
  }), "defaultNodeRenderer"), ObjectInspector = __name(({ showNonenumerable = !1, sortObjectKeys, nodeRenderer, ...treeViewProps }) => {
    let dataIterator = createIterator(showNonenumerable, sortObjectKeys), renderer = nodeRenderer || defaultNodeRenderer;
    return react_default.createElement(TreeView, {
      nodeRenderer: renderer,
      dataIterator,
      ...treeViewProps
    });
  }, "ObjectInspector"), themedObjectInspector = themeAcceptor(ObjectInspector);
  function getHeaders(data) {
    if (typeof data == "object") {
      let rowHeaders = [];
      if (Array.isArray(data)) {
        let nRows = data.length;
        rowHeaders = [...Array(nRows).keys()];
      } else data !== null && (rowHeaders = Object.keys(data));
      let colHeaders = rowHeaders.reduce((colHeaders2, rowHeader) => {
        let row = data[rowHeader];
        return typeof row == "object" && row !== null && Object.keys(row).reduce((xs, x22) => (xs.includes(x22) || xs.push(x22), xs), colHeaders2), colHeaders2;
      }, []);
      return {
        rowHeaders,
        colHeaders
      };
    }
  }
  __name(getHeaders, "getHeaders");
  var DataContainer = __name(({ rows, columns, rowsData }) => {
    let styles3 = useStyles("TableInspectorDataContainer"), borderStyles = useStyles("TableInspectorLeftBorder");
    return react_default.createElement("div", {
      style: styles3.div
    }, react_default.createElement("table", {
      style: styles3.table
    }, react_default.createElement("colgroup", null), react_default.createElement("tbody", null, rows.map((row, i22) => react_default.createElement("tr", {
      key: row,
      style: styles3.tr
    }, react_default.createElement("td", {
      style: { ...styles3.td, ...borderStyles.none }
    }, row), columns.map((column) => {
      let rowData = rowsData[i22];
      return typeof rowData == "object" && rowData !== null && hasOwnProperty.call(rowData, column) ? react_default.createElement("td", {
        key: column,
        style: { ...styles3.td, ...borderStyles.solid }
      }, react_default.createElement(ObjectValue, {
        object: rowData[column]
      })) : react_default.createElement("td", {
        key: column,
        style: { ...styles3.td, ...borderStyles.solid }
      });
    }))))));
  }, "DataContainer"), SortIconContainer = __name((props) => react_default.createElement("div", {
    style: {
      position: "absolute",
      top: 1,
      right: 0,
      bottom: 1,
      display: "flex",
      alignItems: "center"
    }
  }, props.children), "SortIconContainer"), SortIcon = __name(({ sortAscending }) => {
    let styles3 = useStyles("TableInspectorSortIcon"), glyph = sortAscending ? "\u25B2" : "\u25BC";
    return react_default.createElement("div", {
      style: styles3
    }, glyph);
  }, "SortIcon"), TH = __name(({
    sortAscending = !1,
    sorted = !1,
    onClick = void 0,
    borderStyle = {},
    children,
    ...thProps
  }) => {
    let styles3 = useStyles("TableInspectorTH"), [hovered, setHovered] = useState(!1), handleMouseEnter = useCallback(() => setHovered(!0), []), handleMouseLeave = useCallback(() => setHovered(!1), []);
    return react_default.createElement("th", {
      ...thProps,
      style: {
        ...styles3.base,
        ...borderStyle,
        ...hovered ? styles3.base[":hover"] : {}
      },
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick
    }, react_default.createElement("div", {
      style: styles3.div
    }, children), sorted && react_default.createElement(SortIconContainer, null, react_default.createElement(SortIcon, {
      sortAscending
    })));
  }, "TH"), HeaderContainer = __name(({
    indexColumnText = "(index)",
    columns = [],
    sorted,
    sortIndexColumn,
    sortColumn,
    sortAscending,
    onTHClick,
    onIndexTHClick
  }) => {
    let styles3 = useStyles("TableInspectorHeaderContainer"), borderStyles = useStyles("TableInspectorLeftBorder");
    return react_default.createElement("div", {
      style: styles3.base
    }, react_default.createElement("table", {
      style: styles3.table
    }, react_default.createElement("tbody", null, react_default.createElement("tr", null, react_default.createElement(TH, {
      borderStyle: borderStyles.none,
      sorted: sorted && sortIndexColumn,
      sortAscending,
      onClick: onIndexTHClick
    }, indexColumnText), columns.map((column) => react_default.createElement(TH, {
      borderStyle: borderStyles.solid,
      key: column,
      sorted: sorted && sortColumn === column,
      sortAscending,
      onClick: onTHClick.bind(null, column)
    }, column))))));
  }, "HeaderContainer"), TableInspector = __name(({
    data,
    columns
  }) => {
    let styles3 = useStyles("TableInspector"), [{ sorted, sortIndexColumn, sortColumn, sortAscending }, setState] = useState({
      sorted: !1,
      sortIndexColumn: !1,
      sortColumn: void 0,
      sortAscending: !1
    }), handleIndexTHClick = useCallback(() => {
      setState(({ sortIndexColumn: sortIndexColumn2, sortAscending: sortAscending2 }) => ({
        sorted: !0,
        sortIndexColumn: !0,
        sortColumn: void 0,
        sortAscending: sortIndexColumn2 ? !sortAscending2 : !0
      }));
    }, []), handleTHClick = useCallback((col) => {
      setState(({ sortColumn: sortColumn2, sortAscending: sortAscending2 }) => ({
        sorted: !0,
        sortIndexColumn: !1,
        sortColumn: col,
        sortAscending: col === sortColumn2 ? !sortAscending2 : !0
      }));
    }, []);
    if (typeof data != "object" || data === null)
      return react_default.createElement("div", null);
    let { rowHeaders, colHeaders } = getHeaders(data);
    columns !== void 0 && (colHeaders = columns);
    let rowsData = rowHeaders.map((rowHeader) => data[rowHeader]), columnDataWithRowIndexes;
    if (sortColumn !== void 0 ? columnDataWithRowIndexes = rowsData.map((rowData, index3) => typeof rowData == "object" && rowData !== null ? [rowData[sortColumn], index3] : [void 0, index3]) : sortIndexColumn && (columnDataWithRowIndexes = rowHeaders.map((rowData, index3) => [rowHeaders[index3], index3])), columnDataWithRowIndexes !== void 0) {
      let comparator = __name((mapper, ascending) => (a22, b22) => {
        let v1 = mapper(a22), v22 = mapper(b22), type1 = typeof v1, type2 = typeof v22, lt = __name((v12, v222) => v12 < v222 ? -1 : v12 > v222 ? 1 : 0, "lt"), result;
        if (type1 === type2)
          result = lt(v1, v22);
        else {
          let order2 = {
            string: 0,
            number: 1,
            object: 2,
            symbol: 3,
            boolean: 4,
            undefined: 5,
            function: 6
          };
          result = lt(order2[type1], order2[type2]);
        }
        return ascending || (result = -result), result;
      }, "comparator"), sortedRowIndexes = columnDataWithRowIndexes.sort(comparator((item) => item[0], sortAscending)).map((item) => item[1]);
      rowHeaders = sortedRowIndexes.map((i22) => rowHeaders[i22]), rowsData = sortedRowIndexes.map((i22) => rowsData[i22]);
    }
    return react_default.createElement("div", {
      style: styles3.base
    }, react_default.createElement(HeaderContainer, {
      columns: colHeaders,
      sorted,
      sortIndexColumn,
      sortColumn,
      sortAscending,
      onTHClick: handleTHClick,
      onIndexTHClick: handleIndexTHClick
    }), react_default.createElement(DataContainer, {
      rows: rowHeaders,
      columns: colHeaders,
      rowsData
    }));
  }, "TableInspector"), themedTableInspector = themeAcceptor(TableInspector), TEXT_NODE_MAX_INLINE_CHARS = 80, shouldInline = __name((data) => data.childNodes.length === 0 || data.childNodes.length === 1 && data.childNodes[0].nodeType === Node.TEXT_NODE && data.textContent.length < TEXT_NODE_MAX_INLINE_CHARS, "shouldInline"), OpenTag = __name(({ tagName, attributes, styles: styles3 }) => react_default.createElement("span", {
    style: styles3.base
  }, "<", react_default.createElement("span", {
    style: styles3.tagName
  }, tagName), (() => {
    if (attributes) {
      let attributeNodes = [];
      for (let i22 = 0; i22 < attributes.length; i22++) {
        let attribute = attributes[i22];
        attributeNodes.push(react_default.createElement("span", {
          key: i22
        }, " ", react_default.createElement("span", {
          style: styles3.htmlAttributeName
        }, attribute.name), '="', react_default.createElement("span", {
          style: styles3.htmlAttributeValue
        }, attribute.value), '"'));
      }
      return attributeNodes;
    }
  })(), ">"), "OpenTag"), CloseTag = __name(({ tagName, isChildNode = !1, styles: styles3 }) => react_default.createElement("span", {
    style: Object.assign({}, styles3.base, isChildNode && styles3.offsetLeft)
  }, "</", react_default.createElement("span", {
    style: styles3.tagName
  }, tagName), ">"), "CloseTag"), nameByNodeType = {
    1: "ELEMENT_NODE",
    3: "TEXT_NODE",
    7: "PROCESSING_INSTRUCTION_NODE",
    8: "COMMENT_NODE",
    9: "DOCUMENT_NODE",
    10: "DOCUMENT_TYPE_NODE",
    11: "DOCUMENT_FRAGMENT_NODE"
  }, DOMNodePreview = __name(({ isCloseTag, data, expanded }) => {
    let styles3 = useStyles("DOMNodePreview");
    if (isCloseTag)
      return react_default.createElement(CloseTag, {
        styles: styles3.htmlCloseTag,
        isChildNode: !0,
        tagName: data.tagName
      });
    switch (data.nodeType) {
      case Node.ELEMENT_NODE:
        return react_default.createElement("span", null, react_default.createElement(OpenTag, {
          tagName: data.tagName,
          attributes: data.attributes,
          styles: styles3.htmlOpenTag
        }), shouldInline(data) ? data.textContent : !expanded && "\u2026", !expanded && react_default.createElement(CloseTag, {
          tagName: data.tagName,
          styles: styles3.htmlCloseTag
        }));
      case Node.TEXT_NODE:
        return react_default.createElement("span", null, data.textContent);
      case Node.CDATA_SECTION_NODE:
        return react_default.createElement("span", null, "<![CDATA[" + data.textContent + "]]>");
      case Node.COMMENT_NODE:
        return react_default.createElement("span", {
          style: styles3.htmlComment
        }, "<!--", data.textContent, "-->");
      case Node.PROCESSING_INSTRUCTION_NODE:
        return react_default.createElement("span", null, data.nodeName);
      case Node.DOCUMENT_TYPE_NODE:
        return react_default.createElement("span", {
          style: styles3.htmlDoctype
        }, "<!DOCTYPE ", data.name, data.publicId ? ` PUBLIC "${data.publicId}"` : "", !data.publicId && data.systemId ? " SYSTEM" : "", data.systemId ? ` "${data.systemId}"` : "", ">");
      case Node.DOCUMENT_NODE:
        return react_default.createElement("span", null, data.nodeName);
      case Node.DOCUMENT_FRAGMENT_NODE:
        return react_default.createElement("span", null, data.nodeName);
      default:
        return react_default.createElement("span", null, nameByNodeType[data.nodeType]);
    }
  }, "DOMNodePreview"), domIterator = __name(function* (data) {
    if (data && data.childNodes) {
      if (shouldInline(data))
        return;
      for (let i22 = 0; i22 < data.childNodes.length; i22++) {
        let node = data.childNodes[i22];
        node.nodeType === Node.TEXT_NODE && node.textContent.trim().length === 0 || (yield {
          name: `${node.tagName}[${i22}]`,
          data: node
        });
      }
      data.tagName && (yield {
        name: "CLOSE_TAG",
        data: {
          tagName: data.tagName
        },
        isCloseTag: !0
      });
    }
  }, "domIterator"), DOMInspector = __name((props) => react_default.createElement(TreeView, {
    nodeRenderer: DOMNodePreview,
    dataIterator: domIterator,
    ...props
  }), "DOMInspector"), themedDOMInspector = themeAcceptor(DOMInspector), import_is_dom = __toESM22(require_is_dom()), Inspector = __name(({ table = !1, data, ...rest }) => table ? react_default.createElement(themedTableInspector, {
    data,
    ...rest
  }) : (0, import_is_dom.default)(data) ? react_default.createElement(themedDOMInspector, {
    data,
    ...rest
  }) : react_default.createElement(themedObjectInspector, {
    data,
    ...rest
  }), "Inspector"), Action = styled.div({
    display: "flex",
    padding: 0,
    borderLeft: "5px solid transparent",
    borderBottom: "1px solid transparent",
    transition: "all 0.1s",
    alignItems: "flex-start",
    whiteSpace: "pre"
  }), Counter = styled.div(({ theme: theme3 }) => ({
    backgroundColor: curriedOpacify$1(0.5, theme3.appBorderColor),
    color: theme3.color.inverseText,
    fontSize: theme3.typography.size.s1,
    fontWeight: theme3.typography.weight.bold,
    lineHeight: 1,
    padding: "1px 5px",
    borderRadius: 20,
    margin: "2px 0px"
  })), InspectorContainer = styled.div({
    flex: 1,
    padding: "0 0 0 5px"
  }), UnstyledWrapped = forwardRef(
    ({ children, className }, ref) => react_default.createElement(ScrollArea3, { ref, horizontal: !0, vertical: !0, className }, children)
  );
  UnstyledWrapped.displayName = "UnstyledWrapped";
  var Wrapper10 = styled(UnstyledWrapped)({
    margin: 0,
    padding: "10px 5px 20px"
  }), ThemedInspector = withTheme(({ theme: theme3, ...props }) => react_default.createElement(Inspector, { theme: theme3.addonActionsTheme || "chromeLight", table: !1, ...props })), ActionLogger = __name(({ actions: actions2, onClear }) => {
    let wrapperRef = useRef(null), wrapper = wrapperRef.current, wasAtBottom = wrapper && wrapper.scrollHeight - wrapper.scrollTop === wrapper.clientHeight;
    return useEffect(() => {
      wasAtBottom && (wrapperRef.current.scrollTop = wrapperRef.current.scrollHeight);
    }, [wasAtBottom, actions2.length]), react_default.createElement(Fragment, null, react_default.createElement(Wrapper10, { ref: wrapperRef }, actions2.map((action2) => react_default.createElement(Action, { key: action2.id }, action2.count > 1 && react_default.createElement(Counter, null, action2.count), react_default.createElement(InspectorContainer, null, react_default.createElement(
      ThemedInspector,
      {
        sortObjectKeys: !0,
        showNonenumerable: !1,
        name: action2.data.name,
        data: action2.data.args ?? action2.data
      }
    ))))), react_default.createElement(ActionBar2, { actionItems: [{ title: "Clear", onClick: onClear }] }));
  }, "ActionLogger"), safeDeepEqual = __name((a22, b22) => {
    try {
      return dequal(a22, b22);
    } catch {
      return !1;
    }
  }, "safeDeepEqual"), _ActionLogger = class extends Component {
    constructor(props) {
      super(props), this.handleStoryChange = __name(() => {
        let { actions: actions2 } = this.state;
        actions2.length > 0 && actions2[0].options.clearOnStoryChange && this.clearActions();
      }, "handleStoryChange"), this.addAction = __name((action2) => {
        this.setState((prevState) => {
          let actions2 = [...prevState.actions], previous = actions2.length && actions2[actions2.length - 1];
          return previous && safeDeepEqual(previous.data, action2.data) ? previous.count++ : (action2.count = 1, actions2.push(action2)), { actions: actions2.slice(0, action2.options.limit) };
        });
      }, "addAction"), this.clearActions = __name(() => {
        let { api } = this.props;
        api.emit(CLEAR_ID), this.setState({ actions: [] });
      }, "clearActions"), this.mounted = !1, this.state = { actions: [] };
    }
    componentDidMount() {
      this.mounted = !0;
      let { api } = this.props;
      api.on(EVENT_ID, this.addAction), api.on(STORY_CHANGED, this.handleStoryChange);
    }
    componentWillUnmount() {
      this.mounted = !1;
      let { api } = this.props;
      api.off(STORY_CHANGED, this.handleStoryChange), api.off(EVENT_ID, this.addAction);
    }
    render() {
      let { actions: actions2 = [] } = this.state, { active } = this.props, props = {
        actions: actions2,
        onClear: this.clearActions
      };
      return active ? react_default.createElement(ActionLogger, { ...props }) : null;
    }
  };
  __name(_ActionLogger, "ActionLogger");
  var ActionLogger2 = _ActionLogger, manager_default2 = addons3.register(ADDON_ID6, (api) => {
    globalThis?.FEATURES?.actions && addons3.add(PANEL_ID2, {
      title: Title32,
      type: types.PANEL,
      render: __name(({ active }) => react_default.createElement(ActionLogger2, { api, active: !!active }), "render"),
      paramKey: PARAM_KEY4
    });
  }), ADDON_ID72 = "storybook/interactions", PANEL_ID22 = `${ADDON_ID72}/panel`, DOCUMENTATION_LINK = "writing-tests/integrations/vitest-addon", DOCUMENTATION_DISCREPANCY_LINK = `${DOCUMENTATION_LINK}#what-happens-when-there-are-different-test-results-in-multiple-environments`, DOCUMENTATION_PLAY_FUNCTION_LINK = "writing-stories/play-function#writing-stories-with-the-play-function", INTERNAL_RENDER_CALL_ID = "internal_render_call", ADDON_ID8 = "storybook/a11y", PANEL_ID32 = `${ADDON_ID8}/panel`, UI_STATE_ID = `${ADDON_ID8}/ui`, RESULT = `${ADDON_ID8}/result`, REQUEST = `${ADDON_ID8}/request`, RUNNING = `${ADDON_ID8}/running`, ERROR2 = `${ADDON_ID8}/error`, MANUAL = `${ADDON_ID8}/manual`, SELECT = `${ADDON_ID8}/select`, DOCUMENTATION_LINK2 = "writing-tests/accessibility-testing", DOCUMENTATION_DISCREPANCY_LINK2 = `${DOCUMENTATION_LINK2}#why-are-my-tests-failing-in-different-environments`, ADDON_ID9 = "storybook/test", TEST_PROVIDER_ID = `${ADDON_ID9}/test-provider`, STORYBOOK_ADDON_TEST_CHANNEL = "STORYBOOK_ADDON_TEST_CHANNEL", DOCUMENTATION_LINK3 = "writing-tests/integrations/vitest-addon", DOCUMENTATION_FATAL_ERROR_LINK = `${DOCUMENTATION_LINK3}#what-happens-if-vitest-itself-has-an-error`, storeOptions = {
    id: ADDON_ID9,
    initialState: {
      config: {
        coverage: !1,
        a11y: !1
      },
      watching: !1,
      cancelling: !1,
      fatalError: void 0,
      indexUrl: void 0,
      previewAnnotations: [],
      currentRun: {
        triggeredBy: void 0,
        config: {
          coverage: !1,
          a11y: !1
        },
        componentTestCount: {
          success: 0,
          error: 0
        },
        a11yCount: {
          success: 0,
          warning: 0,
          error: 0
        },
        storyIds: void 0,
        totalTestCount: void 0,
        startedAt: void 0,
        finishedAt: void 0,
        unhandledErrors: [],
        coverageSummary: void 0
      }
    }
  }, STORE_CHANNEL_EVENT_NAME = `UNIVERSAL_STORE:${storeOptions.id}`, STATUS_TYPE_ID_COMPONENT_TEST = "storybook/component-test", import_ansi_to_html2 = __toESM2(require_ansi_to_html(), 1);
  function ansiRegex({ onlyFirst = !1 } = {}) {
    let pattern = "(?:\\u001B\\][\\s\\S]*?(?:\\u0007|\\u001B\\u005C|\\u009C))|[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  }
  __name(ansiRegex, "ansiRegex");
  var regex = ansiRegex();
  function stripAnsi(string) {
    if (typeof string != "string")
      throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    return string.replace(regex, "");
  }
  __name(stripAnsi, "stripAnsi");
  function isTestAssertionError(error) {
    return isChaiError(error) || isJestError(error);
  }
  __name(isTestAssertionError, "isTestAssertionError");
  function isChaiError(error) {
    return error && typeof error == "object" && "name" in error && typeof error.name == "string" && error.name === "AssertionError";
  }
  __name(isChaiError, "isChaiError");
  function isJestError(error) {
    return error && typeof error == "object" && "message" in error && typeof error.message == "string" && stripAnsi(error.message).startsWith("expect(");
  }
  __name(isJestError, "isJestError");
  function createAnsiToHtmlFilter(theme3) {
    return new import_ansi_to_html2.default({
      escapeXML: !0,
      fg: theme3.color.defaultText,
      bg: theme3.background.content
    });
  }
  __name(createAnsiToHtmlFilter, "createAnsiToHtmlFilter");
  function useAnsiToHtmlFilter() {
    let theme3 = useTheme();
    return createAnsiToHtmlFilter(theme3);
  }
  __name(useAnsiToHtmlFilter, "useAnsiToHtmlFilter");
  var Wrapper11 = styled.div(({ theme: { color: color2, typography: typography4, background: background2 } }) => ({
    textAlign: "start",
    padding: "11px 15px",
    fontSize: `${typography4.size.s2 - 1}px`,
    fontWeight: typography4.weight.regular,
    lineHeight: "1rem",
    background: background2.app,
    borderBottom: `1px solid ${color2.border}`,
    color: color2.defaultText,
    backgroundClip: "padding-box",
    position: "relative"
  })), DetachedDebuggerMessage = __name(({ storyUrl }) => react_default.createElement(Wrapper11, null, "Debugger controls are not available on composed Storybooks.", " ", react_default.createElement(
    Link3,
    {
      href: `${storyUrl}&addonPanel=${PANEL_ID22}`,
      target: "_blank",
      rel: "noopener noreferrer",
      withArrow: !0
    },
    "Open in external Storybook"
  )), "DetachedDebuggerMessage"), Links22 = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    fontSize: theme3.typography.size.s2 - 1,
    gap: 25
  })), Empty2 = __name(() => {
    let [isLoading, setIsLoading] = useState(!0), docsUrl = useStorybookApi().getDocsUrl({
      subpath: DOCUMENTATION_PLAY_FUNCTION_LINK,
      versioned: !0,
      renderer: !0
    });
    return useEffect(() => {
      let load = setTimeout(() => {
        setIsLoading(!1);
      }, 100);
      return () => clearTimeout(load);
    }, []), isLoading ? null : react_default.createElement("div", null, react_default.createElement(
      EmptyTabContent2,
      {
        title: "Interactions",
        description: react_default.createElement(react_default.Fragment, null, "Interactions allow you to verify the functional aspects of UIs. Write a play function for your story and you'll see it run here."),
        footer: react_default.createElement(Links22, null, react_default.createElement(Link3, { href: docsUrl, target: "_blank", withArrow: !0 }, react_default.createElement(DocumentIcon, null), " Read docs"))
      }
    ));
  }, "Empty");
  function toVal(mix2) {
    var k22, y22, str2 = "";
    if (mix2)
      if (typeof mix2 == "object")
        if (Array.isArray(mix2))
          for (k22 = 0; k22 < mix2.length; k22++)
            mix2[k22] && (y22 = toVal(mix2[k22])) && (str2 && (str2 += " "), str2 += y22);
        else
          for (k22 in mix2)
            mix2[k22] && (y22 = toVal(k22)) && (str2 && (str2 += " "), str2 += y22);
      else typeof mix2 != "boolean" && !mix2.call && (str2 && (str2 += " "), str2 += mix2);
    return str2;
  }
  __name(toVal, "toVal");
  function clsx_m_default() {
    for (var i22 = 0, x22, str2 = ""; i22 < arguments.length; )
      (x22 = toVal(arguments[i22++])) && (str2 && (str2 += " "), str2 += x22);
    return str2;
  }
  __name(clsx_m_default, "default");
  var isArray = __name((val) => Array.isArray(val) || // Detect https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays
  ArrayBuffer.isView(val) && !(val instanceof DataView), "isArray"), isObject4 = __name((val) => val !== null && typeof val == "object" && !isArray(val) && !(val instanceof Date) && !(val instanceof RegExp) && !(val instanceof Error) && !(val instanceof WeakMap) && !(val instanceof WeakSet), "isObject"), isKnownObject = __name((val) => isObject4(val) || isArray(val) || typeof val == "function" || val instanceof Promise, "isKnownObject"), getPromiseState = __name((promise) => {
    let unique = /unique/;
    return Promise.race([promise, unique]).then((result) => result === unique ? ["pending"] : ["fulfilled", result], (e2) => ["rejected", e2]);
  }, "getPromiseState"), buildAST = __name(async (key, value2, depth, sortKeys, isPrototype, showPrototype) => {
    let astNode = {
      key,
      depth,
      value: value2,
      type: "value",
      parent: void 0
    };
    if (value2 && isKnownObject(value2) && depth < 100) {
      let children = [], t = "object";
      if (isArray(value2)) {
        for (let i22 = 0; i22 < value2.length; i22++)
          children.push(async () => {
            let child = await buildAST(i22.toString(), value2[i22], depth + 1, sortKeys);
            return child.parent = astNode, child;
          });
        t = "array";
      } else {
        let keys = Object.getOwnPropertyNames(value2);
        sortKeys && keys.sort();
        for (let i22 = 0; i22 < keys.length; i22++) {
          let safeValue;
          try {
            safeValue = value2[keys[i22]];
          } catch {
          }
          children.push(async () => {
            let child = await buildAST(keys[i22], safeValue, depth + 1, sortKeys);
            return child.parent = astNode, child;
          });
        }
        if (typeof value2 == "function" && (t = "function"), value2 instanceof Promise) {
          let [status, result] = await getPromiseState(value2);
          children.push(async () => {
            let child = await buildAST("<state>", status, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), status !== "pending" && children.push(async () => {
            let child = await buildAST("<value>", result, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "promise";
        }
        if (value2 instanceof Map) {
          let parsedEntries = Array.from(value2.entries()).map((entry) => {
            let [entryKey, entryValue] = entry;
            return {
              "<key>": entryKey,
              "<value>": entryValue
            };
          });
          children.push(async () => {
            let child = await buildAST("<entries>", parsedEntries, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), children.push(async () => {
            let child = await buildAST("size", value2.size, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "map";
        }
        if (value2 instanceof Set) {
          let parsedEntries = Array.from(value2.entries()).map((entry) => entry[1]);
          children.push(async () => {
            let child = await buildAST("<entries>", parsedEntries, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), children.push(async () => {
            let child = await buildAST("size", value2.size, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "set";
        }
      }
      value2 !== Object.prototype && showPrototype && children.push(async () => {
        let child = await buildAST("<prototype>", Object.getPrototypeOf(value2), depth + 1, sortKeys, !0);
        return child.parent = astNode, child;
      }), astNode.type = t, astNode.children = children, astNode.isPrototype = isPrototype;
    }
    return astNode;
  }, "buildAST"), parse42 = __name((data, sortKeys, includePrototypes) => buildAST("root", data, 0, sortKeys === !1 ? sortKeys : !0, void 0, includePrototypes === !1 ? includePrototypes : !0), "parse");
  function ownKeys3(e2, r2) {
    var t = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  __name(ownKeys3, "ownKeys");
  function _objectSpread22(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = arguments[r2] != null ? arguments[r2] : {};
      r2 % 2 ? ownKeys3(Object(t), !0).forEach(function(r3) {
        _defineProperty(e2, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e2;
  }
  __name(_objectSpread22, "_objectSpread2");
  var _excluded4 = ["children"], ThemeContext2 = react_default.createContext({
    theme: "chrome",
    colorScheme: "light"
  }), ThemeProvider2 = __name((_ref) => {
    let {
      children
    } = _ref, value2 = _objectWithoutProperties(_ref, _excluded4), wrappedTheme = react_default.useContext(ThemeContext2);
    return react_default.createElement(ThemeContext2.Provider, {
      value: _objectSpread22(_objectSpread22({}, wrappedTheme), value2)
    }, children);
  }, "ThemeProvider"), useTheme4 = __name((props, styles3 = {}) => {
    let themeContext = react_default.useContext(ThemeContext2), currentTheme = props.theme || themeContext.theme || "chrome", currentColorScheme = props.colorScheme || themeContext.colorScheme || "light", themeClass = clsx_m_default(styles3[currentTheme], styles3[currentColorScheme]);
    return {
      currentColorScheme,
      currentTheme,
      themeClass
    };
  }, "useTheme"), TreeContext = react_default.createContext({
    isChild: !1,
    depth: 0,
    hasHover: !0
  }), TreeContext_default = TreeContext, Tree_css_default = { tree: "Tree-tree-fbbbe38", item: "Tree-item-353d6f3", group: "Tree-group-d3c3d8a", label: "Tree-label-d819155", focusWhite: "Tree-focusWhite-f1e00c2", arrow: "Tree-arrow-03ab2e7", hover: "Tree-hover-3cc4e5d", open: "Tree-open-3f1a336", dark: "Tree-dark-1b4aa00", chrome: "Tree-chrome-bcbcac6", light: "Tree-light-09174ee" }, _excluded22 = ["theme", "hover", "colorScheme", "children", "label", "className", "onUpdate", "onSelect", "open"], Tree = __name((props) => {
    let {
      theme: theme3,
      hover,
      colorScheme,
      children,
      label,
      className,
      onUpdate,
      onSelect,
      open
    } = props, html = _objectWithoutProperties(props, _excluded22), {
      themeClass,
      currentTheme
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, Tree_css_default), [isOpen, setOpen] = useState(open);
    useEffect(() => {
      setOpen(open);
    }, [open]);
    let updateState = __name((value2) => {
      setOpen(value2), onUpdate && onUpdate(value2);
    }, "updateState"), hasChildren = react_default.Children.count(children) > 0, updateFocus = __name((newNode, previousNode) => {
      if (newNode.isSameNode(previousNode || null)) return;
      let focusableNode = newNode.querySelector('[tabindex="-1"]');
      focusableNode?.focus(), newNode.setAttribute("aria-selected", "true"), previousNode?.removeAttribute("aria-selected");
    }, "updateFocus"), getParent = __name((node, role) => {
      let parent = node;
      for (; parent && parent.parentElement; ) {
        if (parent.getAttribute("role") === role)
          return parent;
        parent = parent.parentElement;
      }
      return null;
    }, "getParent"), getListElements = __name((node) => {
      let tree = getParent(node, "tree");
      return tree ? Array.from(tree.querySelectorAll("li")) : [];
    }, "getListElements"), moveBack = __name((node) => {
      let group = getParent(node, "group"), toggle = group?.previousElementSibling;
      if (toggle && toggle.getAttribute("tabindex") === "-1") {
        let toggleParent = toggle.parentElement, nodeParent = node.parentElement;
        updateFocus(toggleParent, nodeParent);
      }
    }, "moveBack"), moveHome = __name((node, direction) => {
      let elements = getListElements(node);
      elements.forEach((element) => {
        element.removeAttribute("aria-selected");
      }), direction === "start" && elements[0] && updateFocus(elements[0]), direction === "end" && elements[elements.length - 1] && updateFocus(elements[elements.length - 1]);
    }, "moveHome"), moveFocusAdjacent = __name((node, direction) => {
      let elements = getListElements(node) || [];
      for (let i22 = 0; i22 < elements.length; i22++) {
        let currentNode = elements[i22];
        if (currentNode.getAttribute("aria-selected") === "true") {
          direction === "up" && elements[i22 - 1] ? updateFocus(elements[i22 - 1], currentNode) : direction === "down" && elements[i22 + 1] && updateFocus(elements[i22 + 1], currentNode);
          return;
        }
      }
      updateFocus(elements[0]);
    }, "moveFocusAdjacent"), handleKeypress = __name((event, isChild2) => {
      let node = event.target;
      (event.key === "Enter" || event.key === " ") && updateState(!isOpen), event.key === "ArrowRight" && isOpen && !isChild2 ? moveFocusAdjacent(node, "down") : event.key === "ArrowRight" && updateState(!0), event.key === "ArrowLeft" && (!isOpen || isChild2) ? moveBack(node) : event.key === "ArrowLeft" && updateState(!1), event.key === "ArrowDown" && moveFocusAdjacent(node, "down"), event.key === "ArrowUp" && moveFocusAdjacent(node, "up"), event.key === "Home" && moveHome(node, "start"), event.key === "End" && moveHome(node, "end");
    }, "handleKeypress"), handleClick = __name((event, isChild2) => {
      let node = event.target, parent = getParent(node, "treeitem"), elements = getListElements(node) || [], found = !1;
      for (let i22 = 0; i22 < elements.length; i22++) {
        let currentNode = elements[i22];
        if (currentNode.getAttribute("aria-selected") === "true") {
          parent && (found = !0, updateFocus(parent, currentNode));
          break;
        }
      }
      !found && parent && updateFocus(parent), isChild2 || updateState(!isOpen);
    }, "handleClick"), handleBlur = __name((event) => {
      let node = event.currentTarget;
      !node.contains(document.activeElement) && node.getAttribute("role") === "tree" && node.setAttribute("tabindex", "0");
    }, "handleBlur"), handleFocus = __name((event) => {
      let node = event.target;
      if (node.getAttribute("role") === "tree") {
        let selected = node.querySelector('[aria-selected="true"]');
        selected ? updateFocus(selected) : moveFocusAdjacent(node, "down"), node.setAttribute("tabindex", "-1");
      }
    }, "handleFocus"), handleButtonFocus = __name(() => {
      onSelect?.();
    }, "handleButtonFocus"), getPaddingStyles = __name((depth2) => {
      let space = depth2 * 0.9 + 0.3;
      return {
        paddingLeft: `${space}em`,
        width: `calc(100% - ${space}em)`
      };
    }, "getPaddingStyles"), {
      isChild,
      depth,
      hasHover
    } = react_default.useContext(TreeContext_default), showHover = hasHover ? hover : !1;
    if (!isChild)
      return react_default.createElement("ul", _extends({
        role: "tree",
        tabIndex: 0,
        className: clsx_m_default(Tree_css_default.tree, Tree_css_default.group, themeClass, className),
        onFocus: handleFocus,
        onBlur: handleBlur
      }, html), react_default.createElement(TreeContext_default.Provider, {
        value: {
          isChild: !0,
          depth: 0,
          hasHover: showHover
        }
      }, react_default.createElement(Tree, props)));
    if (!hasChildren)
      return react_default.createElement("li", _extends({
        role: "treeitem",
        className: Tree_css_default.item
      }, html), react_default.createElement("div", {
        role: "button",
        className: clsx_m_default(Tree_css_default.label, {
          [Tree_css_default.hover]: showHover,
          [Tree_css_default.focusWhite]: currentTheme === "firefox"
        }),
        tabIndex: -1,
        style: getPaddingStyles(depth),
        onKeyDown: __name((e2) => {
          handleKeypress(e2, isChild);
        }, "onKeyDown"),
        onClick: __name((e2) => handleClick(e2, !0), "onClick"),
        onFocus: handleButtonFocus
      }, react_default.createElement("span", null, label)));
    let arrowClass = clsx_m_default(Tree_css_default.arrow, {
      [Tree_css_default.open]: isOpen
    });
    return react_default.createElement("li", {
      role: "treeitem",
      "aria-expanded": isOpen,
      className: Tree_css_default.item
    }, react_default.createElement("div", {
      role: "button",
      tabIndex: -1,
      className: clsx_m_default(Tree_css_default.label, {
        [Tree_css_default.hover]: showHover,
        [Tree_css_default.focusWhite]: currentTheme === "firefox"
      }),
      style: getPaddingStyles(depth),
      onClick: __name((e2) => handleClick(e2), "onClick"),
      onKeyDown: __name((e2) => handleKeypress(e2), "onKeyDown"),
      onFocus: handleButtonFocus
    }, react_default.createElement("span", null, react_default.createElement("span", {
      "aria-hidden": !0,
      className: arrowClass
    }), react_default.createElement("span", null, label))), react_default.createElement("ul", _extends({
      role: "group",
      className: clsx_m_default(className, Tree_css_default.group)
    }, html), isOpen && react_default.Children.map(children, (child) => react_default.createElement(TreeContext_default.Provider, {
      value: {
        isChild: !0,
        depth: depth + 1,
        hasHover: showHover
      }
    }, child))));
  }, "Tree");
  Tree.defaultProps = {
    open: !1,
    hover: !0
  };
  var ObjectInspector_css_default = { "object-inspector": "ObjectInspector-object-inspector-0c33e82", objectInspector: "ObjectInspector-object-inspector-0c33e82", "object-label": "ObjectInspector-object-label-b81482b", objectLabel: "ObjectInspector-object-label-b81482b", text: "ObjectInspector-text-25f57f3", key: "ObjectInspector-key-4f712bb", value: "ObjectInspector-value-f7ec2e5", string: "ObjectInspector-string-c496000", regex: "ObjectInspector-regex-59d45a3", error: "ObjectInspector-error-b818698", boolean: "ObjectInspector-boolean-2dd1642", number: "ObjectInspector-number-a6daabb", undefined: "ObjectInspector-undefined-3a68263", null: "ObjectInspector-null-74acb50", function: "ObjectInspector-function-07bbdcd", "function-decorator": "ObjectInspector-function-decorator-3d22c24", functionDecorator: "ObjectInspector-function-decorator-3d22c24", prototype: "ObjectInspector-prototype-f2449ee", dark: "ObjectInspector-dark-0c96c97", chrome: "ObjectInspector-chrome-2f3ca98", light: "ObjectInspector-light-78bef54" }, _excluded32 = ["ast", "theme", "showKey", "colorScheme", "className"], buildValue = __name((key, value2, valueClass, showKey, depth) => {
    let computedKey = key.includes("-") ? `"${key}"` : key, isRoot = depth <= 0;
    return react_default.createElement("span", {
      className: ObjectInspector_css_default.text
    }, !isRoot && showKey && react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
      className: ObjectInspector_css_default.key
    }, computedKey), react_default.createElement("span", null, ":\xA0")), react_default.createElement("span", {
      className: valueClass
    }, value2));
  }, "buildValue"), ObjectValue2 = __name((props) => {
    let {
      ast,
      theme: theme3,
      showKey,
      colorScheme,
      className
    } = props, html = _objectWithoutProperties(props, _excluded32), {
      themeClass
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default), [asyncValue, setAsyncValue] = useState(react_default.createElement("span", null)), value2 = react_default.createElement("span", null);
    return useEffect(() => {
      ast.value instanceof Promise && __name(async (promise) => {
        setAsyncValue(buildValue(ast.key, `Promise { "${await getPromiseState(promise)}" }`, ObjectInspector_css_default.key, showKey, ast.depth));
      }, "waitForPromiseResult")(ast.value);
    }, [ast, showKey]), typeof ast.value == "number" || typeof ast.value == "bigint" ? value2 = buildValue(ast.key, String(ast.value), ObjectInspector_css_default.number, showKey, ast.depth) : typeof ast.value == "boolean" ? value2 = buildValue(ast.key, String(ast.value), ObjectInspector_css_default.boolean, showKey, ast.depth) : typeof ast.value == "string" ? value2 = buildValue(ast.key, `"${ast.value}"`, ObjectInspector_css_default.string, showKey, ast.depth) : typeof ast.value > "u" ? value2 = buildValue(ast.key, "undefined", ObjectInspector_css_default.undefined, showKey, ast.depth) : typeof ast.value == "symbol" ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.string, showKey, ast.depth) : typeof ast.value == "function" ? value2 = buildValue(ast.key, `${ast.value.name}()`, ObjectInspector_css_default.key, showKey, ast.depth) : typeof ast.value == "object" && (ast.value === null ? value2 = buildValue(ast.key, "null", ObjectInspector_css_default.null, showKey, ast.depth) : Array.isArray(ast.value) ? value2 = buildValue(ast.key, `Array(${ast.value.length})`, ObjectInspector_css_default.key, showKey, ast.depth) : ast.value instanceof Date ? value2 = buildValue(ast.key, `Date ${ast.value.toString()}`, ObjectInspector_css_default.value, showKey, ast.depth) : ast.value instanceof RegExp ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.regex, showKey, ast.depth) : ast.value instanceof Error ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.error, showKey, ast.depth) : isObject4(ast.value) ? value2 = buildValue(ast.key, "{\u2026}", ObjectInspector_css_default.key, showKey, ast.depth) : value2 = buildValue(ast.key, ast.value.constructor.name, ObjectInspector_css_default.key, showKey, ast.depth)), react_default.createElement("span", _extends({
      className: clsx_m_default(themeClass, className)
    }, html), asyncValue, value2);
  }, "ObjectValue");
  ObjectValue2.defaultProps = {
    showKey: !0
  };
  var ObjectValue_default = ObjectValue2, _excluded42 = ["ast", "theme", "previewMax", "open", "colorScheme", "className"], buildPreview = __name((children, previewMax, showKey) => {
    let previews = [];
    for (let i22 = 0; i22 < children.length; i22++) {
      let child = children[i22];
      if (child.isPrototype || (previews.push(react_default.createElement(ObjectValue_default, {
        key: child.key,
        ast: child,
        showKey
      })), i22 < children.length - 1 ? previews.push(", ") : previews.push(" ")), child.isPrototype && i22 === children.length - 1 && (previews.pop(), previews.push(" ")), i22 === previewMax - 1 && children.length > previewMax) {
        previews.push("\u2026 ");
        break;
      }
    }
    return previews;
  }, "buildPreview"), getArrayLabel = __name((ast, open, previewMax, theme3) => {
    let l2 = ast.value.length;
    return open ? react_default.createElement("span", null, "Array(", l2, ")") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `${theme3 === "firefox" ? "Array" : ""}(${l2}) [ `), buildPreview(ast.children, previewMax, !1), react_default.createElement("span", null, "]"));
  }, "getArrayLabel"), getObjectLabel = __name((ast, open, previewMax, theme3) => ast.isPrototype ? react_default.createElement("span", null, `Object ${theme3 === "firefox" ? "{ \u2026 }" : ""}`) : open ? react_default.createElement("span", null, "{\u2026}") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `${theme3 === "firefox" ? "Object " : ""}{ `), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}")), "getObjectLabel"), getPromiseLabel = __name((ast, open, previewMax) => open ? react_default.createElement("span", null, `Promise { "${String(ast.children[0].value)}" }`) : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, "Promise { "), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}")), "getPromiseLabel"), getMapLabel = __name((ast, open, previewMax, theme3) => {
    let {
      size
    } = ast.value;
    return open ? react_default.createElement("span", null, `Map(${size})`) : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `Map${theme3 === "chrome" ? `(${size})` : ""} { `), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}"));
  }, "getMapLabel"), getSetLabel = __name((ast, open, previewMax) => {
    let {
      size
    } = ast.value;
    return open ? react_default.createElement("span", null, "Set(", size, ")") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `Set(${ast.value.size}) {`), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}"));
  }, "getSetLabel"), ObjectLabel2 = __name((props) => {
    let {
      ast,
      theme: theme3,
      previewMax,
      open,
      colorScheme,
      className
    } = props, html = _objectWithoutProperties(props, _excluded42), {
      themeClass,
      currentTheme
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default), isPrototype = ast.isPrototype || !1, classes2 = clsx_m_default(ObjectInspector_css_default.objectLabel, themeClass, className, {
      [ObjectInspector_css_default.prototype]: isPrototype
    }), isRoot = ast.depth <= 0, Key = __name(() => react_default.createElement("span", {
      className: isPrototype ? ObjectInspector_css_default.prototype : ObjectInspector_css_default.key
    }, isRoot ? "" : `${ast.key}: `), "Key");
    return ast.type === "array" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getArrayLabel(ast, open, previewMax, currentTheme)) : ast.type === "function" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), currentTheme === "chrome" && react_default.createElement("span", {
      className: ObjectInspector_css_default.functionDecorator
    }, "\u0192 "), react_default.createElement("span", {
      className: clsx_m_default({
        [ObjectInspector_css_default.function]: !isPrototype
      })
    }, `${ast.value.name}()`)) : ast.type === "promise" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getPromiseLabel(ast, open, previewMax)) : ast.type === "map" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getMapLabel(ast, open, previewMax, currentTheme)) : ast.type === "set" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getSetLabel(ast, open, previewMax)) : react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getObjectLabel(ast, open, previewMax, currentTheme));
  }, "ObjectLabel");
  ObjectLabel2.defaultProps = {
    previewMax: 8,
    open: !1
  };
  var ObjectLabel_default = ObjectLabel2, ObjectInspectorItem = __name((props) => {
    let {
      ast,
      expandLevel,
      depth
    } = props, [resolved, setResolved] = useState(), [open, setOpen] = useState(depth < expandLevel);
    return useEffect(() => {
      __name(async () => {
        if (ast.type !== "value") {
          let promises = ast.children.map((f22) => f22()), children = await Promise.all(promises), r2 = _objectSpread22(_objectSpread22({}, ast), {}, {
            children
          });
          setResolved(r2);
        }
      }, "resolve")();
    }, [ast]), resolved ? react_default.createElement(Tree, {
      hover: !1,
      open,
      label: react_default.createElement(ObjectLabel_default, {
        open,
        ast: resolved
      }),
      onSelect: __name(() => {
        var _props$onSelect;
        (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 || _props$onSelect.call(props, ast);
      }, "onSelect"),
      onUpdate: __name((value2) => {
        setOpen(value2);
      }, "onUpdate")
    }, resolved.children.map((child) => react_default.createElement(ObjectInspectorItem, {
      key: child.key,
      ast: child,
      depth: depth + 1,
      expandLevel,
      onSelect: props.onSelect
    }))) : react_default.createElement(Tree, {
      hover: !1,
      label: react_default.createElement(ObjectValue_default, {
        ast
      }),
      onSelect: __name(() => {
        var _props$onSelect2;
        (_props$onSelect2 = props.onSelect) === null || _props$onSelect2 === void 0 || _props$onSelect2.call(props, ast);
      }, "onSelect")
    });
  }, "ObjectInspectorItem");
  ObjectInspectorItem.defaultProps = {
    expandLevel: 0,
    depth: 0
  };
  var ObjectInspectorItem_default = ObjectInspectorItem, _excluded5 = ["data", "expandLevel", "sortKeys", "includePrototypes", "className", "theme", "colorScheme", "onSelect"], ObjectInspector2 = __name((props) => {
    let {
      data,
      expandLevel,
      sortKeys,
      includePrototypes,
      className,
      theme: theme3,
      colorScheme,
      onSelect
    } = props, html = _objectWithoutProperties(props, _excluded5), [ast, setAST] = useState(void 0), {
      themeClass,
      currentTheme,
      currentColorScheme
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default);
    return useEffect(() => {
      __name(async () => {
        setAST(await parse42(data, sortKeys, includePrototypes));
      }, "runParser")();
    }, [data, sortKeys, includePrototypes]), react_default.createElement("div", _extends({
      className: clsx_m_default(ObjectInspector_css_default.objectInspector, className, themeClass)
    }, html), ast && react_default.createElement(ThemeProvider2, {
      theme: currentTheme,
      colorScheme: currentColorScheme
    }, react_default.createElement(ObjectInspectorItem_default, {
      ast,
      expandLevel,
      onSelect
    })));
  }, "ObjectInspector");
  ObjectInspector2.defaultProps = {
    expandLevel: 0,
    sortKeys: !0,
    includePrototypes: !0
  };
  var colorsLight = {
    base: "#444",
    nullish: "#7D99AA",
    string: "#16B242",
    number: "#5D40D0",
    boolean: "#f41840",
    objectkey: "#698394",
    instance: "#A15C20",
    function: "#EA7509",
    muted: "#7D99AA",
    tag: {
      name: "#6F2CAC",
      suffix: "#1F99E5"
    },
    date: "#459D9C",
    error: {
      name: "#D43900",
      message: "#444"
    },
    regex: {
      source: "#A15C20",
      flags: "#EA7509"
    },
    meta: "#EA7509",
    method: "#0271B6"
  }, colorsDark = {
    base: "#eee",
    nullish: "#aaa",
    string: "#5FE584",
    number: "#6ba5ff",
    boolean: "#ff4191",
    objectkey: "#accfe6",
    instance: "#E3B551",
    function: "#E3B551",
    muted: "#aaa",
    tag: {
      name: "#f57bff",
      suffix: "#8EB5FF"
    },
    date: "#70D4D3",
    error: {
      name: "#f40",
      message: "#eee"
    },
    regex: {
      source: "#FAD483",
      flags: "#E3B551"
    },
    meta: "#FAD483",
    method: "#5EC1FF"
  }, useThemeColors = __name(() => {
    let { base } = useTheme();
    return base === "dark" ? colorsDark : colorsLight;
  }, "useThemeColors"), special = /[^A-Z0-9]/i, trimEnd = /[\s.,]+$/gm, ellipsize = __name((string, maxlength) => {
    if (string.length <= maxlength)
      return string;
    for (let i22 = maxlength - 1; i22 >= 0; i22 -= 1)
      if (special.test(string[i22]) && i22 > 10)
        return `${string.slice(0, i22).replace(trimEnd, "")}\u2026`;
    return `${string.slice(0, maxlength).replace(trimEnd, "")}\u2026`;
  }, "ellipsize"), stringify3 = __name((value2) => {
    try {
      return JSON.stringify(value2, null, 1);
    } catch {
      return String(value2);
    }
  }, "stringify"), interleave = __name((nodes, separator) => nodes.flatMap(
    (node, index3) => index3 === nodes.length - 1 ? [node] : [node, react_default.cloneElement(separator, { key: `sep${index3}` })]
  ), "interleave"), Node2 = __name(({
    value: value2,
    nested,
    showObjectInspector,
    callsById,
    ...props
  }) => {
    switch (!0) {
      case value2 === null:
        return react_default.createElement(NullNode, { ...props });
      case value2 === void 0:
        return react_default.createElement(UndefinedNode, { ...props });
      case Array.isArray(value2):
        return react_default.createElement(ArrayNode, { ...props, value: value2, callsById });
      case typeof value2 == "string":
        return react_default.createElement(StringNode, { ...props, value: value2 });
      case typeof value2 == "number":
        return react_default.createElement(NumberNode, { ...props, value: value2 });
      case typeof value2 == "boolean":
        return react_default.createElement(BooleanNode, { ...props, value: value2 });
      case Object.prototype.hasOwnProperty.call(value2, "__date__"):
        return react_default.createElement(DateNode, { ...props, ...value2.__date__ });
      case Object.prototype.hasOwnProperty.call(value2, "__error__"):
        return react_default.createElement(ErrorNode, { ...props, ...value2.__error__ });
      case Object.prototype.hasOwnProperty.call(value2, "__regexp__"):
        return react_default.createElement(RegExpNode, { ...props, ...value2.__regexp__ });
      case Object.prototype.hasOwnProperty.call(value2, "__function__"):
        return react_default.createElement(FunctionNode, { ...props, ...value2.__function__ });
      case Object.prototype.hasOwnProperty.call(value2, "__symbol__"):
        return react_default.createElement(SymbolNode, { ...props, ...value2.__symbol__ });
      case Object.prototype.hasOwnProperty.call(value2, "__element__"):
        return react_default.createElement(ElementNode, { ...props, ...value2.__element__ });
      case Object.prototype.hasOwnProperty.call(value2, "__class__"):
        return react_default.createElement(ClassNode, { ...props, ...value2.__class__ });
      case Object.prototype.hasOwnProperty.call(value2, "__callId__"):
        return react_default.createElement(MethodCall, { call: callsById?.get(value2.__callId__), callsById });
      case Object.prototype.toString.call(value2) === "[object Object]":
        return react_default.createElement(
          ObjectNode,
          {
            value: value2,
            showInspector: showObjectInspector,
            callsById,
            ...props
          }
        );
      default:
        return react_default.createElement(OtherNode, { value: value2, ...props });
    }
  }, "Node"), NullNode = __name((props) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.nullish }, ...props }, "null");
  }, "NullNode"), UndefinedNode = __name((props) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.nullish }, ...props }, "undefined");
  }, "UndefinedNode"), StringNode = __name(({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.string }, ...props }, JSON.stringify(ellipsize(value2, 50)));
  }, "StringNode"), NumberNode = __name(({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.number }, ...props }, value2);
  }, "NumberNode"), BooleanNode = __name(({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.boolean }, ...props }, String(value2));
  }, "BooleanNode"), ArrayNode = __name(({
    value: value2,
    nested = !1,
    callsById
  }) => {
    let colors3 = useThemeColors();
    if (nested)
      return react_default.createElement("span", { style: { color: colors3.base } }, "[\u2026]");
    let nodes = value2.slice(0, 3).map((v22, index3) => react_default.createElement(Node2, { key: `${index3}--${JSON.stringify(v22)}`, value: v22, nested: !0, callsById })), nodelist = interleave(nodes, react_default.createElement("span", null, ", "));
    return value2.length <= 3 ? react_default.createElement("span", { style: { color: colors3.base } }, "[", nodelist, "]") : react_default.createElement("span", { style: { color: colors3.base } }, "(", value2.length, ") [", nodelist, ", \u2026]");
  }, "ArrayNode"), ObjectNode = __name(({
    showInspector,
    value: value2,
    callsById,
    nested = !1
  }) => {
    let isDarkMode = useTheme().base === "dark", colors3 = useThemeColors();
    if (showInspector)
      return react_default.createElement(react_default.Fragment, null, react_default.createElement(
        ObjectInspector2,
        {
          id: "interactions-object-inspector",
          data: value2,
          includePrototypes: !1,
          colorScheme: isDarkMode ? "dark" : "light"
        }
      ));
    if (nested)
      return react_default.createElement("span", { style: { color: colors3.base } }, "{\u2026}");
    let nodelist = interleave(
      Object.entries(value2).slice(0, 2).map(([k22, v22]) => react_default.createElement(Fragment, { key: k22 }, react_default.createElement("span", { style: { color: colors3.objectkey } }, k22, ": "), react_default.createElement(Node2, { value: v22, callsById, nested: !0 }))),
      react_default.createElement("span", null, ", ")
    );
    return Object.keys(value2).length <= 2 ? react_default.createElement("span", { style: { color: colors3.base } }, "{ ", nodelist, " }") : react_default.createElement("span", { style: { color: colors3.base } }, "(", Object.keys(value2).length, ") ", "{ ", nodelist, ", \u2026 }");
  }, "ObjectNode"), ClassNode = __name(({ name }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.instance } }, name);
  }, "ClassNode"), FunctionNode = __name(({ name }) => {
    let colors3 = useThemeColors();
    return name ? react_default.createElement("span", { style: { color: colors3.function } }, name) : react_default.createElement("span", { style: { color: colors3.nullish, fontStyle: "italic" } }, "anonymous");
  }, "FunctionNode"), ElementNode = __name(({
    prefix: prefix2,
    localName,
    id: id2,
    classNames = [],
    innerText
  }) => {
    let name = prefix2 ? `${prefix2}:${localName}` : localName, colors3 = useThemeColors();
    return react_default.createElement("span", { style: { wordBreak: "keep-all" } }, react_default.createElement("span", { key: `${name}_lt`, style: { color: colors3.muted } }, "<"), react_default.createElement("span", { key: `${name}_tag`, style: { color: colors3.tag.name } }, name), react_default.createElement("span", { key: `${name}_suffix`, style: { color: colors3.tag.suffix } }, id2 ? `#${id2}` : classNames.reduce((acc, className) => `${acc}.${className}`, "")), react_default.createElement("span", { key: `${name}_gt`, style: { color: colors3.muted } }, ">"), !id2 && classNames.length === 0 && innerText && react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { key: `${name}_text` }, innerText), react_default.createElement("span", { key: `${name}_close_lt`, style: { color: colors3.muted } }, "<"), react_default.createElement("span", { key: `${name}_close_tag`, style: { color: colors3.tag.name } }, "/", name), react_default.createElement("span", { key: `${name}_close_gt`, style: { color: colors3.muted } }, ">")));
  }, "ElementNode"), DateNode = __name(({ value: value2 }) => {
    let parsed = new Date(value2);
    isNaN(Number(parsed)) && (logger.warn("Invalid date value:", value2), parsed = null);
    let colors3 = useThemeColors();
    if (!parsed)
      return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.date } }, "Invalid date");
    let [date, time, ms] = parsed.toISOString().split(/[T.Z]/);
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.date } }, date, react_default.createElement("span", { style: { opacity: 0.7 } }, "T"), time === "00:00:00" ? react_default.createElement("span", { style: { opacity: 0.7 } }, time) : time, ms === "000" ? react_default.createElement("span", { style: { opacity: 0.7 } }, ".", ms) : `.${ms}`, react_default.createElement("span", { style: { opacity: 0.7 } }, "Z"));
  }, "DateNode"), ErrorNode = __name(({ name, message }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.error.name } }, name, message && ": ", message && react_default.createElement("span", { style: { color: colors3.error.message }, title: message.length > 50 ? message : "" }, ellipsize(message, 50)));
  }, "ErrorNode"), RegExpNode = __name(({ flags, source }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.regex.flags } }, "/", react_default.createElement("span", { style: { color: colors3.regex.source } }, source), "/", flags);
  }, "RegExpNode"), SymbolNode = __name(({ description }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.instance } }, "Symbol(", description && react_default.createElement("span", { style: { color: colors3.meta } }, '"', description, '"'), ")");
  }, "SymbolNode"), OtherNode = __name(({ value: value2 }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.meta } }, stringify3(value2));
  }, "OtherNode"), StepNode = __name(({ label }) => {
    let colors3 = useThemeColors(), { typography: typography4 } = useTheme();
    return react_default.createElement(
      "span",
      {
        style: {
          color: colors3.base,
          fontFamily: typography4.fonts.base,
          fontSize: typography4.size.s2 - 1
        }
      },
      label
    );
  }, "StepNode"), MethodCall = __name(({
    call,
    callsById
  }) => {
    if (!call)
      return null;
    if (call.method === "step" && call.path?.length === 0)
      return react_default.createElement(StepNode, { label: call.args[0] });
    let path = call.path?.flatMap((elem, index3) => {
      let callId = elem.__callId__;
      return [
        callId ? react_default.createElement(MethodCall, { key: `elem${index3}`, call: callsById?.get(callId), callsById }) : react_default.createElement("span", { key: `elem${index3}` }, elem),
        react_default.createElement("wbr", { key: `wbr${index3}` }),
        react_default.createElement("span", { key: `dot${index3}` }, ".")
      ];
    }), args = call.args?.flatMap((arg, index3, array2) => {
      let node = react_default.createElement(Node2, { key: `node${index3}`, value: arg, callsById });
      return index3 < array2.length - 1 ? [node, react_default.createElement("span", { key: `comma${index3}` }, ",\xA0"), react_default.createElement("wbr", { key: `wbr${index3}` })] : [node];
    }), colors3 = useThemeColors();
    return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: { color: colors3.base } }, path), react_default.createElement("span", { style: { color: colors3.method } }, call.method), react_default.createElement("span", { style: { color: colors3.base } }, "(", react_default.createElement("wbr", null), args, react_default.createElement("wbr", null), ")"));
  }, "MethodCall"), getParams = __name((line, fromIndex = 0) => {
    for (let i22 = fromIndex, depth = 1; i22 < line.length; i22 += 1)
      if (line[i22] === "(" ? depth += 1 : line[i22] === ")" && (depth -= 1), depth === 0)
        return line.slice(fromIndex, i22);
    return "";
  }, "getParams"), parseValue2 = __name((value2) => {
    try {
      return value2 === "undefined" ? void 0 : JSON.parse(value2);
    } catch {
      return value2;
    }
  }, "parseValue"), StyledExpected = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? theme3.color.positiveText : theme3.color.positive
  })), StyledReceived = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? theme3.color.negativeText : theme3.color.negative
  })), Received = __name(({ value: value2, parsed }) => parsed ? react_default.createElement(Node2, { showObjectInspector: !0, value: value2, style: { color: "#D43900" } }) : react_default.createElement(StyledReceived, null, value2), "Received"), Expected = __name(({ value: value2, parsed }) => parsed ? typeof value2 == "string" && value2.startsWith("called with") ? react_default.createElement(react_default.Fragment, null, value2) : react_default.createElement(Node2, { showObjectInspector: !0, value: value2, style: { color: "#16B242" } }) : react_default.createElement(StyledExpected, null, value2), "Expected"), MatcherResult = __name(({
    message,
    style = {}
  }) => {
    let filter = useAnsiToHtmlFilter(), lines = message.split(`
`);
    return react_default.createElement(
      "pre",
      {
        style: {
          margin: 0,
          padding: "8px 10px 8px 36px",
          fontSize: typography.size.s1,
          ...style
        }
      },
      lines.flatMap((line, index3) => {
        if (line.startsWith("expect(")) {
          let received = getParams(line, 7), remainderIndex = received ? 7 + received.length : 0, matcher = received && line.slice(remainderIndex).match(/\.(to|last|nth)[A-Z]\w+\(/);
          if (matcher) {
            let expectedIndex = remainderIndex + (matcher.index ?? 0) + matcher[0].length, expected = getParams(line, expectedIndex);
            if (expected)
              return [
                "expect(",
                react_default.createElement(Received, { key: `received_${received}`, value: received }),
                line.slice(remainderIndex, expectedIndex),
                react_default.createElement(Expected, { key: `expected_${expected}`, value: expected }),
                line.slice(expectedIndex + expected.length),
                react_default.createElement("br", { key: `br${index3}` })
              ];
          }
        }
        if (line.match(/^\s*- /))
          return [react_default.createElement(Expected, { key: line + index3, value: line }), react_default.createElement("br", { key: `br${index3}` })];
        if (line.match(/^\s*\+ /) || line.match(/^Received: $/))
          return [react_default.createElement(Received, { key: line + index3, value: line }), react_default.createElement("br", { key: `br${index3}` })];
        let [, assertionLabel, assertionValue] = line.match(/^(Expected|Received): (.*)$/) || [];
        if (assertionLabel && assertionValue)
          return assertionLabel === "Expected" ? [
            "Expected: ",
            react_default.createElement(Expected, { key: line + index3, value: parseValue2(assertionValue), parsed: !0 }),
            react_default.createElement("br", { key: `br${index3}` })
          ] : [
            "Received: ",
            react_default.createElement(Received, { key: line + index3, value: parseValue2(assertionValue), parsed: !0 }),
            react_default.createElement("br", { key: `br${index3}` })
          ];
        let [, prefix2, numberOfCalls] = line.match(/(Expected number|Received number|Number) of calls: (\d+)$/i) || [];
        if (prefix2 && numberOfCalls)
          return [
            `${prefix2} of calls: `,
            react_default.createElement(Node2, { key: line + index3, value: Number(numberOfCalls) }),
            react_default.createElement("br", { key: `br${index3}` })
          ];
        let [, receivedValue] = line.match(/^Received has value: (.+)$/) || [];
        return receivedValue ? [
          "Received has value: ",
          react_default.createElement(Node2, { key: line + index3, value: parseValue2(receivedValue) }),
          react_default.createElement("br", { key: `br${index3}` })
        ] : [
          react_default.createElement(
            "span",
            {
              key: line + index3,
              dangerouslySetInnerHTML: { __html: filter.toHtml(line) }
            }
          ),
          react_default.createElement("br", { key: `br${index3}` })
        ];
      })
    );
  }, "MatcherResult"), WarningContainer = styled.div({
    width: 14,
    height: 14,
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }), StatusIcon2 = __name(({ status }) => {
    let theme3 = useTheme();
    switch (status) {
      case "done":
        return react_default.createElement(CheckIcon, { color: theme3.color.positive, "data-testid": "icon-done" });
      case "error":
        return react_default.createElement(StopAltIcon, { color: theme3.color.negative, "data-testid": "icon-error" });
      case "active":
        return react_default.createElement(PlayIcon, { color: theme3.color.secondary, "data-testid": "icon-active" });
      case "waiting":
        return react_default.createElement(WarningContainer, { "data-testid": "icon-waiting" }, react_default.createElement(CircleIcon, { color: curriedTransparentize$1(0.5, "#CCCCCC"), size: 6 }));
      default:
        return null;
    }
  }, "StatusIcon"), MethodCallWrapper = styled.div({
    fontFamily: typography.fonts.mono,
    fontSize: typography.size.s1,
    overflowWrap: "break-word",
    inlineSize: "calc( 100% - 40px )"
  }), RowContainer = styled("div", {
    shouldForwardProp: __name((prop) => !["call", "pausedAt"].includes(prop.toString()), "shouldForwardProp")
  })(
    ({ theme: theme3, call }) => ({
      position: "relative",
      display: "flex",
      flexDirection: "column",
      borderBottom: `1px solid ${theme3.appBorderColor}`,
      fontFamily: typography.fonts.base,
      fontSize: 13,
      ...call.status === "error" && {
        backgroundColor: theme3.base === "dark" ? curriedTransparentize$1(0.93, theme3.color.negative) : theme3.background.warning
      },
      paddingLeft: (call.ancestors?.length ?? 0) * 20
    }),
    ({ theme: theme3, call, pausedAt }) => pausedAt === call.id && {
      "&::before": {
        content: '""',
        position: "absolute",
        top: -5,
        zIndex: 1,
        borderTop: "4.5px solid transparent",
        borderLeft: `7px solid ${theme3.color.warning}`,
        borderBottom: "4.5px solid transparent"
      },
      "&::after": {
        content: '""',
        position: "absolute",
        top: -1,
        zIndex: 1,
        width: "100%",
        borderTop: `1.5px solid ${theme3.color.warning}`
      }
    }
  ), RowHeader = styled.div(({ theme: theme3, isInteractive }) => ({
    display: "flex",
    "&:hover": isInteractive ? {} : { background: theme3.background.hoverable }
  })), RowLabel = styled("button", {
    shouldForwardProp: __name((prop) => !["call"].includes(prop.toString()), "shouldForwardProp")
  })(({ theme: theme3, disabled, call }) => ({
    flex: 1,
    display: "grid",
    background: "none",
    border: 0,
    gridTemplateColumns: "15px 1fr",
    alignItems: "center",
    minHeight: 40,
    margin: 0,
    padding: "8px 15px",
    textAlign: "start",
    cursor: disabled || call.status === "error" ? "default" : "pointer",
    "&:focus-visible": {
      outline: 0,
      boxShadow: `inset 3px 0 0 0 ${call.status === "error" ? theme3.color.warning : theme3.color.secondary}`,
      background: call.status === "error" ? "transparent" : theme3.background.hoverable
    },
    "& > div": {
      opacity: call.status === "waiting" ? 0.5 : 1
    }
  })), RowActions = styled.div({
    display: "flex",
    alignItems: "center",
    padding: 6
  }), StyledIconButton = styled(IconButton2)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor,
    margin: "0 3px"
  })), Note3 = styled(TooltipNote2)(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base
  })), RowMessage = styled("div")(({ theme: theme3 }) => ({
    padding: "8px 10px 8px 36px",
    fontSize: typography.size.s1,
    color: theme3.color.defaultText,
    pre: {
      margin: 0,
      padding: 0
    }
  })), ErrorName2 = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? "#5EC1FF" : "#0271B6"
  })), ErrorMessage2 = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? "#eee" : "#444"
  })), ErrorExplainer = styled.p(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? theme3.color.negative : theme3.color.negativeText,
    fontSize: theme3.typography.size.s2,
    maxWidth: 500,
    textWrap: "balance"
  })), Exception = __name(({ exception }) => {
    let filter = useAnsiToHtmlFilter();
    if (!exception)
      return null;
    if (exception.callId === INTERNAL_RENDER_CALL_ID)
      return createElement(RowMessage, null, createElement("pre", null, createElement(ErrorName2, null, exception.name, ":"), " ", createElement(ErrorMessage2, null, exception.message)), createElement(ErrorExplainer, null, "The component failed to render properly. Automated component tests will not run until this is resolved. Check the full error message in Storybook\u2019s canvas to debug."));
    if (isJestError(exception))
      return createElement(MatcherResult, { ...exception });
    if (isChaiError(exception))
      return createElement(RowMessage, null, createElement(
        MatcherResult,
        {
          message: `${exception.message}${exception.diff ? `

${exception.diff}` : ""}`,
          style: { padding: 0 }
        }
      ), createElement("p", null, "See the full stack trace in the browser console."));
    let paragraphs = exception.message.split(`

`), more = paragraphs.length > 1;
    return createElement(RowMessage, null, createElement("pre", { dangerouslySetInnerHTML: { __html: filter.toHtml(paragraphs[0]) } }), more && createElement("p", null, "See the full stack trace in the browser console."));
  }, "Exception"), Interaction = __name(({
    call,
    callsById,
    controls,
    controlStates,
    childCallIds,
    isHidden: isHidden2,
    isCollapsed,
    toggleCollapsed,
    pausedAt
  }) => {
    let [isHovered, setIsHovered] = useState(!1), isInteractive = !controlStates.goto || !call.interceptable || !!call.ancestors?.length;
    return isHidden2 || call.id === INTERNAL_RENDER_CALL_ID ? null : createElement(RowContainer, { call, pausedAt }, createElement(RowHeader, { isInteractive }, createElement(
      RowLabel,
      {
        "aria-label": "Interaction step",
        call,
        onClick: () => controls.goto(call.id),
        disabled: isInteractive,
        onMouseEnter: () => controlStates.goto && setIsHovered(!0),
        onMouseLeave: () => controlStates.goto && setIsHovered(!1)
      },
      createElement(StatusIcon2, { status: isHovered ? "active" : call.status }),
      createElement(MethodCallWrapper, { style: { marginLeft: 6, marginBottom: 1 } }, createElement(MethodCall, { call, callsById }))
    ), createElement(RowActions, null, (childCallIds?.length ?? 0) > 0 && createElement(
      WithTooltip2,
      {
        hasChrome: !1,
        tooltip: createElement(Note3, { note: `${isCollapsed ? "Show" : "Hide"} interactions` })
      },
      createElement(
        StyledIconButton,
        {
          onClick: toggleCollapsed,
          "aria-label": isCollapsed ? "Expand interaction" : "Collapse interaction"
        },
        isCollapsed ? createElement(ChevronDownIcon, null) : createElement(ChevronUpIcon, null)
      )
    ))), call.status === "error" && call.exception?.callId === call.id && createElement(Exception, { exception: call.exception }));
  }, "Interaction"), StatusColorMapping = {
    rendering: "mediumdark",
    playing: "warning",
    completed: "positive",
    errored: "negative",
    aborted: "purple"
  }, StatusTextMapping = {
    rendering: "Wait",
    playing: "Runs",
    completed: "Pass",
    errored: "Fail",
    aborted: "Bail"
  }, StatusNoteMapping = {
    rendering: "Story is rendering",
    playing: "Interactions are running",
    completed: "Story ran successfully",
    errored: "Story failed to complete",
    aborted: "Interactions aborted due to file changes"
  }, StyledBadge = styled.div(({ theme: theme3, status }) => ({
    display: "inline-block",
    padding: "4px 6px 4px 8px",
    borderRadius: "4px",
    backgroundColor: theme3.color[StatusColorMapping[status]],
    color: "white",
    fontFamily: typography.fonts.base,
    textTransform: "uppercase",
    fontSize: typography.size.s1,
    letterSpacing: 3,
    fontWeight: typography.weight.bold,
    minWidth: 65,
    textAlign: "center"
  })), StatusBadge = __name(({ status }) => {
    let badgeText = StatusTextMapping[status], badgeNote = StatusNoteMapping[status];
    return react_default.createElement(
      WithTooltip,
      {
        hasChrome: !1,
        placement: "top",
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote, { note: badgeNote })
      },
      react_default.createElement(StyledBadge, { "aria-label": "Story status", status }, badgeText)
    );
  }, "StatusBadge"), SubnavWrapper = styled.div(({ theme: theme3 }) => ({
    boxShadow: `${theme3.appBorderColor} 0 -1px 0 0 inset`,
    background: theme3.background.app,
    position: "sticky",
    top: 0,
    zIndex: 1
  })), StyledSubnav = styled.nav({
    height: 39,
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    paddingLeft: 15
  }), StyledButton2 = styled(Button2)(({ theme: theme3 }) => ({
    borderRadius: 4,
    padding: 6,
    color: theme3.textMutedColor,
    "&:not(:disabled)": {
      "&:hover,&:focus-visible": {
        color: theme3.color.secondary
      }
    }
  })), Note22 = styled(TooltipNote2)(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base
  })), StyledIconButton2 = styled(IconButton2)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor,
    margin: "0 3px"
  })), StyledSeparator = styled(Separator2)({
    marginTop: 0
  }), StyledLocation = styled(P2)(({ theme: theme3, isText }) => ({
    color: isText ? theme3.textMutedColor : theme3.color.secondary,
    cursor: isText ? "default" : "pointer",
    fontWeight: isText ? theme3.typography.weight.regular : theme3.typography.weight.bold,
    justifyContent: "flex-end",
    textAlign: "right",
    whiteSpace: "nowrap",
    marginTop: "auto",
    marginBottom: 1,
    paddingRight: 15,
    fontSize: 13
  })), Group2 = styled.div({
    display: "flex",
    alignItems: "center"
  }), RewindButton = styled(StyledIconButton2)({
    marginLeft: 9
  }), JumpToEndButton = styled(StyledButton2)({
    marginLeft: 9,
    marginRight: 9,
    lineHeight: "12px"
  }), RerunButton = styled(StyledIconButton2)(({ theme: theme3, animating, disabled }) => ({
    opacity: disabled ? 0.5 : 1,
    svg: {
      animation: animating ? `${theme3.animation.rotate360} 200ms ease-out` : void 0
    }
  })), Subnav = __name(({
    controls,
    controlStates,
    status,
    storyFileName,
    onScrollToEnd,
    importPath,
    canOpenInEditor,
    api
  }) => {
    let buttonText = status === "errored" ? "Scroll to error" : "Scroll to end", theme3 = useTheme();
    return react_default.createElement(SubnavWrapper, null, react_default.createElement(Bar2, { backgroundColor: theme3.background.app }, react_default.createElement(StyledSubnav, { "aria-label": "Component tests toolbar" }, react_default.createElement(Group2, null, react_default.createElement(StatusBadge, { status }), react_default.createElement(JumpToEndButton, { onClick: onScrollToEnd, disabled: !onScrollToEnd }, buttonText), react_default.createElement(StyledSeparator, null), react_default.createElement(WithTooltip2, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go to start" }) }, react_default.createElement(
      RewindButton,
      {
        "aria-label": "Go to start",
        onClick: controls.start,
        disabled: !controlStates.start
      },
      react_default.createElement(RewindIcon, null)
    )), react_default.createElement(WithTooltip2, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go back" }) }, react_default.createElement(
      StyledIconButton2,
      {
        "aria-label": "Go back",
        onClick: controls.back,
        disabled: !controlStates.back
      },
      react_default.createElement(PlayBackIcon, null)
    )), react_default.createElement(WithTooltip2, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go forward" }) }, react_default.createElement(
      StyledIconButton2,
      {
        "aria-label": "Go forward",
        onClick: controls.next,
        disabled: !controlStates.next
      },
      react_default.createElement(PlayNextIcon, null)
    )), react_default.createElement(WithTooltip2, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go to end" }) }, react_default.createElement(
      StyledIconButton2,
      {
        "aria-label": "Go to end",
        onClick: controls.end,
        disabled: !controlStates.end
      },
      react_default.createElement(FastForwardIcon, null)
    )), react_default.createElement(WithTooltip2, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Rerun" }) }, react_default.createElement(RerunButton, { "aria-label": "Rerun", onClick: controls.rerun }, react_default.createElement(SyncIcon, null)))), (importPath || storyFileName) && react_default.createElement(Group2, null, canOpenInEditor ? react_default.createElement(
      WithTooltip2,
      {
        trigger: "hover",
        hasChrome: !1,
        tooltip: react_default.createElement(Note22, { note: "Open in editor" })
      },
      react_default.createElement(
        StyledLocation,
        {
          "aria-label": "Open in editor",
          onClick: () => {
            api.openInEditor({
              file: importPath
            });
          }
        },
        storyFileName
      )
    ) : react_default.createElement(StyledLocation, { isText: !0 }, storyFileName)))));
  }, "Subnav"), Wrapper12 = styled.div(({ theme: { color: color2, typography: typography4, background: background2 } }) => ({
    textAlign: "start",
    padding: "11px 15px",
    fontSize: `${typography4.size.s2 - 1}px`,
    fontWeight: typography4.weight.regular,
    lineHeight: "1rem",
    background: background2.app,
    borderBottom: `1px solid ${color2.border}`,
    color: color2.defaultText,
    backgroundClip: "padding-box",
    position: "relative",
    code: {
      fontSize: `${typography4.size.s1 - 1}px`,
      color: "inherit",
      margin: "0 0.2em",
      padding: "0 0.2em",
      background: "rgba(255, 255, 255, 0.8)",
      borderRadius: "2px",
      boxShadow: "0 0 0 1px rgba(0, 0, 0, 0.1)"
    }
  })), TestDiscrepancyMessage = __name(({ browserTestStatus }) => {
    let docsUrl = useStorybookApi().getDocsUrl({
      subpath: DOCUMENTATION_DISCREPANCY_LINK,
      versioned: !0,
      renderer: !0
    }), [passed, failed] = browserTestStatus === "error" ? ["the CLI", "this browser"] : ["this browser", "the CLI"];
    return react_default.createElement(Wrapper12, null, "This interaction test passed in ", passed, ", but the tests failed in ", failed, ".", " ", react_default.createElement(Link3, { href: docsUrl, target: "_blank", withArrow: !0 }, "Learn what could cause this"));
  }, "TestDiscrepancyMessage"), Container32 = styled.div(({ theme: theme3 }) => ({
    height: "100%",
    background: theme3.background.content
  })), CaughtException = styled.div(({ theme: theme3 }) => ({
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    backgroundColor: theme3.base === "dark" ? curriedTransparentize$1(0.93, theme3.color.negative) : theme3.background.warning,
    padding: 15,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "19px"
  })), CaughtExceptionCode = styled.code(({ theme: theme3 }) => ({
    margin: "0 1px",
    padding: 3,
    fontSize: theme3.typography.size.s1 - 1,
    lineHeight: 1,
    verticalAlign: "top",
    background: "rgba(0, 0, 0, 0.05)",
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 3
  })), CaughtExceptionTitle = styled.div({
    paddingBottom: 4,
    fontWeight: "bold"
  }), CaughtExceptionDescription = styled.p({
    margin: 0,
    padding: "0 0 20px"
  }), CaughtExceptionStack = styled.pre(({ theme: theme3 }) => ({
    margin: 0,
    padding: 0,
    "&:not(:last-child)": {
      paddingBottom: 16
    },
    fontSize: theme3.typography.size.s1 - 1
  })), InteractionsPanel = memo(
    __name(function({
      storyUrl,
      status,
      calls,
      controls,
      controlStates,
      interactions,
      fileName,
      hasException,
      caughtException,
      unhandledErrors,
      pausedAt,
      onScrollToEnd,
      endRef,
      hasResultMismatch,
      browserTestStatus,
      importPath,
      canOpenInEditor,
      api
    }) {
      let filter = useAnsiToHtmlFilter(), hasRealInteractions = interactions.some((i22) => i22.id !== INTERNAL_RENDER_CALL_ID);
      return createElement(Container32, null, hasResultMismatch && createElement(TestDiscrepancyMessage, { browserTestStatus }), controlStates.detached && (hasRealInteractions || hasException) && createElement(DetachedDebuggerMessage, { storyUrl }), createElement(
        Subnav,
        {
          controls,
          controlStates,
          status,
          storyFileName: fileName,
          onScrollToEnd,
          importPath,
          canOpenInEditor,
          api
        }
      ), createElement("div", { "aria-label": "Interactions list" }, interactions.map((call) => createElement(
        Interaction,
        {
          key: call.id,
          call,
          callsById: calls,
          controls,
          controlStates,
          childCallIds: call.childCallIds,
          isHidden: call.isHidden,
          isCollapsed: call.isCollapsed,
          toggleCollapsed: call.toggleCollapsed,
          pausedAt
        }
      ))), caughtException && !isTestAssertionError(caughtException) && createElement(CaughtException, null, createElement(CaughtExceptionTitle, null, "Caught exception in ", createElement(CaughtExceptionCode, null, "play"), " function"), createElement(
        CaughtExceptionStack,
        {
          "data-chromatic": "ignore",
          dangerouslySetInnerHTML: {
            __html: filter.toHtml(printSerializedError(caughtException))
          }
        }
      )), unhandledErrors && createElement(CaughtException, null, createElement(CaughtExceptionTitle, null, "Unhandled Errors"), createElement(CaughtExceptionDescription, null, "Found ", unhandledErrors.length, " unhandled error", unhandledErrors.length > 1 ? "s" : "", " ", "while running the play function. This might cause false positive assertions. Resolve unhandled errors or ignore unhandled errors with setting the", createElement(CaughtExceptionCode, null, "test.dangerouslyIgnoreUnhandledErrors"), " ", "parameter to ", createElement(CaughtExceptionCode, null, "true"), "."), unhandledErrors.map((error, i22) => createElement(CaughtExceptionStack, { key: i22, "data-chromatic": "ignore" }, printSerializedError(error)))), createElement("div", { ref: endRef }), status === "completed" && !caughtException && !hasRealInteractions && createElement(Empty2, null));
    }, "InteractionsPanel")
  );
  function printSerializedError(error) {
    return error.stack || `${error.name}: ${error.message}`;
  }
  __name(printSerializedError, "printSerializedError");
  var INITIAL_CONTROL_STATES = {
    detached: !1,
    start: !1,
    back: !1,
    goto: !1,
    next: !1,
    end: !1
  }, playStatusMap = {
    rendering: "rendering",
    playing: "playing",
    completed: "completed",
    errored: "errored",
    aborted: "aborted"
  }, terminalStatuses = ["completed", "errored", "aborted"], storyStatusMap = {
    done: "status-value:success",
    error: "status-value:error",
    active: "status-value:pending",
    waiting: "status-value:pending"
  }, getInteractions = __name(({
    log,
    calls,
    collapsed,
    setCollapsed
  }) => {
    let callsById = /* @__PURE__ */ new Map(), childCallMap = /* @__PURE__ */ new Map();
    return log.map(({ callId, ancestors, status }) => {
      let isHidden2 = !1;
      return ancestors.forEach((ancestor) => {
        collapsed.has(ancestor) && (isHidden2 = !0), childCallMap.set(ancestor, (childCallMap.get(ancestor) || []).concat(callId));
      }), { ...calls.get(callId), status, isHidden: isHidden2 };
    }).map((call) => {
      let status = call.status === "error" && call.ancestors && callsById.get(call.ancestors.slice(-1)[0])?.status === "active" ? "active" : call.status;
      return callsById.set(call.id, { ...call, status }), {
        ...call,
        status,
        childCallIds: childCallMap.get(call.id),
        isCollapsed: collapsed.has(call.id),
        toggleCollapsed: __name(() => setCollapsed((ids) => (ids.has(call.id) ? ids.delete(call.id) : ids.add(call.id), new Set(ids))), "toggleCollapsed")
      };
    });
  }, "getInteractions"), getPanelState = __name((state3, {
    log,
    calls,
    collapsed,
    setCollapsed
  }) => getInteractions({ log, calls, collapsed, setCollapsed }).reduce(
    (acc, interaction) => (interaction.id === INTERNAL_RENDER_CALL_ID ? acc.interactions.push(interaction) : state3.status !== "rendering" && (acc.controlStates = state3.controlStates, acc.interactions.push(interaction), interaction.method !== "step" && acc.interactionsCount++), acc),
    {
      ...state3,
      controlStates: INITIAL_CONTROL_STATES,
      interactions: [],
      interactionsCount: 0
    }
  ), "getPanelState"), getInternalRenderCall = __name((storyId, exception) => ({
    id: INTERNAL_RENDER_CALL_ID,
    method: "render",
    args: [],
    cursor: 0,
    storyId,
    ancestors: [],
    path: [],
    interceptable: !0,
    retain: !1,
    exception
  }), "getInternalRenderCall"), getInternalRenderLogItem = __name((status) => ({
    callId: INTERNAL_RENDER_CALL_ID,
    status,
    ancestors: []
  }), "getInternalRenderLogItem"), Panel = memo(
    __name(function({ refId, storyId, storyUrl }) {
      let { statusValue, testRunId } = experimental_useStatusStore((state22) => {
        let storyStatus = refId ? void 0 : state22[storyId]?.[STATUS_TYPE_ID_COMPONENT_TEST];
        return {
          statusValue: storyStatus?.value,
          testRunId: storyStatus?.data?.testRunId
        };
      }), state3 = useStorybookState(), api = useStorybookApi(), importPath = api.getData(state3.storyId, state3.refId)?.importPath, canOpenInEditor = scope.CONFIG_TYPE === "DEVELOPMENT" && !state3.refId, [panelState, set] = useAddonState(ADDON_ID72, {
        status: "rendering",
        controlStates: INITIAL_CONTROL_STATES,
        interactions: [],
        interactionsCount: 0,
        hasException: !1,
        pausedAt: void 0,
        caughtException: void 0,
        unhandledErrors: void 0
      }), [scrollTarget, setScrollTarget] = useState(void 0), [collapsed, setCollapsed] = useState(/* @__PURE__ */ new Set()), [hasResultMismatch, setResultMismatch] = useState(!1), {
        status = "rendering",
        controlStates = INITIAL_CONTROL_STATES,
        interactions = [],
        pausedAt = void 0,
        caughtException = void 0,
        unhandledErrors = void 0
      } = panelState, log = useRef([getInternalRenderLogItem(
        "active"
        /* ACTIVE */
      )]), calls = useRef(
        /* @__PURE__ */ new Map([[INTERNAL_RENDER_CALL_ID, getInternalRenderCall(storyId)]])
      ), setCall = __name(({ status: status2, ...call }) => calls.current.set(call.id, call), "setCall"), endRef = useRef();
      useEffect(() => {
        let observer;
        return scope.IntersectionObserver && (observer = new scope.IntersectionObserver(
          ([end2]) => setScrollTarget(end2.isIntersecting ? void 0 : end2.target),
          { root: scope.document.querySelector("#panel-tab-content") }
        ), endRef.current && observer.observe(endRef.current)), () => observer?.disconnect();
      }, []);
      let lastStoryId = useRef(void 0), lastRenderId = useRef(0), emit = useChannel2(
        {
          [EVENTS3.CALL]: setCall,
          [EVENTS3.SYNC]: (payload) => {
            log.current = [getInternalRenderLogItem(
              "done"
              /* DONE */
            ), ...payload.logItems], set(
              (state22) => getPanelState(
                { ...state22, controlStates: payload.controlStates, pausedAt: payload.pausedAt },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              )
            );
          },
          [STORY_RENDER_PHASE_CHANGED]: (event) => {
            lastStoryId.current === event.storyId && ["preparing", "loading"].includes(event.newPhase) || (lastStoryId.current = event.storyId, lastRenderId.current = Math.max(lastRenderId.current, event.renderId || 0), lastRenderId.current === event.renderId && (event.newPhase === "rendering" ? (log.current = [getInternalRenderLogItem(
              "active"
              /* ACTIVE */
            )], calls.current.set(INTERNAL_RENDER_CALL_ID, getInternalRenderCall(storyId)), set({
              status: "rendering",
              controlStates: INITIAL_CONTROL_STATES,
              pausedAt: void 0,
              interactions: [],
              interactionsCount: 0,
              hasException: !1,
              caughtException: void 0,
              unhandledErrors: void 0
            })) : set((state22) => {
              let status2 = event.newPhase in playStatusMap && !terminalStatuses.includes(state22.status) ? playStatusMap[event.newPhase] : state22.status;
              return getPanelState(
                { ...state22, status: status2, pausedAt: void 0 },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              );
            })));
          },
          [STORY_THREW_EXCEPTION]: (e2) => {
            log.current = [getInternalRenderLogItem(
              "error"
              /* ERROR */
            )], calls.current.set(
              INTERNAL_RENDER_CALL_ID,
              getInternalRenderCall(storyId, { ...e2, callId: INTERNAL_RENDER_CALL_ID })
            ), set(
              (state22) => getPanelState(
                {
                  ...state22,
                  hasException: !0,
                  caughtException: void 0,
                  controlStates: INITIAL_CONTROL_STATES,
                  pausedAt: void 0
                },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              )
            );
          },
          [PLAY_FUNCTION_THREW_EXCEPTION]: (caughtException2) => {
            set((state22) => ({ ...state22, caughtException: caughtException2, hasException: !0 }));
          },
          [UNHANDLED_ERRORS_WHILE_PLAYING]: (unhandledErrors2) => {
            set((state22) => ({ ...state22, unhandledErrors: unhandledErrors2, hasException: !0 }));
          }
        },
        [collapsed]
      );
      useEffect(() => {
        set(
          (state22) => getPanelState(state22, { log: log.current, calls: calls.current, collapsed, setCollapsed })
        );
      }, [set, collapsed]);
      let controls = useMemo(
        () => ({
          start: __name(() => emit(EVENTS3.START, { storyId }), "start"),
          back: __name(() => emit(EVENTS3.BACK, { storyId }), "back"),
          goto: __name((callId) => emit(EVENTS3.GOTO, { storyId, callId }), "goto"),
          next: __name(() => emit(EVENTS3.NEXT, { storyId }), "next"),
          end: __name(() => emit(EVENTS3.END, { storyId }), "end"),
          rerun: __name(() => {
            emit(FORCE_REMOUNT, { storyId });
          }, "rerun")
        }),
        [emit, storyId]
      ), storyFilePath = useParameter2("fileName", ""), [fileName] = storyFilePath.toString().split("/").slice(-1), scrollToTarget = __name(() => scrollTarget?.scrollIntoView({ behavior: "smooth", block: "end" }), "scrollToTarget"), hasException = !!caughtException || !!unhandledErrors || interactions.some(
        (v22) => v22.status === "error"
        /* ERROR */
      ), browserTestStatus = useMemo(() => status !== "playing" && (interactions.length > 0 || hasException) ? hasException ? "error" : "done" : status === "playing" ? "active" : void 0, [status, interactions, hasException]);
      return useEffect(() => {
        if (browserTestStatus && statusValue && statusValue !== "status-value:pending" && statusValue !== storyStatusMap[browserTestStatus]) {
          let timeout = setTimeout(
            () => setResultMismatch((currentValue) => (currentValue || emit(STORYBOOK_ADDON_TEST_CHANNEL, {
              type: "test-discrepancy",
              payload: {
                browserStatus: browserTestStatus === "done" ? "PASS" : "FAIL",
                cliStatus: browserTestStatus === "done" ? "FAIL" : "PASS",
                storyId,
                testRunId
              }
            }), !0)),
            2e3
          );
          return () => clearTimeout(timeout);
        } else
          setResultMismatch(!1);
      }, [emit, browserTestStatus, statusValue, storyId, testRunId]), react_default.createElement(Fragment, { key: "component-tests" }, react_default.createElement(
        InteractionsPanel,
        {
          storyUrl,
          status,
          hasResultMismatch,
          browserTestStatus,
          calls: calls.current,
          controls,
          controlStates: { ...controlStates, detached: !!refId || controlStates.detached },
          interactions,
          fileName,
          hasException,
          caughtException,
          unhandledErrors,
          pausedAt,
          endRef,
          onScrollToEnd: scrollTarget && scrollToTarget,
          importPath,
          canOpenInEditor,
          api
        }
      ));
    }, "PanelMemoized")
  );
  function PanelTitle() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), [addonState = {}] = useAddonState(ADDON_ID72), { status, hasException, interactionsCount } = addonState;
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Interactions"), interactionsCount && status !== "errored" && !hasException ? react_default.createElement(Badge2, { compact: !0, status: selectedPanel === PANEL_ID22 ? "active" : "neutral" }, interactionsCount) : null, status === "errored" || hasException ? react_default.createElement(StatusIcon2, {
      status: "error"
      /* ERROR */
    }) : null);
  }
  __name(PanelTitle, "PanelTitle");
  var manager_default3 = addons3.register(ADDON_ID72, () => {
    if (globalThis?.FEATURES?.interactions) {
      let filter = __name(({ state: state3 }) => {
        let origin = state3.refId && state3.refs[state3.refId]?.url || document.location.origin, { pathname, search = "" } = state3.location, path = pathname + (state3.refId ? search.replace(`/${state3.refId}_`, "/") : search);
        return {
          refId: state3.refId,
          storyId: state3.storyId,
          storyUrl: origin + path
        };
      }, "filter");
      addons3.add(PANEL_ID22, {
        type: types.PANEL,
        title: __name(() => react_default.createElement(PanelTitle, null), "title"),
        match: __name(({ viewMode }) => viewMode === "story", "match"),
        render: __name(({ active }) => react_default.createElement(AddonPanel2, { active: !!active }, react_default.createElement(Consumer, { filter }, (props) => react_default.createElement(Panel, { ...props }))), "render")
      });
    }
  }), BackgroundTool = memo(__name(function() {
    let config2 = useParameter2(PARAM_KEY), [globals, updateGlobals, storyGlobals] = useGlobals2(), [isTooltipVisible, setIsTooltipVisible] = useState(!1), { options: options2 = DEFAULT_BACKGROUNDS, disable = !0 } = config2 || {};
    if (disable)
      return null;
    let data = globals[PARAM_KEY] || {}, backgroundName = data.value, isGridActive = data.grid || !1, item = options2[backgroundName], isLocked = !!storyGlobals?.[PARAM_KEY], length2 = Object.keys(options2).length;
    return react_default.createElement(
      Pure,
      {
        length: length2,
        backgroundMap: options2,
        item,
        updateGlobals,
        backgroundName,
        setIsTooltipVisible,
        isLocked,
        isGridActive,
        isTooltipVisible
      }
    );
  }, "BackgroundSelector")), Pure = memo(__name(function(props) {
    let {
      item,
      length: length2,
      updateGlobals,
      setIsTooltipVisible,
      backgroundMap,
      backgroundName,
      isLocked,
      isGridActive: isGrid,
      isTooltipVisible
    } = props, update = useCallback(
      (input) => {
        updateGlobals({
          [PARAM_KEY]: input
        });
      },
      [updateGlobals]
    );
    return react_default.createElement(Fragment, null, react_default.createElement(
      IconButton2,
      {
        key: "grid",
        active: isGrid,
        disabled: isLocked,
        title: "Apply a grid to the preview",
        onClick: () => update({ value: backgroundName, grid: !isGrid })
      },
      react_default.createElement(GridIcon, null)
    ), length2 > 0 ? react_default.createElement(
      WithTooltip2,
      {
        key: "background",
        placement: "top",
        closeOnOutsideClick: !0,
        tooltip: ({ onHide }) => react_default.createElement(
          TooltipLinkList2,
          {
            links: [
              ...item ? [
                {
                  id: "reset",
                  title: "Reset background",
                  icon: react_default.createElement(RefreshIcon, null),
                  onClick: __name(() => {
                    update(void 0), onHide();
                  }, "onClick")
                }
              ] : [],
              ...Object.entries(backgroundMap).map(([k22, value2]) => ({
                id: k22,
                title: value2.name,
                icon: react_default.createElement(CircleIcon, { color: value2?.value || "grey" }),
                active: k22 === backgroundName,
                onClick: __name(() => {
                  update({ value: k22, grid: isGrid }), onHide();
                }, "onClick")
              }))
            ].flat()
          }
        ),
        onVisibleChange: setIsTooltipVisible
      },
      react_default.createElement(
        IconButton2,
        {
          disabled: isLocked,
          key: "background",
          title: "Change the background of the preview",
          active: !!item || isTooltipVisible
        },
        react_default.createElement(PhotoIcon, null)
      )
    ) : null);
  }, "PureTool")), manager_default4 = addons3.register(ADDON_ID, () => {
    globalThis?.FEATURES?.backgrounds && addons3.add(ADDON_ID, {
      title: "Backgrounds",
      type: types.TOOL,
      match: __name(({ viewMode, tabId }) => !!(viewMode && viewMode.match(/^(story|docs)$/)) && !tabId, "match"),
      render: __name(() => react_default.createElement(BackgroundTool, null), "render")
    });
  }), Tool = __name(() => {
    let [globals, updateGlobals] = useGlobals2(), { measureEnabled } = globals || {}, api = useStorybookApi(), toggleMeasure = useCallback(
      () => updateGlobals({
        measureEnabled: !measureEnabled
      }),
      [updateGlobals, measureEnabled]
    );
    return useEffect(() => {
      api.setAddonShortcut(ADDON_ID2, {
        label: "Toggle Measure",
        defaultShortcut: ["M"],
        actionName: "measure",
        showInMenu: !1,
        action: toggleMeasure
      });
    }, [toggleMeasure, api]), react_default.createElement(
      IconButton2,
      {
        key: TOOL_ID,
        active: measureEnabled,
        title: "Enable measure",
        onClick: toggleMeasure
      },
      react_default.createElement(RulerIcon, null)
    );
  }, "Tool"), manager_default5 = addons3.register(ADDON_ID2, () => {
    globalThis?.FEATURES?.measure && addons3.add(TOOL_ID, {
      type: types.TOOL,
      title: "Measure",
      match: __name(({ viewMode, tabId }) => viewMode === "story" && !tabId, "match"),
      render: __name(() => react_default.createElement(Tool, null), "render")
    });
  }), OutlineSelector = memo(__name(function() {
    let [globals, updateGlobals] = useGlobals2(), api = useStorybookApi(), isActive = [!0, "true"].includes(globals[PARAM_KEY3]), toggleOutline = useCallback(
      () => updateGlobals({
        [PARAM_KEY3]: !isActive
      }),
      [isActive]
    );
    return useEffect(() => {
      api.setAddonShortcut(ADDON_ID3, {
        label: "Toggle Outline",
        defaultShortcut: ["alt", "O"],
        actionName: "outline",
        showInMenu: !1,
        action: toggleOutline
      });
    }, [toggleOutline, api]), react_default.createElement(
      IconButton2,
      {
        key: "outline",
        active: isActive,
        title: "Apply outlines to the preview",
        onClick: toggleOutline
      },
      react_default.createElement(OutlineIcon, null)
    );
  }, "OutlineSelector")), manager_default6 = addons3.register(ADDON_ID3, () => {
    globalThis?.FEATURES?.outline && addons3.add(ADDON_ID3, {
      title: "Outline",
      type: types.TOOL,
      match: __name(({ viewMode, tabId }) => !!(viewMode && viewMode.match(/^(story|docs)$/)) && !tabId, "match"),
      render: __name(() => react_default.createElement(OutlineSelector, null), "render")
    });
  }), getCurrentViewportIndex = __name((viewportsKeys, current) => viewportsKeys.indexOf(current), "getCurrentViewportIndex"), getNextViewport = __name((viewportsKeys, current) => {
    let currentViewportIndex = getCurrentViewportIndex(viewportsKeys, current);
    return currentViewportIndex === viewportsKeys.length - 1 ? viewportsKeys[0] : viewportsKeys[currentViewportIndex + 1];
  }, "getNextViewport"), getPreviousViewport = __name((viewportsKeys, current) => {
    let currentViewportIndex = getCurrentViewportIndex(viewportsKeys, current);
    return currentViewportIndex < 1 ? viewportsKeys[viewportsKeys.length - 1] : viewportsKeys[currentViewportIndex - 1];
  }, "getPreviousViewport"), registerShortcuts = __name(async (api, viewport2, updateGlobals, viewportsKeys) => {
    await api.setAddonShortcut(ADDON_ID7, {
      label: "Previous viewport",
      defaultShortcut: ["alt", "shift", "V"],
      actionName: "previous",
      action: __name(() => {
        updateGlobals({
          viewport: getPreviousViewport(viewportsKeys, viewport2)
        });
      }, "action")
    }), await api.setAddonShortcut(ADDON_ID7, {
      label: "Next viewport",
      defaultShortcut: ["alt", "V"],
      actionName: "next",
      action: __name(() => {
        updateGlobals({
          viewport: getNextViewport(viewportsKeys, viewport2)
        });
      }, "action")
    }), await api.setAddonShortcut(ADDON_ID7, {
      label: "Reset viewport",
      defaultShortcut: ["alt", "control", "V"],
      actionName: "reset",
      action: __name(() => {
        updateGlobals({
          viewport: { value: void 0, isRotated: !1 }
        });
      }, "action")
    });
  }, "registerShortcuts"), ActiveViewportSize = styled.div({
    display: "inline-flex",
    alignItems: "center"
  }), ActiveViewportLabel = styled.div(({ theme: theme3 }) => ({
    display: "inline-block",
    textDecoration: "none",
    padding: 10,
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "1",
    height: 40,
    border: "none",
    borderTop: "3px solid transparent",
    borderBottom: "3px solid transparent",
    background: "transparent"
  })), IconButtonWithLabel = styled(IconButton2)(() => ({
    display: "inline-flex",
    alignItems: "center"
  })), IconButtonLabel = styled.div(({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2 - 1,
    marginLeft: 10
  })), iconsMap = {
    desktop: react_default.createElement(BrowserIcon, null),
    mobile: react_default.createElement(MobileIcon, null),
    tablet: react_default.createElement(TabletIcon, null),
    other: react_default.createElement(Fragment, null)
  }, ViewportTool = __name(({ api }) => {
    let config2 = useParameter2(PARAM_KEY5), [globals, updateGlobals, storyGlobals] = useGlobals2(), [isTooltipVisible, setIsTooltipVisible] = useState(!1), { options: options2 = MINIMAL_VIEWPORTS, disable } = config2 || {}, data = globals?.[PARAM_KEY5] || {}, viewportName = typeof data == "string" ? data : data.value, isRotated = typeof data == "string" ? !1 : !!data.isRotated, item = options2[viewportName] || responsiveViewport, isActive = isTooltipVisible || item !== responsiveViewport, isLocked = PARAM_KEY5 in storyGlobals, length2 = Object.keys(options2).length;
    if (useEffect(() => {
      registerShortcuts(api, viewportName, updateGlobals, Object.keys(options2));
    }, [options2, viewportName, updateGlobals, api]), item.styles === null || !options2 || length2 < 1)
      return null;
    if (typeof item.styles == "function")
      return console.warn(
        "Addon Viewport no longer supports dynamic styles using a function, use css calc() instead"
      ), null;
    let width = isRotated ? item.styles.height : item.styles.width, height = isRotated ? item.styles.width : item.styles.height;
    return disable ? null : react_default.createElement(
      Pure2,
      {
        item,
        updateGlobals,
        viewportMap: options2,
        viewportName,
        isRotated,
        setIsTooltipVisible,
        isLocked,
        isActive,
        width,
        height
      }
    );
  }, "ViewportTool"), Pure2 = react_default.memo(__name(function(props) {
    let {
      item,
      viewportMap,
      viewportName,
      isRotated,
      updateGlobals,
      setIsTooltipVisible,
      isLocked,
      isActive,
      width,
      height
    } = props, update = useCallback(
      (input) => updateGlobals({ [PARAM_KEY5]: input }),
      [updateGlobals]
    );
    return react_default.createElement(Fragment, null, react_default.createElement(
      WithTooltip2,
      {
        placement: "bottom",
        tooltip: ({ onHide }) => react_default.createElement(
          TooltipLinkList2,
          {
            links: [
              ...length > 0 && item !== responsiveViewport ? [
                {
                  id: "reset",
                  title: "Reset viewport",
                  icon: react_default.createElement(RefreshIcon, null),
                  onClick: __name(() => {
                    update(void 0), onHide();
                  }, "onClick")
                }
              ] : [],
              ...Object.entries(viewportMap).map(([k22, value2]) => ({
                id: k22,
                title: value2.name,
                icon: iconsMap[value2.type],
                active: k22 === viewportName,
                onClick: __name(() => {
                  update({ value: k22, isRotated: !1 }), onHide();
                }, "onClick")
              }))
            ].flat()
          }
        ),
        closeOnOutsideClick: !0,
        onVisibleChange: setIsTooltipVisible
      },
      react_default.createElement(
        IconButtonWithLabel,
        {
          disabled: isLocked,
          key: "viewport",
          title: "Change the size of the preview",
          active: isActive,
          onDoubleClick: () => {
            update({ value: void 0, isRotated: !1 });
          }
        },
        react_default.createElement(GrowIcon, null),
        item !== responsiveViewport ? react_default.createElement(IconButtonLabel, null, item.name, " ", isRotated ? "(L)" : "(P)") : null
      )
    ), react_default.createElement(
      Global,
      {
        styles: {
          'iframe[data-is-storybook="true"]': { width, height }
        }
      }
    ), item !== responsiveViewport ? react_default.createElement(ActiveViewportSize, null, react_default.createElement(ActiveViewportLabel, { title: "Viewport width" }, width.replace("px", "")), isLocked ? "/" : react_default.createElement(
      IconButton2,
      {
        key: "viewport-rotate",
        title: "Rotate viewport",
        onClick: () => {
          update({ value: viewportName, isRotated: !isRotated });
        }
      },
      react_default.createElement(TransferIcon, null)
    ), react_default.createElement(ActiveViewportLabel, { title: "Viewport height" }, height.replace("px", ""))) : null);
  }, "PureTool")), manager_default7 = addons3.register(ADDON_ID7, (api) => {
    globalThis?.FEATURES?.viewport && addons3.add(TOOL_ID2, {
      title: "viewport / media-queries",
      type: types.TOOL,
      match: __name(({ viewMode, tabId }) => viewMode === "story" && !tabId, "match"),
      render: __name(() => createElement(ViewportTool, { api }), "render")
    });
  }), TAG_FILTERS = "tag-filters", STATIC_FILTER = "static-filter", tagFiltersManager = addons3.register(TAG_FILTERS, (api) => {
    let staticExcludeTags = Object.entries(scope.TAGS_OPTIONS ?? {}).reduce(
      (acc, entry) => {
        let [tag, option] = entry;
        return option.excludeFromSidebar && (acc[tag] = !0), acc;
      },
      {}
    );
    api.experimental_setFilter(STATIC_FILTER, (item) => {
      let tags = item.tags ?? [];
      return (
        // we can filter out the primary story, but we still want to show autodocs
        (tags.includes("dev") || item.type === "docs") && tags.filter((tag) => staticExcludeTags[tag]).length === 0
      );
    });
  });
})();
}catch(e){ console.error("[Storybook] One of your manager-entries failed: " + import.meta.url, e); }
