import {
  require_test
} from "./chunk-MUGBNPQY.js";
import {
  require_client_logger
} from "./chunk-LHOSQLWN.js";
import {
  dedent,
  require_memoizerific
} from "./chunk-NB566PAL.js";
import {
  action,
  require_preview_errors
} from "./chunk-VGMEBJCG.js";
import {
  require_global
} from "./chunk-62Y44TTL.js";
import {
  require_core_events
} from "./chunk-7ZSBYTHS.js";
import {
  require_preview_api
} from "./chunk-ZLWVYHQP.js";
import {
  PARAM_KEY
} from "./chunk-52GMUAQK.js";
import {
  __commonJS as __commonJS2,
  __export,
  __name,
  __toESM as __toESM2
} from "./chunk-TYPDZRGF.js";
import {
  __commonJS,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/.cache/sb-vite-plugin-externals/storybook/internal/channels.js
var require_channels = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/storybook/internal/channels.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_CHANNELS__;
  }
});

// node_modules/storybook/dist/_browser-chunks/chunk-CADGRH3P.js
var ADDON_ID = "storybook/background";
var PARAM_KEY2 = "backgrounds";
var EVENTS = {
  UPDATE: `${ADDON_ID}/update`
};
var ADDON_ID2 = "storybook/measure-addon";
var TOOL_ID = `${ADDON_ID2}/tool`;
var PARAM_KEY22 = "measureEnabled";
var EVENTS2 = {
  RESULT: `${ADDON_ID2}/result`,
  REQUEST: `${ADDON_ID2}/request`,
  CLEAR: `${ADDON_ID2}/clear`
};
var PARAM_KEY3 = "outline";
var DEFAULT_BACKGROUNDS = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};

// node_modules/storybook/dist/_browser-chunks/chunk-Y3M7TW6K.js
var require_string_util = __commonJS2({
  "../node_modules/picoquery/lib/string-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeString = encodeString;
    var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function encodeString(str2) {
      const len = str2.length;
      if (len === 0) {
        return "";
      }
      let out = "";
      let lastPos = 0;
      let i = 0;
      outer: for (; i < len; i++) {
        let c = str2.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str2.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str2.charCodeAt(i);
        }
        if (lastPos < i)
          out += str2.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str2.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      if (lastPos === 0)
        return str2;
      if (lastPos < len)
        return out + str2.slice(lastPos);
      return out;
    }
    __name(encodeString, "encodeString");
  }
});
var require_shared = __commonJS2({
  "../node_modules/picoquery/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
    var string_util_js_1 = require_string_util();
    var defaultValueSerializer = __name((value) => {
      switch (typeof value) {
        case "string":
          return (0, string_util_js_1.encodeString)(value);
        case "bigint":
        case "boolean":
          return "" + value;
        case "number":
          if (Number.isFinite(value)) {
            return value < 1e21 ? "" + value : (0, string_util_js_1.encodeString)("" + value);
          }
          break;
      }
      if (value instanceof Date) {
        return (0, string_util_js_1.encodeString)(value.toISOString());
      }
      return "";
    }, "defaultValueSerializer");
    exports.defaultValueSerializer = defaultValueSerializer;
    var defaultShouldSerializeObject = __name((val) => {
      return val instanceof Date;
    }, "defaultShouldSerializeObject");
    exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
    var identityFunc = __name((v) => v, "identityFunc");
    exports.defaultOptions = {
      nesting: true,
      nestingSyntax: "dot",
      arrayRepeat: false,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: identityFunc,
      valueSerializer: exports.defaultValueSerializer,
      keyDeserializer: identityFunc,
      shouldSerializeObject: exports.defaultShouldSerializeObject
    };
  }
});
var require_object_util = __commonJS2({
  "../node_modules/picoquery/lib/object-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDeepObject = getDeepObject;
    exports.stringifyObject = stringifyObject;
    var shared_js_1 = require_shared();
    var string_util_js_1 = require_string_util();
    function isPrototypeKey(value) {
      return value === "__proto__" || value === "constructor" || value === "prototype";
    }
    __name(isPrototypeKey, "isPrototypeKey");
    function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
      if (isPrototypeKey(key))
        return obj;
      const currObj = obj[key];
      if (typeof currObj === "object" && currObj !== null) {
        return currObj;
      }
      if (!forceObject && (forceArray || typeof nextKey === "number" || typeof nextKey === "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1)) {
        return obj[key] = [];
      }
      return obj[key] = {};
    }
    __name(getDeepObject, "getDeepObject");
    var MAX_DEPTH = 20;
    var strBracketPair = "[]";
    var strBracketLeft = "[";
    var strBracketRight = "]";
    var strDot = ".";
    function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
      const { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options;
      const strDelimiter = typeof delimiter === "number" ? String.fromCharCode(delimiter) : delimiter;
      const useArrayRepeatKey = isProbableArray === true && arrayRepeat;
      const shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
      if (depth > MAX_DEPTH) {
        return "";
      }
      let result = "";
      let firstKey = true;
      let valueIsProbableArray = false;
      for (const key in obj) {
        const value = obj[key];
        if (value === void 0) {
          continue;
        }
        let path;
        if (parentKey) {
          path = parentKey;
          if (useArrayRepeatKey) {
            if (arrayRepeatSyntax === "bracket") {
              path += strBracketPair;
            }
          } else if (shouldUseDot) {
            path += strDot;
            path += key;
          } else {
            path += strBracketLeft;
            path += key;
            path += strBracketRight;
          }
        } else {
          path = key;
        }
        if (!firstKey) {
          result += strDelimiter;
        }
        if (typeof value === "object" && value !== null && !shouldSerializeObject(value)) {
          valueIsProbableArray = value.pop !== void 0;
          if (nesting || arrayRepeat && valueIsProbableArray) {
            result += stringifyObject(value, options, depth + 1, path, valueIsProbableArray);
          }
        } else {
          result += (0, string_util_js_1.encodeString)(path);
          result += "=";
          result += valueSerializer(value, key);
        }
        if (firstKey) {
          firstKey = false;
        }
      }
      return result;
    }
    __name(stringifyObject, "stringifyObject");
  }
});
var require_decode_uri_component = __commonJS2({
  "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeURIComponent = decodeURIComponent;
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent(uri) {
      let percentPosition = uri.indexOf("%");
      if (percentPosition === -1) {
        return uri;
      }
      const length = uri.length;
      let decoded = "";
      let last = 0;
      let codepoint = 0;
      let startOfOctets = percentPosition;
      let state3 = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        const high = hexCodeToInt(uri[percentPosition + 1], 4);
        const low = hexCodeToInt(uri[percentPosition + 2], 0);
        const byte = high | low;
        const type = UTF8_DATA[byte];
        state3 = UTF8_DATA[256 + state3 + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state3 === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state3 === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    __name(decodeURIComponent, "decodeURIComponent");
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function hexCodeToInt(c, shift) {
      const i = HEX[c];
      return i === void 0 ? 255 : i << shift;
    }
    __name(hexCodeToInt, "hexCodeToInt");
  }
});
var require_parse = __commonJS2({
  "../node_modules/picoquery/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0;
    exports.parse = parse3;
    var object_util_js_1 = require_object_util();
    var shared_js_1 = require_shared();
    var decode_uri_component_js_1 = require_decode_uri_component();
    var numberKeyDeserializer = __name((key) => {
      const asNumber = Number(key);
      if (!Number.isNaN(asNumber)) {
        return asNumber;
      }
      return key;
    }, "numberKeyDeserializer");
    exports.numberKeyDeserializer = numberKeyDeserializer;
    var numberValueDeserializer = __name((value) => {
      const asNumber = Number(value);
      if (!Number.isNaN(asNumber)) {
        return asNumber;
      }
      return value;
    }, "numberValueDeserializer");
    exports.numberValueDeserializer = numberValueDeserializer;
    var regexPlus = /\+/g;
    var Empty = __name(function() {
    }, "Empty");
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function computeKeySlice(input, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
      let chunk = input.substring(startIndex, endIndex);
      if (keyHasPlus) {
        chunk = chunk.replace(regexPlus, " ");
      }
      if (shouldDecodeKey) {
        chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk;
      }
      return chunk;
    }
    __name(computeKeySlice, "computeKeySlice");
    function parse3(input, options) {
      const { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {};
      const charDelimiter = typeof delimiter === "string" ? delimiter.charCodeAt(0) : delimiter;
      const isJsNestingSyntax = nestingSyntax === "js";
      const result = new Empty();
      if (typeof input !== "string") {
        return result;
      }
      const inputLength = input.length;
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let keySeparatorIndex = -1;
      let currentObj = result;
      let lastKey = void 0;
      let currentKey = "";
      let keyChunk = "";
      let shouldDecodeKey = false;
      let shouldDecodeValue = false;
      let keyHasPlus = false;
      let valueHasPlus = false;
      let keyIsDot = false;
      let hasBothKeyValuePair = false;
      let c = 0;
      let arrayRepeatBracketIndex = -1;
      let prevIndex = -1;
      let prevChar = -1;
      for (let i = 0; i < inputLength + 1; i++) {
        c = i !== inputLength ? input.charCodeAt(i) : charDelimiter;
        if (c === charDelimiter) {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair) {
            equalityIndex = i;
          }
          if (keySeparatorIndex !== equalityIndex - 1) {
            keyChunk = computeKeySlice(input, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey);
            currentKey = keyDeserializer(keyChunk);
            if (lastKey !== void 0) {
              currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0);
            }
          }
          if (hasBothKeyValuePair || currentKey !== "") {
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (valueHasPlus) {
                value = value.replace(regexPlus, " ");
              }
              if (shouldDecodeValue) {
                value = (0, decode_uri_component_js_1.decodeURIComponent)(value) || value;
              }
            }
            const newValue = valueDeserializer(value, currentKey);
            if (arrayRepeat) {
              const currentValue = currentObj[currentKey];
              if (currentValue === void 0) {
                if (arrayRepeatBracketIndex > -1) {
                  currentObj[currentKey] = [newValue];
                } else {
                  currentObj[currentKey] = newValue;
                }
              } else if (currentValue.pop) {
                currentValue.push(newValue);
              } else {
                currentObj[currentKey] = [currentValue, newValue];
              }
            } else
              currentObj[currentKey] = newValue;
          }
          value = "";
          startingIndex = i;
          equalityIndex = i;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
          keyIsDot = false;
          arrayRepeatBracketIndex = -1;
          keySeparatorIndex = i;
          currentObj = result;
          lastKey = void 0;
          currentKey = "";
        } else if (c === 93) {
          if (arrayRepeat && arrayRepeatSyntax === "bracket") {
            if (prevChar === 91) {
              arrayRepeatBracketIndex = prevIndex;
            }
          }
          if (nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex) {
            if (keySeparatorIndex !== prevIndex) {
              keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i, keyHasPlus, shouldDecodeKey);
              currentKey = keyDeserializer(keyChunk);
              if (lastKey !== void 0) {
                currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0);
              }
              lastKey = currentKey;
              keyHasPlus = false;
              shouldDecodeKey = false;
            }
            keySeparatorIndex = i;
            keyIsDot = false;
          }
        } else if (c === 46) {
          if (nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex) {
            if (keySeparatorIndex !== prevIndex) {
              keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i, keyHasPlus, shouldDecodeKey);
              currentKey = keyDeserializer(keyChunk);
              if (lastKey !== void 0) {
                currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax);
              }
              lastKey = currentKey;
              keyHasPlus = false;
              shouldDecodeKey = false;
            }
            keyIsDot = true;
            keySeparatorIndex = i;
          }
        } else if (c === 91) {
          if (nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex) {
            if (keySeparatorIndex !== prevIndex) {
              keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i, keyHasPlus, shouldDecodeKey);
              currentKey = keyDeserializer(keyChunk);
              if (isJsNestingSyntax && lastKey !== void 0) {
                currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax);
              }
              lastKey = currentKey;
              keyHasPlus = false;
              shouldDecodeKey = false;
              keyIsDot = false;
            }
            keySeparatorIndex = i;
          }
        } else if (c === 61) {
          if (equalityIndex <= startingIndex) {
            equalityIndex = i;
          } else {
            shouldDecodeValue = true;
          }
        } else if (c === 43) {
          if (equalityIndex > startingIndex) {
            valueHasPlus = true;
          } else {
            keyHasPlus = true;
          }
        } else if (c === 37) {
          if (equalityIndex > startingIndex) {
            shouldDecodeValue = true;
          } else {
            shouldDecodeKey = true;
          }
        }
        prevIndex = i;
        prevChar = c;
      }
      return result;
    }
    __name(parse3, "parse");
  }
});
var require_stringify = __commonJS2({
  "../node_modules/picoquery/lib/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = stringify3;
    var object_util_js_1 = require_object_util();
    function stringify3(input, options) {
      if (input === null || typeof input !== "object") {
        return "";
      }
      const optionsObj = options ?? {};
      return (0, object_util_js_1.stringifyObject)(input, optionsObj);
    }
    __name(stringify3, "stringify");
  }
});
var require_main = __commonJS2({
  "../node_modules/picoquery/lib/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: __name(function() {
      return parse_js_1.parse;
    }, "get") });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: __name(function() {
      return stringify_js_1.stringify;
    }, "get") });
    __exportStar(require_shared(), exports);
  }
});

// node_modules/storybook/dist/_browser-chunks/chunk-FSBVR7H5.js
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}
__name(isPlainObject, "isPlainObject");
function isPrimitive(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}
__name(isPrimitive, "isPrimitive");
function isTypedArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
__name(isTypedArray, "isTypedArray");
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
__name(getSymbols, "getSymbols");
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
__name(getTag, "getTag");
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// node_modules/storybook/dist/_browser-chunks/chunk-UTNZYD2N.js
function mapValues(object, getNewValue) {
  const result = {};
  const keys = Object.keys(object);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const value = object[key];
    result[key] = getNewValue(value, key, object);
  }
  return result;
}
__name(mapValues, "mapValues");
function isUnsafeProperty(key) {
  return key === "__proto__";
}
__name(isUnsafeProperty, "isUnsafeProperty");
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
__name(isObjectLike, "isObjectLike");
function mergeWith(target, source, merge2) {
  const sourceKeys = Object.keys(source);
  for (let i = 0; i < sourceKeys.length; i++) {
    const key = sourceKeys[i];
    if (isUnsafeProperty(key)) {
      continue;
    }
    const sourceValue = source[key];
    const targetValue = target[key];
    const merged = merge2(targetValue, sourceValue, key, target, source);
    if (merged !== void 0) {
      target[key] = merged;
    } else if (Array.isArray(sourceValue)) {
      target[key] = mergeWith(targetValue ?? [], sourceValue, merge2);
    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
      target[key] = mergeWith(targetValue ?? {}, sourceValue, merge2);
    } else if (targetValue === void 0 || sourceValue !== void 0) {
      target[key] = sourceValue;
    }
  }
  return target;
}
__name(mergeWith, "mergeWith");
function pick(obj, keys) {
  const result = {};
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (Object.hasOwn(obj, key)) {
      result[key] = obj[key];
    }
  }
  return result;
}
__name(pick, "pick");
function pickBy(obj, shouldPick) {
  const result = {};
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const value = obj[key];
    if (shouldPick(value, key)) {
      result[key] = value;
    }
  }
  return result;
}
__name(pickBy, "pickBy");
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
  if (cloned !== void 0) {
    return cloned;
  }
  if (isPrimitive(valueToClone)) {
    return valueToClone;
  }
  if (stack.has(valueToClone)) {
    return stack.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result = new Array(valueToClone.length);
    stack.set(valueToClone, result);
    for (let i = 0; i < valueToClone.length; i++) {
      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result.input = valueToClone.input;
    }
    return result;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result = new RegExp(valueToClone.source, valueToClone.flags);
    result.lastIndex = valueToClone.lastIndex;
    return result;
  }
  if (valueToClone instanceof Map) {
    const result = /* @__PURE__ */ new Map();
    stack.set(valueToClone, result);
    for (const [key, value] of valueToClone) {
      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
    }
    return result;
  }
  if (valueToClone instanceof Set) {
    const result = /* @__PURE__ */ new Set();
    stack.set(valueToClone, result);
    for (const value of valueToClone) {
      result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
    }
    return result;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray(valueToClone)) {
    const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack.set(valueToClone, result);
    for (let i = 0; i < valueToClone.length; i++) {
      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    return result;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Blob) {
    const result = new Blob([valueToClone], { type: valueToClone.type });
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Error) {
    const result = new valueToClone.constructor();
    stack.set(valueToClone, result);
    result.message = valueToClone.message;
    result.name = valueToClone.name;
    result.stack = valueToClone.stack;
    result.cause = valueToClone.cause;
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result = Object.create(Object.getPrototypeOf(valueToClone));
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  return valueToClone;
}
__name(cloneDeepWithImpl, "cloneDeepWithImpl");
function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
  const keys = [...Object.keys(source), ...getSymbols(source)];
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null || descriptor.writable) {
      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
    }
  }
}
__name(copyProperties, "copyProperties");
function isCloneableObject(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
__name(isCloneableObject, "isCloneableObject");
function cloneDeep(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}
__name(cloneDeep, "cloneDeep");
function merge(target, source) {
  const sourceKeys = Object.keys(source);
  for (let i = 0; i < sourceKeys.length; i++) {
    const key = sourceKeys[i];
    if (isUnsafeProperty(key)) {
      continue;
    }
    const sourceValue = source[key];
    const targetValue = target[key];
    if (Array.isArray(sourceValue)) {
      if (Array.isArray(targetValue)) {
        target[key] = merge(targetValue, sourceValue);
      } else {
        target[key] = merge([], sourceValue);
      }
    } else if (isPlainObject(sourceValue)) {
      if (isPlainObject(targetValue)) {
        target[key] = merge(targetValue, sourceValue);
      } else {
        target[key] = merge({}, sourceValue);
      }
    } else if (targetValue === void 0 || sourceValue !== void 0) {
      target[key] = sourceValue;
    }
  }
  return target;
}
__name(merge, "merge");
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
function toMerged(target, source) {
  return merge(cloneDeep(target), source);
}
__name(toMerged, "toMerged");

// node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js
var import_preview_errors = __toESM(require_preview_errors(), 1);
var import_preview_errors2 = __toESM(require_preview_errors(), 1);
var require_dist = __commonJS2({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module) {
    (function(global12, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global12 = typeof globalThis !== "undefined" ? globalThis : global12 || self, factory(global12.jtpp = {}));
    })(exports, function(exports2) {
      "use strict";
      function tokenToString(token) {
        if (token.text !== void 0 && token.text !== "") {
          return `'${token.type}' with value '${token.text}'`;
        } else {
          return `'${token.type}'`;
        }
      }
      __name(tokenToString, "tokenToString");
      const _NoParsletFoundError = class _NoParsletFoundError2 extends Error {
        constructor(token) {
          super(`No parslet found for token: ${tokenToString(token)}`);
          this.token = token;
          Object.setPrototypeOf(this, _NoParsletFoundError2.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      __name(_NoParsletFoundError, "NoParsletFoundError");
      let NoParsletFoundError = _NoParsletFoundError;
      const _EarlyEndOfParseError = class _EarlyEndOfParseError2 extends Error {
        constructor(token) {
          super(`The parsing ended early. The next token was: ${tokenToString(token)}`);
          this.token = token;
          Object.setPrototypeOf(this, _EarlyEndOfParseError2.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      __name(_EarlyEndOfParseError, "EarlyEndOfParseError");
      let EarlyEndOfParseError = _EarlyEndOfParseError;
      const _UnexpectedTypeError = class _UnexpectedTypeError2 extends Error {
        constructor(result, message) {
          let error = `Unexpected type: '${result.type}'.`;
          if (message !== void 0) {
            error += ` Message: ${message}`;
          }
          super(error);
          Object.setPrototypeOf(this, _UnexpectedTypeError2.prototype);
        }
      };
      __name(_UnexpectedTypeError, "UnexpectedTypeError");
      let UnexpectedTypeError = _UnexpectedTypeError;
      function makePunctuationRule(type) {
        return (text) => {
          if (text.startsWith(type)) {
            return { type, text: type };
          } else {
            return null;
          }
        };
      }
      __name(makePunctuationRule, "makePunctuationRule");
      function getQuoted(text) {
        let position = 0;
        let char;
        const mark = text[0];
        let escaped = false;
        if (mark !== "'" && mark !== '"') {
          return null;
        }
        while (position < text.length) {
          position++;
          char = text[position];
          if (!escaped && char === mark) {
            position++;
            break;
          }
          escaped = !escaped && char === "\\";
        }
        if (char !== mark) {
          throw new Error("Unterminated String");
        }
        return text.slice(0, position);
      }
      __name(getQuoted, "getQuoted");
      const identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      const identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char)) {
          return null;
        }
        let position = 1;
        do {
          char = text[position];
          if (!identifierContinueRegex.test(char)) {
            break;
          }
          position++;
        } while (position < text.length);
        return text.slice(0, position);
      }
      __name(getIdentifier, "getIdentifier");
      const numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function getNumber(text) {
        var _a, _b;
        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
      }
      __name(getNumber, "getNumber");
      const identifierRule = __name((text) => {
        const value = getIdentifier(text);
        if (value == null) {
          return null;
        }
        return {
          type: "Identifier",
          text: value
        };
      }, "identifierRule");
      function makeKeyWordRule(type) {
        return (text) => {
          if (!text.startsWith(type)) {
            return null;
          }
          const prepends = text[type.length];
          if (prepends !== void 0 && identifierContinueRegex.test(prepends)) {
            return null;
          }
          return {
            type,
            text: type
          };
        };
      }
      __name(makeKeyWordRule, "makeKeyWordRule");
      const stringValueRule = __name((text) => {
        const value = getQuoted(text);
        if (value == null) {
          return null;
        }
        return {
          type: "StringValue",
          text: value
        };
      }, "stringValueRule");
      const eofRule = __name((text) => {
        if (text.length > 0) {
          return null;
        }
        return {
          type: "EOF",
          text: ""
        };
      }, "eofRule");
      const numberRule = __name((text) => {
        const value = getNumber(text);
        if (value === null) {
          return null;
        }
        return {
          type: "Number",
          text: value
        };
      }, "numberRule");
      const rules = [
        eofRule,
        makePunctuationRule("=>"),
        makePunctuationRule("("),
        makePunctuationRule(")"),
        makePunctuationRule("{"),
        makePunctuationRule("}"),
        makePunctuationRule("["),
        makePunctuationRule("]"),
        makePunctuationRule("|"),
        makePunctuationRule("&"),
        makePunctuationRule("<"),
        makePunctuationRule(">"),
        makePunctuationRule(","),
        makePunctuationRule(";"),
        makePunctuationRule("*"),
        makePunctuationRule("?"),
        makePunctuationRule("!"),
        makePunctuationRule("="),
        makePunctuationRule(":"),
        makePunctuationRule("..."),
        makePunctuationRule("."),
        makePunctuationRule("#"),
        makePunctuationRule("~"),
        makePunctuationRule("/"),
        makePunctuationRule("@"),
        makeKeyWordRule("undefined"),
        makeKeyWordRule("null"),
        makeKeyWordRule("function"),
        makeKeyWordRule("this"),
        makeKeyWordRule("new"),
        makeKeyWordRule("module"),
        makeKeyWordRule("event"),
        makeKeyWordRule("extends"),
        makeKeyWordRule("external"),
        makeKeyWordRule("infer"),
        makeKeyWordRule("typeof"),
        makeKeyWordRule("keyof"),
        makeKeyWordRule("readonly"),
        makeKeyWordRule("import"),
        makeKeyWordRule("is"),
        makeKeyWordRule("in"),
        makeKeyWordRule("asserts"),
        numberRule,
        identifierRule,
        stringValueRule
      ];
      const breakingWhitespaceRegex = /^\s*\n\s*/;
      const _Lexer = class _Lexer2 {
        static create(text) {
          const current = this.read(text);
          text = current.text;
          const next = this.read(text);
          text = next.text;
          return new _Lexer2(text, void 0, current.token, next.token);
        }
        constructor(text, previous, current, next) {
          this.text = "";
          this.text = text;
          this.previous = previous;
          this.current = current;
          this.next = next;
        }
        static read(text, startOfLine = false) {
          startOfLine = startOfLine || breakingWhitespaceRegex.test(text);
          text = text.trim();
          for (const rule of rules) {
            const partial = rule(text);
            if (partial !== null) {
              const token = Object.assign(Object.assign({}, partial), { startOfLine });
              text = text.slice(token.text.length);
              return { text, token };
            }
          }
          throw new Error("Unexpected Token " + text);
        }
        advance() {
          const next = _Lexer2.read(this.text);
          return new _Lexer2(next.text, this.current, this.next, next.token);
        }
      };
      __name(_Lexer, "Lexer");
      let Lexer = _Lexer;
      function assertRootResult(result) {
        if (result === void 0) {
          throw new Error("Unexpected undefined");
        }
        if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter") {
          throw new UnexpectedTypeError(result);
        }
        return result;
      }
      __name(assertRootResult, "assertRootResult");
      function assertPlainKeyValueOrRootResult(result) {
        if (result.type === "JsdocTypeKeyValue") {
          return assertPlainKeyValueResult(result);
        }
        return assertRootResult(result);
      }
      __name(assertPlainKeyValueOrRootResult, "assertPlainKeyValueOrRootResult");
      function assertPlainKeyValueOrNameResult(result) {
        if (result.type === "JsdocTypeName") {
          return result;
        }
        return assertPlainKeyValueResult(result);
      }
      __name(assertPlainKeyValueOrNameResult, "assertPlainKeyValueOrNameResult");
      function assertPlainKeyValueResult(result) {
        if (result.type !== "JsdocTypeKeyValue") {
          throw new UnexpectedTypeError(result);
        }
        return result;
      }
      __name(assertPlainKeyValueResult, "assertPlainKeyValueResult");
      function assertNumberOrVariadicNameResult(result) {
        var _a;
        if (result.type === "JsdocTypeVariadic") {
          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === "JsdocTypeName") {
            return result;
          }
          throw new UnexpectedTypeError(result);
        }
        if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName") {
          throw new UnexpectedTypeError(result);
        }
        return result;
      }
      __name(assertNumberOrVariadicNameResult, "assertNumberOrVariadicNameResult");
      function assertArrayOrTupleResult(result) {
        if (result.type === "JsdocTypeTuple") {
          return result;
        }
        if (result.type === "JsdocTypeGeneric" && result.meta.brackets === "square") {
          return result;
        }
        throw new UnexpectedTypeError(result);
      }
      __name(assertArrayOrTupleResult, "assertArrayOrTupleResult");
      function isSquaredProperty(result) {
        return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
      }
      __name(isSquaredProperty, "isSquaredProperty");
      var Precedence;
      (function(Precedence2) {
        Precedence2[Precedence2["ALL"] = 0] = "ALL";
        Precedence2[Precedence2["PARAMETER_LIST"] = 1] = "PARAMETER_LIST";
        Precedence2[Precedence2["OBJECT"] = 2] = "OBJECT";
        Precedence2[Precedence2["KEY_VALUE"] = 3] = "KEY_VALUE";
        Precedence2[Precedence2["INDEX_BRACKETS"] = 4] = "INDEX_BRACKETS";
        Precedence2[Precedence2["UNION"] = 5] = "UNION";
        Precedence2[Precedence2["INTERSECTION"] = 6] = "INTERSECTION";
        Precedence2[Precedence2["PREFIX"] = 7] = "PREFIX";
        Precedence2[Precedence2["INFIX"] = 8] = "INFIX";
        Precedence2[Precedence2["TUPLE"] = 9] = "TUPLE";
        Precedence2[Precedence2["SYMBOL"] = 10] = "SYMBOL";
        Precedence2[Precedence2["OPTIONAL"] = 11] = "OPTIONAL";
        Precedence2[Precedence2["NULLABLE"] = 12] = "NULLABLE";
        Precedence2[Precedence2["KEY_OF_TYPE_OF"] = 13] = "KEY_OF_TYPE_OF";
        Precedence2[Precedence2["FUNCTION"] = 14] = "FUNCTION";
        Precedence2[Precedence2["ARROW"] = 15] = "ARROW";
        Precedence2[Precedence2["ARRAY_BRACKETS"] = 16] = "ARRAY_BRACKETS";
        Precedence2[Precedence2["GENERIC"] = 17] = "GENERIC";
        Precedence2[Precedence2["NAME_PATH"] = 18] = "NAME_PATH";
        Precedence2[Precedence2["PARENTHESIS"] = 19] = "PARENTHESIS";
        Precedence2[Precedence2["SPECIAL_TYPES"] = 20] = "SPECIAL_TYPES";
      })(Precedence || (Precedence = {}));
      const _Parser = class _Parser {
        constructor(grammar, textOrLexer, baseParser) {
          this.grammar = grammar;
          if (typeof textOrLexer === "string") {
            this._lexer = Lexer.create(textOrLexer);
          } else {
            this._lexer = textOrLexer;
          }
          this.baseParser = baseParser;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          const result = this.parseType(Precedence.ALL);
          if (this.lexer.current.type !== "EOF") {
            throw new EarlyEndOfParseError(this.lexer.current);
          }
          return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
          return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
          const result = this.tryParslets(null, precedence);
          if (result === null) {
            throw new NoParsletFoundError(this.lexer.current);
          }
          return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
          let result = this.tryParslets(left, precedence);
          while (result !== null) {
            left = result;
            result = this.tryParslets(left, precedence);
          }
          return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
          for (const parslet of this.grammar) {
            const result = parslet(this, precedence, left);
            if (result !== null) {
              return result;
            }
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
          if (!Array.isArray(types)) {
            types = [types];
          }
          if (types.includes(this.lexer.current.type)) {
            this._lexer = this.lexer.advance();
            return true;
          } else {
            return false;
          }
        }
        acceptLexerState(parser) {
          this._lexer = parser.lexer;
        }
      };
      __name(_Parser, "Parser");
      let Parser = _Parser;
      function isQuestionMarkUnknownType(next) {
        return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
      }
      __name(isQuestionMarkUnknownType, "isQuestionMarkUnknownType");
      const nullableParslet = __name((parser, precedence, left) => {
        const type = parser.lexer.current.type;
        const next = parser.lexer.next.type;
        const accept = left == null && type === "?" && !isQuestionMarkUnknownType(next) || left != null && type === "?";
        if (!accept) {
          return null;
        }
        parser.consume("?");
        if (left == null) {
          return {
            type: "JsdocTypeNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          };
        } else {
          return {
            type: "JsdocTypeNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          };
        }
      }, "nullableParslet");
      function composeParslet(options) {
        const parslet = __name((parser, curPrecedence, left) => {
          const type = parser.lexer.current.type;
          const next = parser.lexer.next.type;
          if (left === null) {
            if ("parsePrefix" in options) {
              if (options.accept(type, next)) {
                return options.parsePrefix(parser);
              }
            }
          } else {
            if ("parseInfix" in options) {
              if (options.precedence > curPrecedence && options.accept(type, next)) {
                return options.parseInfix(parser, left);
              }
            }
          }
          return null;
        }, "parslet");
        Object.defineProperty(parslet, "name", {
          value: options.name
        });
        return parslet;
      }
      __name(composeParslet, "composeParslet");
      const optionalParslet = composeParslet({
        name: "optionalParslet",
        accept: __name((type) => type === "=", "accept"),
        precedence: Precedence.OPTIONAL,
        parsePrefix: __name((parser) => {
          parser.consume("=");
          return {
            type: "JsdocTypeOptional",
            element: parser.parseType(Precedence.OPTIONAL),
            meta: {
              position: "prefix"
            }
          };
        }, "parsePrefix"),
        parseInfix: __name((parser, left) => {
          parser.consume("=");
          return {
            type: "JsdocTypeOptional",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          };
        }, "parseInfix")
      });
      const numberParslet = composeParslet({
        name: "numberParslet",
        accept: __name((type) => type === "Number", "accept"),
        parsePrefix: __name((parser) => {
          const value = parseFloat(parser.lexer.current.text);
          parser.consume("Number");
          return {
            type: "JsdocTypeNumber",
            value
          };
        }, "parsePrefix")
      });
      const parenthesisParslet = composeParslet({
        name: "parenthesisParslet",
        accept: __name((type) => type === "(", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("(");
          if (parser.consume(")")) {
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          }
          const result = parser.parseIntermediateType(Precedence.ALL);
          if (!parser.consume(")")) {
            throw new Error("Unterminated parenthesis");
          }
          if (result.type === "JsdocTypeParameterList") {
            return result;
          } else if (result.type === "JsdocTypeKeyValue") {
            return {
              type: "JsdocTypeParameterList",
              elements: [result]
            };
          }
          return {
            type: "JsdocTypeParenthesis",
            element: assertRootResult(result)
          };
        }, "parsePrefix")
      });
      const specialTypesParslet = composeParslet({
        name: "specialTypesParslet",
        accept: __name((type, next) => type === "?" && isQuestionMarkUnknownType(next) || type === "null" || type === "undefined" || type === "*", "accept"),
        parsePrefix: __name((parser) => {
          if (parser.consume("null")) {
            return {
              type: "JsdocTypeNull"
            };
          }
          if (parser.consume("undefined")) {
            return {
              type: "JsdocTypeUndefined"
            };
          }
          if (parser.consume("*")) {
            return {
              type: "JsdocTypeAny"
            };
          }
          if (parser.consume("?")) {
            return {
              type: "JsdocTypeUnknown"
            };
          }
          throw new Error("Unacceptable token: " + parser.lexer.current.text);
        }, "parsePrefix")
      });
      const notNullableParslet = composeParslet({
        name: "notNullableParslet",
        accept: __name((type) => type === "!", "accept"),
        precedence: Precedence.NULLABLE,
        parsePrefix: __name((parser) => {
          parser.consume("!");
          return {
            type: "JsdocTypeNotNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          };
        }, "parsePrefix"),
        parseInfix: __name((parser, left) => {
          parser.consume("!");
          return {
            type: "JsdocTypeNotNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          };
        }, "parseInfix")
      });
      function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
          name: "parameterListParslet",
          accept: __name((type) => type === ",", "accept"),
          precedence: Precedence.PARAMETER_LIST,
          parseInfix: __name((parser, left) => {
            const elements = [
              assertPlainKeyValueOrRootResult(left)
            ];
            parser.consume(",");
            do {
              try {
                const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                elements.push(assertPlainKeyValueOrRootResult(next));
              } catch (e) {
                if (e instanceof NoParsletFoundError) {
                  break;
                } else {
                  throw e;
                }
              }
            } while (parser.consume(","));
            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === "JsdocTypeVariadic")) {
              throw new Error("Only the last parameter may be a rest parameter");
            }
            return {
              type: "JsdocTypeParameterList",
              elements
            };
          }, "parseInfix")
        });
      }
      __name(createParameterListParslet, "createParameterListParslet");
      const genericParslet = composeParslet({
        name: "genericParslet",
        accept: __name((type, next) => type === "<" || type === "." && next === "<", "accept"),
        precedence: Precedence.GENERIC,
        parseInfix: __name((parser, left) => {
          const dot = parser.consume(".");
          parser.consume("<");
          const objects = [];
          let infer = false;
          if (parser.consume("infer")) {
            infer = true;
            const left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName") {
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            }
            objects.push(left2);
          } else {
            do {
              objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            } while (parser.consume(","));
          }
          if (!parser.consume(">")) {
            throw new Error("Unterminated generic parameter list");
          }
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {
            brackets: "angle",
            dot
          } });
        }, "parseInfix")
      });
      const unionParslet = composeParslet({
        name: "unionParslet",
        accept: __name((type) => type === "|", "accept"),
        precedence: Precedence.UNION,
        parseInfix: __name((parser, left) => {
          parser.consume("|");
          const elements = [];
          do {
            elements.push(parser.parseType(Precedence.UNION));
          } while (parser.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [assertRootResult(left), ...elements]
          };
        }, "parseInfix")
      });
      const baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
          allowTrailingComma: true
        }),
        genericParslet,
        unionParslet,
        optionalParslet
      ];
      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
        return __name(function namePathParslet(parser, precedence, left) {
          if (left == null || precedence >= Precedence.NAME_PATH) {
            return null;
          }
          const type = parser.lexer.current.type;
          const next = parser.lexer.next.type;
          const accept = type === "." && next !== "<" || type === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type === "~" || type === "#");
          if (!accept) {
            return null;
          }
          let pathType;
          let brackets = false;
          if (parser.consume(".")) {
            pathType = "property";
          } else if (parser.consume("[")) {
            pathType = "property-brackets";
            brackets = true;
          } else if (parser.consume("~")) {
            pathType = "inner";
          } else {
            parser.consume("#");
            pathType = "instance";
          }
          const pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser;
          const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
          parser.acceptLexerState(pathParser);
          let right;
          switch (parsed.type) {
            case "JsdocTypeName":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: parsed.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (parsed.specialType === "event") {
                right = parsed;
              } else {
                throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              }
              break;
            default:
              throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (brackets && !parser.consume("]")) {
            const token = parser.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: assertRootResult(left),
            right,
            pathType
          };
        }, "namePathParslet");
      }
      __name(createNamePathParslet, "createNamePathParslet");
      function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
          name: "nameParslet",
          accept: __name((type) => type === "Identifier" || type === "this" || type === "new" || allowedAdditionalTokens.includes(type), "accept"),
          parsePrefix: __name((parser) => {
            const { type, text } = parser.lexer.current;
            parser.consume(type);
            return {
              type: "JsdocTypeName",
              value: text
            };
          }, "parsePrefix")
        });
      }
      __name(createNameParslet, "createNameParslet");
      const stringValueParslet = composeParslet({
        name: "stringValueParslet",
        accept: __name((type) => type === "StringValue", "accept"),
        parsePrefix: __name((parser) => {
          const text = parser.lexer.current.text;
          parser.consume("StringValue");
          return {
            type: "JsdocTypeStringValue",
            value: text.slice(1, -1),
            meta: {
              quote: text[0] === "'" ? "single" : "double"
            }
          };
        }, "parsePrefix")
      });
      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
        return composeParslet({
          name: "specialNamePathParslet",
          accept: __name((type) => allowedTypes.includes(type), "accept"),
          parsePrefix: __name((parser) => {
            const type = parser.lexer.current.type;
            parser.consume(type);
            if (!parser.consume(":")) {
              return {
                type: "JsdocTypeName",
                value: type
              };
            }
            let result;
            let token = parser.lexer.current;
            if (parser.consume("StringValue")) {
              result = {
                type: "JsdocTypeSpecialNamePath",
                value: token.text.slice(1, -1),
                specialType: type,
                meta: {
                  quote: token.text[0] === "'" ? "single" : "double"
                }
              };
            } else {
              let value = "";
              const allowed = ["Identifier", "@", "/"];
              while (allowed.some((type2) => parser.consume(type2))) {
                value += token.text;
                token = parser.lexer.current;
              }
              result = {
                type: "JsdocTypeSpecialNamePath",
                value,
                specialType: type,
                meta: {
                  quote: void 0
                }
              };
            }
            const moduleParser = new Parser(pathGrammar2, parser.lexer, parser);
            const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
            parser.acceptLexerState(moduleParser);
            return assertRootResult(moduleResult);
          }, "parsePrefix")
        });
      }
      __name(createSpecialNamePathParslet, "createSpecialNamePathParslet");
      const basePathGrammar = [
        createNameParslet({
          allowedAdditionalTokens: ["external", "module"]
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar: null
        })
      ];
      const pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
          allowedTypes: ["event"],
          pathGrammar: basePathGrammar
        })
      ];
      function getParameters(value) {
        let parameters2;
        if (value.type === "JsdocTypeParameterList") {
          parameters2 = value.elements;
        } else if (value.type === "JsdocTypeParenthesis") {
          parameters2 = [value.element];
        } else {
          throw new UnexpectedTypeError(value);
        }
        return parameters2.map((p2) => assertPlainKeyValueOrRootResult(p2));
      }
      __name(getParameters, "getParameters");
      function getUnnamedParameters(value) {
        const parameters2 = getParameters(value);
        if (parameters2.some((p2) => p2.type === "JsdocTypeKeyValue")) {
          throw new Error("No parameter should be named");
        }
        return parameters2;
      }
      __name(getUnnamedParameters, "getUnnamedParameters");
      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
          name: "functionParslet",
          accept: __name((type, next) => type === "function" || allowNewAsFunctionKeyword && type === "new" && next === "(", "accept"),
          parsePrefix: __name((parser) => {
            const newKeyword = parser.consume("new");
            parser.consume("function");
            const hasParenthesis = parser.lexer.current.type === "(";
            if (!hasParenthesis) {
              if (!allowWithoutParenthesis) {
                throw new Error("function is missing parameter list");
              }
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let result = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: false,
              constructor: newKeyword,
              parenthesis: hasParenthesis
            };
            const value = parser.parseIntermediateType(Precedence.FUNCTION);
            if (allowNamedParameters === void 0) {
              result.parameters = getUnnamedParameters(value);
            } else if (newKeyword && value.type === "JsdocTypeFunction" && value.arrow) {
              result = value;
              result.constructor = true;
              return result;
            } else {
              result.parameters = getParameters(value);
              for (const p2 of result.parameters) {
                if (p2.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p2.key)) {
                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p2.type}`);
                }
              }
            }
            if (parser.consume(":")) {
              result.returnType = parser.parseType(Precedence.PREFIX);
            } else {
              if (!allowNoReturnType) {
                throw new Error("function is missing return type");
              }
            }
            return result;
          }, "parsePrefix")
        });
      }
      __name(createFunctionParslet, "createFunctionParslet");
      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
          name: "variadicParslet",
          accept: __name((type) => type === "...", "accept"),
          precedence: Precedence.PREFIX,
          parsePrefix: __name((parser) => {
            parser.consume("...");
            const brackets = allowEnclosingBrackets && parser.consume("[");
            try {
              const element = parser.parseType(Precedence.PREFIX);
              if (brackets && !parser.consume("]")) {
                throw new Error("Unterminated variadic type. Missing ']'");
              }
              return {
                type: "JsdocTypeVariadic",
                element: assertRootResult(element),
                meta: {
                  position: "prefix",
                  squareBrackets: brackets
                }
              };
            } catch (e) {
              if (e instanceof NoParsletFoundError) {
                if (brackets) {
                  throw new Error("Empty square brackets for variadic are not allowed.");
                }
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: false
                  }
                };
              } else {
                throw e;
              }
            }
          }, "parsePrefix"),
          parseInfix: allowPostfix ? (parser, left) => {
            parser.consume("...");
            return {
              type: "JsdocTypeVariadic",
              element: assertRootResult(left),
              meta: {
                position: "suffix",
                squareBrackets: false
              }
            };
          } : void 0
        });
      }
      __name(createVariadicParslet, "createVariadicParslet");
      const symbolParslet = composeParslet({
        name: "symbolParslet",
        accept: __name((type) => type === "(", "accept"),
        precedence: Precedence.SYMBOL,
        parseInfix: __name((parser, left) => {
          if (left.type !== "JsdocTypeName") {
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          }
          parser.consume("(");
          const result = {
            type: "JsdocTypeSymbol",
            value: left.value
          };
          if (!parser.consume(")")) {
            const next = parser.parseIntermediateType(Precedence.SYMBOL);
            result.element = assertNumberOrVariadicNameResult(next);
            if (!parser.consume(")")) {
              throw new Error("Symbol does not end after value");
            }
          }
          return result;
        }, "parseInfix")
      });
      const arrayBracketsParslet = composeParslet({
        name: "arrayBracketsParslet",
        precedence: Precedence.ARRAY_BRACKETS,
        accept: __name((type, next) => type === "[" && next === "]", "accept"),
        parseInfix: __name((parser, left) => {
          parser.consume("[");
          parser.consume("]");
          return {
            type: "JsdocTypeGeneric",
            left: {
              type: "JsdocTypeName",
              value: "Array"
            },
            elements: [
              assertRootResult(left)
            ],
            meta: {
              brackets: "square",
              dot: false
            }
          };
        }, "parseInfix")
      });
      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
        return composeParslet({
          name: "objectParslet",
          accept: __name((type) => type === "{", "accept"),
          parsePrefix: __name((parser) => {
            parser.consume("{");
            const result = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!parser.consume("}")) {
              let separator;
              const fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
              while (true) {
                fieldParser.acceptLexerState(parser);
                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                parser.acceptLexerState(fieldParser);
                if (field === void 0 && allowKeyTypes) {
                  field = parser.parseIntermediateType(Precedence.OBJECT);
                }
                let optional = false;
                if (field.type === "JsdocTypeNullable") {
                  optional = true;
                  field = field.element;
                }
                if (field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                  let quote2;
                  if (field.type === "JsdocTypeStringValue") {
                    quote2 = field.meta.quote;
                  }
                  result.elements.push({
                    type: "JsdocTypeObjectField",
                    key: field.value.toString(),
                    right: void 0,
                    optional,
                    readonly: false,
                    meta: {
                      quote: quote2
                    }
                  });
                } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") {
                  result.elements.push(field);
                } else {
                  throw new UnexpectedTypeError(field);
                }
                if (parser.lexer.current.startOfLine) {
                  separator = "linebreak";
                  parser.consume(",") || parser.consume(";");
                } else if (parser.consume(",")) {
                  separator = "comma";
                } else if (parser.consume(";")) {
                  separator = "semicolon";
                } else {
                  break;
                }
                const type = parser.lexer.current.type;
                if (type === "}") {
                  break;
                }
              }
              result.meta.separator = separator !== null && separator !== void 0 ? separator : "comma";
              if (separator === "linebreak") {
                result.meta.propertyIndent = "  ";
              }
              if (!parser.consume("}")) {
                throw new Error("Unterminated record type. Missing '}'");
              }
            }
            return result;
          }, "parsePrefix")
        });
      }
      __name(createObjectParslet, "createObjectParslet");
      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
          name: "objectFieldParslet",
          precedence: Precedence.KEY_VALUE,
          accept: __name((type) => type === ":", "accept"),
          parseInfix: __name((parser, left) => {
            var _a;
            let optional = false;
            let readonlyProperty = false;
            if (allowOptional && left.type === "JsdocTypeNullable") {
              optional = true;
              left = left.element;
            }
            if (allowReadonly && left.type === "JsdocTypeReadonlyProperty") {
              readonlyProperty = true;
              left = left.element;
            }
            const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;
            parentParser.acceptLexerState(parser);
            if (left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
              if (isSquaredProperty(left) && !allowSquaredProperties) {
                throw new UnexpectedTypeError(left);
              }
              parentParser.consume(":");
              let quote2;
              if (left.type === "JsdocTypeStringValue") {
                quote2 = left.meta.quote;
              }
              const right = parentParser.parseType(Precedence.KEY_VALUE);
              parser.acceptLexerState(parentParser);
              return {
                type: "JsdocTypeObjectField",
                key: isSquaredProperty(left) ? left : left.value.toString(),
                right,
                optional,
                readonly: readonlyProperty,
                meta: {
                  quote: quote2
                }
              };
            } else {
              if (!allowKeyTypes) {
                throw new UnexpectedTypeError(left);
              }
              parentParser.consume(":");
              const right = parentParser.parseType(Precedence.KEY_VALUE);
              parser.acceptLexerState(parentParser);
              return {
                type: "JsdocTypeJsdocObjectField",
                left: assertRootResult(left),
                right
              };
            }
          }, "parseInfix")
        });
      }
      __name(createObjectFieldParslet, "createObjectFieldParslet");
      function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
          name: "keyValueParslet",
          precedence: Precedence.KEY_VALUE,
          accept: __name((type) => type === ":", "accept"),
          parseInfix: __name((parser, left) => {
            let optional = false;
            let variadic = false;
            if (allowOptional && left.type === "JsdocTypeNullable") {
              optional = true;
              left = left.element;
            }
            if (allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0) {
              variadic = true;
              left = left.element;
            }
            if (left.type !== "JsdocTypeName") {
              throw new UnexpectedTypeError(left);
            }
            parser.consume(":");
            const right = parser.parseType(Precedence.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: left.value,
              right,
              optional,
              variadic
            };
          }, "parseInfix")
        });
      }
      __name(createKeyValueParslet, "createKeyValueParslet");
      const jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
          allowedTypes: ["module", "external", "event"],
          pathGrammar
        }),
        createVariadicParslet({
          allowEnclosingBrackets: true,
          allowPostfix: true
        }),
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        })
      ];
      const jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            createNameParslet({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            createObjectFieldParslet({
              allowSquaredProperties: false,
              allowKeyTypes: true,
              allowOptional: false,
              allowReadonly: false
            }),
            ...jsdocBaseGrammar
          ],
          allowKeyTypes: true
        }),
        createKeyValueParslet({
          allowOptional: true,
          allowVariadic: true
        })
      ];
      const typeOfParslet = composeParslet({
        name: "typeOfParslet",
        accept: __name((type) => type === "typeof", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("typeof");
          return {
            type: "JsdocTypeTypeof",
            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
          };
        }, "parsePrefix")
      });
      const objectFieldGrammar$1 = [
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: false,
          allowKeyTypes: false,
          allowOptional: false,
          allowReadonly: false
        })
      ];
      const closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        typeOfParslet,
        createFunctionParslet({
          allowWithoutParenthesis: false,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        }),
        createKeyValueParslet({
          allowOptional: false,
          allowVariadic: false
        }),
        symbolParslet
      ];
      const assertsParslet = composeParslet({
        name: "assertsParslet",
        accept: __name((type) => type === "asserts", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("asserts");
          const left = parser.parseIntermediateType(Precedence.SYMBOL);
          if (left.type !== "JsdocTypeName") {
            throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
          }
          if (!parser.consume("is")) {
            return {
              type: "JsdocTypeAssertsPlain",
              element: left
            };
          }
          return {
            type: "JsdocTypeAsserts",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }, "parsePrefix")
      });
      function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
          name: "tupleParslet",
          accept: __name((type) => type === "[", "accept"),
          parsePrefix: __name((parser) => {
            parser.consume("[");
            const result = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (parser.consume("]")) {
              return result;
            }
            const typeList = parser.parseIntermediateType(Precedence.ALL);
            if (typeList.type === "JsdocTypeParameterList") {
              if (typeList.elements[0].type === "JsdocTypeKeyValue") {
                result.elements = typeList.elements.map(assertPlainKeyValueResult);
              } else {
                result.elements = typeList.elements.map(assertRootResult);
              }
            } else {
              if (typeList.type === "JsdocTypeKeyValue") {
                result.elements = [assertPlainKeyValueResult(typeList)];
              } else {
                result.elements = [assertRootResult(typeList)];
              }
            }
            if (!parser.consume("]")) {
              throw new Error("Unterminated '['");
            }
            if (result.elements.some((e) => e.type === "JsdocTypeUnknown")) {
              throw new Error("Question mark in tuple not allowed");
            }
            return result;
          }, "parsePrefix")
        });
      }
      __name(createTupleParslet, "createTupleParslet");
      const keyOfParslet = composeParslet({
        name: "keyOfParslet",
        accept: __name((type) => type === "keyof", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("keyof");
          return {
            type: "JsdocTypeKeyof",
            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
          };
        }, "parsePrefix")
      });
      const importParslet = composeParslet({
        name: "importParslet",
        accept: __name((type) => type === "import", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("import");
          if (!parser.consume("(")) {
            throw new Error("Missing parenthesis after import keyword");
          }
          const path = parser.parseType(Precedence.PREFIX);
          if (path.type !== "JsdocTypeStringValue") {
            throw new Error("Only string values are allowed as paths for imports");
          }
          if (!parser.consume(")")) {
            throw new Error("Missing closing parenthesis after import keyword");
          }
          return {
            type: "JsdocTypeImport",
            element: path
          };
        }, "parsePrefix")
      });
      const readonlyPropertyParslet = composeParslet({
        name: "readonlyPropertyParslet",
        accept: __name((type) => type === "readonly", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("readonly");
          return {
            type: "JsdocTypeReadonlyProperty",
            element: parser.parseIntermediateType(Precedence.KEY_VALUE)
          };
        }, "parsePrefix")
      });
      const arrowFunctionParslet = composeParslet({
        name: "arrowFunctionParslet",
        precedence: Precedence.ARROW,
        accept: __name((type) => type === "=>", "accept"),
        parseInfix: __name((parser, left) => {
          parser.consume("=>");
          return {
            type: "JsdocTypeFunction",
            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
            arrow: true,
            constructor: false,
            parenthesis: true,
            returnType: parser.parseType(Precedence.OBJECT)
          };
        }, "parseInfix")
      });
      const genericArrowFunctionParslet = composeParslet({
        name: "genericArrowFunctionParslet",
        accept: __name((type) => type === "<", "accept"),
        parsePrefix: __name((parser) => {
          const typeParameters = [];
          parser.consume("<");
          do {
            let defaultValue;
            let name = parser.parseIntermediateType(Precedence.SYMBOL);
            if (name.type === "JsdocTypeOptional") {
              name = name.element;
              defaultValue = parser.parseType(Precedence.SYMBOL);
            }
            if (name.type !== "JsdocTypeName") {
              throw new UnexpectedTypeError(name);
            }
            let constraint;
            if (parser.consume("extends")) {
              constraint = parser.parseType(Precedence.SYMBOL);
              if (constraint.type === "JsdocTypeOptional") {
                constraint = constraint.element;
                defaultValue = parser.parseType(Precedence.SYMBOL);
              }
            }
            const typeParameter = {
              type: "JsdocTypeTypeParameter",
              name
            };
            if (constraint !== void 0) {
              typeParameter.constraint = constraint;
            }
            if (defaultValue !== void 0) {
              typeParameter.defaultValue = defaultValue;
            }
            typeParameters.push(typeParameter);
            if (parser.consume(">")) {
              break;
            }
          } while (parser.consume(","));
          const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
          functionBase.typeParameters = typeParameters;
          return functionBase;
        }, "parsePrefix")
      });
      const intersectionParslet = composeParslet({
        name: "intersectionParslet",
        accept: __name((type) => type === "&", "accept"),
        precedence: Precedence.INTERSECTION,
        parseInfix: __name((parser, left) => {
          parser.consume("&");
          const elements = [];
          do {
            elements.push(parser.parseType(Precedence.INTERSECTION));
          } while (parser.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [assertRootResult(left), ...elements]
          };
        }, "parseInfix")
      });
      const predicateParslet = composeParslet({
        name: "predicateParslet",
        precedence: Precedence.INFIX,
        accept: __name((type) => type === "is", "accept"),
        parseInfix: __name((parser, left) => {
          if (left.type !== "JsdocTypeName") {
            throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
          }
          parser.consume("is");
          return {
            type: "JsdocTypePredicate",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }, "parseInfix")
      });
      const objectSquaredPropertyParslet = composeParslet({
        name: "objectSquareBracketPropertyParslet",
        accept: __name((type) => type === "[", "accept"),
        parsePrefix: __name((parser) => {
          if (parser.baseParser === void 0) {
            throw new Error("Only allowed inside object grammar");
          }
          parser.consume("[");
          const key = parser.lexer.current.text;
          parser.consume("Identifier");
          let result;
          if (parser.consume(":")) {
            const parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser);
            result = {
              type: "JsdocTypeIndexSignature",
              key,
              right: parentParser.parseType(Precedence.INDEX_BRACKETS)
            };
            parser.acceptLexerState(parentParser);
          } else if (parser.consume("in")) {
            const parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser);
            result = {
              type: "JsdocTypeMappedType",
              key,
              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
            };
            parser.acceptLexerState(parentParser);
          } else {
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          }
          if (!parser.consume("]")) {
            throw new Error("Unterminated square brackets");
          }
          return result;
        }, "parsePrefix")
      });
      const readonlyArrayParslet = composeParslet({
        name: "readonlyArrayParslet",
        accept: __name((type) => type === "readonly", "accept"),
        parsePrefix: __name((parser) => {
          parser.consume("readonly");
          return {
            type: "JsdocTypeReadonlyArray",
            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
          };
        }, "parsePrefix")
      });
      const conditionalParslet = composeParslet({
        name: "conditionalParslet",
        precedence: Precedence.INFIX,
        accept: __name((type) => type === "extends", "accept"),
        parseInfix: __name((parser, left) => {
          parser.consume("extends");
          const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;
          const trueType = parser.parseType(Precedence.INFIX);
          parser.consume(":");
          return {
            type: "JsdocTypeConditional",
            checksType: assertRootResult(left),
            extendsType,
            trueType,
            falseType: parser.parseType(Precedence.INFIX)
          };
        }, "parseInfix")
      });
      const objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: true,
          allowKeyTypes: false,
          allowOptional: true,
          allowReadonly: true
        }),
        objectSquaredPropertyParslet
      ];
      const typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar
        }),
        readonlyArrayParslet,
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNoReturnType: false,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: true
        }),
        createTupleParslet({
          allowQuestionMark: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        assertsParslet,
        conditionalParslet,
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        genericArrowFunctionParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: true,
          allowJsdocNamePaths: false,
          pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
          allowVariadic: true,
          allowOptional: true
        })
      ];
      function parse3(expression, mode) {
        switch (mode) {
          case "closure":
            return new Parser(closureGrammar, expression).parse();
          case "jsdoc":
            return new Parser(jsdocGrammar, expression).parse();
          case "typescript":
            return new Parser(typescriptGrammar, expression).parse();
        }
      }
      __name(parse3, "parse");
      function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
        let error;
        for (const mode of modes) {
          try {
            return parse3(expression, mode);
          } catch (e) {
            error = e;
          }
        }
        throw error;
      }
      __name(tryParse, "tryParse");
      function transform(rules2, parseResult) {
        const rule = rules2[parseResult.type];
        if (rule === void 0) {
          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        }
        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
      }
      __name(transform, "transform");
      function notAvailableTransform(parseResult) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      __name(notAvailableTransform, "notAvailableTransform");
      function extractSpecialParams(source) {
        const result = {
          params: []
        };
        for (const param of source.parameters) {
          if (param.type === "JsdocTypeKeyValue") {
            if (param.key === "this") {
              result.this = param.right;
            } else if (param.key === "new") {
              result.new = param.right;
            } else {
              result.params.push(param);
            }
          } else {
            result.params.push(param);
          }
        }
        return result;
      }
      __name(extractSpecialParams, "extractSpecialParams");
      function applyPosition(position, target, value) {
        return position === "prefix" ? value + target : target + value;
      }
      __name(applyPosition, "applyPosition");
      function quote(value, quote2) {
        switch (quote2) {
          case "double":
            return `"${value}"`;
          case "single":
            return `'${value}'`;
          case void 0:
            return value;
        }
      }
      __name(quote, "quote");
      function stringifyRules2() {
        return {
          JsdocTypeParenthesis: __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeParenthesis"),
          JsdocTypeKeyof: __name((result, transform2) => `keyof ${transform2(result.element)}`, "JsdocTypeKeyof"),
          JsdocTypeFunction: __name((result, transform2) => {
            var _a;
            if (!result.arrow) {
              let stringified = result.constructor ? "new" : "function";
              if (!result.parenthesis) {
                return stringified;
              }
              stringified += `(${result.parameters.map(transform2).join(", ")})`;
              if (result.returnType !== void 0) {
                stringified += `: ${transform2(result.returnType)}`;
              }
              return stringified;
            } else {
              if (result.returnType === void 0) {
                throw new Error("Arrow function needs a return type.");
              }
              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(", ")) !== null && _a !== void 0 ? _a : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
              if (result.constructor) {
                stringified = "new " + stringified;
              }
              return stringified;
            }
          }, "JsdocTypeFunction"),
          JsdocTypeName: __name((result) => result.value, "JsdocTypeName"),
          JsdocTypeTuple: __name((result, transform2) => `[${result.elements.map(transform2).join(", ")}]`, "JsdocTypeTuple"),
          JsdocTypeVariadic: __name((result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."), "JsdocTypeVariadic"),
          JsdocTypeNamePath: __name((result, transform2) => {
            const left = transform2(result.left);
            const right = transform2(result.right);
            switch (result.pathType) {
              case "inner":
                return `${left}~${right}`;
              case "instance":
                return `${left}#${right}`;
              case "property":
                return `${left}.${right}`;
              case "property-brackets":
                return `${left}[${right}]`;
            }
          }, "JsdocTypeNamePath"),
          JsdocTypeStringValue: __name((result) => quote(result.value, result.meta.quote), "JsdocTypeStringValue"),
          JsdocTypeAny: __name(() => "*", "JsdocTypeAny"),
          JsdocTypeGeneric: __name((result, transform2) => {
            if (result.meta.brackets === "square") {
              const element = result.elements[0];
              const transformed = transform2(element);
              if (element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection") {
                return `(${transformed})[]`;
              } else {
                return `${transformed}[]`;
              }
            } else {
              return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === true ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
            }
          }, "JsdocTypeGeneric"),
          JsdocTypeImport: __name((result, transform2) => `import(${transform2(result.element)})`, "JsdocTypeImport"),
          JsdocTypeObjectField: __name((result, transform2) => {
            let text = "";
            if (result.readonly) {
              text += "readonly ";
            }
            if (typeof result.key === "string") {
              text += quote(result.key, result.meta.quote);
            } else {
              text += transform2(result.key);
            }
            if (result.optional) {
              text += "?";
            }
            if (result.right === void 0) {
              return text;
            } else {
              return text + `: ${transform2(result.right)}`;
            }
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: __name((result, transform2) => {
            return `${transform2(result.left)}: ${transform2(result.right)}`;
          }, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: __name((result, transform2) => {
            let text = result.key;
            if (result.optional) {
              text += "?";
            }
            if (result.variadic) {
              text = "..." + text;
            }
            if (result.right === void 0) {
              return text;
            } else {
              return text + `: ${transform2(result.right)}`;
            }
          }, "JsdocTypeKeyValue"),
          JsdocTypeSpecialNamePath: __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, "JsdocTypeSpecialNamePath"),
          JsdocTypeNotNullable: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"), "JsdocTypeNotNullable"),
          JsdocTypeNull: __name(() => "null", "JsdocTypeNull"),
          JsdocTypeNullable: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"), "JsdocTypeNullable"),
          JsdocTypeNumber: __name((result) => result.value.toString(), "JsdocTypeNumber"),
          JsdocTypeObject: __name((result, transform2) => {
            var _a, _b;
            return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? "\n" + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? "\n" + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? "\n" : "")}}`;
          }, "JsdocTypeObject"),
          JsdocTypeOptional: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="), "JsdocTypeOptional"),
          JsdocTypeSymbol: __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeSymbol"),
          JsdocTypeTypeof: __name((result, transform2) => `typeof ${transform2(result.element)}`, "JsdocTypeTypeof"),
          JsdocTypeUndefined: __name(() => "undefined", "JsdocTypeUndefined"),
          JsdocTypeUnion: __name((result, transform2) => result.elements.map(transform2).join(" | "), "JsdocTypeUnion"),
          JsdocTypeUnknown: __name(() => "?", "JsdocTypeUnknown"),
          JsdocTypeIntersection: __name((result, transform2) => result.elements.map(transform2).join(" & "), "JsdocTypeIntersection"),
          JsdocTypeProperty: __name((result) => quote(result.value, result.meta.quote), "JsdocTypeProperty"),
          JsdocTypePredicate: __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypePredicate"),
          JsdocTypeIndexSignature: __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, "JsdocTypeMappedType"),
          JsdocTypeAsserts: __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: __name((result, transform2) => `readonly ${transform2(result.element)}`, "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: __name((result, transform2) => `asserts ${transform2(result.element)}`, "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, "JsdocTypeConditional"),
          JsdocTypeTypeParameter: __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
        };
      }
      __name(stringifyRules2, "stringifyRules");
      const storedStringifyRules = stringifyRules2();
      function stringify22(result) {
        return transform(storedStringifyRules, result);
      }
      __name(stringify22, "stringify");
      const reservedWords = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function makeName(value) {
        const result = {
          type: "NameExpression",
          name: value
        };
        if (reservedWords.includes(value)) {
          result.reservedWord = true;
        }
        return result;
      }
      __name(makeName, "makeName");
      const catharsisTransformRules = {
        JsdocTypeOptional: __name((result, transform2) => {
          const transformed = transform2(result.element);
          transformed.optional = true;
          return transformed;
        }, "JsdocTypeOptional"),
        JsdocTypeNullable: __name((result, transform2) => {
          const transformed = transform2(result.element);
          transformed.nullable = true;
          return transformed;
        }, "JsdocTypeNullable"),
        JsdocTypeNotNullable: __name((result, transform2) => {
          const transformed = transform2(result.element);
          transformed.nullable = false;
          return transformed;
        }, "JsdocTypeNotNullable"),
        JsdocTypeVariadic: __name((result, transform2) => {
          if (result.element === void 0) {
            throw new Error("dots without value are not allowed in catharsis mode");
          }
          const transformed = transform2(result.element);
          transformed.repeatable = true;
          return transformed;
        }, "JsdocTypeVariadic"),
        JsdocTypeAny: __name(() => ({
          type: "AllLiteral"
        }), "JsdocTypeAny"),
        JsdocTypeNull: __name(() => ({
          type: "NullLiteral"
        }), "JsdocTypeNull"),
        JsdocTypeStringValue: __name((result) => makeName(quote(result.value, result.meta.quote)), "JsdocTypeStringValue"),
        JsdocTypeUndefined: __name(() => ({
          type: "UndefinedLiteral"
        }), "JsdocTypeUndefined"),
        JsdocTypeUnknown: __name(() => ({
          type: "UnknownLiteral"
        }), "JsdocTypeUnknown"),
        JsdocTypeFunction: __name((result, transform2) => {
          const params = extractSpecialParams(result);
          const transformed = {
            type: "FunctionType",
            params: params.params.map(transform2)
          };
          if (params.this !== void 0) {
            transformed.this = transform2(params.this);
          }
          if (params.new !== void 0) {
            transformed.new = transform2(params.new);
          }
          if (result.returnType !== void 0) {
            transformed.result = transform2(result.returnType);
          }
          return transformed;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: __name((result, transform2) => ({
          type: "TypeApplication",
          applications: result.elements.map((o) => transform2(o)),
          expression: transform2(result.left)
        }), "JsdocTypeGeneric"),
        JsdocTypeSpecialNamePath: __name((result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)), "JsdocTypeSpecialNamePath"),
        JsdocTypeName: __name((result) => {
          if (result.value !== "function") {
            return makeName(result.value);
          } else {
            return {
              type: "FunctionType",
              params: []
            };
          }
        }, "JsdocTypeName"),
        JsdocTypeNumber: __name((result) => makeName(result.value.toString()), "JsdocTypeNumber"),
        JsdocTypeObject: __name((result, transform2) => {
          const transformed = {
            type: "RecordType",
            fields: []
          };
          for (const field of result.elements) {
            if (field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField") {
              transformed.fields.push({
                type: "FieldType",
                key: transform2(field),
                value: void 0
              });
            } else {
              transformed.fields.push(transform2(field));
            }
          }
          return transformed;
        }, "JsdocTypeObject"),
        JsdocTypeObjectField: __name((result, transform2) => {
          if (typeof result.key !== "string") {
            throw new Error("Index signatures and mapped types are not supported");
          }
          return {
            type: "FieldType",
            key: makeName(quote(result.key, result.meta.quote)),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: __name((result, transform2) => ({
          type: "FieldType",
          key: transform2(result.left),
          value: transform2(result.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeUnion: __name((result, transform2) => ({
          type: "TypeUnion",
          elements: result.elements.map((e) => transform2(e))
        }), "JsdocTypeUnion"),
        JsdocTypeKeyValue: __name((result, transform2) => {
          return {
            type: "FieldType",
            key: makeName(result.key),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeNamePath: __name((result, transform2) => {
          const leftResult = transform2(result.left);
          let rightValue;
          if (result.right.type === "JsdocTypeSpecialNamePath") {
            rightValue = transform2(result.right).name;
          } else {
            rightValue = quote(result.right.value, result.right.meta.quote);
          }
          const joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
          return makeName(`${leftResult.name}${joiner}${rightValue}`);
        }, "JsdocTypeNamePath"),
        JsdocTypeSymbol: __name((result) => {
          let value = "";
          let element = result.element;
          let trailingDots = false;
          if ((element === null || element === void 0 ? void 0 : element.type) === "JsdocTypeVariadic") {
            if (element.meta.position === "prefix") {
              value = "...";
            } else {
              trailingDots = true;
            }
            element = element.element;
          }
          if ((element === null || element === void 0 ? void 0 : element.type) === "JsdocTypeName") {
            value += element.value;
          } else if ((element === null || element === void 0 ? void 0 : element.type) === "JsdocTypeNumber") {
            value += element.value.toString();
          }
          if (trailingDots) {
            value += "...";
          }
          return makeName(`${result.value}(${value})`);
        }, "JsdocTypeSymbol"),
        JsdocTypeParenthesis: __name((result, transform2) => transform2(assertRootResult(result.element)), "JsdocTypeParenthesis"),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
      }
      __name(catharsisTransform, "catharsisTransform");
      function getQuoteStyle(quote2) {
        switch (quote2) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      __name(getQuoteStyle, "getQuoteStyle");
      function getMemberType(type) {
        switch (type) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      __name(getMemberType, "getMemberType");
      function nestResults(type, results) {
        if (results.length === 2) {
          return {
            type,
            left: results[0],
            right: results[1]
          };
        } else {
          return {
            type,
            left: results[0],
            right: nestResults(type, results.slice(1))
          };
        }
      }
      __name(nestResults, "nestResults");
      const jtpRules = {
        JsdocTypeOptional: __name((result, transform2) => ({
          type: "OPTIONAL",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }), "JsdocTypeOptional"),
        JsdocTypeNullable: __name((result, transform2) => ({
          type: "NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }), "JsdocTypeNullable"),
        JsdocTypeNotNullable: __name((result, transform2) => ({
          type: "NOT_NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeVariadic: __name((result, transform2) => {
          const transformed = {
            type: "VARIADIC",
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          if (result.element !== void 0) {
            transformed.value = transform2(result.element);
          }
          return transformed;
        }, "JsdocTypeVariadic"),
        JsdocTypeName: __name((result) => ({
          type: "NAME",
          name: result.value
        }), "JsdocTypeName"),
        JsdocTypeTypeof: __name((result, transform2) => ({
          type: "TYPE_QUERY",
          name: transform2(result.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeTuple: __name((result, transform2) => ({
          type: "TUPLE",
          entries: result.elements.map(transform2)
        }), "JsdocTypeTuple"),
        JsdocTypeKeyof: __name((result, transform2) => ({
          type: "KEY_QUERY",
          value: transform2(result.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeImport: __name((result) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.element.meta.quote),
            string: result.element.value
          }
        }), "JsdocTypeImport"),
        JsdocTypeUndefined: __name(() => ({
          type: "NAME",
          name: "undefined"
        }), "JsdocTypeUndefined"),
        JsdocTypeAny: __name(() => ({
          type: "ANY"
        }), "JsdocTypeAny"),
        JsdocTypeFunction: __name((result, transform2) => {
          const specialParams = extractSpecialParams(result);
          const transformed = {
            type: result.arrow ? "ARROW" : "FUNCTION",
            params: specialParams.params.map((param) => {
              if (param.type === "JsdocTypeKeyValue") {
                if (param.right === void 0) {
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                }
                return {
                  type: "NAMED_PARAMETER",
                  name: param.key,
                  typeName: transform2(param.right)
                };
              } else {
                return transform2(param);
              }
            }),
            new: null,
            returns: null
          };
          if (specialParams.this !== void 0) {
            transformed.this = transform2(specialParams.this);
          } else if (!result.arrow) {
            transformed.this = null;
          }
          if (specialParams.new !== void 0) {
            transformed.new = transform2(specialParams.new);
          }
          if (result.returnType !== void 0) {
            transformed.returns = transform2(result.returnType);
          }
          return transformed;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: __name((result, transform2) => {
          const transformed = {
            type: "GENERIC",
            subject: transform2(result.left),
            objects: result.elements.map(transform2),
            meta: {
              syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          if (result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis) {
            transformed.objects[0] = {
              type: "NAME",
              name: "function"
            };
          }
          return transformed;
        }, "JsdocTypeGeneric"),
        JsdocTypeObjectField: __name((result, transform2) => {
          if (typeof result.key !== "string") {
            throw new Error("Index signatures and mapped types are not supported");
          }
          if (result.right === void 0) {
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: null,
              readonly: false
            };
          }
          let right = transform2(result.right);
          if (result.optional) {
            right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            };
          }
          return {
            type: "RECORD_ENTRY",
            key: result.key.toString(),
            quoteStyle: getQuoteStyle(result.meta.quote),
            value: right,
            readonly: false
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: __name(() => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        }, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: __name((result, transform2) => {
          if (result.right === void 0) {
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: null,
              readonly: false
            };
          }
          let right = transform2(result.right);
          if (result.optional) {
            right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            };
          }
          return {
            type: "RECORD_ENTRY",
            key: result.key,
            quoteStyle: "none",
            value: right,
            readonly: false
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeObject: __name((result, transform2) => {
          const entries = [];
          for (const field of result.elements) {
            if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") {
              entries.push(transform2(field));
            }
          }
          return {
            type: "RECORD",
            entries
          };
        }, "JsdocTypeObject"),
        JsdocTypeSpecialNamePath: __name((result) => {
          if (result.specialType !== "module") {
            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
          }
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: getQuoteStyle(result.meta.quote),
              path: result.value
            }
          };
        }, "JsdocTypeSpecialNamePath"),
        JsdocTypeNamePath: __name((result, transform2) => {
          let hasEventPrefix = false;
          let name;
          let quoteStyle;
          if (result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event") {
            hasEventPrefix = true;
            name = result.right.value;
            quoteStyle = getQuoteStyle(result.right.meta.quote);
          } else {
            name = result.right.value;
            quoteStyle = getQuoteStyle(result.right.meta.quote);
          }
          const transformed = {
            type: getMemberType(result.pathType),
            owner: transform2(result.left),
            name,
            quoteStyle,
            hasEventPrefix
          };
          if (transformed.owner.type === "MODULE") {
            const tModule = transformed.owner;
            transformed.owner = transformed.owner.value;
            tModule.value = transformed;
            return tModule;
          } else {
            return transformed;
          }
        }, "JsdocTypeNamePath"),
        JsdocTypeUnion: __name((result, transform2) => nestResults("UNION", result.elements.map(transform2)), "JsdocTypeUnion"),
        JsdocTypeParenthesis: __name((result, transform2) => ({
          type: "PARENTHESIS",
          value: transform2(assertRootResult(result.element))
        }), "JsdocTypeParenthesis"),
        JsdocTypeNull: __name(() => ({
          type: "NAME",
          name: "null"
        }), "JsdocTypeNull"),
        JsdocTypeUnknown: __name(() => ({
          type: "UNKNOWN"
        }), "JsdocTypeUnknown"),
        JsdocTypeStringValue: __name((result) => ({
          type: "STRING_VALUE",
          quoteStyle: getQuoteStyle(result.meta.quote),
          string: result.value
        }), "JsdocTypeStringValue"),
        JsdocTypeIntersection: __name((result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)), "JsdocTypeIntersection"),
        JsdocTypeNumber: __name((result) => ({
          type: "NUMBER_VALUE",
          number: result.value.toString()
        }), "JsdocTypeNumber"),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function jtpTransform(result) {
        return transform(jtpRules, result);
      }
      __name(jtpTransform, "jtpTransform");
      function identityTransformRules() {
        return {
          JsdocTypeIntersection: __name((result, transform2) => ({
            type: "JsdocTypeIntersection",
            elements: result.elements.map(transform2)
          }), "JsdocTypeIntersection"),
          JsdocTypeGeneric: __name((result, transform2) => ({
            type: "JsdocTypeGeneric",
            left: transform2(result.left),
            elements: result.elements.map(transform2),
            meta: {
              dot: result.meta.dot,
              brackets: result.meta.brackets
            }
          }), "JsdocTypeGeneric"),
          JsdocTypeNullable: __name((result) => result, "JsdocTypeNullable"),
          JsdocTypeUnion: __name((result, transform2) => ({
            type: "JsdocTypeUnion",
            elements: result.elements.map(transform2)
          }), "JsdocTypeUnion"),
          JsdocTypeUnknown: __name((result) => result, "JsdocTypeUnknown"),
          JsdocTypeUndefined: __name((result) => result, "JsdocTypeUndefined"),
          JsdocTypeTypeof: __name((result, transform2) => ({
            type: "JsdocTypeTypeof",
            element: transform2(result.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeSymbol: __name((result, transform2) => {
            const transformed = {
              type: "JsdocTypeSymbol",
              value: result.value
            };
            if (result.element !== void 0) {
              transformed.element = transform2(result.element);
            }
            return transformed;
          }, "JsdocTypeSymbol"),
          JsdocTypeOptional: __name((result, transform2) => ({
            type: "JsdocTypeOptional",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }), "JsdocTypeOptional"),
          JsdocTypeObject: __name((result, transform2) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: result.elements.map(transform2)
          }), "JsdocTypeObject"),
          JsdocTypeNumber: __name((result) => result, "JsdocTypeNumber"),
          JsdocTypeNull: __name((result) => result, "JsdocTypeNull"),
          JsdocTypeNotNullable: __name((result, transform2) => ({
            type: "JsdocTypeNotNullable",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeSpecialNamePath: __name((result) => result, "JsdocTypeSpecialNamePath"),
          JsdocTypeObjectField: __name((result, transform2) => ({
            type: "JsdocTypeObjectField",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            readonly: result.readonly,
            meta: result.meta
          }), "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: __name((result, transform2) => ({
            type: "JsdocTypeJsdocObjectField",
            left: transform2(result.left),
            right: transform2(result.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: __name((result, transform2) => {
            return {
              type: "JsdocTypeKeyValue",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              variadic: result.variadic
            };
          }, "JsdocTypeKeyValue"),
          JsdocTypeImport: __name((result, transform2) => ({
            type: "JsdocTypeImport",
            element: transform2(result.element)
          }), "JsdocTypeImport"),
          JsdocTypeAny: __name((result) => result, "JsdocTypeAny"),
          JsdocTypeStringValue: __name((result) => result, "JsdocTypeStringValue"),
          JsdocTypeNamePath: __name((result) => result, "JsdocTypeNamePath"),
          JsdocTypeVariadic: __name((result, transform2) => {
            const transformed = {
              type: "JsdocTypeVariadic",
              meta: {
                position: result.meta.position,
                squareBrackets: result.meta.squareBrackets
              }
            };
            if (result.element !== void 0) {
              transformed.element = transform2(result.element);
            }
            return transformed;
          }, "JsdocTypeVariadic"),
          JsdocTypeTuple: __name((result, transform2) => ({
            type: "JsdocTypeTuple",
            elements: result.elements.map(transform2)
          }), "JsdocTypeTuple"),
          JsdocTypeName: __name((result) => result, "JsdocTypeName"),
          JsdocTypeFunction: __name((result, transform2) => {
            const transformed = {
              type: "JsdocTypeFunction",
              arrow: result.arrow,
              parameters: result.parameters.map(transform2),
              constructor: result.constructor,
              parenthesis: result.parenthesis
            };
            if (result.returnType !== void 0) {
              transformed.returnType = transform2(result.returnType);
            }
            return transformed;
          }, "JsdocTypeFunction"),
          JsdocTypeKeyof: __name((result, transform2) => ({
            type: "JsdocTypeKeyof",
            element: transform2(result.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeParenthesis: __name((result, transform2) => ({
            type: "JsdocTypeParenthesis",
            element: transform2(result.element)
          }), "JsdocTypeParenthesis"),
          JsdocTypeProperty: __name((result) => result, "JsdocTypeProperty"),
          JsdocTypePredicate: __name((result, transform2) => ({
            type: "JsdocTypePredicate",
            left: transform2(result.left),
            right: transform2(result.right)
          }), "JsdocTypePredicate"),
          JsdocTypeIndexSignature: __name((result, transform2) => ({
            type: "JsdocTypeIndexSignature",
            key: result.key,
            right: transform2(result.right)
          }), "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: __name((result, transform2) => ({
            type: "JsdocTypeMappedType",
            key: result.key,
            right: transform2(result.right)
          }), "JsdocTypeMappedType"),
          JsdocTypeAsserts: __name((result, transform2) => ({
            type: "JsdocTypeAsserts",
            left: transform2(result.left),
            right: transform2(result.right)
          }), "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: __name((result, transform2) => ({
            type: "JsdocTypeReadonlyArray",
            element: transform2(result.element)
          }), "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: __name((result, transform2) => ({
            type: "JsdocTypeAssertsPlain",
            element: transform2(result.element)
          }), "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: __name((result, transform2) => ({
            type: "JsdocTypeConditional",
            checksType: transform2(result.checksType),
            extendsType: transform2(result.extendsType),
            trueType: transform2(result.trueType),
            falseType: transform2(result.falseType)
          }), "JsdocTypeConditional"),
          JsdocTypeTypeParameter: __name((result, transform2) => ({
            type: "JsdocTypeTypeParameter",
            name: transform2(result.name),
            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
          }), "JsdocTypeTypeParameter")
        };
      }
      __name(identityTransformRules, "identityTransformRules");
      const visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);
        const keysToVisit = visitorKeys[node.type];
        for (const key of keysToVisit) {
          const value = node[key];
          if (value !== void 0) {
            if (Array.isArray(value)) {
              for (const element of value) {
                _traverse(element, node, key, onEnter, onLeave);
              }
            } else {
              _traverse(value, node, key, onEnter, onLeave);
            }
          }
        }
        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);
      }
      __name(_traverse, "_traverse");
      function traverse(node, onEnter, onLeave) {
        _traverse(node, void 0, void 0, onEnter, onLeave);
      }
      __name(traverse, "traverse");
      exports2.catharsisTransform = catharsisTransform;
      exports2.identityTransformRules = identityTransformRules;
      exports2.jtpTransform = jtpTransform;
      exports2.parse = parse3;
      exports2.stringify = stringify22;
      exports2.stringifyRules = stringifyRules2;
      exports2.transform = transform;
      exports2.traverse = traverse;
      exports2.tryParse = tryParse;
      exports2.visitorKeys = visitorKeys;
    });
  }
});
var isLiteral = __name((type) => type.name === "literal", "isLiteral");
var toEnumOption = __name((element) => element.value.replace(/['|"]/g, ""), "toEnumOption");
var convertSig = __name((type) => {
  switch (type.type) {
    case "function":
      return { name: "function" };
    case "object":
      const values = {};
      type.signature.properties.forEach((prop) => {
        values[prop.key] = convert(prop.value);
      });
      return {
        name: "object",
        value: values
      };
    default:
      throw new import_preview_errors.UnknownArgTypesError({ type, language: "Flow" });
  }
}, "convertSig");
var convert = __name((type) => {
  const { name, raw } = type;
  const base = {};
  if (typeof raw !== "undefined") {
    base.raw = raw;
  }
  switch (type.name) {
    case "literal":
      return { ...base, name: "other", value: type.value };
    case "string":
    case "number":
    case "symbol":
    case "boolean": {
      return { ...base, name };
    }
    case "Array": {
      return { ...base, name: "array", value: type.elements.map(convert) };
    }
    case "signature":
      return { ...base, ...convertSig(type) };
    case "union":
      if (type.elements?.every(isLiteral)) {
        return { ...base, name: "enum", value: type.elements?.map(toEnumOption) };
      }
      return { ...base, name, value: type.elements?.map(convert) };
    case "intersection":
      return { ...base, name, value: type.elements?.map(convert) };
    default:
      return { ...base, name: "other", value: name };
  }
}, "convert");
var QUOTE_REGEX = /^['"]|['"]$/g;
var trimQuotes = __name((str2) => str2.replace(QUOTE_REGEX, ""), "trimQuotes");
var includesQuotes = __name((str2) => QUOTE_REGEX.test(str2), "includesQuotes");
var parseLiteral = __name((str2) => {
  const trimmedValue = trimQuotes(str2);
  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);
}, "parseLiteral");
var SIGNATURE_REGEXP = /^\(.*\) => /;
var convert2 = __name((type) => {
  const { name, raw, computed, value } = type;
  const base = {};
  if (typeof raw !== "undefined") {
    base.raw = raw;
  }
  switch (name) {
    case "enum": {
      const values2 = computed ? value : value.map((v) => parseLiteral(v.value));
      return { ...base, name, value: values2 };
    }
    case "string":
    case "number":
    case "symbol":
      return { ...base, name };
    case "func":
      return { ...base, name: "function" };
    case "bool":
    case "boolean":
      return { ...base, name: "boolean" };
    case "arrayOf":
    case "array":
      return { ...base, name: "array", value: value && convert2(value) };
    case "object":
      return { ...base, name };
    case "objectOf":
      return { ...base, name, value: convert2(value) };
    case "shape":
    case "exact":
      const values = mapValues(value, (field) => convert2(field));
      return { ...base, name: "object", value: values };
    case "union":
      return { ...base, name: "union", value: value.map((v) => convert2(v)) };
    case "instanceOf":
    case "element":
    case "elementType":
    default: {
      if (name?.indexOf("|") > 0) {
        try {
          const literalValues = name.split("|").map((v) => JSON.parse(v));
          return { ...base, name: "enum", value: literalValues };
        } catch (err) {
        }
      }
      const otherVal = value ? `${name}(${value})` : name;
      const otherName = SIGNATURE_REGEXP.test(name) ? "function" : "other";
      return { ...base, name: otherName, value: otherVal };
    }
  }
}, "convert");
var convertSig2 = __name((type) => {
  switch (type.type) {
    case "function":
      return { name: "function" };
    case "object":
      const values = {};
      type.signature.properties.forEach((prop) => {
        values[prop.key] = convert3(prop.value);
      });
      return {
        name: "object",
        value: values
      };
    default:
      throw new import_preview_errors2.UnknownArgTypesError({ type, language: "Typescript" });
  }
}, "convertSig");
var convert3 = __name((type) => {
  const { name, raw } = type;
  const base = {};
  if (typeof raw !== "undefined") {
    base.raw = raw;
  }
  switch (type.name) {
    case "string":
    case "number":
    case "symbol":
    case "boolean": {
      return { ...base, name };
    }
    case "Array": {
      return { ...base, name: "array", value: type.elements.map(convert3) };
    }
    case "signature":
      return { ...base, ...convertSig2(type) };
    case "union":
      let result;
      if (type.elements?.every((element) => element.name === "literal")) {
        result = {
          ...base,
          name: "enum",
          // @ts-expect-error fix types
          value: type.elements?.map((v) => parseLiteral(v.value))
        };
      } else {
        result = { ...base, name, value: type.elements?.map(convert3) };
      }
      return result;
    case "intersection":
      return { ...base, name, value: type.elements?.map(convert3) };
    default:
      return { ...base, name: "other", value: name };
  }
}, "convert");
var convert4 = __name((docgenInfo) => {
  const { type, tsType, flowType } = docgenInfo;
  try {
    if (type != null) {
      return convert2(type);
    }
    if (tsType != null) {
      return convert3(tsType);
    }
    if (flowType != null) {
      return convert(flowType);
    }
  } catch (err) {
    console.error(err);
  }
  return null;
}, "convert");
var TypeSystem = ((TypeSystem2) => {
  TypeSystem2["JAVASCRIPT"] = "JavaScript";
  TypeSystem2["FLOW"] = "Flow";
  TypeSystem2["TYPESCRIPT"] = "TypeScript";
  TypeSystem2["UNKNOWN"] = "Unknown";
  return TypeSystem2;
})(TypeSystem || {});
var BLACKLIST = ["null", "undefined"];
function isDefaultValueBlacklisted(value) {
  return BLACKLIST.some((x) => x === value);
}
__name(isDefaultValueBlacklisted, "isDefaultValueBlacklisted");
var str = __name((obj) => {
  if (!obj) {
    return "";
  }
  if (typeof obj === "string") {
    return obj;
  }
  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);
}, "str");
function hasDocgen(component) {
  return !!component.__docgenInfo;
}
__name(hasDocgen, "hasDocgen");
function isValidDocgenSection(docgenSection) {
  return docgenSection != null && Object.keys(docgenSection).length > 0;
}
__name(isValidDocgenSection, "isValidDocgenSection");
function getDocgenSection(component, section) {
  return hasDocgen(component) ? component.__docgenInfo[section] : null;
}
__name(getDocgenSection, "getDocgenSection");
function getDocgenDescription(component) {
  return hasDocgen(component) ? str(component.__docgenInfo.description) : "";
}
__name(getDocgenDescription, "getDocgenDescription");
var Markers;
(function(Markers2) {
  Markers2["start"] = "/**";
  Markers2["nostart"] = "/***";
  Markers2["delim"] = "*";
  Markers2["end"] = "*/";
})(Markers = Markers || (Markers = {}));
function isSpace(source) {
  return /^\s+$/.test(source);
}
__name(isSpace, "isSpace");
function splitCR(source) {
  const matches3 = source.match(/\r+$/);
  return matches3 == null ? ["", source] : [source.slice(-matches3[0].length), source.slice(0, -matches3[0].length)];
}
__name(splitCR, "splitCR");
function splitSpace(source) {
  const matches3 = source.match(/^\s+/);
  return matches3 == null ? ["", source] : [source.slice(0, matches3[0].length), source.slice(matches3[0].length)];
}
__name(splitSpace, "splitSpace");
function splitLines(source) {
  return source.split(/\n/);
}
__name(splitLines, "splitLines");
function seedSpec(spec = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: false, description: "", problems: [], source: [] }, spec);
}
__name(seedSpec, "seedSpec");
function seedTokens(tokens = {}) {
  return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, tokens);
}
__name(seedTokens, "seedTokens");
var reTag = /^@\S+/;
function getParser({ fence = "```" } = {}) {
  const fencer = getFencer(fence);
  const toggleFence = __name((source, isFenced) => fencer(source) ? !isFenced : isFenced, "toggleFence");
  return __name(function parseBlock(source) {
    const sections = [[]];
    let isFenced = false;
    for (const line of source) {
      if (reTag.test(line.tokens.description) && !isFenced) {
        sections.push([line]);
      } else {
        sections[sections.length - 1].push(line);
      }
      isFenced = toggleFence(line.tokens.description, isFenced);
    }
    return sections;
  }, "parseBlock");
}
__name(getParser, "getParser");
function getFencer(fence) {
  if (typeof fence === "string")
    return (source) => source.split(fence).length % 2 === 0;
  return fence;
}
__name(getFencer, "getFencer");
function getParser2({ startLine = 0, markers = Markers } = {}) {
  let block = null;
  let num = startLine;
  return __name(function parseSource(source) {
    let rest = source;
    const tokens = seedTokens();
    [tokens.lineEnd, rest] = splitCR(rest);
    [tokens.start, rest] = splitSpace(rest);
    if (block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart)) {
      block = [];
      tokens.delimiter = rest.slice(0, markers.start.length);
      rest = rest.slice(markers.start.length);
      [tokens.postDelimiter, rest] = splitSpace(rest);
    }
    if (block === null) {
      num++;
      return null;
    }
    const isClosed = rest.trimRight().endsWith(markers.end);
    if (tokens.delimiter === "" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end)) {
      tokens.delimiter = markers.delim;
      rest = rest.slice(markers.delim.length);
      [tokens.postDelimiter, rest] = splitSpace(rest);
    }
    if (isClosed) {
      const trimmed = rest.trimRight();
      tokens.end = rest.slice(trimmed.length - markers.end.length);
      rest = trimmed.slice(0, -markers.end.length);
    }
    tokens.description = rest;
    block.push({ number: num, source, tokens });
    num++;
    if (isClosed) {
      const result = block.slice();
      block = null;
      return result;
    }
    return null;
  }, "parseSource");
}
__name(getParser2, "getParser");
function getParser3({ tokenizers }) {
  return __name(function parseSpec(source) {
    var _a;
    let spec = seedSpec({ source });
    for (const tokenize of tokenizers) {
      spec = tokenize(spec);
      if ((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0 ? void 0 : _a.critical)
        break;
    }
    return spec;
  }, "parseSpec");
}
__name(getParser3, "getParser");
function tagTokenizer() {
  return (spec) => {
    const { tokens } = spec.source[0];
    const match = tokens.description.match(/\s*(@(\S+))(\s*)/);
    if (match === null) {
      spec.problems.push({
        code: "spec:tag:prefix",
        message: 'tag should start with "@" symbol',
        line: spec.source[0].number,
        critical: true
      });
      return spec;
    }
    tokens.tag = match[1];
    tokens.postTag = match[3];
    tokens.description = tokens.description.slice(match[0].length);
    spec.tag = match[2];
    return spec;
  };
}
__name(tagTokenizer, "tagTokenizer");
function typeTokenizer(spacing = "compact") {
  const join2 = getJoiner(spacing);
  return (spec) => {
    let curlies = 0;
    let lines = [];
    for (const [i, { tokens }] of spec.source.entries()) {
      let type = "";
      if (i === 0 && tokens.description[0] !== "{")
        return spec;
      for (const ch of tokens.description) {
        if (ch === "{")
          curlies++;
        if (ch === "}")
          curlies--;
        type += ch;
        if (curlies === 0)
          break;
      }
      lines.push([tokens, type]);
      if (curlies === 0)
        break;
    }
    if (curlies !== 0) {
      spec.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: spec.source[0].number,
        critical: true
      });
      return spec;
    }
    const parts = [];
    const offset2 = lines[0][0].postDelimiter.length;
    for (const [i, [tokens, type]] of lines.entries()) {
      tokens.type = type;
      if (i > 0) {
        tokens.type = tokens.postDelimiter.slice(offset2) + type;
        tokens.postDelimiter = tokens.postDelimiter.slice(0, offset2);
      }
      [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length));
      parts.push(tokens.type);
    }
    parts[0] = parts[0].slice(1);
    parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1);
    spec.type = join2(parts);
    return spec;
  };
}
__name(typeTokenizer, "typeTokenizer");
var trim = __name((x) => x.trim(), "trim");
function getJoiner(spacing) {
  if (spacing === "compact")
    return (t) => t.map(trim).join("");
  else if (spacing === "preserve")
    return (t) => t.join("\n");
  else
    return spacing;
}
__name(getJoiner, "getJoiner");
var isQuoted = __name((s2) => s2 && s2.startsWith('"') && s2.endsWith('"'), "isQuoted");
function nameTokenizer() {
  const typeEnd = __name((num, { tokens }, i) => tokens.type === "" ? num : i, "typeEnd");
  return (spec) => {
    const { tokens } = spec.source[spec.source.reduce(typeEnd, 0)];
    const source = tokens.description.trimLeft();
    const quotedGroups = source.split('"');
    if (quotedGroups.length > 1 && quotedGroups[0] === "" && quotedGroups.length % 2 === 1) {
      spec.name = quotedGroups[1];
      tokens.name = `"${quotedGroups[1]}"`;
      [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));
      return spec;
    }
    let brackets = 0;
    let name = "";
    let optional = false;
    let defaultValue;
    for (const ch of source) {
      if (brackets === 0 && isSpace(ch))
        break;
      if (ch === "[")
        brackets++;
      if (ch === "]")
        brackets--;
      name += ch;
    }
    if (brackets !== 0) {
      spec.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: spec.source[0].number,
        critical: true
      });
      return spec;
    }
    const nameToken = name;
    if (name[0] === "[" && name[name.length - 1] === "]") {
      optional = true;
      name = name.slice(1, -1);
      const parts = name.split("=");
      name = parts[0].trim();
      if (parts[1] !== void 0)
        defaultValue = parts.slice(1).join("=").trim();
      if (name === "") {
        spec.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: spec.source[0].number,
          critical: true
        });
        return spec;
      }
      if (defaultValue === "") {
        spec.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: spec.source[0].number,
          critical: true
        });
        return spec;
      }
      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue)) {
        spec.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: spec.source[0].number,
          critical: true
        });
        return spec;
      }
    }
    spec.optional = optional;
    spec.name = name;
    tokens.name = nameToken;
    if (defaultValue !== void 0)
      spec.default = defaultValue;
    [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));
    return spec;
  };
}
__name(nameTokenizer, "nameTokenizer");
function descriptionTokenizer(spacing = "compact", markers = Markers) {
  const join2 = getJoiner2(spacing);
  return (spec) => {
    spec.description = join2(spec.source, markers);
    return spec;
  };
}
__name(descriptionTokenizer, "descriptionTokenizer");
function getJoiner2(spacing) {
  if (spacing === "compact")
    return compactJoiner;
  if (spacing === "preserve")
    return preserveJoiner;
  return spacing;
}
__name(getJoiner2, "getJoiner");
function compactJoiner(lines, markers = Markers) {
  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== "").join(" ");
}
__name(compactJoiner, "compactJoiner");
var lineNo = __name((num, { tokens }, i) => tokens.type === "" ? num : i, "lineNo");
var getDescription = __name(({ tokens }) => (tokens.delimiter === "" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, "getDescription");
function preserveJoiner(lines, markers = Markers) {
  if (lines.length === 0)
    return "";
  if (lines[0].tokens.description === "" && lines[0].tokens.delimiter === markers.start)
    lines = lines.slice(1);
  const lastLine = lines[lines.length - 1];
  if (lastLine !== void 0 && lastLine.tokens.description === "" && lastLine.tokens.end.endsWith(markers.end))
    lines = lines.slice(0, -1);
  lines = lines.slice(lines.reduce(lineNo, 0));
  return lines.map(getDescription).join("\n");
}
__name(preserveJoiner, "preserveJoiner");
function getParser4({ startLine = 0, fence = "```", spacing = "compact", markers = Markers, tokenizers = [
  tagTokenizer(),
  typeTokenizer(spacing),
  nameTokenizer(),
  descriptionTokenizer(spacing)
] } = {}) {
  if (startLine < 0 || startLine % 1 > 0)
    throw new Error("Invalid startLine");
  const parseSource = getParser2({ startLine, markers });
  const parseBlock = getParser({ fence });
  const parseSpec = getParser3({ tokenizers });
  const joinDescription = getJoiner2(spacing);
  return function(source) {
    const blocks = [];
    for (const line of splitLines(source)) {
      const lines = parseSource(line);
      if (lines === null)
        continue;
      const sections = parseBlock(lines);
      const specs = sections.slice(1).map(parseSpec);
      blocks.push({
        description: joinDescription(sections[0], markers),
        tags: specs,
        source: lines,
        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])
      });
    }
    return blocks;
  };
}
__name(getParser4, "getParser");
function join(tokens) {
  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;
}
__name(join, "join");
function getStringifier() {
  return (block) => block.source.map(({ tokens }) => join(tokens)).join("\n");
}
__name(getStringifier, "getStringifier");
var zeroWidth = {
  line: 0,
  start: 0,
  delimiter: 0,
  postDelimiter: 0,
  tag: 0,
  postTag: 0,
  name: 0,
  postName: 0,
  type: 0,
  postType: 0,
  description: 0,
  end: 0,
  lineEnd: 0
};
var fields = Object.keys(zeroWidth);
function parse(source, options = {}) {
  return getParser4(options)(source);
}
__name(parse, "parse");
var stringify = getStringifier();
var import_jsdoc_type_pratt_parser = __toESM2(require_dist(), 1);
function containsJsDoc(value) {
  return value != null && value.includes("@");
}
__name(containsJsDoc, "containsJsDoc");
function parse2(content) {
  const contentString = content ?? "";
  const mappedLines = contentString.split("\n").map((line) => ` * ${line}`).join("\n");
  const normalisedContent = "/**\n" + mappedLines + "\n*/";
  const ast = parse(normalisedContent, {
    spacing: "preserve"
  });
  if (!ast || ast.length === 0) {
    throw new Error("Cannot parse JSDoc tags.");
  }
  return ast[0];
}
__name(parse2, "parse");
var DEFAULT_OPTIONS = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
};
var parseJsDoc = __name((value, options = DEFAULT_OPTIONS) => {
  if (!containsJsDoc(value)) {
    return {
      includesJsDoc: false,
      ignore: false
    };
  }
  const jsDocAst = parse2(value);
  const extractedTags = extractJsDocTags(jsDocAst, options.tags);
  if (extractedTags.ignore) {
    return {
      includesJsDoc: true,
      ignore: true
    };
  }
  return {
    includesJsDoc: true,
    ignore: false,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: jsDocAst.description.trim(),
    extractedTags
  };
}, "parseJsDoc");
function extractJsDocTags(ast, tags) {
  const extractedTags = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: false
  };
  for (const tagSpec of ast.tags) {
    if (tags !== void 0 && !tags.includes(tagSpec.tag)) {
      continue;
    }
    if (tagSpec.tag === "ignore") {
      extractedTags.ignore = true;
      break;
    } else {
      switch (tagSpec.tag) {
        // arg & argument are aliases for param.
        case "param":
        case "arg":
        case "argument": {
          const paramTag = extractParam(tagSpec);
          if (paramTag != null) {
            if (extractedTags.params == null) {
              extractedTags.params = [];
            }
            extractedTags.params.push(paramTag);
          }
          break;
        }
        case "deprecated": {
          const deprecatedTag = extractDeprecated(tagSpec);
          if (deprecatedTag != null) {
            extractedTags.deprecated = deprecatedTag;
          }
          break;
        }
        case "returns": {
          const returnsTag = extractReturns(tagSpec);
          if (returnsTag != null) {
            extractedTags.returns = returnsTag;
          }
          break;
        }
        default:
          break;
      }
    }
  }
  return extractedTags;
}
__name(extractJsDocTags, "extractJsDocTags");
function normaliseParamName(name) {
  return name.replace(/[\.-]$/, "");
}
__name(normaliseParamName, "normaliseParamName");
function extractParam(tag) {
  if (!tag.name || tag.name === "-") {
    return null;
  }
  const type = extractType(tag.type);
  return {
    name: tag.name,
    type,
    description: normaliseDescription(tag.description),
    getPrettyName: __name(() => {
      return normaliseParamName(tag.name);
    }, "getPrettyName"),
    getTypeName: __name(() => {
      return type ? extractTypeName(type) : null;
    }, "getTypeName")
  };
}
__name(extractParam, "extractParam");
function extractDeprecated(tag) {
  if (tag.name) {
    return joinNameAndDescription(tag.name, tag.description);
  }
  return null;
}
__name(extractDeprecated, "extractDeprecated");
function joinNameAndDescription(name, desc) {
  const joined = name === "" ? desc : `${name} ${desc}`;
  return normaliseDescription(joined);
}
__name(joinNameAndDescription, "joinNameAndDescription");
function normaliseDescription(text) {
  const normalised = text.replace(/^- /g, "").trim();
  return normalised === "" ? null : normalised;
}
__name(normaliseDescription, "normaliseDescription");
function extractReturns(tag) {
  const type = extractType(tag.type);
  if (type) {
    return {
      type,
      description: joinNameAndDescription(tag.name, tag.description),
      getTypeName: __name(() => {
        return extractTypeName(type);
      }, "getTypeName")
    };
  }
  return null;
}
__name(extractReturns, "extractReturns");
var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();
var originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
jsdocStringifyRules.JsdocTypeAny = () => "any";
jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
function extractType(typeString) {
  try {
    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, "typescript");
  } catch (_err) {
    return null;
  }
}
__name(extractType, "extractType");
function extractTypeName(type) {
  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);
}
__name(extractTypeName, "extractTypeName");
var MAX_TYPE_SUMMARY_LENGTH = 90;
var MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;
function isTooLongForTypeSummary(value) {
  return value.length > MAX_TYPE_SUMMARY_LENGTH;
}
__name(isTooLongForTypeSummary, "isTooLongForTypeSummary");
function isTooLongForDefaultValueSummary(value) {
  return value.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;
}
__name(isTooLongForDefaultValueSummary, "isTooLongForDefaultValueSummary");
function createSummaryValue(summary, detail) {
  if (summary === detail) {
    return { summary };
  }
  return { summary, detail };
}
__name(createSummaryValue, "createSummaryValue");
var normalizeNewlines = __name((string) => string.replace(/\\r\\n/g, "\\n"), "normalizeNewlines");
function createDefaultValue(defaultValue, type) {
  if (defaultValue != null) {
    const { value } = defaultValue;
    if (!isDefaultValueBlacklisted(value)) {
      return !isTooLongForDefaultValueSummary(value) ? createSummaryValue(value) : createSummaryValue(type?.name, value);
    }
  }
  return null;
}
__name(createDefaultValue, "createDefaultValue");
function generateUnionElement({ name, value, elements, raw }) {
  if (value != null) {
    return value;
  }
  if (elements != null) {
    return elements.map(generateUnionElement).join(" | ");
  }
  if (raw != null) {
    return raw;
  }
  return name;
}
__name(generateUnionElement, "generateUnionElement");
function generateUnion({ name, raw, elements }) {
  if (elements != null) {
    return createSummaryValue(elements.map(generateUnionElement).join(" | "));
  }
  if (raw != null) {
    return createSummaryValue(raw.replace(/^\|\s*/, ""));
  }
  return createSummaryValue(name);
}
__name(generateUnion, "generateUnion");
function generateFuncSignature({ type, raw }) {
  if (raw != null) {
    return createSummaryValue(raw);
  }
  return createSummaryValue(type);
}
__name(generateFuncSignature, "generateFuncSignature");
function generateObjectSignature({ type, raw }) {
  if (raw != null) {
    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(type, raw);
  }
  return createSummaryValue(type);
}
__name(generateObjectSignature, "generateObjectSignature");
function generateSignature(flowType) {
  const { type } = flowType;
  return type === "object" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);
}
__name(generateSignature, "generateSignature");
function generateDefault({ name, raw }) {
  if (raw != null) {
    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(name, raw);
  }
  return createSummaryValue(name);
}
__name(generateDefault, "generateDefault");
function createType(type) {
  if (type == null) {
    return null;
  }
  switch (type.name) {
    case "union":
      return generateUnion(type);
    case "signature":
      return generateSignature(type);
    default:
      return generateDefault(type);
  }
}
__name(createType, "createType");
var createFlowPropDef = __name((propName, docgenInfo) => {
  const { flowType, description, required, defaultValue } = docgenInfo;
  return {
    name: propName,
    type: createType(flowType),
    required,
    description,
    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)
  };
}, "createFlowPropDef");
function createDefaultValue2({ defaultValue }) {
  if (defaultValue != null) {
    const { value } = defaultValue;
    if (!isDefaultValueBlacklisted(value)) {
      return createSummaryValue(value);
    }
  }
  return null;
}
__name(createDefaultValue2, "createDefaultValue");
function createType2({ tsType, required }) {
  if (tsType == null) {
    return null;
  }
  let typeName = tsType.name;
  if (!required) {
    typeName = typeName.replace(" | undefined", "");
  }
  return createSummaryValue(
    ["Array", "Record", "signature"].includes(tsType.name) ? tsType.raw : typeName
  );
}
__name(createType2, "createType");
var createTsPropDef = __name((propName, docgenInfo) => {
  const { description, required } = docgenInfo;
  return {
    name: propName,
    type: createType2(docgenInfo),
    required,
    description,
    defaultValue: createDefaultValue2(docgenInfo)
  };
}, "createTsPropDef");
function createType3(type) {
  return type != null ? createSummaryValue(type.name) : null;
}
__name(createType3, "createType");
function isReactDocgenTypescript(defaultValue) {
  const { computed, func } = defaultValue;
  return typeof computed === "undefined" && typeof func === "undefined";
}
__name(isReactDocgenTypescript, "isReactDocgenTypescript");
function isStringValued(type) {
  if (!type) {
    return false;
  }
  if (type.name === "string") {
    return true;
  }
  if (type.name === "enum") {
    return Array.isArray(type.value) && type.value.every(
      ({ value: tv }) => typeof tv === "string" && tv[0] === '"' && tv[tv.length - 1] === '"'
    );
  }
  return false;
}
__name(isStringValued, "isStringValued");
function createDefaultValue3(defaultValue, type) {
  if (defaultValue != null) {
    const { value } = defaultValue;
    if (!isDefaultValueBlacklisted(value)) {
      if (isReactDocgenTypescript(defaultValue) && isStringValued(type)) {
        return createSummaryValue(JSON.stringify(value));
      }
      return createSummaryValue(value);
    }
  }
  return null;
}
__name(createDefaultValue3, "createDefaultValue");
function createBasicPropDef(name, type, docgenInfo) {
  const { description, required, defaultValue } = docgenInfo;
  return {
    name,
    type: createType3(type),
    required,
    description,
    defaultValue: createDefaultValue3(defaultValue, type)
  };
}
__name(createBasicPropDef, "createBasicPropDef");
function applyJsDocResult(propDef, jsDocParsingResult) {
  if (jsDocParsingResult?.includesJsDoc) {
    const { description, extractedTags } = jsDocParsingResult;
    if (description != null) {
      propDef.description = jsDocParsingResult.description;
    }
    const value = {
      ...extractedTags,
      params: extractedTags?.params?.map(
        (x) => ({
          name: x.getPrettyName(),
          description: x.description
        })
      )
    };
    if (Object.values(value).filter(Boolean).length > 0) {
      propDef.jsDocTags = value;
    }
  }
  return propDef;
}
__name(applyJsDocResult, "applyJsDocResult");
var javaScriptFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
  const propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);
  propDef.sbType = convert4(docgenInfo);
  return applyJsDocResult(propDef, jsDocParsingResult);
}, "javaScriptFactory");
var tsFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
  const propDef = createTsPropDef(propName, docgenInfo);
  propDef.sbType = convert4(docgenInfo);
  return applyJsDocResult(propDef, jsDocParsingResult);
}, "tsFactory");
var flowFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
  const propDef = createFlowPropDef(propName, docgenInfo);
  propDef.sbType = convert4(docgenInfo);
  return applyJsDocResult(propDef, jsDocParsingResult);
}, "flowFactory");
var unknownFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
  const propDef = createBasicPropDef(propName, { name: "unknown" }, docgenInfo);
  return applyJsDocResult(propDef, jsDocParsingResult);
}, "unknownFactory");
var getPropDefFactory = __name((typeSystem) => {
  switch (typeSystem) {
    case "JavaScript":
      return javaScriptFactory;
    case "TypeScript":
      return tsFactory;
    case "Flow":
      return flowFactory;
    default:
      return unknownFactory;
  }
}, "getPropDefFactory");
var getTypeSystem = __name((docgenInfo) => {
  if (docgenInfo.type != null) {
    return "JavaScript";
  }
  if (docgenInfo.flowType != null) {
    return "Flow";
  }
  if (docgenInfo.tsType != null) {
    return "TypeScript";
  }
  return "Unknown";
}, "getTypeSystem");
var extractComponentSectionArray = __name((docgenSection) => {
  const typeSystem = getTypeSystem(docgenSection[0]);
  const createPropDef = getPropDefFactory(typeSystem);
  return docgenSection.map((item) => {
    let sanitizedItem = item;
    if (item.type?.elements) {
      sanitizedItem = {
        ...item,
        type: {
          ...item.type,
          value: item.type.elements
        }
      };
    }
    return extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);
  });
}, "extractComponentSectionArray");
var extractComponentSectionObject = __name((docgenSection) => {
  const docgenPropsKeys = Object.keys(docgenSection);
  const typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]);
  const createPropDef = getPropDefFactory(typeSystem);
  return docgenPropsKeys.map((propName) => {
    const docgenInfo = docgenSection[propName];
    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;
  }).filter(Boolean);
}, "extractComponentSectionObject");
var extractComponentProps = __name((component, section) => {
  const docgenSection = getDocgenSection(component, section);
  if (!isValidDocgenSection(docgenSection)) {
    return [];
  }
  return Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection);
}, "extractComponentProps");
function extractProp(propName, docgenInfo, typeSystem, createPropDef) {
  const jsDocParsingResult = parseJsDoc(docgenInfo.description);
  const isIgnored = jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore;
  if (!isIgnored) {
    const propDef = createPropDef(propName, docgenInfo, jsDocParsingResult);
    return {
      propDef,
      jsDocTags: jsDocParsingResult.extractedTags,
      docgenInfo,
      typeSystem
    };
  }
  return null;
}
__name(extractProp, "extractProp");
function extractComponentDescription(component) {
  return component != null ? getDocgenDescription(component) : "";
}
__name(extractComponentDescription, "extractComponentDescription");
var combineParameters = __name((...parameterSets) => {
  const mergeKeys = {};
  const definedParametersSets = parameterSets.filter(Boolean);
  const combined = definedParametersSets.reduce((acc, parameters2) => {
    Object.entries(parameters2).forEach(([key, value]) => {
      const existing = acc[key];
      if (Array.isArray(value) || typeof existing === "undefined") {
        acc[key] = value;
      } else if (isPlainObject(value) && isPlainObject(existing)) {
        mergeKeys[key] = true;
      } else if (typeof value !== "undefined") {
        acc[key] = value;
      }
    });
    return acc;
  }, {});
  Object.keys(mergeKeys).forEach((key) => {
    const mergeValues = definedParametersSets.filter(Boolean).map((p2) => p2[key]).filter((value) => typeof value !== "undefined");
    if (mergeValues.every((value) => isPlainObject(value))) {
      combined[key] = combineParameters(...mergeValues);
    } else {
      combined[key] = mergeValues[mergeValues.length - 1];
    }
  });
  return combined;
}, "combineParameters");
var enhanceArgTypes = __name((context) => {
  const {
    component,
    argTypes: userArgTypes,
    parameters: { docs = {} }
  } = context;
  const { extractArgTypes } = docs;
  if (!extractArgTypes || !component) {
    return userArgTypes;
  }
  const extractedArgTypes = extractArgTypes(component);
  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;
}, "enhanceArgTypes");
var ADDON_ID3 = "storybook/docs";
var PANEL_ID = `${ADDON_ID3}/panel`;
var SNIPPET_RENDERED = `${ADDON_ID3}/snippet-rendered`;
var SourceType = ((SourceType2) => {
  SourceType2["AUTO"] = "auto";
  SourceType2["CODE"] = "code";
  SourceType2["DYNAMIC"] = "dynamic";
  return SourceType2;
})(SourceType || {});

// node_modules/storybook/dist/_browser-chunks/chunk-AB7OOPUX.js
function noop() {
}
__name(noop, "noop");

// node_modules/storybook/dist/_browser-chunks/chunk-ZNRFDIVA.js
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
__name(eq, "eq");
function isEqualWith(a2, b, areValuesEqual) {
  return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
}
__name(isEqualWith, "isEqualWith");
function isEqualWithImpl(a2, b, property, aParent, bParent, stack, areValuesEqual) {
  const result = areValuesEqual(a2, b, property, aParent, bParent, stack);
  if (result !== void 0) {
    return result;
  }
  if (typeof a2 === typeof b) {
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a2 === b;
      }
      case "number": {
        return a2 === b || Object.is(a2, b);
      }
      case "function": {
        return a2 === b;
      }
      case "object": {
        return areObjectsEqual(a2, b, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a2, b, stack, areValuesEqual);
}
__name(isEqualWithImpl, "isEqualWithImpl");
function areObjectsEqual(a2, b, stack, areValuesEqual) {
  if (Object.is(a2, b)) {
    return true;
  }
  let aTag = getTag(a2);
  let bTag = getTag(b);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a2.toString() === b.toString();
    case numberTag: {
      const x = a2.valueOf();
      const y = b.valueOf();
      return eq(x, y);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a2.valueOf(), b.valueOf());
    case regexpTag: {
      return a2.source === b.source && a2.flags === b.flags;
    }
    case functionTag: {
      return a2 === b;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a2);
  const bStack = stack.get(b);
  if (aStack != null && bStack != null) {
    return aStack === b;
  }
  stack.set(a2, b);
  stack.set(b, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const [key, value] of a2.entries()) {
          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a2.size !== b.size) {
          return false;
        }
        const aValues = Array.from(a2.values());
        const bValues = Array.from(b.values());
        for (let i = 0; i < aValues.length; i++) {
          const aValue = aValues[i];
          const index2 = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
          });
          if (index2 === -1) {
            return false;
          }
          bValues.splice(index2, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
          return false;
        }
        if (a2.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (!isEqualWithImpl(a2[i], b[i], i, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a2.byteLength !== b.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
      }
      case errorTag: {
        return a2.name === b.name && a2.message === b.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
        const bKeys = [...Object.keys(b), ...getSymbols(b)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i = 0; i < aKeys.length; i++) {
          const propKey = aKeys[i];
          const aProp = a2[propKey];
          if (!Object.hasOwn(b, propKey)) {
            return false;
          }
          const bProp = b[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a2);
    stack.delete(b);
  }
}
__name(areObjectsEqual, "areObjectsEqual");
function isEqual(a2, b) {
  return isEqualWith(a2, b, noop);
}
__name(isEqual, "isEqual");

// node_modules/storybook/dist/_browser-chunks/chunk-FUOHXXZT.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
__name(invariant, "invariant");

// node_modules/storybook/dist/_browser-chunks/chunk-F4Q6SGTB.js
var require_entities = __commonJS2({
  "../node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\n", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
  }
});
var require_legacy = __commonJS2({
  "../node_modules/entities/lib/maps/legacy.json"(exports, module) {
    module.exports = { Aacute: "Á", aacute: "á", Acirc: "Â", acirc: "â", acute: "´", AElig: "Æ", aelig: "æ", Agrave: "À", agrave: "à", amp: "&", AMP: "&", Aring: "Å", aring: "å", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", brvbar: "¦", Ccedil: "Ç", ccedil: "ç", cedil: "¸", cent: "¢", copy: "©", COPY: "©", curren: "¤", deg: "°", divide: "÷", Eacute: "É", eacute: "é", Ecirc: "Ê", ecirc: "ê", Egrave: "È", egrave: "è", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", frac12: "½", frac14: "¼", frac34: "¾", gt: ">", GT: ">", Iacute: "Í", iacute: "í", Icirc: "Î", icirc: "î", iexcl: "¡", Igrave: "Ì", igrave: "ì", iquest: "¿", Iuml: "Ï", iuml: "ï", laquo: "«", lt: "<", LT: "<", macr: "¯", micro: "µ", middot: "·", nbsp: " ", not: "¬", Ntilde: "Ñ", ntilde: "ñ", Oacute: "Ó", oacute: "ó", Ocirc: "Ô", ocirc: "ô", Ograve: "Ò", ograve: "ò", ordf: "ª", ordm: "º", Oslash: "Ø", oslash: "ø", Otilde: "Õ", otilde: "õ", Ouml: "Ö", ouml: "ö", para: "¶", plusmn: "±", pound: "£", quot: '"', QUOT: '"', raquo: "»", reg: "®", REG: "®", sect: "§", shy: "­", sup1: "¹", sup2: "²", sup3: "³", szlig: "ß", THORN: "Þ", thorn: "þ", times: "×", Uacute: "Ú", uacute: "ú", Ucirc: "Û", ucirc: "û", Ugrave: "Ù", ugrave: "ù", uml: "¨", Uuml: "Ü", uuml: "ü", Yacute: "Ý", yacute: "ý", yen: "¥", yuml: "ÿ" };
  }
});
var require_xml = __commonJS2({
  "../node_modules/entities/lib/maps/xml.json"(exports, module) {
    module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});
var require_decode = __commonJS2({
  "../node_modules/entities/lib/maps/decode.json"(exports, module) {
    module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});
var require_decode_codepoint = __commonJS2({
  "../node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode());
    var fromCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      }
    );
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "�";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      return fromCodePoint(codePoint);
    }
    __name(decodeCodePoint, "decodeCodePoint");
    exports.default = decodeCodePoint;
  }
});
var require_decode2 = __commonJS2({
  "../node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml());
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var replace = getReplacer(map2);
      return function(str2) {
        return String(str2).replace(strictEntityRe, replace);
      };
    }
    __name(getStrictDecoder, "getStrictDecoder");
    var sorter = __name(function(a2, b) {
      return a2 < b ? 1 : -1;
    }, "sorter");
    exports.decodeHTML = (function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);
      for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
          keys[i] += ";?";
          j++;
        } else {
          keys[i] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str2) {
        if (str2.substr(-1) !== ";")
          str2 += ";";
        return replace(str2);
      }
      __name(replacer, "replacer");
      return function(str2) {
        return String(str2).replace(re, replacer);
      };
    })();
    function getReplacer(map2) {
      return __name(function replace(str2) {
        if (str2.charAt(1) === "#") {
          var secondChar = str2.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str2.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str2.substr(2), 10));
        }
        return map2[str2.slice(1, -1)] || str2;
      }, "replace");
    }
    __name(getReplacer, "getReplacer");
  }
});
var require_encode = __commonJS2({
  "../node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    __name(getInverseObj, "getInverseObj");
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
          single.push("\\" + k);
        } else {
          multiple.push(k);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count2 = 1 + end - start;
        if (count2 < 3)
          continue;
        single.splice(start, count2, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    __name(getInverseReplacer, "getInverseReplacer");
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (function(str2) {
          return str2.codePointAt(0);
        })
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (function(c) {
          return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
        })
      )
    );
    function singleCharReplacer(c) {
      return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    __name(singleCharReplacer, "singleCharReplacer");
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    __name(getInverse, "getInverse");
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape2(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    __name(escape2, "escape");
    exports.escape = escape2;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    __name(escapeUTF8, "escapeUTF8");
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c) {
          return obj[c] || singleCharReplacer(c);
        });
      };
    }
    __name(getASCIIEncoder, "getASCIIEncoder");
  }
});
var require_lib = __commonJS2({
  "../node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    __name(decode, "decode");
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    __name(decodeStrict, "decodeStrict");
    exports.decodeStrict = decodeStrict;
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    __name(encode, "encode");
    exports.encode = encode;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: __name(function() {
      return encode_2.encodeXML;
    }, "get") });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: __name(function() {
      return encode_2.encodeHTML;
    }, "get") });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: __name(function() {
      return encode_2.encodeNonAsciiHTML;
    }, "get") });
    Object.defineProperty(exports, "escape", { enumerable: true, get: __name(function() {
      return encode_2.escape;
    }, "get") });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: __name(function() {
      return encode_2.escapeUTF8;
    }, "get") });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: __name(function() {
      return encode_2.encodeHTML;
    }, "get") });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: __name(function() {
      return encode_2.encodeHTML;
    }, "get") });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: __name(function() {
      return decode_2.decodeXML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: __name(function() {
      return decode_2.decodeHTML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: __name(function() {
      return decode_2.decodeHTMLStrict;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: __name(function() {
      return decode_2.decodeHTML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: __name(function() {
      return decode_2.decodeHTML;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: __name(function() {
      return decode_2.decodeHTMLStrict;
    }, "get") });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: __name(function() {
      return decode_2.decodeHTMLStrict;
    }, "get") });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: __name(function() {
      return decode_2.decodeXML;
    }, "get") });
  }
});
var require_ansi_to_html = __commonJS2({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = __name(function F2() {
          }, "F");
          return { s: F, n: __name(function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, "n"), e: __name(function e(_e) {
            throw _e;
          }, "e"), f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: __name(function s2() {
        it = it.call(o);
      }, "s"), n: __name(function n() {
        var step2 = it.next();
        normalCompletion = step2.done;
        return step2;
      }, "n"), e: __name(function e(_e2) {
        didErr = true;
        err = _e2;
      }, "e"), f: __name(function f2() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }, "f") };
    }
    __name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    var entities = require_lib();
    var defaults = {
      fg: "#FFF",
      bg: "#000",
      newline: false,
      escapeXML: false,
      stream: false,
      colors: getDefaultColors()
    };
    function getDefaultColors() {
      var colors3 = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      range(0, 5).forEach(function(red) {
        range(0, 5).forEach(function(green) {
          range(0, 5).forEach(function(blue) {
            return setStyleColor(red, green, blue, colors3);
          });
        });
      });
      range(0, 23).forEach(function(gray) {
        var c = gray + 232;
        var l = toHexString(gray * 10 + 8);
        colors3[c] = "#" + l + l + l;
      });
      return colors3;
    }
    __name(getDefaultColors, "getDefaultColors");
    function setStyleColor(red, green, blue, colors3) {
      var c = 16 + red * 36 + green * 6 + blue;
      var r = red > 0 ? red * 40 + 55 : 0;
      var g = green > 0 ? green * 40 + 55 : 0;
      var b = blue > 0 ? blue * 40 + 55 : 0;
      colors3[c] = toColorHexString([r, g, b]);
    }
    __name(setStyleColor, "setStyleColor");
    function toHexString(num) {
      var str2 = num.toString(16);
      while (str2.length < 2) {
        str2 = "0" + str2;
      }
      return str2;
    }
    __name(toHexString, "toHexString");
    function toColorHexString(ref) {
      var results = [];
      var _iterator = _createForOfIteratorHelper(ref), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var r = _step.value;
          results.push(toHexString(r));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return "#" + results.join("");
    }
    __name(toColorHexString, "toColorHexString");
    function generateOutput(stack, token, data, options) {
      var result;
      if (token === "text") {
        result = pushText(data, options);
      } else if (token === "display") {
        result = handleDisplay(stack, data, options);
      } else if (token === "xterm256Foreground") {
        result = pushForegroundColor(stack, options.colors[data]);
      } else if (token === "xterm256Background") {
        result = pushBackgroundColor(stack, options.colors[data]);
      } else if (token === "rgb") {
        result = handleRgb(stack, data);
      }
      return result;
    }
    __name(generateOutput, "generateOutput");
    function handleRgb(stack, data) {
      data = data.substring(2).slice(0, -1);
      var operation = +data.substr(0, 2);
      var color = data.substring(5).split(";");
      var rgb = color.map(function(value) {
        return ("0" + Number(value).toString(16)).substr(-2);
      }).join("");
      return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
    }
    __name(handleRgb, "handleRgb");
    function handleDisplay(stack, code, options) {
      code = parseInt(code, 10);
      var codeMap = {
        "-1": __name(function _() {
          return "<br/>";
        }, "_"),
        0: __name(function _() {
          return stack.length && resetStyles(stack);
        }, "_"),
        1: __name(function _() {
          return pushTag(stack, "b");
        }, "_"),
        3: __name(function _() {
          return pushTag(stack, "i");
        }, "_"),
        4: __name(function _() {
          return pushTag(stack, "u");
        }, "_"),
        8: __name(function _() {
          return pushStyle(stack, "display:none");
        }, "_"),
        9: __name(function _() {
          return pushTag(stack, "strike");
        }, "_"),
        22: __name(function _() {
          return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
        }, "_"),
        23: __name(function _() {
          return closeTag(stack, "i");
        }, "_"),
        24: __name(function _() {
          return closeTag(stack, "u");
        }, "_"),
        39: __name(function _() {
          return pushForegroundColor(stack, options.fg);
        }, "_"),
        49: __name(function _() {
          return pushBackgroundColor(stack, options.bg);
        }, "_"),
        53: __name(function _() {
          return pushStyle(stack, "text-decoration:overline");
        }, "_")
      };
      var result;
      if (codeMap[code]) {
        result = codeMap[code]();
      } else if (4 < code && code < 7) {
        result = pushTag(stack, "blink");
      } else if (29 < code && code < 38) {
        result = pushForegroundColor(stack, options.colors[code - 30]);
      } else if (39 < code && code < 48) {
        result = pushBackgroundColor(stack, options.colors[code - 40]);
      } else if (89 < code && code < 98) {
        result = pushForegroundColor(stack, options.colors[8 + (code - 90)]);
      } else if (99 < code && code < 108) {
        result = pushBackgroundColor(stack, options.colors[8 + (code - 100)]);
      }
      return result;
    }
    __name(handleDisplay, "handleDisplay");
    function resetStyles(stack) {
      var stackClone = stack.slice(0);
      stack.length = 0;
      return stackClone.reverse().map(function(tag) {
        return "</" + tag + ">";
      }).join("");
    }
    __name(resetStyles, "resetStyles");
    function range(low, high) {
      var results = [];
      for (var j = low; j <= high; j++) {
        results.push(j);
      }
      return results;
    }
    __name(range, "range");
    function notCategory(category) {
      return function(e) {
        return (category === null || e.category !== category) && category !== "all";
      };
    }
    __name(notCategory, "notCategory");
    function categoryForCode(code) {
      code = parseInt(code, 10);
      var result = null;
      if (code === 0) {
        result = "all";
      } else if (code === 1) {
        result = "bold";
      } else if (2 < code && code < 5) {
        result = "underline";
      } else if (4 < code && code < 7) {
        result = "blink";
      } else if (code === 8) {
        result = "hide";
      } else if (code === 9) {
        result = "strike";
      } else if (29 < code && code < 38 || code === 39 || 89 < code && code < 98) {
        result = "foreground-color";
      } else if (39 < code && code < 48 || code === 49 || 99 < code && code < 108) {
        result = "background-color";
      }
      return result;
    }
    __name(categoryForCode, "categoryForCode");
    function pushText(text, options) {
      if (options.escapeXML) {
        return entities.encodeXML(text);
      }
      return text;
    }
    __name(pushText, "pushText");
    function pushTag(stack, tag, style) {
      if (!style) {
        style = "";
      }
      stack.push(tag);
      return "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
    }
    __name(pushTag, "pushTag");
    function pushStyle(stack, style) {
      return pushTag(stack, "span", style);
    }
    __name(pushStyle, "pushStyle");
    function pushForegroundColor(stack, color) {
      return pushTag(stack, "span", "color:" + color);
    }
    __name(pushForegroundColor, "pushForegroundColor");
    function pushBackgroundColor(stack, color) {
      return pushTag(stack, "span", "background-color:" + color);
    }
    __name(pushBackgroundColor, "pushBackgroundColor");
    function closeTag(stack, style) {
      var last;
      if (stack.slice(-1)[0] === style) {
        last = stack.pop();
      }
      if (last) {
        return "</" + style + ">";
      }
    }
    __name(closeTag, "closeTag");
    function tokenize(text, options, callback) {
      var ansiMatch = false;
      var ansiHandler = 3;
      function remove() {
        return "";
      }
      __name(remove, "remove");
      function removeXterm256Foreground(m, g1) {
        callback("xterm256Foreground", g1);
        return "";
      }
      __name(removeXterm256Foreground, "removeXterm256Foreground");
      function removeXterm256Background(m, g1) {
        callback("xterm256Background", g1);
        return "";
      }
      __name(removeXterm256Background, "removeXterm256Background");
      function newline(m) {
        if (options.newline) {
          callback("display", -1);
        } else {
          callback("text", m);
        }
        return "";
      }
      __name(newline, "newline");
      function ansiMess(m, g1) {
        ansiMatch = true;
        if (g1.trim().length === 0) {
          g1 = "0";
        }
        g1 = g1.trimRight(";").split(";");
        var _iterator2 = _createForOfIteratorHelper(g1), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var g = _step2.value;
            callback("display", g);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return "";
      }
      __name(ansiMess, "ansiMess");
      function realText(m) {
        callback("text", m);
        return "";
      }
      __name(realText, "realText");
      function rgb(m) {
        callback("rgb", m);
        return "";
      }
      __name(rgb, "rgb");
      var tokens = [{
        pattern: /^\x08+/,
        sub: remove
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: remove
      }, {
        pattern: /^\x1b\[\(B/,
        sub: remove
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: rgb
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: removeXterm256Foreground
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: removeXterm256Background
      }, {
        pattern: /^\n/,
        sub: newline
      }, {
        pattern: /^\r+\n/,
        sub: newline
      }, {
        pattern: /^\r/,
        sub: newline
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: ansiMess
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: remove
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: remove
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: remove
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: realText
      }];
      function process2(handler2, i2) {
        if (i2 > ansiHandler && ansiMatch) {
          return;
        }
        ansiMatch = false;
        text = text.replace(handler2.pattern, handler2.sub);
      }
      __name(process2, "process");
      var results1 = [];
      var _text = text, length = _text.length;
      outer: while (length > 0) {
        for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {
          var handler = tokens[i];
          process2(handler, i);
          if (text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length) {
          break;
        }
        results1.push(0);
        length = text.length;
      }
      return results1;
    }
    __name(tokenize, "tokenize");
    function updateStickyStack(stickyStack, token, data) {
      if (token !== "text") {
        stickyStack = stickyStack.filter(notCategory(categoryForCode(data)));
        stickyStack.push({
          token,
          data,
          category: categoryForCode(data)
        });
      }
      return stickyStack;
    }
    __name(updateStickyStack, "updateStickyStack");
    var Filter = (function() {
      function Filter2(options) {
        _classCallCheck(this, Filter2);
        options = options || {};
        if (options.colors) {
          options.colors = Object.assign({}, defaults.colors, options.colors);
        }
        this.options = Object.assign({}, defaults, options);
        this.stack = [];
        this.stickyStack = [];
      }
      __name(Filter2, "Filter");
      _createClass(Filter2, [{
        key: "toHtml",
        value: __name(function toHtml(input) {
          var _this = this;
          input = typeof input === "string" ? [input] : input;
          var stack = this.stack, options = this.options;
          var buf = [];
          this.stickyStack.forEach(function(element) {
            var output = generateOutput(stack, element.token, element.data, options);
            if (output) {
              buf.push(output);
            }
          });
          tokenize(input.join(""), options, function(token, data) {
            var output = generateOutput(stack, token, data, options);
            if (output) {
              buf.push(output);
            }
            if (options.stream) {
              _this.stickyStack = updateStickyStack(_this.stickyStack, token, data);
            }
          });
          if (stack.length) {
            buf.push(resetStyles(stack));
          }
          return buf.join("");
        }, "toHtml")
      }]);
      return Filter2;
    })();
    module.exports = Filter;
  }
});

// node_modules/storybook/dist/_browser-chunks/chunk-LYCSRYYR.js
var ANIMATION_TIMEOUT = 5e3;
function isTestEnvironment() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
__name(isTestEnvironment, "isTestEnvironment");
function pauseAnimations(atEnd = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document)) {
    return () => {
    };
  }
  const disableStyle = document.createElement("style");
  disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`;
  document.head.appendChild(disableStyle);
  const pauseStyle = document.createElement("style");
  pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`;
  document.head.appendChild(pauseStyle);
  document.body.clientHeight;
  document.head.removeChild(disableStyle);
  return () => {
    pauseStyle.parentNode?.removeChild(pauseStyle);
  };
}
__name(pauseAnimations, "pauseAnimations");
async function waitForAnimations(signal) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document)) {
    return;
  }
  let timedOut = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((resolve) => {
      setTimeout(() => {
        const animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)];
        const checkAnimationsFinished = __name(async () => {
          if (timedOut || signal?.aborted) {
            return;
          }
          const runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a2) => a2.playState === "running" && !isInfiniteAnimation(a2));
          if (runningAnimations.length > 0) {
            await Promise.all(runningAnimations.map((a2) => a2.finished));
            await checkAnimationsFinished();
          }
        }, "checkAnimationsFinished");
        checkAnimationsFinished().then(resolve);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (resolve) => setTimeout(() => {
        timedOut = true;
        resolve(void 0);
      }, ANIMATION_TIMEOUT)
    )
  ]);
}
__name(waitForAnimations, "waitForAnimations");
function getShadowRoots(doc) {
  return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => {
    if ("shadowRoot" in el && el.shadowRoot) {
      acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot));
    }
    return acc;
  }, []);
}
__name(getShadowRoots, "getShadowRoots");
function isInfiniteAnimation(anim) {
  if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
    const style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement);
    const index2 = style.animationName?.split(", ").indexOf(anim.animationName);
    const iterations = style.animationIterationCount.split(", ")[index2];
    return iterations === "infinite";
  }
  return false;
}
__name(isInfiniteAnimation, "isInfiniteAnimation");

// node_modules/storybook/dist/_browser-chunks/chunk-W4QKLQSC.js
var import_global = __toESM(require_global(), 1);
var import_channels = __toESM(require_channels(), 1);
var import_client_logger = __toESM(require_client_logger(), 1);
var import_core_events = __toESM(require_core_events(), 1);
var import_global2 = __toESM(require_global(), 1);
var import_preview_errors3 = __toESM(require_preview_errors(), 1);
var import_client_logger2 = __toESM(require_client_logger(), 1);
var import_client_logger3 = __toESM(require_client_logger(), 1);
var import_preview_errors4 = __toESM(require_preview_errors(), 1);
var import_client_logger4 = __toESM(require_client_logger(), 1);
var import_client_logger5 = __toESM(require_client_logger(), 1);
var import_preview_errors5 = __toESM(require_preview_errors(), 1);
var import_global3 = __toESM(require_global(), 1);
var import_global4 = __toESM(require_global(), 1);
var import_client_logger6 = __toESM(require_client_logger(), 1);
var import_client_logger7 = __toESM(require_client_logger(), 1);
var import_global5 = __toESM(require_global(), 1);
var import_preview_errors6 = __toESM(require_preview_errors(), 1);
var import_client_logger8 = __toESM(require_client_logger(), 1);
var import_client_logger9 = __toESM(require_client_logger(), 1);
var import_core_events2 = __toESM(require_core_events(), 1);
var import_preview_errors7 = __toESM(require_preview_errors(), 1);
var import_global6 = __toESM(require_global(), 1);
var import_core_events3 = __toESM(require_core_events(), 1);
var import_preview_errors8 = __toESM(require_preview_errors(), 1);
var import_global7 = __toESM(require_global(), 1);
var import_client_logger10 = __toESM(require_client_logger(), 1);
var import_core_events4 = __toESM(require_core_events(), 1);
var import_preview_errors9 = __toESM(require_preview_errors(), 1);
var import_core_events5 = __toESM(require_core_events(), 1);
var import_core_events6 = __toESM(require_core_events(), 1);
var import_global8 = __toESM(require_global(), 1);
var import_client_logger11 = __toESM(require_client_logger(), 1);
var import_client_logger12 = __toESM(require_client_logger(), 1);
var import_global9 = __toESM(require_global(), 1);
var import_global10 = __toESM(require_global(), 1);
function mockChannel() {
  const transport = {
    setHandler: __name(() => {
    }, "setHandler"),
    send: __name(() => {
    }, "send")
  };
  return new import_channels.Channel({ transport });
}
__name(mockChannel, "mockChannel");
var _AddonStore = class _AddonStore2 {
  constructor() {
    this.getChannel = __name(() => {
      if (!this.channel) {
        const channel = mockChannel();
        this.setChannel(channel);
        return channel;
      }
      return this.channel;
    }, "getChannel");
    this.ready = __name(() => this.promise, "ready");
    this.hasChannel = __name(() => !!this.channel, "hasChannel");
    this.setChannel = __name((channel) => {
      this.channel = channel;
      this.resolve();
    }, "setChannel");
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
__name(_AddonStore, "AddonStore");
var AddonStore = _AddonStore;
var KEY = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  if (!import_global.global[KEY]) {
    import_global.global[KEY] = new AddonStore();
  }
  return import_global.global[KEY];
}
__name(getAddonsStore, "getAddonsStore");
var addons = getAddonsStore();
var _HooksContext = class _HooksContext2 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = __name((storyId) => {
      if (storyId !== this.currentContext?.id) {
        return;
      }
      this.triggerEffects();
      this.currentContext = null;
      this.removeRenderListeners();
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap();
    this.mountedDecorators = /* @__PURE__ */ new Set();
    this.prevMountedDecorators = /* @__PURE__ */ new Set();
    this.currentHooks = [];
    this.nextHookIndex = 0;
    this.currentPhase = "NONE";
    this.currentEffects = [];
    this.prevEffects = [];
    this.currentDecoratorName = null;
    this.hasUpdates = false;
    this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      if (effect.destroy) {
        effect.destroy();
      }
    });
    this.init();
    this.removeRenderListeners();
  }
  getNextHook() {
    const hook = this.currentHooks[this.nextHookIndex];
    this.nextHookIndex += 1;
    return hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      if (!this.currentEffects.includes(effect) && effect.destroy) {
        effect.destroy();
      }
    });
    this.currentEffects.forEach((effect) => {
      if (!this.prevEffects.includes(effect)) {
        effect.destroy = effect.create();
      }
    });
    this.prevEffects = this.currentEffects;
    this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners();
    const channel = addons.getChannel();
    channel.on(import_core_events.STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    const channel = addons.getChannel();
    channel.removeListener(import_core_events.STORY_RENDERED, this.renderListener);
  }
};
__name(_HooksContext, "HooksContext");
var HooksContext = _HooksContext;
function hookify(fn2) {
  const hookified = __name((...args) => {
    const { hooks } = typeof args[0] === "function" ? args[1] : args[0];
    const prevPhase = hooks.currentPhase;
    const prevHooks = hooks.currentHooks;
    const prevNextHookIndex = hooks.nextHookIndex;
    const prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn2.name;
    if (hooks.prevMountedDecorators.has(fn2)) {
      hooks.currentPhase = "UPDATE";
      hooks.currentHooks = hooks.hookListsMap.get(fn2) || [];
    } else {
      hooks.currentPhase = "MOUNT";
      hooks.currentHooks = [];
      hooks.hookListsMap.set(fn2, hooks.currentHooks);
      hooks.prevMountedDecorators.add(fn2);
    }
    hooks.nextHookIndex = 0;
    const prevContext = import_global2.global.STORYBOOK_HOOKS_CONTEXT;
    import_global2.global.STORYBOOK_HOOKS_CONTEXT = hooks;
    const result = fn2(...args);
    import_global2.global.STORYBOOK_HOOKS_CONTEXT = prevContext;
    if (hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null) {
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    }
    hooks.currentPhase = prevPhase;
    hooks.currentHooks = prevHooks;
    hooks.nextHookIndex = prevNextHookIndex;
    hooks.currentDecoratorName = prevDecoratorName;
    return result;
  }, "hookified");
  hookified.originalFn = fn2;
  return hookified;
}
__name(hookify, "hookify");
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = __name((applyDecorators) => (storyFn, decorators4) => {
  const decorated = applyDecorators(
    hookify(storyFn),
    decorators4.map((decorator) => hookify(decorator))
  );
  return (context) => {
    const { hooks } = context;
    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set();
    hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]);
    hooks.currentContext = context;
    hooks.hasUpdates = false;
    let result = decorated(context);
    numberOfRenders = 1;
    while (hooks.hasUpdates) {
      hooks.hasUpdates = false;
      hooks.currentEffects = [];
      result = decorated(context);
      numberOfRenders += 1;
      if (numberOfRenders > RENDER_LIMIT) {
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
      }
    }
    hooks.addRenderListeners();
    return result;
  };
}, "applyHooks");
var areDepsEqual = __name((deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i) => dep === nextDeps[i]), "areDepsEqual");
var invalidHooksError = __name(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
function getHooksContextOrNull() {
  return import_global2.global.STORYBOOK_HOOKS_CONTEXT || null;
}
__name(getHooksContextOrNull, "getHooksContextOrNull");
function getHooksContextOrThrow() {
  const hooks = getHooksContextOrNull();
  if (hooks == null) {
    throw invalidHooksError();
  }
  return hooks;
}
__name(getHooksContextOrThrow, "getHooksContextOrThrow");
function useHook(name, callback, deps) {
  const hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    if (deps != null && !Array.isArray(deps)) {
      import_client_logger.logger.warn(
        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
      );
    }
    const hook = { name, deps };
    hooks.currentHooks.push(hook);
    callback(hook);
    return hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    const hook = hooks.getNextHook();
    if (hook == null) {
      throw new Error("Rendered more hooks than during the previous render.");
    }
    if (hook.name !== name) {
      import_client_logger.logger.warn(
        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
      );
    }
    if (deps != null && hook.deps == null) {
      import_client_logger.logger.warn(
        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
      );
    }
    if (deps != null && hook.deps != null && deps.length !== hook.deps.length) {
      import_client_logger.logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`);
    }
    if (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) {
      callback(hook);
      hook.deps = deps;
    }
    return hook;
  }
  throw invalidHooksError();
}
__name(useHook, "useHook");
function useMemoLike(name, nextCreate, deps) {
  const { memoizedState } = useHook(
    name,
    (hook) => {
      hook.memoizedState = nextCreate();
    },
    deps
  );
  return memoizedState;
}
__name(useMemoLike, "useMemoLike");
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
__name(useMemo, "useMemo");
function useCallback(callback, deps) {
  return useMemoLike("useCallback", () => callback, deps);
}
__name(useCallback, "useCallback");
function useRefLike(name, initialValue) {
  return useMemoLike(name, () => ({ current: initialValue }), []);
}
__name(useRefLike, "useRefLike");
function useRef(initialValue) {
  return useRefLike("useRef", initialValue);
}
__name(useRef, "useRef");
function triggerUpdate() {
  const hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE") {
    hooks.hasUpdates = true;
  } else {
    try {
      addons.getChannel().emit(import_core_events.FORCE_RE_RENDER);
    } catch (e) {
      import_client_logger.logger.warn("State updates of Storybook preview hooks work only in browser");
    }
  }
}
__name(triggerUpdate, "triggerUpdate");
function useStateLike(name, initialState) {
  const stateRef = useRefLike(
    name,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof initialState === "function" ? initialState() : initialState
  );
  const setState = __name((update) => {
    stateRef.current = typeof update === "function" ? update(stateRef.current) : update;
    triggerUpdate();
  }, "setState");
  return [stateRef.current, setState];
}
__name(useStateLike, "useStateLike");
function useState(initialState) {
  return useStateLike("useState", initialState);
}
__name(useState, "useState");
function useReducer(reducer, initialArg, init2) {
  const initialState = init2 != null ? () => init2(initialArg) : initialArg;
  const [state3, setState] = useStateLike("useReducer", initialState);
  const dispatch = __name((action2) => setState((prevState) => reducer(prevState, action2)), "dispatch");
  return [state3, dispatch];
}
__name(useReducer, "useReducer");
function useEffect(create, deps) {
  const hooks = getHooksContextOrThrow();
  const effect = useMemoLike("useEffect", () => ({ create }), deps);
  if (!hooks.currentEffects.includes(effect)) {
    hooks.currentEffects.push(effect);
  }
}
__name(useEffect, "useEffect");
function useChannel(eventMap, deps = []) {
  const channel = addons.getChannel();
  useEffect(() => {
    Object.entries(eventMap).forEach(([type, listener]) => channel.on(type, listener));
    return () => {
      Object.entries(eventMap).forEach(
        ([type, listener]) => channel.removeListener(type, listener)
      );
    };
  }, [...Object.keys(eventMap), ...deps]);
  return useCallback(channel.emit.bind(channel), [channel]);
}
__name(useChannel, "useChannel");
function useStoryContext() {
  const { currentContext } = getHooksContextOrThrow();
  if (currentContext == null) {
    throw invalidHooksError();
  }
  return currentContext;
}
__name(useStoryContext, "useStoryContext");
function useParameter(parameterKey, defaultValue) {
  const { parameters: parameters2 } = useStoryContext();
  if (parameterKey) {
    return parameters2[parameterKey] ?? defaultValue;
  }
  return void 0;
}
__name(useParameter, "useParameter");
function useArgs() {
  const channel = addons.getChannel();
  const { id: storyId, args } = useStoryContext();
  const updateArgs = useCallback(
    (updatedArgs) => channel.emit(import_core_events.UPDATE_STORY_ARGS, { storyId, updatedArgs }),
    [channel, storyId]
  );
  const resetArgs = useCallback(
    (argNames) => channel.emit(import_core_events.RESET_STORY_ARGS, { storyId, argNames }),
    [channel, storyId]
  );
  return [args, updateArgs, resetArgs];
}
__name(useArgs, "useArgs");
function useGlobals() {
  const channel = addons.getChannel();
  const { globals } = useStoryContext();
  const updateGlobals = useCallback(
    (newGlobals) => channel.emit(import_core_events.UPDATE_GLOBALS, { globals: newGlobals }),
    [channel]
  );
  return [globals, updateGlobals];
}
__name(useGlobals, "useGlobals");
var makeDecorator = __name(({
  name,
  parameterName,
  wrapper,
  skipIfNoParametersOrOptions = false
}) => {
  const decorator = __name((options) => (storyFn, context) => {
    const parameters2 = context.parameters && context.parameters[parameterName];
    if (parameters2 && parameters2.disable) {
      return storyFn(context);
    }
    if (skipIfNoParametersOrOptions && !options && !parameters2) {
      return storyFn(context);
    }
    return wrapper(storyFn, context, {
      options,
      parameters: parameters2
    });
  }, "decorator");
  return (...args) => {
    if (typeof args[0] === "function") {
      return decorator()(...args);
    }
    return (...innerArgs) => {
      if (innerArgs.length > 1) {
        if (args.length > 1) {
          return decorator(args)(...innerArgs);
        }
        return decorator(...args)(...innerArgs);
      }
      throw new Error(
        `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
      );
    };
  };
}, "makeDecorator");
var import_memoizerific2 = __toESM2(require_memoizerific(), 1);
var INCOMPATIBLE = Symbol("incompatible");
var map = __name((arg, argType) => {
  const type = argType.type;
  if (arg === void 0 || arg === null || !type) {
    return arg;
  }
  if (argType.mapping) {
    return arg;
  }
  switch (type.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return String(arg) === "true";
    case "array":
      if (!type.value || !Array.isArray(arg)) {
        return INCOMPATIBLE;
      }
      return arg.reduce((acc, item, index2) => {
        const mapped = map(item, { type: type.value });
        if (mapped !== INCOMPATIBLE) {
          acc[index2] = mapped;
        }
        return acc;
      }, new Array(arg.length));
    case "object":
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (!type.value || typeof arg !== "object") {
        return INCOMPATIBLE;
      }
      return Object.entries(arg).reduce((acc, [key, val]) => {
        const mapped = map(val, { type: type.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    case "other": {
      const isPrimitiveArg = typeof arg === "string" || typeof arg === "number" || typeof arg === "boolean";
      if (type.value === "ReactNode" && isPrimitiveArg) {
        return arg;
      }
      return INCOMPATIBLE;
    }
    default:
      return INCOMPATIBLE;
  }
}, "map");
var mapArgsToTypes = __name((args, argTypes) => {
  return Object.entries(args).reduce((acc, [key, value]) => {
    if (!argTypes[key]) {
      return acc;
    }
    const mapped = map(value, argTypes[key]);
    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
  }, {});
}, "mapArgsToTypes");
var combineArgs = __name((value, update) => {
  if (Array.isArray(value) && Array.isArray(update)) {
    return update.reduce(
      (acc, upd, index2) => {
        acc[index2] = combineArgs(value[index2], update[index2]);
        return acc;
      },
      [...value]
    ).filter((v) => v !== void 0);
  }
  if (!isPlainObject(value) || !isPlainObject(update)) {
    return update;
  }
  return Object.keys({ ...value, ...update }).reduce((acc, key) => {
    if (key in update) {
      const combined = combineArgs(value[key], update[key]);
      if (combined !== void 0) {
        acc[key] = combined;
      }
    } else {
      acc[key] = value[key];
    }
    return acc;
  }, {});
}, "combineArgs");
var validateOptions = __name((args, argTypes) => {
  return Object.entries(argTypes).reduce((acc, [key, { options }]) => {
    function allowArg() {
      if (key in args) {
        acc[key] = args[key];
      }
      return acc;
    }
    __name(allowArg, "allowArg");
    if (!options) {
      return allowArg();
    }
    if (!Array.isArray(options)) {
      import_client_logger2.once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `);
      return allowArg();
    }
    if (options.some((opt) => opt && ["object", "function"].includes(typeof opt))) {
      import_client_logger2.once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `);
      return allowArg();
    }
    const isArray = Array.isArray(args[key]);
    const invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val));
    const isValidArray = isArray && invalidIndex === -1;
    if (args[key] === void 0 || options.includes(args[key]) || isValidArray) {
      return allowArg();
    }
    const field = isArray ? `${key}[${invalidIndex}]` : key;
    const supportedOptions = options.map((opt) => typeof opt === "string" ? `'${opt}'` : String(opt)).join(", ");
    import_client_logger2.once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);
    return acc;
  }, {});
}, "validateOptions");
var DEEPLY_EQUAL = Symbol("Deeply equal");
var deepDiff = __name((value, update) => {
  if (typeof value !== typeof update) {
    return update;
  }
  if (isEqual(value, update)) {
    return DEEPLY_EQUAL;
  }
  if (Array.isArray(value) && Array.isArray(update)) {
    const res = update.reduce((acc, upd, index2) => {
      const diff2 = deepDiff(value[index2], upd);
      if (diff2 !== DEEPLY_EQUAL) {
        acc[index2] = diff2;
      }
      return acc;
    }, new Array(update.length));
    if (update.length >= value.length) {
      return res;
    }
    return res.concat(new Array(value.length - update.length).fill(void 0));
  }
  if (isPlainObject(value) && isPlainObject(update)) {
    return Object.keys({ ...value, ...update }).reduce((acc, key) => {
      const diff2 = deepDiff(value?.[key], update?.[key]);
      return diff2 === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff2 });
    }, {});
  }
  return update;
}, "deepDiff");
var UNTARGETED = "UNTARGETED";
function groupArgsByTarget({
  args,
  argTypes
}) {
  const groupedArgs = {};
  Object.entries(args).forEach(([name, value]) => {
    const { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {};
    groupedArgs[target][name] = value;
  });
  return groupedArgs;
}
__name(groupArgsByTarget, "groupArgsByTarget");
function deleteUndefined(obj) {
  Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]);
  return obj;
}
__name(deleteUndefined, "deleteUndefined");
var _ArgsStore = class _ArgsStore2 {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId)) {
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    }
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id]) {
      this.initialArgsByStoryId[story.id] = story.initialArgs;
      this.argsByStoryId[story.id] = story.initialArgs;
    } else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      const delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs;
      this.argsByStoryId[story.id] = story.initialArgs;
      if (delta !== DEEPLY_EQUAL) {
        this.updateFromDelta(story, delta);
      }
    }
  }
  updateFromDelta(story, delta) {
    const validatedDelta = validateOptions(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    const mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId)) {
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    }
    this.argsByStoryId[storyId] = deleteUndefined({
      ...this.argsByStoryId[storyId],
      ...argsUpdate
    });
  }
};
__name(_ArgsStore, "ArgsStore");
var ArgsStore = _ArgsStore;
var getValuesFromArgTypes = __name((argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => {
  if (typeof defaultValue !== "undefined") {
    acc[arg] = defaultValue;
  }
  return acc;
}, {}), "getValuesFromArgTypes");
var _GlobalsStore = class _GlobalsStore2 {
  constructor({
    globals = {},
    globalTypes = {}
  }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    const defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals };
    this.globals = this.initialGlobals;
    if (delta && delta !== DEEPLY_EQUAL) {
      this.updateFromPersisted(delta);
    }
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => {
      if (this.allowedGlobalNames.has(key)) {
        acc[key] = value;
      } else {
        import_client_logger3.logger.warn(
          `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
        );
      }
      return acc;
    }, {});
  }
  updateFromPersisted(persisted) {
    const allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
    for (const key in newGlobals) {
      if (newGlobals[key] === void 0) {
        this.globals[key] = this.initialGlobals[key];
      }
    }
  }
};
__name(_GlobalsStore, "GlobalsStore");
var GlobalsStore = _GlobalsStore;
var import_memoizerific = __toESM2(require_memoizerific(), 1);
var getImportPathMap = (0, import_memoizerific.default)(1)(
  (entries) => Object.values(entries).reduce(
    (acc, entry) => {
      acc[entry.importPath] = acc[entry.importPath] || entry;
      return acc;
    },
    {}
  )
);
var _StoryIndexStore = class _StoryIndexStore2 {
  constructor({ entries } = { v: 5, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    const entries = Object.values(this.entries);
    if (specifier === "*") {
      return entries[0];
    }
    if (typeof specifier === "string") {
      if (this.entries[specifier]) {
        return this.entries[specifier];
      }
      return entries.find((entry) => entry.id.startsWith(specifier));
    }
    const { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    const storyEntry = this.entries[storyId];
    if (!storyEntry) {
      throw new import_preview_errors4.MissingStoryAfterHmrError({ storyId });
    }
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
__name(_StoryIndexStore, "StoryIndexStore");
var StoryIndexStore = _StoryIndexStore;
var normalizeType = __name((type) => {
  return typeof type === "string" ? { name: type } : type;
}, "normalizeType");
var normalizeControl = __name((control) => typeof control === "string" ? { type: control } : control, "normalizeControl");
var normalizeInputType = __name((inputType, key) => {
  const { type, control, ...rest } = inputType;
  const normalized = {
    name: key,
    ...rest
  };
  if (type) {
    normalized.type = normalizeType(type);
  }
  if (control) {
    normalized.control = normalizeControl(control);
  } else if (control === false) {
    normalized.control = { disable: true };
  }
  return normalized;
}, "normalizeInputType");
var normalizeInputTypes = __name((inputTypes) => mapValues(inputTypes, normalizeInputType), "normalizeInputTypes");
var normalizeArrays = __name((array) => {
  if (Array.isArray(array)) {
    return array;
  }
  return array ? [array] : [];
}, "normalizeArrays");
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function normalizeStory(key, storyAnnotations, meta) {
  const storyObject = storyAnnotations;
  const userStoryFn = typeof storyAnnotations === "function" ? storyAnnotations : null;
  const { story } = storyObject;
  if (story) {
    import_client_logger4.logger.debug("deprecated story", story);
    (0, import_client_logger4.deprecate)(deprecatedStoryAnnotation);
  }
  const exportName = storyNameFromExport(key);
  const name = typeof storyObject !== "function" && storyObject.name || storyObject.storyName || story?.name || exportName;
  const decorators4 = [
    ...normalizeArrays(storyObject.decorators),
    ...normalizeArrays(story?.decorators)
  ];
  const parameters2 = { ...story?.parameters, ...storyObject.parameters };
  const args = { ...story?.args, ...storyObject.args };
  const argTypes = { ...story?.argTypes, ...storyObject.argTypes };
  const loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)];
  const beforeEach = [
    ...normalizeArrays(storyObject.beforeEach),
    ...normalizeArrays(story?.beforeEach)
  ];
  const afterEach = [
    ...normalizeArrays(storyObject.afterEach),
    ...normalizeArrays(story?.afterEach)
  ];
  const { render, play, tags = [], globals = {} } = storyObject;
  const id = parameters2.__id || toId(meta.id, exportName);
  return {
    moduleExport: storyAnnotations,
    id,
    name,
    tags,
    decorators: decorators4,
    parameters: parameters2,
    args,
    argTypes: normalizeInputTypes(argTypes),
    loaders: loaders2,
    beforeEach,
    afterEach,
    globals,
    ...render && { render },
    ...userStoryFn && { userStoryFn },
    ...play && { play }
  };
}
__name(normalizeStory, "normalizeStory");
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  const { id, argTypes } = defaultExport;
  return {
    id: sanitize(id || title),
    ...defaultExport,
    title,
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    parameters: {
      fileName: importPath,
      ...defaultExport.parameters
    }
  };
}
__name(normalizeComponentAnnotations, "normalizeComponentAnnotations");
var checkGlobals = __name((parameters2) => {
  const { globals, globalTypes } = parameters2;
  if (globals || globalTypes) {
    import_client_logger5.logger.error(
      "Global args/argTypes can only be set globally",
      JSON.stringify({
        globals,
        globalTypes
      })
    );
  }
}, "checkGlobals");
var checkStorySort = __name((parameters2) => {
  const { options } = parameters2;
  if (options?.storySort) {
    import_client_logger5.logger.error("The storySort option parameter can only be set globally");
  }
}, "checkStorySort");
var checkDisallowedParameters = __name((parameters2) => {
  if (!parameters2) {
    return;
  }
  checkGlobals(parameters2);
  checkStorySort(parameters2);
}, "checkDisallowedParameters");
function processCSFFile(moduleExports, importPath, title) {
  const { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports;
  const firstStory = Object.values(namedExports)[0];
  if (isStory(firstStory)) {
    const meta2 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);
    checkDisallowedParameters(meta2.parameters);
    const csfFile2 = { meta: meta2, stories: {}, moduleExports };
    Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta2)) {
        const story = namedExports[key];
        const storyMeta = normalizeStory(key, story.input, meta2);
        checkDisallowedParameters(storyMeta.parameters);
        csfFile2.stories[storyMeta.id] = storyMeta;
        getStoryChildren(story).forEach((child) => {
          const name = child.input.name;
          const childId = toTestId(storyMeta.id, name);
          child.input.parameters ??= {};
          child.input.parameters.__id = childId;
          csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);
        });
      }
    });
    csfFile2.projectAnnotations = firstStory.meta.preview.composed;
    return csfFile2;
  }
  const meta = normalizeComponentAnnotations(
    defaultExport,
    title,
    importPath
  );
  checkDisallowedParameters(meta.parameters);
  const csfFile = { meta, stories: {}, moduleExports };
  Object.keys(namedExports).forEach((key) => {
    if (isExportStory(key, meta)) {
      const storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters);
      csfFile.stories[storyMeta.id] = storyMeta;
    }
  });
  return csfFile;
}
__name(processCSFFile, "processCSFFile");
function mountDestructured(playFunction) {
  return playFunction != null && getUsedProps(playFunction).includes("mount");
}
__name(mountDestructured, "mountDestructured");
function getUsedProps(fn2) {
  const match = fn2.toString().match(/[^(]*\(([^)]*)/);
  if (!match) {
    return [];
  }
  const args = splitByComma(match[1]);
  if (!args.length) {
    return [];
  }
  const first = args[0];
  if (!(first.startsWith("{") && first.endsWith("}"))) {
    return [];
  }
  const props = splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => {
    return prop.replace(/:.*|=.*/g, "");
  });
  return props;
}
__name(getUsedProps, "getUsedProps");
function splitByComma(s2) {
  const result = [];
  const stack = [];
  let start = 0;
  for (let i = 0; i < s2.length; i++) {
    if (s2[i] === "{" || s2[i] === "[") {
      stack.push(s2[i] === "{" ? "}" : "]");
    } else if (s2[i] === stack[stack.length - 1]) {
      stack.pop();
    } else if (!stack.length && s2[i] === ",") {
      const token = s2.substring(start, i).trim();
      if (token) {
        result.push(token);
      }
      start = i + 1;
    }
  }
  const lastToken = s2.substring(start).trim();
  if (lastToken) {
    result.push(lastToken);
  }
  return result;
}
__name(splitByComma, "splitByComma");
function decorateStory(storyFn, decorator, bindWithContext) {
  const boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
__name(decorateStory, "decorateStory");
function sanitizeStoryContextUpdate({
  componentId,
  title,
  kind,
  id,
  name,
  story,
  parameters: parameters2,
  initialArgs,
  argTypes,
  ...update
} = {}) {
  return update;
}
__name(sanitizeStoryContextUpdate, "sanitizeStoryContextUpdate");
function defaultDecorateStory(storyFn, decorators4) {
  const contextStore = {};
  const bindWithContext = __name((decoratedStoryFn) => (update) => {
    if (!contextStore.value) {
      throw new Error("Decorated function called without init");
    }
    contextStore.value = {
      ...contextStore.value,
      ...sanitizeStoryContextUpdate(update)
    };
    return decoratedStoryFn(contextStore.value);
  }, "bindWithContext");
  const decoratedWithContextStore = decorators4.reduce(
    (story, decorator) => decorateStory(story, decorator, bindWithContext),
    storyFn
  );
  return (context) => {
    contextStore.value = context;
    return decoratedWithContextStore(context);
  };
}
__name(defaultDecorateStory, "defaultDecorateStory");
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  const { moduleExport, id, name } = storyAnnotations || {};
  const partialAnnotations = preparePartialAnnotations(
    storyAnnotations,
    componentAnnotations,
    projectAnnotations
  );
  const applyLoaders = __name(async (context) => {
    const loaded = {};
    for (const loaders2 of [
      normalizeArrays(projectAnnotations.loaders),
      normalizeArrays(componentAnnotations.loaders),
      normalizeArrays(storyAnnotations.loaders)
    ]) {
      if (context.abortSignal.aborted) {
        return loaded;
      }
      const loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
      Object.assign(loaded, ...loadResults);
    }
    return loaded;
  }, "applyLoaders");
  const applyBeforeEach = __name(async (context) => {
    const cleanupCallbacks = new Array();
    for (const beforeEach of [
      ...normalizeArrays(projectAnnotations.beforeEach),
      ...normalizeArrays(componentAnnotations.beforeEach),
      ...normalizeArrays(storyAnnotations.beforeEach)
    ]) {
      if (context.abortSignal.aborted) {
        return cleanupCallbacks;
      }
      const cleanup = await beforeEach(context);
      if (cleanup) {
        cleanupCallbacks.push(cleanup);
      }
    }
    return cleanupCallbacks;
  }, "applyBeforeEach");
  const applyAfterEach = __name(async (context) => {
    const reversedFinalizers = [
      ...normalizeArrays(projectAnnotations.afterEach),
      ...normalizeArrays(componentAnnotations.afterEach),
      ...normalizeArrays(storyAnnotations.afterEach)
    ].reverse();
    for (const finalizer of reversedFinalizers) {
      if (context.abortSignal.aborted) {
        return;
      }
      await finalizer(context);
    }
  }, "applyAfterEach");
  const undecoratedStoryFn = __name((context) => context.originalStoryFn(context.args, context), "undecoratedStoryFn");
  const { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations;
  const decorators4 = [
    ...normalizeArrays(storyAnnotations?.decorators),
    ...normalizeArrays(componentAnnotations?.decorators),
    ...normalizeArrays(projectAnnotations?.decorators)
  ];
  const render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators4);
  const unboundStoryFn = __name((context) => decoratedStoryFn(context), "unboundStoryFn");
  const playFunction = storyAnnotations?.play ?? componentAnnotations?.play;
  const usesMount = mountDestructured(playFunction);
  if (!render && !usesMount) {
    throw new import_preview_errors5.NoRenderFunctionError({ id });
  }
  const defaultMount = __name((context) => {
    return async () => {
      await context.renderToCanvas();
      return context.canvas;
    };
  }, "defaultMount");
  const mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount;
  const testingLibraryRender = projectAnnotations.testingLibraryRender;
  return {
    storyGlobals: {},
    ...partialAnnotations,
    moduleExport,
    id,
    name,
    story: name,
    originalStoryFn: render,
    undecoratedStoryFn,
    unboundStoryFn,
    applyLoaders,
    applyBeforeEach,
    applyAfterEach,
    playFunction,
    runStep,
    mount,
    testingLibraryRender,
    renderToCanvas: projectAnnotations.renderToCanvas,
    usesMount
  };
}
__name(prepareStory, "prepareStory");
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return {
    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
    moduleExport
  };
}
__name(prepareMeta, "prepareMeta");
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  const defaultTags = ["dev", "test"];
  const extraTags = import_global4.global.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [];
  const overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [];
  const tags = combineTags2(
    ...defaultTags,
    ...extraTags,
    ...projectAnnotations.tags ?? [],
    ...componentAnnotations.tags ?? [],
    ...overrideTags,
    ...storyAnnotations?.tags ?? []
  );
  const parameters2 = combineParameters(
    projectAnnotations.parameters,
    componentAnnotations.parameters,
    storyAnnotations?.parameters
  );
  const { argTypesEnhancers = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations;
  const passedArgTypes = combineParameters(
    projectAnnotations.argTypes,
    componentAnnotations.argTypes,
    storyAnnotations?.argTypes
  );
  if (storyAnnotations) {
    const render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
    parameters2.__isArgsStory = render && render.length > 0;
  }
  const passedArgs = {
    ...projectAnnotations.args,
    ...componentAnnotations.args,
    ...storyAnnotations?.args
  };
  const storyGlobals = {
    ...componentAnnotations.globals,
    ...storyAnnotations?.globals
  };
  const contextForEnhancers = {
    componentId: componentAnnotations.id,
    title: componentAnnotations.title,
    kind: componentAnnotations.title,
    // Back compat
    id: storyAnnotations?.id || componentAnnotations.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: storyAnnotations?.name || "__meta",
    story: storyAnnotations?.name || "__meta",
    // Back compat
    component: componentAnnotations.component,
    subcomponents: componentAnnotations.subcomponents,
    tags,
    parameters: parameters2,
    initialArgs: passedArgs,
    argTypes: passedArgTypes,
    storyGlobals
  };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce(
    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
    contextForEnhancers.argTypes
  );
  const initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
    (accumulatedArgs, enhancer) => ({
      ...accumulatedArgs,
      ...enhancer({
        ...contextForEnhancers,
        initialArgs: accumulatedArgs
      })
    }),
    initialArgsBeforeEnhancers
  );
  const { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
__name(preparePartialAnnotations, "preparePartialAnnotations");
function prepareContext(context) {
  const { args: unmappedArgs } = context;
  let targetedContext = {
    ...context,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (import_global3.global.FEATURES?.argTypeTargetsV7) {
    const argsByTarget = groupArgsByTarget(context);
    targetedContext = {
      ...context,
      allArgs: context.args,
      argsByTarget,
      args: argsByTarget[UNTARGETED] || {}
    };
  }
  const mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
    if (!targetedContext.argTypes[key]?.mapping) {
      acc[key] = val;
      return acc;
    }
    const mappingFn = __name((originalValue) => {
      const mapping = targetedContext.argTypes[key].mapping;
      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
    }, "mappingFn");
    acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val);
    return acc;
  }, {});
  const includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
    const argType = targetedContext.argTypes[key] || {};
    if (includeConditionalArg(argType, mappedArgs, targetedContext.globals)) {
      acc[key] = val;
    }
    return acc;
  }, {});
  return { ...targetedContext, unmappedArgs, args: includedArgs };
}
__name(prepareContext, "prepareContext");
var inferType = __name((value, name, visited) => {
  const type = typeof value;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type };
    default:
      break;
  }
  if (value) {
    if (visited.has(value)) {
      import_client_logger6.logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `);
      return { name: "other", value: "cyclic object" };
    }
    visited.add(value);
    if (Array.isArray(value)) {
      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" };
      return { name: "array", value: childType };
    }
    const fieldTypes = mapValues(value, (field) => inferType(field, name, new Set(visited)));
    return { name: "object", value: fieldTypes };
  }
  return { name: "object", value: {} };
}, "inferType");
var inferArgTypes = __name((context) => {
  const { id, argTypes: userArgTypes = {}, initialArgs = {} } = context;
  const argTypes = mapValues(initialArgs, (arg, key) => ({
    name: key,
    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())
  }));
  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
    name: key
  }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
}, "inferArgTypes");
inferArgTypes.secondPass = true;
var matches = __name((name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), "matches");
var filterArgTypes = __name((argTypes, include, exclude) => {
  if (!include && !exclude) {
    return argTypes;
  }
  return argTypes && pickBy(argTypes, (argType, key) => {
    const name = argType.name || key.toString();
    return !!(!include || matches(name, include)) && (!exclude || !matches(name, exclude));
  });
}, "filterArgTypes");
var inferControl = __name((argType, name, matchers) => {
  const { type, options } = argType;
  if (!type) {
    return void 0;
  }
  if (matchers.color && matchers.color.test(name)) {
    const controlType = type.name;
    if (controlType === "string") {
      return { control: { type: "color" } };
    }
    if (controlType !== "enum") {
      import_client_logger7.logger.warn(
        `Addon controls: Control of type color only supports string, received "${controlType}" instead`
      );
    }
  }
  if (matchers.date && matchers.date.test(name)) {
    return { control: { type: "date" } };
  }
  switch (type.name) {
    case "array":
      return { control: { type: "object" } };
    case "boolean":
      return { control: { type: "boolean" } };
    case "string":
      return { control: { type: "text" } };
    case "number":
      return { control: { type: "number" } };
    case "enum": {
      const { value } = type;
      return { control: { type: value?.length <= 5 ? "radio" : "select" }, options: value };
    }
    case "function":
    case "symbol":
      return null;
    default:
      return { control: { type: options ? "select" : "object" } };
  }
}, "inferControl");
var inferControls = __name((context) => {
  const {
    argTypes,
    parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }
  } = context;
  if (!__isArgsStory) {
    return argTypes;
  }
  const filteredArgTypes = filterArgTypes(argTypes, include, exclude);
  const withControls = mapValues(filteredArgTypes, (argType, name) => {
    return argType?.type && inferControl(argType, name.toString(), matchers);
  });
  return combineParameters(withControls, filteredArgTypes);
}, "inferControls");
inferControls.secondPass = true;
function normalizeProjectAnnotations({
  argTypes,
  globalTypes,
  argTypesEnhancers,
  decorators: decorators4,
  loaders: loaders2,
  beforeEach,
  afterEach,
  initialGlobals: initialGlobals5,
  ...annotations
}) {
  return {
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
    decorators: normalizeArrays(decorators4),
    loaders: normalizeArrays(loaders2),
    beforeEach: normalizeArrays(beforeEach),
    afterEach: normalizeArrays(afterEach),
    argTypesEnhancers: [
      ...argTypesEnhancers || [],
      inferArgTypes,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      inferControls
    ],
    initialGlobals: initialGlobals5,
    ...annotations
  };
}
__name(normalizeProjectAnnotations, "normalizeProjectAnnotations");
var composeBeforeAllHooks = __name((hooks) => {
  return async () => {
    const cleanups2 = [];
    for (const hook of hooks) {
      const cleanup = await hook();
      if (cleanup) {
        cleanups2.unshift(cleanup);
      }
    }
    return async () => {
      for (const cleanup of cleanups2) {
        await cleanup();
      }
    };
  };
}, "composeBeforeAllHooks");
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    const composedPlay = stepRunners.reduceRight(
      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
      async () => play(playContext)
    );
    await composedPlay();
  };
}
__name(composeStepRunners, "composeStepRunners");
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
}
__name(getField, "getField");
function getArrayField(moduleExportList, field, options = {}) {
  return getField(moduleExportList, field).reduce((prev, cur) => {
    const normalized = normalizeArrays(cur);
    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
  }, []);
}
__name(getArrayField, "getArrayField");
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
__name(getObjectField, "getObjectField");
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
__name(getSingletonField, "getSingletonField");
function composeConfigs(moduleExportList) {
  const allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers");
  const stepRunners = getField(moduleExportList, "runStep");
  const beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
  return {
    parameters: combineParameters(...getField(moduleExportList, "parameters")),
    decorators: getArrayField(moduleExportList, "decorators", {
      reverseFileOrder: !(import_global5.global.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: getObjectField(moduleExportList, "args"),
    argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
    argTypes: getObjectField(moduleExportList, "argTypes"),
    argTypesEnhancers: [
      ...allArgTypeEnhancers.filter((e) => !e.secondPass),
      ...allArgTypeEnhancers.filter((e) => e.secondPass)
    ],
    initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
    globalTypes: getObjectField(moduleExportList, "globalTypes"),
    loaders: getArrayField(moduleExportList, "loaders"),
    beforeAll: composeBeforeAllHooks(beforeAllHooks),
    beforeEach: getArrayField(moduleExportList, "beforeEach"),
    afterEach: getArrayField(moduleExportList, "afterEach"),
    render: getSingletonField(moduleExportList, "render"),
    renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
    applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
    runStep: composeStepRunners(stepRunners),
    tags: getArrayField(moduleExportList, "tags"),
    mount: getSingletonField(moduleExportList, "mount"),
    testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
  };
}
__name(composeConfigs, "composeConfigs");
var _ReporterAPI = class _ReporterAPI2 {
  constructor() {
    this.reports = [];
  }
  async addReport(report) {
    this.reports.push(report);
  }
};
__name(_ReporterAPI, "ReporterAPI");
var ReporterAPI = _ReporterAPI;
function getCsfFactoryAnnotations(story, meta, projectAnnotations) {
  return isStory(story) ? {
    story: story.input,
    meta: story.meta.input,
    preview: story.meta.preview.composed
  } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };
}
__name(getCsfFactoryAnnotations, "getCsfFactoryAnnotations");
function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
}
__name(setDefaultProjectAnnotations, "setDefaultProjectAnnotations");
var DEFAULT_STORY_TITLE = "ComposedStory";
var DEFAULT_STORY_NAME = "Unnamed Story";
function extractAnnotation(annotation) {
  if (!annotation) {
    return {};
  }
  return composeConfigs([annotation]);
}
__name(extractAnnotation, "extractAnnotation");
function setProjectAnnotations(projectAnnotations) {
  const annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
  globalThis.globalProjectAnnotations = composeConfigs([
    ...getCoreAnnotations(),
    globalThis.defaultProjectAnnotations ?? {},
    composeConfigs(annotations.map(extractAnnotation))
  ]);
  return globalThis.globalProjectAnnotations ?? {};
}
__name(setProjectAnnotations, "setProjectAnnotations");
var cleanups = [];
function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {
  if (storyAnnotations === void 0) {
    throw new Error("Expected a story but received undefined.");
  }
  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
  const normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations);
  const storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME;
  const normalizedStory = normalizeStory(
    storyName,
    storyAnnotations,
    normalizedComponentAnnotations
  );
  const normalizedProjectAnnotations = normalizeProjectAnnotations(
    composeConfigs([
      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},
      projectAnnotations ?? {}
    ])
  );
  const story = prepareStory(
    normalizedStory,
    normalizedComponentAnnotations,
    normalizedProjectAnnotations
  );
  const globalsFromGlobalTypes = getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes);
  const globals = {
    ...globalsFromGlobalTypes,
    ...normalizedProjectAnnotations.initialGlobals,
    ...story.storyGlobals
  };
  const reporting = new ReporterAPI();
  const initializeContext = __name(() => {
    const context = prepareContext({
      hooks: new HooksContext(),
      globals,
      args: { ...story.initialArgs },
      viewMode: "story",
      reporting,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: __name((label, play2) => story.runStep(label, play2, context), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: normalizedProjectAnnotations.globalTypes,
      ...story,
      context: null,
      mount: null
    });
    context.parameters.__isPortableStory = true;
    context.context = context;
    if (story.renderToCanvas) {
      context.renderToCanvas = async () => {
        const unmount = await story.renderToCanvas?.(
          {
            componentId: story.componentId,
            title: story.title,
            id: story.id,
            name: story.name,
            tags: story.tags,
            showMain: __name(() => {
            }, "showMain"),
            showError: __name((error) => {
              throw new Error(`${error.title}
${error.description}`);
            }, "showError"),
            showException: __name((error) => {
              throw error;
            }, "showException"),
            forceRemount: true,
            storyContext: context,
            storyFn: __name(() => story.unboundStoryFn(context), "storyFn"),
            unboundStoryFn: story.unboundStoryFn
          },
          context.canvasElement
        );
        if (unmount) {
          cleanups.push(unmount);
        }
      };
    }
    context.mount = story.mount(context);
    return context;
  }, "initializeContext");
  let loadedContext;
  const play = __name(async (extraContext) => {
    const context = initializeContext();
    context.canvasElement ??= globalThis?.document?.body;
    if (loadedContext) {
      context.loaded = loadedContext.loaded;
    }
    Object.assign(context, extraContext);
    return story.playFunction(context);
  }, "play");
  const run = __name((extraContext) => {
    const context = initializeContext();
    Object.assign(context, extraContext);
    return runStory(story, context);
  }, "run");
  const playFunction = story.playFunction ? play : void 0;
  const composedStory = Object.assign(
    __name(function storyFn(extraArgs) {
      const context = initializeContext();
      if (loadedContext) {
        context.loaded = loadedContext.loaded;
      }
      context.args = {
        ...context.initialArgs,
        ...extraArgs
      };
      return story.unboundStoryFn(context);
    }, "storyFn"),
    {
      id: story.id,
      storyName,
      load: __name(async () => {
        for (const callback of [...cleanups].reverse()) {
          await callback();
        }
        cleanups.length = 0;
        const context = initializeContext();
        context.loaded = await story.applyLoaders(context);
        cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
        loadedContext = context;
      }, "load"),
      globals,
      args: story.initialArgs,
      parameters: story.parameters,
      argTypes: story.argTypes,
      play: playFunction,
      run,
      reporting,
      tags: story.tags
    }
  );
  return composedStory;
}
__name(composeStory, "composeStory");
var defaultComposeStory = __name((story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName), "defaultComposeStory");
function composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {
  const { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport;
  let meta = metaExport;
  const composedStories = Object.entries(stories).reduce(
    (storiesMap, [exportsName, story]) => {
      const { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);
      if (!meta && componentAnnotations) {
        meta = componentAnnotations;
      }
      if (!isExportStory(exportsName, meta)) {
        return storiesMap;
      }
      const result = Object.assign(storiesMap, {
        [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)
      });
      return result;
    },
    {}
  );
  return composedStories;
}
__name(composeStories, "composeStories");
function createPlaywrightTest(baseTest) {
  return baseTest.extend({
    mount: __name(async ({ mount, page }, use) => {
      await use(async (storyRef, ...restArgs) => {
        if (!("__pw_type" in storyRef) || "__pw_type" in storyRef && storyRef.__pw_type !== "jsx") {
          throw new Error(dedent`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        }
        const { props, ...storyRefWithoutProps } = storyRef;
        await page.evaluate(async (wrappedStoryRef) => {
          const unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
          const story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef;
          return story?.load?.();
        }, storyRefWithoutProps);
        const mountResult = await mount(storyRef, ...restArgs);
        await page.evaluate(async (wrappedStoryRef) => {
          const unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
          const story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef;
          const canvasElement = document.querySelector("#root");
          return story?.play?.({ canvasElement });
        }, storyRefWithoutProps);
        return mountResult;
      });
    }, "mount")
  });
}
__name(createPlaywrightTest, "createPlaywrightTest");
async function runStory(story, context) {
  for (const callback of [...cleanups].reverse()) {
    await callback();
  }
  cleanups.length = 0;
  if (!context.canvasElement) {
    const container = document.createElement("div");
    globalThis?.document?.body?.appendChild(container);
    context.canvasElement = container;
    cleanups.push(() => {
      if (globalThis?.document?.body?.contains(container)) {
        globalThis?.document?.body?.removeChild(container);
      }
    });
  }
  context.loaded = await story.applyLoaders(context);
  if (context.abortSignal.aborted) {
    return;
  }
  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
  const playFunction = story.playFunction;
  const isMountDestructured = story.usesMount;
  if (!isMountDestructured) {
    await context.mount();
  }
  if (context.abortSignal.aborted) {
    return;
  }
  if (playFunction) {
    if (!isMountDestructured) {
      context.mount = async () => {
        throw new import_preview_errors6.MountMustBeDestructuredError({ playFunction: playFunction.toString() });
      };
    }
    await playFunction(context);
  }
  let cleanUp;
  if (isTestEnvironment()) {
    cleanUp = pauseAnimations();
  } else {
    await waitForAnimations(context.abortSignal);
  }
  await story.applyAfterEach(context);
  await cleanUp?.();
}
__name(runStory, "runStory");
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var _StoryStore = class _StoryStore2 {
  constructor(storyIndex, importFn, projectAnnotations) {
    this.importFn = importFn;
    this.storyIndex = new StoryIndexStore(storyIndex);
    this.projectAnnotations = normalizeProjectAnnotations(
      composeConfigs([...getCoreAnnotations(), projectAnnotations])
    );
    const { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
    this.args = new ArgsStore();
    this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes });
    this.hooks = {};
    this.cleanupCallbacks = {};
    this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile);
    this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta);
    this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    const { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
    this.userGlobals.set({ globals: initialGlobals5, globalTypes });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (importFn) {
      this.importFn = importFn;
    }
    if (storyIndex) {
      this.storyIndex.entries = storyIndex.entries;
    }
    if (this.cachedCSFFiles) {
      await this.cacheAllCSFFiles();
    }
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(storyId) {
    return this.storyIndex.storyIdToEntry(storyId);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(storyId) {
    const { importPath, title } = this.storyIndex.storyIdToEntry(storyId);
    const moduleExports = await this.importFn(importPath);
    return this.processCSFFileWithCache(moduleExports, importPath, title);
  }
  async loadAllCSFFiles() {
    const importPaths = {};
    Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
      importPaths[importPath] = storyId;
    });
    const list = await Promise.all(
      Object.entries(importPaths).map(async ([importPath, storyId]) => ({
        importPath,
        csfFile: await this.loadCSFFileByStoryId(storyId)
      }))
    );
    return list.reduce(
      (acc, { importPath, csfFile }) => {
        acc[importPath] = csfFile;
        return acc;
      },
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile }) {
    const componentAnnotations = csfFile.meta;
    return this.prepareMetaWithCache(
      componentAnnotations,
      this.projectAnnotations,
      csfFile.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId }) {
    const csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId,
    csfFile
  }) {
    const storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations) {
      throw new import_preview_errors3.MissingStoryFromCsfFileError({ storyId });
    }
    const componentAnnotations = csfFile.meta;
    const story = this.prepareStoryWithCache(
      storyAnnotations,
      componentAnnotations,
      csfFile.projectAnnotations ?? this.projectAnnotations
    );
    this.args.setInitial(story);
    this.hooks[story.id] = this.hooks[story.id] || new HooksContext();
    return story;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile
  }) {
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    const entry = await this.storyIdToEntry(id);
    const storyImports = entry.type === "docs" ? entry.storiesImports : [];
    const [entryExports, ...csfFiles] = await Promise.all([
      this.importFn(entry.importPath),
      ...storyImports.map((storyImportPath) => {
        const firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
        return this.loadCSFFileByStoryId(firstStoryEntry.id);
      })
    ]);
    return { entryExports, csfFiles };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    const userGlobals = this.userGlobals.get();
    const { initialGlobals: initialGlobals5 } = this.userGlobals;
    const reporting = new ReporterAPI();
    return prepareContext({
      ...story,
      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
      initialGlobals: initialGlobals5,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals,
      reporting,
      globals: {
        ...userGlobals,
        ...story.storyGlobals
      },
      hooks: this.hooks[story.id]
    });
  }
  addCleanupCallbacks(story, ...callbacks) {
    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
  }
  async cleanupStory(story) {
    this.hooks[story.id].clean();
    const callbacks = this.cleanupCallbacks[story.id];
    if (callbacks) {
      for (const callback of [...callbacks].reverse()) {
        await callback();
      }
    }
    delete this.cleanupCallbacks[story.id];
  }
  extract(options = { includeDocsOnly: false }) {
    const { cachedCSFFiles } = this;
    console.log("extract: extracting stories", cachedCSFFiles);
    if (!cachedCSFFiles) {
      throw new import_preview_errors3.CalledExtractOnStoreError();
    }
    const stories = Object.entries(this.storyIndex.entries).reduce(
      (acc, [storyId, entry]) => {
        if (entry.type === "docs") {
          return acc;
        }
        const csfFile = cachedCSFFiles[entry.importPath];
        const story = this.storyFromCSFFile({ storyId, csfFile });
        if (!options.includeDocsOnly && story.parameters.docsOnly) {
          return acc;
        }
        acc[storyId] = Object.entries(story).reduce(
          (storyAcc, [key, value]) => {
            if (key === "story" && entry.subtype === "test") {
              return { ...storyAcc, story: entry.parentName };
            }
            if (key === "moduleExport") {
              return storyAcc;
            }
            if (typeof value === "function") {
              return storyAcc;
            }
            if (Array.isArray(value)) {
              return Object.assign(storyAcc, { [key]: value.slice().sort() });
            }
            return Object.assign(storyAcc, { [key]: value });
          },
          {
            args: story.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...story.storyGlobals
            },
            storyId: entry.parent ? entry.parent : storyId
          }
        );
        return acc;
      },
      {}
    );
    console.log("extract: stories", stories);
    return stories;
  }
};
__name(_StoryStore, "StoryStore");
var StoryStore = _StoryStore;
function slash(path) {
  const isExtendedLengthPath = path.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path;
  }
  return path.replace(/\\/g, "/");
}
__name(slash, "slash");
var sanitize2 = __name((parts) => {
  if (parts.length === 0) {
    return parts;
  }
  const last = parts[parts.length - 1];
  const lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (parts.length === 1) {
    return [lastStripped];
  }
  const nextToLast = parts[parts.length - 2];
  if (lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase()) {
    return [...parts.slice(0, -2), lastStripped];
  }
  return lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
}, "sanitize");
function pathJoin(paths) {
  return paths.flatMap((p2) => p2.split("/")).filter(Boolean).join("/");
}
__name(pathJoin, "pathJoin");
var userOrAutoTitleFromSpecifier = __name((fileName, entry, userTitle) => {
  const { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  if (typeof fileName === "number") {
    import_client_logger8.once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  }
  const normalizedFileName = slash(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      const suffix = normalizedFileName.replace(directory, "");
      let parts = pathJoin([titlePrefix, suffix]).split("/");
      parts = sanitize2(parts);
      return parts.join("/");
    }
    if (!titlePrefix) {
      return userTitle;
    }
    return pathJoin([titlePrefix, userTitle]);
  }
  return void 0;
}, "userOrAutoTitleFromSpecifier");
var userOrAutoTitle = __name((fileName, storiesEntries, userTitle) => {
  for (let i = 0; i < storiesEntries.length; i += 1) {
    const title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);
    if (title) {
      return title;
    }
  }
  return userTitle || void 0;
}, "userOrAutoTitle");
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var storySort = __name((options = {}) => (a2, b) => {
  if (a2.title === b.title && !options.includeNames) {
    return 0;
  }
  const method = options.method || "configure";
  let order = options.order || [];
  const storyTitleA = a2.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  const storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  if (options.includeNames) {
    storyTitleA.push(a2.name);
    storyTitleB.push(b.name);
  }
  let depth = 0;
  while (storyTitleA[depth] || storyTitleB[depth]) {
    if (!storyTitleA[depth]) {
      return -1;
    }
    if (!storyTitleB[depth]) {
      return 1;
    }
    const nameA = storyTitleA[depth];
    const nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA);
      let indexB = order.indexOf(nameB);
      const indexWildcard = order.indexOf("*");
      if (indexA !== -1 || indexB !== -1) {
        if (indexA === -1) {
          if (indexWildcard !== -1) {
            indexA = indexWildcard;
          } else {
            indexA = order.length;
          }
        }
        if (indexB === -1) {
          if (indexWildcard !== -1) {
            indexB = indexWildcard;
          } else {
            indexB = order.length;
          }
        }
        return indexA - indexB;
      }
      if (method === "configure") {
        return 0;
      }
      return nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let index2 = order.indexOf(nameA);
    if (index2 === -1) {
      index2 = order.indexOf("*");
    }
    order = index2 !== -1 && Array.isArray(order[index2 + 1]) ? order[index2 + 1] : [];
    depth += 1;
  }
  return 0;
}, "storySort");
var sortStoriesCommon = __name((stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    if (typeof storySortParameter === "function") {
      sortFn = storySortParameter;
    } else {
      sortFn = storySort(storySortParameter);
    }
    stories.sort(sortFn);
  } else {
    stories.sort(
      (s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath)
    );
  }
  return stories;
}, "sortStoriesCommon");
var sortStoriesV7 = __name((stories, storySortParameter, fileNameOrder) => {
  try {
    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
  } catch (err) {
    throw new Error(dedent`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");
var PREPARE_ABORTED = new Error("prepareAborted");
var { AbortController: AbortController2 } = globalThis;
function serializeError(error) {
  try {
    const { name = "Error", message = String(error), stack } = error;
    return { name, message, stack };
  } catch (e) {
    return { name: "Error", message: String(error) };
  }
}
__name(serializeError, "serializeError");
var _StoryRender = class _StoryRender2 {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = __name(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new AbortController2();
    this.renderId = Date.now();
    if (story) {
      this.story = story;
      this.phase = "preparing";
    }
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase;
    this.channel.emit(import_core_events3.STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    });
    if (phaseFn) {
      await phaseFn();
      this.checkIfAborted(signal);
    }
  }
  checkIfAborted(signal) {
    if (signal.aborted && !["finished", "aborted", "errored"].includes(this.phase)) {
      this.phase = "aborted";
      this.channel.emit(import_core_events3.STORY_RENDER_PHASE_CHANGED, {
        newPhase: this.phase,
        renderId: this.renderId,
        storyId: this.id
      });
    }
    return signal.aborted;
  }
  async prepare() {
    await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    });
    if (this.abortController.signal.aborted) {
      await this.store.cleanupStory(this.story);
      throw PREPARE_ABORTED;
    }
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(canvasElement) {
    this.canvasElement = canvasElement;
    return this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story) {
      throw new Error(`Cannot call storyContext before preparing`);
    }
    const { forceInitialArgs } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs });
  }
  async render({
    initial = false,
    forceRemount = false
  } = {}) {
    const { canvasElement } = this;
    if (!this.story) {
      throw new Error("cannot render when not prepared");
    }
    const story = this.story;
    if (!canvasElement) {
      throw new Error("cannot render when canvasElement is unset");
    }
    const {
      id,
      componentId,
      title,
      name,
      tags,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      unboundStoryFn,
      playFunction,
      runStep
    } = story;
    if (forceRemount && !initial) {
      this.cancelRender();
      this.abortController = new AbortController2();
    }
    const abortSignal = this.abortController.signal;
    let mounted = false;
    const isMountDestructured = story.usesMount;
    try {
      const context = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal,
        canvasElement,
        loaded: {},
        step: __name((label, play) => runStep(label, play, context), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: __name(async () => {
          const teardown = await this.renderToScreen(renderContext, canvasElement);
          this.teardownRender = teardown || (() => {
          });
          mounted = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: __name(async (...args) => {
          this.callbacks.showStoryDuringRender?.();
          let mountReturn = null;
          await this.runPhase(abortSignal, "rendering", async () => {
            mountReturn = await story.mount(context)(...args);
          });
          if (isMountDestructured) {
            await this.runPhase(abortSignal, "playing");
          }
          return mountReturn;
        }, "mount")
      };
      context.context = context;
      const renderContext = {
        componentId,
        title,
        kind: title,
        id,
        name,
        story: name,
        tags,
        ...this.callbacks,
        showError: __name((error) => {
          this.phase = "errored";
          return this.callbacks.showError(error);
        }, "showError"),
        showException: __name((error) => {
          this.phase = "errored";
          return this.callbacks.showException(error);
        }, "showException"),
        forceRemount: forceRemount || this.notYetRendered,
        storyContext: context,
        storyFn: __name(() => unboundStoryFn(context), "storyFn"),
        unboundStoryFn
      };
      await this.runPhase(abortSignal, "loading", async () => {
        context.loaded = await applyLoaders(context);
      });
      if (abortSignal.aborted) {
        return;
      }
      const cleanupCallbacks = await applyBeforeEach(context);
      this.store.addCleanupCallbacks(story, ...cleanupCallbacks);
      if (this.checkIfAborted(abortSignal)) {
        return;
      }
      if (!mounted && !isMountDestructured) {
        await context.mount();
      }
      this.notYetRendered = false;
      if (abortSignal.aborted) {
        return;
      }
      const ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true;
      const unhandledErrors = /* @__PURE__ */ new Set();
      const onError = __name((event) => {
        if (event.error) {
          unhandledErrors.add(event.error);
        }
      }, "onError");
      const onUnhandledRejection = __name((event) => {
        if (event.reason) {
          unhandledErrors.add(event.reason);
        }
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        window?.addEventListener?.("error", onError);
        window?.addEventListener?.("unhandledrejection", onUnhandledRejection);
        this.disableKeyListeners = true;
        try {
          if (!isMountDestructured) {
            context.mount = async () => {
              throw new import_preview_errors8.MountMustBeDestructuredError({ playFunction: playFunction.toString() });
            };
            await this.runPhase(abortSignal, "playing", async () => playFunction(context));
          } else {
            await playFunction(context);
          }
          if (!mounted) {
            throw new import_preview_errors8.NoStoryMountedError();
          }
          this.checkIfAborted(abortSignal);
          if (!ignoreUnhandledErrors && unhandledErrors.size > 0) {
            await this.runPhase(abortSignal, "errored");
          } else {
            await this.runPhase(abortSignal, "played");
          }
        } catch (error) {
          this.callbacks.showStoryDuringRender?.();
          await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(import_core_events3.PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          });
          if (this.story.parameters.throwPlayFunctionExceptions !== false) {
            throw error;
          }
          console.error(error);
        }
        if (!ignoreUnhandledErrors && unhandledErrors.size > 0) {
          this.channel.emit(
            import_core_events3.UNHANDLED_ERRORS_WHILE_PLAYING,
            Array.from(unhandledErrors).map(serializeError)
          );
        }
        this.disableKeyListeners = false;
        window?.removeEventListener?.("unhandledrejection", onUnhandledRejection);
        window?.removeEventListener?.("error", onError);
        if (abortSignal.aborted) {
          return;
        }
      }
      await this.runPhase(abortSignal, "completing", async () => {
        if (isTestEnvironment()) {
          this.store.addCleanupCallbacks(story, pauseAnimations());
        } else {
          await waitForAnimations(abortSignal);
        }
      });
      await this.runPhase(abortSignal, "completed", async () => {
        this.channel.emit(import_core_events3.STORY_RENDERED, id);
      });
      if (this.phase !== "errored") {
        await this.runPhase(abortSignal, "afterEach", async () => {
          await applyAfterEach(context);
        });
      }
      const hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0;
      const hasSomeReportsFailed = context.reporting.reports.some(
        (report) => report.status === "failed"
      );
      const hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(import_core_events3.STORY_FINISHED, {
          storyId: id,
          status: hasStoryErrored ? "error" : "success",
          reporters: context.reporting.reports
        })
      );
    } catch (err) {
      this.phase = "errored";
      this.callbacks.showException(err);
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(import_core_events3.STORY_FINISHED, {
          storyId: id,
          status: "error",
          reporters: []
        })
      );
    }
    if (this.rerenderEnqueued) {
      this.rerenderEnqueued = false;
      this.render();
    }
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing") {
      this.rerenderEnqueued = true;
    } else {
      return this.render();
    }
  }
  async remount() {
    await this.teardown();
    return this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    if (this.phase === "playing") {
      this.abortController.abort();
      this.runPhase(this.abortController.signal, "aborted");
    }
  }
  async teardown() {
    this.torndown = true;
    this.cancelRender();
    if (this.story) {
      await this.store.cleanupStory(this.story);
    }
    for (let i = 0; i < 3; i += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window?.location?.reload?.();
    await new Promise(() => {
    });
  }
};
__name(_StoryRender, "StoryRender");
var StoryRender = _StoryRender;
var { fetch } = import_global6.global;
var STORY_INDEX_PATH = "./index.json";
var _Preview = class _Preview2 {
  constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = true) {
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.channel = channel;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((resolve, reject) => {
      this.resolveStoreInitializationPromise = resolve;
      this.rejectStoreInitializationPromise = reject;
    });
    if (shouldInitialize) {
      this.initialize();
    }
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: __name((_, method) => {
          if (this.storyStoreValue) {
            (0, import_client_logger9.deprecate)("Accessing the Story Store is deprecated and will be removed in 9.0");
            return this.storyStoreValue[method];
          }
          throw new import_preview_errors7.StoryStoreAccessedBeforeInitializationError();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      const projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(projectAnnotations);
      await this.initializeWithProjectAnnotations(projectAnnotations);
      const userAgent = globalThis?.navigator?.userAgent;
      await this.channel.emit(import_core_events2.PREVIEW_INITIALIZED, { userAgent });
    } catch (err) {
      this.rejectStoreInitializationPromise(err);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(import_core_events2.STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));
    this.channel.on(import_core_events2.UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));
    this.channel.on(import_core_events2.UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));
    this.channel.on(import_core_events2.ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this));
    this.channel.on(import_core_events2.RESET_STORY_ARGS, this.onResetArgs.bind(this));
    this.channel.on(import_core_events2.FORCE_RE_RENDER, this.onForceReRender.bind(this));
    this.channel.on(import_core_events2.FORCE_REMOUNT, this.onForceRemount.bind(this));
    this.channel.on(import_core_events2.STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      const projectAnnotations = await this.getProjectAnnotations();
      this.renderToCanvas = projectAnnotations.renderToCanvas;
      if (!this.renderToCanvas) {
        throw new import_preview_errors7.MissingRenderToCanvasError();
      }
      return projectAnnotations;
    } catch (err) {
      this.renderPreviewEntryError("Error reading preview.js:", err);
      throw err;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(projectAnnotations) {
    this.projectAnnotationsBeforeInitialization = projectAnnotations;
    try {
      const storyIndex = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(storyIndex);
    } catch (err) {
      this.renderPreviewEntryError("Error loading story index:", err);
      throw err;
    }
  }
  async runBeforeAllHook(projectAnnotations) {
    try {
      await this.beforeAllCleanup?.();
      this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
    } catch (err) {
      this.renderPreviewEntryError("Error in beforeAll hook:", err);
      throw err;
    }
  }
  async getStoryIndexFromServer() {
    const result = await fetch(STORY_INDEX_PATH);
    if (result.status === 200) {
      return result.json();
    }
    throw new import_preview_errors7.StoryIndexFetchError({ text: await result.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(storyIndex) {
    if (!this.projectAnnotationsBeforeInitialization) {
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    }
    this.storyStoreValue = new StoryStore(
      storyIndex,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    );
    delete this.projectAnnotationsBeforeInitialization;
    this.setInitialGlobals();
    this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
    }
    const payload = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(import_core_events2.SET_GLOBALS, payload);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    delete this.previewEntryError;
    this.getProjectAnnotations = getProjectAnnotations;
    const projectAnnotations = await this.getProjectAnnotationsOrRenderError();
    await this.runBeforeAllHook(projectAnnotations);
    if (!this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(projectAnnotations);
    this.emitGlobals();
  }
  async onStoryIndexChanged() {
    delete this.previewEntryError;
    if (!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization) {
      return;
    }
    try {
      const storyIndex = await this.getStoryIndexFromServer();
      if (this.projectAnnotationsBeforeInitialization) {
        this.initializeWithStoryIndex(storyIndex);
        return;
      }
      await this.onStoriesChanged({ storyIndex });
    } catch (err) {
      this.renderPreviewEntryError("Error loading story index:", err);
      throw err;
    }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
    }
    await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({
    globals: updatedGlobals,
    currentStory
  }) {
    if (!this.storyStoreValue) {
      await this.storeInitializationPromise;
    }
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
    }
    this.storyStoreValue.userGlobals.update(updatedGlobals);
    if (currentStory) {
      const { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
      this.channel.emit(import_core_events2.GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      });
    } else {
      const { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(import_core_events2.GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals: globals,
        storyGlobals: {},
        globals
      });
    }
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
    }
    this.storyStoreValue.args.update(storyId, updatedArgs);
    await Promise.all(
      this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map(
        (r) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r.story && r.story.usesMount ? r.remount() : r.rerender()
        )
      )
    );
    this.channel.emit(import_core_events2.STORY_ARGS_UPDATED, {
      storyId,
      args: this.storyStoreValue.args.get(storyId)
    });
  }
  async onRequestArgTypesInfo({ id, payload }) {
    try {
      await this.storeInitializationPromise;
      const story = await this.storyStoreValue?.loadStory(payload);
      this.channel.emit(import_core_events2.ARGTYPES_INFO_RESPONSE, {
        id,
        success: true,
        payload: { argTypes: story?.argTypes || {} },
        error: null
      });
    } catch (e) {
      this.channel.emit(import_core_events2.ARGTYPES_INFO_RESPONSE, {
        id,
        success: false,
        error: e?.message
      });
    }
  }
  async onResetArgs({ storyId, argNames }) {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
    }
    const render = this.storyRenders.find((r) => r.id === storyId);
    const story = render?.story || await this.storyStoreValue.loadStory({ storyId });
    const argNamesToReset = argNames || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(story.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(storyId))
      ])
    ];
    const updatedArgs = argNamesToReset.reduce((acc, argName) => {
      acc[argName] = story.initialArgs[argName];
      return acc;
    }, {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((r) => r.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(story, element, callbacks, options) {
    if (!this.renderToCanvas || !this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({
        methodName: "renderStoryToElement"
      });
    }
    const render = new StoryRender(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      callbacks,
      story.id,
      "docs",
      options,
      story
    );
    render.renderToElement(element);
    this.storyRenders.push(render);
    return async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== render);
    await render?.teardown?.({ viewModeChanged });
  }
  // API
  async loadStory({ storyId }) {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
    }
    return this.storyStoreValue.loadStory({ storyId });
  }
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
    }
    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
  }
  async extract(options) {
    if (!this.storyStoreValue) {
      throw new import_preview_errors7.CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
    }
    if (this.previewEntryError) {
      throw this.previewEntryError;
    }
    await this.storyStoreValue.cacheAllCSFFiles();
    return this.storyStoreValue.extract(options);
  }
  // UTILITIES
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err;
    import_client_logger9.logger.error(reason);
    import_client_logger9.logger.error(err);
    this.channel.emit(import_core_events2.CONFIG_ERROR, err);
  }
};
__name(_Preview, "Preview");
var Preview = _Preview;
var _DocsContext = class _DocsContext2 {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = __name((storyName) => {
      const storyId = this.nameToStoryId.get(storyName);
      if (storyId) {
        return storyId;
      }
      throw new Error(`No story found with that name: ${storyName}`);
    }, "storyIdByName");
    this.componentStories = __name(() => {
      return this.componentStoriesValue;
    }, "componentStories");
    this.componentStoriesFromCSFFile = __name((csfFile) => {
      return this.store.componentStoriesFromCSFFile({ csfFile });
    }, "componentStoriesFromCSFFile");
    this.storyById = __name((storyId) => {
      if (!storyId) {
        if (!this.primaryStory) {
          throw new Error(
            `No primary story defined for docs entry. Did you forget to use \`<Meta>\`?`
          );
        }
        return this.primaryStory;
      }
      const csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile) {
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      }
      return this.store.storyFromCSFFile({ storyId, csfFile });
    }, "storyById");
    this.getStoryContext = __name((story) => {
      return {
        ...this.store.getStoryContext(story),
        loaded: {},
        viewMode: "docs"
      };
    }, "getStoryContext");
    this.loadStory = __name((id) => {
      return this.store.loadStory({ storyId: id });
    }, "loadStory");
    this.componentStoriesValue = [];
    this.storyIdToCSFFile = /* @__PURE__ */ new Map();
    this.exportToStory = /* @__PURE__ */ new Map();
    this.exportsToCSFFile = /* @__PURE__ */ new Map();
    this.nameToStoryId = /* @__PURE__ */ new Map();
    this.attachedCSFFiles = /* @__PURE__ */ new Set();
    csfFiles.forEach((csfFile, index2) => {
      this.referenceCSFFile(csfFile);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile);
    this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile);
    const stories = this.store.componentStoriesFromCSFFile({ csfFile });
    stories.forEach((story) => {
      const annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile);
      this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports)) {
      throw new Error("Cannot attach a CSF file that has not been referenced");
    }
    if (this.attachedCSFFiles.has(csfFile)) {
      return;
    }
    this.attachedCSFFiles.add(csfFile);
    const stories = this.store.componentStoriesFromCSFFile({ csfFile });
    stories.forEach((story) => {
      this.nameToStoryId.set(story.name, story.id);
      this.componentStoriesValue.push(story);
      if (!this.primaryStory) {
        this.primaryStory = story;
      }
    });
  }
  referenceMeta(metaExports, attach) {
    const resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta") {
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    }
    if (attach) {
      this.attachCSFFile(resolved.csfFile);
    }
  }
  get projectAnnotations() {
    const { projectAnnotations } = this.store;
    if (!projectAnnotations) {
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    }
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory) {
        throw new Error(
          `No primary story attached to this docs file, did you forget to use <Meta of={} />?`
        );
      }
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0) {
      throw new Error(
        `No CSF file attached to this docs file, did you forget to use <Meta of={} />?`
      );
    }
    const firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
    if (moduleExportType === "meta") {
      return { type: "meta", csfFile: firstAttachedCSFFile };
    }
    const { component } = firstAttachedCSFFile.meta;
    if (!component) {
      throw new Error(
        `Attached CSF file does not defined a component, did you forget to export one?`
      );
    }
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    const csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (csfFile) {
      return { type: "meta", csfFile };
    }
    const story = this.exportToStory.get(
      isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
    );
    if (story) {
      return { type: "story", story };
    }
    return { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      const type = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type);
    } else {
      resolved = this.resolveModuleExport(moduleExportOrType);
    }
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      const prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (resolved.type) {
      case "component": {
        return {
          ...resolved,
          projectAnnotations: this.projectAnnotations
        };
      }
      case "meta": {
        return {
          ...resolved,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
        };
      }
      case "story":
      default: {
        return resolved;
      }
    }
  }
};
__name(_DocsContext, "DocsContext");
var DocsContext = _DocsContext;
var _CsfDocsRender = class _CsfDocsRender2 {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
    this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    const { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown) {
      throw PREPARE_ABORTED;
    }
    const { importPath, title } = this.entry;
    const primaryCsfFile = this.store.processCSFFileWithCache(
      entryExports,
      importPath,
      title
    );
    const primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile });
    this.csfFiles = [primaryCsfFile, ...csfFiles];
    this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles) {
      throw new Error("Cannot render docs before preparing");
    }
    const docsContext = new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
    this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile));
    return docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles) {
      throw new Error("Cannot render docs before preparing");
    }
    const docsContext = this.docsContext(renderStoryToElement);
    const { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter) {
      throw new Error(
        `Cannot render a story in viewMode=docs if \`@storybook/addon-docs\` is not installed`
      );
    }
    const renderer = await docsParameter.renderer();
    const { render } = renderer;
    const renderDocs = __name(async () => {
      try {
        await render(docsContext, docsParameter, canvasElement);
        this.channel.emit(import_core_events5.DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    }, "renderDocs");
    this.rerender = async () => renderDocs();
    this.teardownRender = async ({ viewModeChanged }) => {
      if (!viewModeChanged || !canvasElement) {
        return;
      }
      renderer.unmount(canvasElement);
    };
    return renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged });
    this.torndown = true;
  }
};
__name(_CsfDocsRender, "CsfDocsRender");
var CsfDocsRender = _CsfDocsRender;
var _MdxDocsRender = class _MdxDocsRender2 {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
    this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    const { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown) {
      throw PREPARE_ABORTED;
    }
    this.csfFiles = csfFiles;
    this.exports = entryExports;
    this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles) {
      throw new Error("Cannot render docs before preparing");
    }
    return new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations) {
      throw new Error("Cannot render docs before preparing");
    }
    const docsContext = this.docsContext(renderStoryToElement);
    const { docs } = this.store.projectAnnotations.parameters ?? {};
    if (!docs) {
      throw new Error(
        `Cannot render a story in viewMode=docs if \`@storybook/addon-docs\` is not installed`
      );
    }
    const docsParameter = { ...docs, page: this.exports.default };
    const renderer = await docs.renderer();
    const { render } = renderer;
    const renderDocs = __name(async () => {
      try {
        await render(docsContext, docsParameter, canvasElement);
        this.channel.emit(import_core_events6.DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    }, "renderDocs");
    this.rerender = async () => renderDocs();
    this.teardownRender = async ({ viewModeChanged } = {}) => {
      if (!viewModeChanged || !canvasElement) {
        return;
      }
      renderer.unmount(canvasElement);
      this.torndown = true;
    };
    return renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged });
    this.torndown = true;
  }
};
__name(_MdxDocsRender, "MdxDocsRender");
var MdxDocsRender = _MdxDocsRender;
var globalWindow = globalThis;
function focusInInput(event) {
  const target = event.composedPath && event.composedPath()[0] || event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
__name(focusInInput, "focusInInput");
var ATTACHED_MDX_TAG = "attached-mdx";
var UNATTACHED_MDX_TAG = "unattached-mdx";
function isMdxEntry({ tags }) {
  return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);
}
__name(isMdxEntry, "isMdxEntry");
function isStoryRender(r) {
  return r.type === "story";
}
__name(isStoryRender, "isStoryRender");
function isDocsRender(r) {
  return r.type === "docs";
}
__name(isDocsRender, "isDocsRender");
function isCsfDocsRender(r) {
  return isDocsRender(r) && r.subtype === "csf";
}
__name(isCsfDocsRender, "isCsfDocsRender");
var _PreviewWithSelection = class _PreviewWithSelection2 extends Preview {
  constructor(importFn, getProjectAnnotations, selectionStore, view) {
    super(importFn, getProjectAnnotations, void 0, false);
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.selectionStore = selectionStore;
    this.view = view;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners();
    globalWindow.onkeydown = this.onKeydown.bind(this);
    this.channel.on(import_core_events4.SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));
    this.channel.on(import_core_events4.UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));
    this.channel.on(import_core_events4.PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue) {
      throw new import_preview_errors9.CalledPreviewMethodBeforeInitializationError({ methodName: "setInitialGlobals" });
    }
    const { globals } = this.selectionStore.selectionSpecifier || {};
    if (globals) {
      this.storyStoreValue.userGlobals.updateFromPersisted(globals);
    }
    this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(storyIndex) {
    await super.initializeWithStoryIndex(storyIndex);
    return this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue) {
      throw new import_preview_errors9.CalledPreviewMethodBeforeInitializationError({
        methodName: "selectSpecifiedStory"
      });
    }
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier, args } = this.selectionStore.selectionSpecifier;
    const entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      if (storySpecifier === "*") {
        this.renderStoryLoadingException(storySpecifier, new import_preview_errors9.EmptyIndexError());
      } else {
        this.renderStoryLoadingException(
          storySpecifier,
          new import_preview_errors9.NoStoryMatchError({ storySpecifier: storySpecifier.toString() })
        );
      }
      return;
    }
    const { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode });
    this.channel.emit(import_core_events4.STORY_SPECIFIED, this.selectionStore.selection);
    this.channel.emit(import_core_events4.CURRENT_STORY_WAS_SET, this.selectionStore.selection);
    await this.renderSelection({ persistedArgs: args });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations });
    if (this.selectionStore.selection) {
      this.renderSelection();
    }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    await super.onStoriesChanged({ importFn, storyIndex });
    if (this.selectionStore.selection) {
      await this.renderSelection();
    } else {
      await this.selectSpecifiedStory();
    }
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !focusInInput(event)) {
      const { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
      this.channel.emit(import_core_events4.PREVIEW_KEYDOWN, {
        event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }
      });
    }
  }
  async onSetCurrentStory(selection) {
    this.selectionStore.setSelection({ viewMode: "story", ...selection });
    await this.storeInitializationPromise;
    this.channel.emit(import_core_events4.CURRENT_STORY_WAS_SET, this.selectionStore.selection);
    this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    const currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals, currentStory });
    if (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) {
      await this.currentRender.rerender?.();
    }
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await this.storeInitializationPromise;
    if (this.storyStoreValue) {
      await Promise.allSettled(ids.map((id) => this.storyStoreValue?.loadEntry(id)));
    }
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs } = {}) {
    const { renderToCanvas } = this;
    if (!this.storyStoreValue || !renderToCanvas) {
      throw new import_preview_errors9.CalledPreviewMethodBeforeInitializationError({ methodName: "renderSelection" });
    }
    const { selection } = this.selectionStore;
    if (!selection) {
      throw new Error("Cannot call renderSelection as no selection was made");
    }
    const { storyId } = selection;
    let entry;
    try {
      entry = await this.storyStoreValue.storyIdToEntry(storyId);
    } catch (err) {
      if (this.currentRender) {
        await this.teardownRender(this.currentRender);
      }
      this.renderStoryLoadingException(storyId, err);
      return;
    }
    const storyIdChanged = this.currentSelection?.storyId !== storyId;
    const viewModeChanged = this.currentRender?.type !== entry.type;
    if (entry.type === "story") {
      this.view.showPreparingStory({ immediate: viewModeChanged });
    } else {
      this.view.showPreparingDocs({ immediate: viewModeChanged });
    }
    if (this.currentRender?.isPreparing()) {
      await this.teardownRender(this.currentRender);
    }
    let render;
    if (entry.type === "story") {
      render = new StoryRender(
        this.channel,
        this.storyStoreValue,
        renderToCanvas,
        this.mainStoryCallbacks(storyId),
        storyId,
        "story"
      );
    } else if (isMdxEntry(entry)) {
      render = new MdxDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      );
    } else {
      render = new CsfDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      );
    }
    const lastSelection = this.currentSelection;
    this.currentSelection = selection;
    const lastRender = this.currentRender;
    this.currentRender = render;
    try {
      await render.prepare();
    } catch (err) {
      if (lastRender) {
        await this.teardownRender(lastRender);
      }
      if (err !== PREPARE_ABORTED) {
        this.renderStoryLoadingException(storyId, err);
      }
      return;
    }
    const implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render)) {
      invariant(!!render.story);
      this.storyStoreValue.args.updateFromPersisted(render.story, persistedArgs);
    }
    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender;
      this.channel.emit(import_core_events4.STORY_UNCHANGED, storyId);
      this.view.showMain();
      return;
    }
    if (lastRender) {
      await this.teardownRender(lastRender, { viewModeChanged });
    }
    if (lastSelection && (storyIdChanged || viewModeChanged)) {
      this.channel.emit(import_core_events4.STORY_CHANGED, storyId);
    }
    if (isStoryRender(render)) {
      invariant(!!render.story);
      const {
        parameters: parameters2,
        initialArgs,
        argTypes,
        unmappedArgs,
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      } = this.storyStoreValue.getStoryContext(render.story);
      this.channel.emit(import_core_events4.STORY_PREPARED, {
        id: storyId,
        parameters: parameters2,
        initialArgs,
        argTypes,
        args: unmappedArgs
      });
      this.channel.emit(import_core_events4.GLOBALS_UPDATED, { userGlobals, storyGlobals, globals, initialGlobals: initialGlobals5 });
    } else {
      let { parameters: parameters2 } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(import_core_events4.GLOBALS_UPDATED, {
        globals,
        initialGlobals: initialGlobals5,
        storyGlobals: {},
        userGlobals: globals
      });
      if (isCsfDocsRender(render) || render.entry.tags?.includes(ATTACHED_MDX_TAG)) {
        if (!render.csfFiles) {
          throw new import_preview_errors9.MdxFileWithNoCsfReferencesError({ storyId });
        }
        ({ parameters: parameters2 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: render.csfFiles[0]
        }));
      }
      this.channel.emit(import_core_events4.DOCS_PREPARED, {
        id: storyId,
        parameters: parameters2
      });
    }
    if (isStoryRender(render)) {
      invariant(!!render.story);
      this.storyRenders.push(render);
      this.currentRender.renderToElement(
        this.view.prepareForStory(render.story)
      );
    } else {
      this.currentRender.renderToElement(
        this.view.prepareForDocs(),
        // This argument is used for docs, which is currently only compatible with HTMLElements
        this.renderStoryToElement.bind(this)
      );
    }
  }
  async teardownRender(render, { viewModeChanged = false } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== render);
    await render?.teardown?.({ viewModeChanged });
  }
  // UTILITIES
  mainStoryCallbacks(storyId) {
    return {
      showStoryDuringRender: __name(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: __name(() => this.view.showMain(), "showMain"),
      showError: __name((err) => this.renderError(storyId, err), "showError"),
      showException: __name((err) => this.renderException(storyId, err), "showException")
    };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err);
    this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview();
    this.channel.emit(import_core_events4.STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    import_client_logger10.logger.error(err);
    this.view.showErrorDisplay(err);
    this.channel.emit(import_core_events4.STORY_MISSING, storySpecifier);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(storyId, error) {
    const { name = "Error", message = String(error), stack } = error;
    const renderId = this.currentRender?.renderId;
    this.channel.emit(import_core_events4.STORY_THREW_EXCEPTION, { name, message, stack });
    this.channel.emit(import_core_events4.STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId });
    this.view.showErrorDisplay(error);
    import_client_logger10.logger.error(`Error rendering story '${storyId}':`);
    import_client_logger10.logger.error(error);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(storyId, { title, description }) {
    const renderId = this.currentRender?.renderId;
    this.channel.emit(import_core_events4.STORY_ERRORED, { title, description });
    this.channel.emit(import_core_events4.STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId });
    this.view.showErrorDisplay({ message: title, stack: description });
    import_client_logger10.logger.error(`Error rendering story ${title}: ${description}`);
  }
};
__name(_PreviewWithSelection, "PreviewWithSelection");
var PreviewWithSelection = _PreviewWithSelection;
var import_picoquery2 = __toESM2(require_main(), 1);
var import_picoquery = __toESM2(require_main(), 1);
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;
var NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/;
var HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var validateArgs = __name((key = "", value) => {
  if (key === null) {
    return false;
  }
  if (key === "" || !VALIDATION_REGEXP.test(key)) {
    return false;
  }
  if (value === null || value === void 0) {
    return true;
  }
  if (value instanceof Date) {
    return true;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return true;
  }
  if (typeof value === "string") {
    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);
  }
  if (Array.isArray(value)) {
    return value.every((v) => validateArgs(key, v));
  }
  if (isPlainObject(value)) {
    return Object.entries(value).every(([k, v]) => validateArgs(k, v));
  }
  return false;
}, "validateArgs");
var QUERY_OPTIONS = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(str2) {
    if (str2.startsWith("!")) {
      if (str2 === "!undefined") {
        return void 0;
      }
      if (str2 === "!null") {
        return null;
      }
      if (str2 === "!true") {
        return true;
      }
      if (str2 === "!false") {
        return false;
      }
      if (str2.startsWith("!date(") && str2.endsWith(")")) {
        return new Date(str2.replaceAll(" ", "+").slice(6, -1));
      }
      if (str2.startsWith("!hex(") && str2.endsWith(")")) {
        return `#${str2.slice(5, -1)}`;
      }
      const color = str2.slice(1).match(COLOR_REGEXP);
      if (color) {
        if (str2.startsWith("!rgba") || str2.startsWith("!RGBA")) {
          return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;
        }
        if (str2.startsWith("!hsla") || str2.startsWith("!HSLA")) {
          return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;
        }
        return str2.startsWith("!rgb") || str2.startsWith("!RGB") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
      }
    }
    if (NUMBER_REGEXP.test(str2)) {
      return Number(str2);
    }
    return str2;
  }
};
var parseArgsParam = __name((argsString) => {
  const parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries((0, import_picoquery.parse)(parts.join(";"), QUERY_OPTIONS)).reduce((acc, [key, value]) => {
    if (validateArgs(key, value)) {
      return Object.assign(acc, { [key]: value });
    }
    import_client_logger11.once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `);
    return acc;
  }, {});
}, "parseArgsParam");
var { history, document: document2 } = import_global8.global;
function pathToId(path) {
  const match = (path || "").match(/^\/story\/(.+)/);
  if (!match) {
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  }
  return match[1];
}
__name(pathToId, "pathToId");
var getQueryString = __name(({
  selection,
  extraParams
}) => {
  const search = document2?.location.search.slice(1);
  const { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);
  const queryStr = (0, import_picoquery2.stringify)({
    ...rest,
    ...extraParams,
    ...selection && { id: selection.storyId, viewMode: selection.viewMode }
  });
  return `?${queryStr}`;
}, "getQueryString");
var setPath = __name((selection) => {
  if (!selection) {
    return;
  }
  const query = getQueryString({ selection });
  const { hash = "" } = document2.location;
  document2.title = selection.storyId;
  history.replaceState({}, "", `${document2.location.pathname}${query}${hash}`);
}, "setPath");
var isObject = __name((val) => val != null && typeof val === "object" && Array.isArray(val) === false, "isObject");
var getFirstString = __name((v) => {
  if (v === void 0) {
    return void 0;
  }
  if (typeof v === "string") {
    return v;
  }
  if (Array.isArray(v)) {
    return getFirstString(v[0]);
  }
  if (isObject(v)) {
    return getFirstString(
      Object.values(v).filter(Boolean)
    );
  }
  return void 0;
}, "getFirstString");
var getSelectionSpecifierFromPath = __name(() => {
  if (typeof document2 !== "undefined") {
    const queryStr = document2.location.search.slice(1);
    const query = (0, import_picoquery2.parse)(queryStr);
    const args = typeof query.args === "string" ? parseArgsParam(query.args) : void 0;
    const globals = typeof query.globals === "string" ? parseArgsParam(query.globals) : void 0;
    let viewMode = getFirstString(query.viewMode);
    if (typeof viewMode !== "string" || !viewMode.match(/docs|story/)) {
      viewMode = "story";
    }
    const path = getFirstString(query.path);
    const storyId = path ? pathToId(path) : getFirstString(query.id);
    if (storyId) {
      return { storySpecifier: storyId, args, globals, viewMode };
    }
  }
  return null;
}, "getSelectionSpecifierFromPath");
var _UrlStore = class _UrlStore2 {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection;
    setPath(this.selection);
  }
  setQueryParams(queryParams) {
    const query = getQueryString({ extraParams: queryParams });
    const { hash = "" } = document2.location;
    history.replaceState({}, "", `${document2.location.pathname}${query}${hash}`);
  }
};
__name(_UrlStore, "UrlStore");
var UrlStore = _UrlStore;
var import_ansi_to_html = __toESM2(require_ansi_to_html(), 1);
var import_picoquery3 = __toESM2(require_main(), 1);
var { document: document3 } = import_global9.global;
var PREPARING_DELAY = 100;
var Mode = ((Mode2) => {
  Mode2["MAIN"] = "MAIN";
  Mode2["NOPREVIEW"] = "NOPREVIEW";
  Mode2["PREPARING_STORY"] = "PREPARING_STORY";
  Mode2["PREPARING_DOCS"] = "PREPARING_DOCS";
  Mode2["ERROR"] = "ERROR";
  return Mode2;
})(Mode || {});
var classes = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
};
var layoutClassMap = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
};
var ansiConverter = new import_ansi_to_html.default({
  escapeXML: true
});
var _WebView = class _WebView2 {
  constructor() {
    this.testing = false;
    if (typeof document3 !== "undefined") {
      const { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document3.location.search.slice(1));
      switch (__SPECIAL_TEST_PARAMETER__) {
        case "preparing-story": {
          this.showPreparingStory();
          this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs();
          this.testing = true;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(story) {
    this.showStory();
    this.applyLayout(story.parameters.layout);
    document3.documentElement.scrollTop = 0;
    document3.documentElement.scrollLeft = 0;
    return this.storyRoot();
  }
  storyRoot() {
    return document3.getElementById("storybook-root");
  }
  prepareForDocs() {
    this.showMain();
    this.showDocs();
    this.applyLayout("fullscreen");
    document3.documentElement.scrollTop = 0;
    document3.documentElement.scrollLeft = 0;
    return this.docsRoot();
  }
  docsRoot() {
    return document3.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document3.body.classList.remove(this.currentLayoutClass);
      this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    const layoutClass = layoutClassMap[layout];
    document3.body.classList.remove(this.currentLayoutClass);
    document3.body.classList.add(layoutClass);
    this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    if (!layoutClassMap[layout]) {
      import_client_logger12.logger.warn(
        dedent`
          The desired layout: ${layout} is not a valid option.
          The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.
        `
      );
    }
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout);
    Object.keys(Mode).forEach((otherMode) => {
      if (otherMode === mode) {
        document3.body.classList.add(classes[otherMode]);
      } else {
        document3.body.classList.remove(classes[otherMode]);
      }
    });
  }
  showErrorDisplay({ message = "", stack = "" }) {
    let header = message;
    let detail = stack;
    const parts = message.split("\n");
    if (parts.length > 1) {
      [header] = parts;
      detail = parts.slice(1).join("\n").replace(/^\n/, "");
    }
    document3.getElementById("error-message").innerHTML = ansiConverter.toHtml(header);
    document3.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail);
    this.showMode(
      "ERROR"
      /* ERROR */
    );
  }
  showNoPreview() {
    if (this.testing) {
      return;
    }
    this.showMode(
      "NOPREVIEW"
      /* NOPREVIEW */
    );
    this.storyRoot()?.setAttribute("hidden", "true");
    this.docsRoot()?.setAttribute("hidden", "true");
  }
  showPreparingStory({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout);
    if (immediate) {
      this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      );
    } else {
      this.preparingTimeout = setTimeout(
        () => this.showMode(
          "PREPARING_STORY"
          /* PREPARING_STORY */
        ),
        PREPARING_DELAY
      );
    }
  }
  showPreparingDocs({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout);
    if (immediate) {
      this.showMode(
        "PREPARING_DOCS"
        /* PREPARING_DOCS */
      );
    } else {
      this.preparingTimeout = setTimeout(() => this.showMode(
        "PREPARING_DOCS"
        /* PREPARING_DOCS */
      ), PREPARING_DELAY);
    }
  }
  showMain() {
    this.showMode(
      "MAIN"
      /* MAIN */
    );
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true");
    this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true");
    this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document3.body.classList.add(classes.MAIN);
  }
};
__name(_WebView, "WebView");
var WebView = _WebView;
var _PreviewWeb = class _PreviewWeb2 extends PreviewWithSelection {
  constructor(importFn, getProjectAnnotations) {
    super(importFn, getProjectAnnotations, new UrlStore(), new WebView());
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    import_global7.global.__STORYBOOK_PREVIEW__ = this;
  }
};
__name(_PreviewWeb, "PreviewWeb");
var { document: document4 } = import_global10.global;
var runScriptTypes = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var SCRIPT = "script";
var SCRIPTS_ROOT_ID = "scripts-root";
function simulateDOMContentLoaded() {
  const DOMContentLoadedEvent = document4.createEvent("Event");
  DOMContentLoadedEvent.initEvent("DOMContentLoaded", true, true);
  document4.dispatchEvent(DOMContentLoadedEvent);
}
__name(simulateDOMContentLoaded, "simulateDOMContentLoaded");
function insertScript($script, callback, $scriptRoot) {
  const scriptEl = document4.createElement("script");
  scriptEl.type = $script.type === "module" ? "module" : "text/javascript";
  if ($script.src) {
    scriptEl.onload = callback;
    scriptEl.onerror = callback;
    scriptEl.src = $script.src;
  } else {
    scriptEl.textContent = $script.innerText;
  }
  if ($scriptRoot) {
    $scriptRoot.appendChild(scriptEl);
  } else {
    document4.head.appendChild(scriptEl);
  }
  $script.parentNode.removeChild($script);
  if (!$script.src) {
    callback();
  }
}
__name(insertScript, "insertScript");
function insertScriptsSequentially(scriptsToExecute, callback, index2 = 0) {
  scriptsToExecute[index2](() => {
    index2++;
    if (index2 === scriptsToExecute.length) {
      callback();
    } else {
      insertScriptsSequentially(scriptsToExecute, callback, index2);
    }
  });
}
__name(insertScriptsSequentially, "insertScriptsSequentially");
function simulatePageLoad($container) {
  let $scriptsRoot = document4.getElementById(SCRIPTS_ROOT_ID);
  if (!$scriptsRoot) {
    $scriptsRoot = document4.createElement("div");
    $scriptsRoot.id = SCRIPTS_ROOT_ID;
    document4.body.appendChild($scriptsRoot);
  } else {
    $scriptsRoot.innerHTML = "";
  }
  const $scripts = Array.from($container.querySelectorAll(SCRIPT));
  if ($scripts.length) {
    const scriptsToExecute = [];
    $scripts.forEach(($script) => {
      const typeAttr = $script.getAttribute("type");
      if (!typeAttr || runScriptTypes.includes(typeAttr)) {
        scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
      }
    });
    if (scriptsToExecute.length) {
      insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
    }
  } else {
    simulateDOMContentLoaded();
  }
}
__name(simulatePageLoad, "simulatePageLoad");
async function emitTransformCode(source, context) {
  const transform = context.parameters?.docs?.source?.transform;
  const { id, unmappedArgs } = context;
  const transformed = transform && source ? transform?.(source, context) : source;
  const result = transformed ? await transformed : void 0;
  addons.getChannel().emit(SNIPPET_RENDERED, {
    id,
    source: result,
    args: unmappedArgs
  });
}
__name(emitTransformCode, "emitTransformCode");

// node_modules/storybook/dist/_browser-chunks/chunk-GTKOCWCT.js
var ADDON_ID4 = "storybook/highlight";
var HIGHLIGHT = `${ADDON_ID4}/add`;
var REMOVE_HIGHLIGHT = `${ADDON_ID4}/remove`;
var RESET_HIGHLIGHT = `${ADDON_ID4}/reset`;
var SCROLL_INTO_VIEW = `${ADDON_ID4}/scroll-into-view`;
var MAX_Z_INDEX = 2147483647;
var MIN_TOUCH_AREA_SIZE = 28;

// node_modules/storybook/dist/csf/index.js
var import_test = __toESM(require_test());
var import_preview_api = __toESM(require_preview_api());

// node_modules/storybook/dist/_browser-chunks/chunk-SN4J4IQ3.js
var EVENTS3 = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
};
var CallStates = ((CallStates2) => {
  CallStates2["DONE"] = "done";
  CallStates2["ERROR"] = "error";
  CallStates2["ACTIVE"] = "active";
  CallStates2["WAITING"] = "waiting";
  return CallStates2;
})(CallStates || {});

// node_modules/storybook/dist/_browser-chunks/chunk-JVSKG4YS.js
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
var h = Object.entries(f);
function a(n) {
  return String(n);
}
__name(a, "a");
a.open = "";
a.close = "";
var B = h.reduce(
  (n, [e]) => (n[e] = a, n),
  { isColorSupported: false }
);
function C(n = false) {
  let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
__name(C, "C");
function p(n = false) {
  let e = C(n), i = __name((r, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r.substring(s2, o) + c, s2 = o + t.length, o = r.indexOf(t, s2);
    while (~o);
    return l + r.substring(s2);
  }, "i"), g = __name((r, t, c = r) => {
    let o = __name((l) => {
      let s2 = String(l), b = s2.indexOf(t, r.length);
      return ~b ? r + i(s2, t, c, b) + t : r + s2 + t;
    }, "o");
    return o.open = r, o.close = t, o;
  }, "g"), u = {
    isColorSupported: e
  }, d = __name((r) => `\x1B[${r}m`, "d");
  for (let [r, t] of h)
    u[r] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a;
  return u;
}
__name(p, "p");
var s = p();
function _mergeNamespaces(n, m2) {
  m2.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: __name(function() {
            return e[k];
          }, "get")
        });
      }
    });
  });
  return Object.freeze(n);
}
__name(_mergeNamespaces, "_mergeNamespaces");
function getKeysOfEnumerableProperties(object, compareKeys) {
  const rawKeys = Object.keys(object);
  const keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols) {
    for (const symbol of Object.getOwnPropertySymbols(object)) {
      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
        keys.push(symbol);
      }
    }
  }
  return keys;
}
__name(getKeysOfEnumerableProperties, "getKeysOfEnumerableProperties");
function printIteratorEntries(iterator, config, indentation, depth, refs, printer2, separator = ": ") {
  let result = "";
  let width = 0;
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config.maxWidth) {
        result += "…";
        break;
      }
      const name = printer2(current.value[0], config, indentationNext, depth, refs);
      const value = printer2(current.value[1], config, indentationNext, depth, refs);
      result += name + separator + value;
      current = iterator.next();
      if (!current.done) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
__name(printIteratorEntries, "printIteratorEntries");
function printIteratorValues(iterator, config, indentation, depth, refs, printer2) {
  let result = "";
  let width = 0;
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config.maxWidth) {
        result += "…";
        break;
      }
      result += printer2(current.value, config, indentationNext, depth, refs);
      current = iterator.next();
      if (!current.done) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
__name(printIteratorValues, "printIteratorValues");
function printListItems(list, config, indentation, depth, refs, printer2) {
  let result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  const isDataView = __name((l) => l instanceof DataView, "isDataView");
  const length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i = 0; i < length; i++) {
      result += indentationNext;
      if (i === config.maxWidth) {
        result += "…";
        break;
      }
      if (isDataView(list) || i in list) {
        result += printer2(isDataView(list) ? list.getInt8(i) : list[i], config, indentationNext, depth, refs);
      }
      if (i < length - 1) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
__name(printListItems, "printListItems");
function printObjectProperties(val, config, indentation, depth, refs, printer2) {
  let result = "";
  const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
  if (keys.length > 0) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const name = printer2(key, config, indentationNext, depth, refs);
      const value = printer2(val[key], config, indentationNext, depth, refs);
      result += `${indentationNext + name}: ${value}`;
      if (i < keys.length - 1) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
__name(printObjectProperties, "printObjectProperties");
var asymmetricMatcher = typeof Symbol === "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var SPACE$2 = " ";
var serialize$5 = __name((val, config, indentation, depth, refs, printer2) => {
  const stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
    if (++depth > config.maxDepth) {
      return `[${stringedValue}]`;
    }
    return `${stringedValue + SPACE$2}[${printListItems(val.sample, config, indentation, depth, refs, printer2)}]`;
  }
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
    if (++depth > config.maxDepth) {
      return `[${stringedValue}]`;
    }
    return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config, indentation, depth, refs, printer2)}}`;
  }
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);
  }
  if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);
  }
  if (typeof val.toAsymmetricMatcher !== "function") {
    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  }
  return val.toAsymmetricMatcher();
}, "serialize$5");
var test$5 = __name((val) => val && val.$$typeof === asymmetricMatcher, "test$5");
var plugin$5 = {
  serialize: serialize$5,
  test: test$5
};
var SPACE$1 = " ";
var OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]);
var ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
__name(testName, "testName");
var test$4 = __name((val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name), "test$4");
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
__name(isNamedNodeMap, "isNamedNodeMap");
var serialize$4 = __name((collection, config, indentation, depth, refs, printer2) => {
  const name = collection.constructor.name;
  if (++depth > config.maxDepth) {
    return `[${name}]`;
  }
  return (config.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => {
    props[attribute.name] = attribute.value;
    return props;
  }, {}) : { ...collection }, config, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config, indentation, depth, refs, printer2)}]`);
}, "serialize$4");
var plugin$4 = {
  serialize: serialize$4,
  test: test$4
};
function escapeHTML(str2) {
  return str2.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
__name(escapeHTML, "escapeHTML");
function printProps(keys, props, config, indentation, depth, refs, printer2) {
  const indentationNext = indentation + config.indent;
  const colors3 = config.colors;
  return keys.map((key) => {
    const value = props[key];
    let printed = printer2(value, config, indentationNext, depth, refs);
    if (typeof value !== "string") {
      if (printed.includes("\n")) {
        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
      }
      printed = `{${printed}}`;
    }
    return `${config.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
  }).join("");
}
__name(printProps, "printProps");
function printChildren(children, config, indentation, depth, refs, printer2) {
  return children.map((child) => config.spacingOuter + indentation + (typeof child === "string" ? printText(child, config) : printer2(child, config, indentation, depth, refs))).join("");
}
__name(printChildren, "printChildren");
function printText(text, config) {
  const contentColor = config.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
__name(printText, "printText");
function printComment(comment, config) {
  const commentColor = config.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
__name(printComment, "printComment");
function printElement(type, printedProps, printedChildren, config, indentation) {
  const tagColor = config.colors.tag;
  return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? "" : " "}/`}>${tagColor.close}`;
}
__name(printElement, "printElement");
function printElementAsLeaf(type, config) {
  const tagColor = config.colors.tag;
  return `${tagColor.open}<${type}${tagColor.close} …${tagColor.open} />${tagColor.close}`;
}
__name(printElementAsLeaf, "printElementAsLeaf");
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var FRAGMENT_NODE = 11;
var ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute === "function" && val.hasAttribute("is");
  } catch {
    return false;
  }
}
__name(testHasAttribute, "testHasAttribute");
function testNode(val) {
  const constructorName = val.constructor.name;
  const { nodeType, tagName } = val;
  const isCustomElement = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
__name(testNode, "testNode");
var test$3 = __name((val) => {
  var _val$constructor;
  return (val === null || val === void 0 || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
}, "test$3");
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
__name(nodeIsText, "nodeIsText");
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
__name(nodeIsComment, "nodeIsComment");
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
__name(nodeIsFragment, "nodeIsFragment");
var serialize$3 = __name((node, config, indentation, depth, refs, printer2) => {
  if (nodeIsText(node)) {
    return printText(node.data, config);
  }
  if (nodeIsComment(node)) {
    return printComment(node.data, config);
  }
  const type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  if (++depth > config.maxDepth) {
    return printElementAsLeaf(type, config);
  }
  return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => {
    props[attribute.name] = attribute.value;
    return props;
  }, {}), config, indentation + config.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer2), config, indentation);
}, "serialize$3");
var plugin$3 = {
  serialize: serialize$3,
  test: test$3
};
var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
var getImmutableName = __name((name) => `Immutable.${name}`, "getImmutableName");
var printAsLeaf = __name((name) => `[${name}]`, "printAsLeaf");
var SPACE = " ";
var LAZY = "…";
function printImmutableEntries(val, config, indentation, depth, refs, printer2, type) {
  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2)}}`;
}
__name(printImmutableEntries, "printImmutableEntries");
function getRecordEntries(val) {
  let i = 0;
  return { next() {
    if (i < val._keys.length) {
      const key = val._keys[i++];
      return {
        done: false,
        value: [key, val.get(key)]
      };
    }
    return {
      done: true,
      value: void 0
    };
  } };
}
__name(getRecordEntries, "getRecordEntries");
function printImmutableRecord(val, config, indentation, depth, refs, printer2) {
  const name = getImmutableName(val._name || "Record");
  return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer2)}}`;
}
__name(printImmutableRecord, "printImmutableRecord");
function printImmutableSeq(val, config, indentation, depth, refs, printer2) {
  const name = getImmutableName("Seq");
  if (++depth > config.maxDepth) {
    return printAsLeaf(name);
  }
  if (val[IS_KEYED_SENTINEL]) {
    return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2) : LAZY}}`;
  }
  return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer2) : LAZY}]`;
}
__name(printImmutableSeq, "printImmutableSeq");
function printImmutableValues(val, config, indentation, depth, refs, printer2, type) {
  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config, indentation, depth, refs, printer2)}]`;
}
__name(printImmutableValues, "printImmutableValues");
var serialize$2 = __name((val, config, indentation, depth, refs, printer2) => {
  if (val[IS_MAP_SENTINEL]) {
    return printImmutableEntries(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map");
  }
  if (val[IS_LIST_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer2, "List");
  }
  if (val[IS_SET_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set");
  }
  if (val[IS_STACK_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer2, "Stack");
  }
  if (val[IS_SEQ_SENTINEL]) {
    return printImmutableSeq(val, config, indentation, depth, refs, printer2);
  }
  return printImmutableRecord(val, config, indentation, depth, refs, printer2);
}, "serialize$2");
var test$2 = __name((val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true), "test$2");
var plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var reactIs$1 = { exports: {} };
var reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  __name(typeOf, "typeOf");
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
__name(requireReactIs_production, "requireReactIs_production");
var reactIs_development$1 = {};
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  if (hasRequiredReactIs_development$1) return reactIs_development$1;
  hasRequiredReactIs_development$1 = 1;
  (function() {
    function typeOf(object) {
      if ("object" === typeof object && null !== object) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object = object.type, object) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object;
              default:
                switch (object = object && object.$$typeof, object) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object;
                  case REACT_CONSUMER_TYPE:
                    return object;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    __name(typeOf, "typeOf");
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE;
    reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE;
    reactIs_development$1.Element = REACT_ELEMENT_TYPE;
    reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE;
    reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE;
    reactIs_development$1.Lazy = REACT_LAZY_TYPE;
    reactIs_development$1.Memo = REACT_MEMO_TYPE;
    reactIs_development$1.Portal = REACT_PORTAL_TYPE;
    reactIs_development$1.Profiler = REACT_PROFILER_TYPE;
    reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE;
    reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE;
    reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    reactIs_development$1.isContextConsumer = function(object) {
      return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    reactIs_development$1.isContextProvider = function(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    reactIs_development$1.isElement = function(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    reactIs_development$1.isForwardRef = function(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    reactIs_development$1.isFragment = function(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    reactIs_development$1.isLazy = function(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    };
    reactIs_development$1.isMemo = function(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    };
    reactIs_development$1.isPortal = function(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    };
    reactIs_development$1.isProfiler = function(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    };
    reactIs_development$1.isStrictMode = function(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    reactIs_development$1.isSuspense = function(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    reactIs_development$1.isSuspenseList = function(object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    reactIs_development$1.isValidElementType = function(type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
    };
    reactIs_development$1.typeOf = typeOf;
  })();
  return reactIs_development$1;
}
__name(requireReactIs_development$1, "requireReactIs_development$1");
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  if (false) {
    reactIs$1.exports = requireReactIs_production();
  } else {
    reactIs$1.exports = requireReactIs_development$1();
  }
  return reactIs$1.exports;
}
__name(requireReactIs$1, "requireReactIs$1");
var reactIsExports$1 = requireReactIs$1();
var index$1 = getDefaultExportFromCjs(reactIsExports$1);
var ReactIs19 = _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [reactIsExports$1]);
var reactIs = { exports: {} };
var reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f2 = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h2 = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
  u = Symbol.for("react.module.reference");
  function v(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r = a2.$$typeof;
      switch (r) {
        case b:
          switch (a2 = a2.type, a2) {
            case d:
            case f2:
            case e:
            case m2:
            case n:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k:
                case h2:
                case l:
                case q:
                case p2:
                case g:
                  return a2;
                default:
                  return r;
              }
          }
        case c:
          return r;
      }
    }
  }
  __name(v, "v");
  reactIs_production_min.ContextConsumer = h2;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c;
  reactIs_production_min.Profiler = f2;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m2;
  reactIs_production_min.SuspenseList = n;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v(a2) === h2;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v(a2) === g;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v(a2) === l;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v(a2) === d;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v(a2) === q;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v(a2) === c;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v(a2) === f2;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v(a2) === e;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v(a2) === m2;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v(a2) === n;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f2 || a2 === e || a2 === m2 || a2 === n || a2 === t || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h2 || a2.$$typeof === l || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v;
  return reactIs_production_min;
}
__name(requireReactIs_production_min, "requireReactIs_production_min");
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      __name(isValidElementType, "isValidElementType");
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      __name(typeOf, "typeOf");
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
          }
        }
        return false;
      }
      __name(isAsyncMode, "isAsyncMode");
      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true;
            console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
          }
        }
        return false;
      }
      __name(isConcurrentMode, "isConcurrentMode");
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      __name(isContextConsumer, "isContextConsumer");
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      __name(isContextProvider, "isContextProvider");
      function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      __name(isElement, "isElement");
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      __name(isForwardRef, "isForwardRef");
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      __name(isFragment, "isFragment");
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      __name(isLazy, "isLazy");
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      __name(isMemo, "isMemo");
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      __name(isPortal, "isPortal");
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      __name(isProfiler, "isProfiler");
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      __name(isStrictMode, "isStrictMode");
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      __name(isSuspense, "isSuspense");
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      __name(isSuspenseList, "isSuspenseList");
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element2;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.SuspenseList = SuspenseList;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isSuspenseList = isSuspenseList;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
__name(requireReactIs_development, "requireReactIs_development");
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  if (false) {
    reactIs.exports = requireReactIs_production_min();
  } else {
    reactIs.exports = requireReactIs_development();
  }
  return reactIs.exports;
}
__name(requireReactIs, "requireReactIs");
var reactIsExports = requireReactIs();
var index = getDefaultExportFromCjs(reactIsExports);
var ReactIs18 = _mergeNamespaces({
  __proto__: null,
  default: index
}, [reactIsExports]);
var reactIsMethods = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
];
var ReactIs = Object.fromEntries(reactIsMethods.map((m2) => [m2, (v) => ReactIs18[m2](v) || ReactIs19[m2](v)]));
function getChildren(arg, children = []) {
  if (Array.isArray(arg)) {
    for (const item of arg) {
      getChildren(item, children);
    }
  } else if (arg != null && arg !== false && arg !== "") {
    children.push(arg);
  }
  return children;
}
__name(getChildren, "getChildren");
function getType(element) {
  const type = element.type;
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "function") {
    return type.displayName || type.name || "Unknown";
  }
  if (ReactIs.isFragment(element)) {
    return "React.Fragment";
  }
  if (ReactIs.isSuspense(element)) {
    return "React.Suspense";
  }
  if (typeof type === "object" && type !== null) {
    if (ReactIs.isContextProvider(element)) {
      return "Context.Provider";
    }
    if (ReactIs.isContextConsumer(element)) {
      return "Context.Consumer";
    }
    if (ReactIs.isForwardRef(element)) {
      if (type.displayName) {
        return type.displayName;
      }
      const functionName = type.render.displayName || type.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (ReactIs.isMemo(element)) {
      const functionName = type.displayName || type.type.displayName || type.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
__name(getType, "getType");
function getPropKeys$1(element) {
  const { props } = element;
  return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
__name(getPropKeys$1, "getPropKeys$1");
var serialize$1 = __name((element, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(getType(element), config) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer2), config, indentation), "serialize$1");
var test$1 = __name((val) => val != null && ReactIs.isElement(val), "test$1");
var plugin$1 = {
  serialize: serialize$1,
  test: test$1
};
var testSymbol = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
  const { props } = object;
  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
__name(getPropKeys, "getPropKeys");
var serialize = __name((object, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(object.type, config) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer2) : "", object.children ? printChildren(object.children, config, indentation + config.indent, depth, refs, printer2) : "", config, indentation), "serialize");
var test = __name((val) => val && val.$$typeof === testSymbol, "test");
var plugin = {
  serialize,
  test
};
var toString = Object.prototype.toString;
var toISOString = Date.prototype.toISOString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor === "function" && val.constructor.name || "Object";
}
__name(getConstructorName, "getConstructorName");
function isWindow(val) {
  return typeof window !== "undefined" && val === window;
}
__name(isWindow, "isWindow");
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
var NEWLINE_REGEXP = /\n/g;
var _PrettyFormatPluginError = class _PrettyFormatPluginError2 extends Error {
  constructor(message, stack) {
    super(message);
    this.stack = stack;
    this.name = this.constructor.name;
  }
};
__name(_PrettyFormatPluginError, "PrettyFormatPluginError");
var PrettyFormatPluginError = _PrettyFormatPluginError;
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
__name(isToStringedArrayType, "isToStringedArrayType");
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
__name(printNumber, "printNumber");
function printBigInt(val) {
  return String(`${val}n`);
}
__name(printBigInt, "printBigInt");
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return "[Function]";
  }
  return `[Function ${val.name || "anonymous"}]`;
}
__name(printFunction, "printFunction");
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
__name(printSymbol, "printSymbol");
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
__name(printError, "printError");
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return `${val}`;
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  const typeOf = typeof val;
  if (typeOf === "number") {
    return printNumber(val);
  }
  if (typeOf === "bigint") {
    return printBigInt(val);
  }
  if (typeOf === "string") {
    if (escapeString) {
      return `"${val.replaceAll(/"|\\/g, "\\$&")}"`;
    }
    return `"${val}"`;
  }
  if (typeOf === "function") {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === "symbol") {
    return printSymbol(val);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object WeakMap]") {
    return "WeakMap {}";
  }
  if (toStringed === "[object WeakSet]") {
    return "WeakSet {}";
  }
  if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === "[object Symbol]") {
    return printSymbol(val);
  }
  if (toStringed === "[object Date]") {
    return Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
  }
  if (toStringed === "[object Error]") {
    return printError(val);
  }
  if (toStringed === "[object RegExp]") {
    if (escapeRegex) {
      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}
__name(printBasicValue, "printBasicValue");
function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val)) {
    return "[Circular]";
  }
  refs = [...refs];
  refs.push(val);
  const hitMaxDepth = ++depth > config.maxDepth;
  const min = config.min;
  if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
    return printer(val.toJSON(), config, indentation, depth, refs, true);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object Arguments]") {
    return hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config, indentation, depth, refs, printer)}]`;
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? "" : !config.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config, indentation, depth, refs, printer)}]`;
  }
  if (toStringed === "[object Map]") {
    return hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer, " => ")}}`;
  }
  if (toStringed === "[object Set]") {
    return hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config, indentation, depth, refs, printer)}}`;
  }
  return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? "" : !config.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config, indentation, depth, refs, printer)}}`;
}
__name(printComplexValue, "printComplexValue");
var ErrorPlugin = {
  test: __name((val) => val && val instanceof Error, "test"),
  serialize(val, config, indentation, depth, refs, printer2) {
    if (refs.includes(val)) {
      return "[Circular]";
    }
    refs = [...refs, val];
    const hitMaxDepth = ++depth > config.maxDepth;
    const { message, cause, ...rest } = val;
    const entries = {
      message,
      ...typeof cause !== "undefined" ? { cause } : {},
      ...val instanceof AggregateError ? { errors: val.errors } : {},
      ...rest
    };
    const name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config, indentation, depth, refs, printer2)}}`;
  }
};
function isNewPlugin(plugin2) {
  return plugin2.serialize != null;
}
__name(isNewPlugin, "isNewPlugin");
function printPlugin(plugin2, val, config, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config, indentation, depth, refs), (str2) => {
      const indentationNext = indentation + config.indent;
      return indentationNext + str2.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, {
      edgeSpacing: config.spacingOuter,
      min: config.min,
      spacing: config.spacingInner
    }, config.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== "string") {
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  }
  return printed;
}
__name(printPlugin, "printPlugin");
function findPlugin(plugins2, val) {
  for (const plugin2 of plugins2) {
    try {
      if (plugin2.test(val)) {
        return plugin2;
      }
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  }
  return null;
}
__name(findPlugin, "findPlugin");
function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
  const plugin2 = findPlugin(config.plugins, val);
  if (plugin2 !== null) {
    return printPlugin(plugin2, val, config, indentation, depth, refs);
  }
  const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
}
__name(printer, "printer");
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
};
var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
var DEFAULT_OPTIONS2 = {
  callToJSON: true,
  compareKeys: void 0,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: false,
  plugins: [],
  printBasicPrototype: true,
  printFunctionName: true,
  theme: DEFAULT_THEME
};
function validateOptions2(options) {
  for (const key of Object.keys(options)) {
    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS2, key)) {
      throw new Error(`pretty-format: Unknown option "${key}".`);
    }
  }
  if (options.min && options.indent !== void 0 && options.indent !== 0) {
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
  }
}
__name(validateOptions2, "validateOptions");
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
    const value = DEFAULT_THEME[key];
    const color = value && s[value];
    if (color && typeof color.close === "string" && typeof color.open === "string") {
      colors3[key] = color;
    } else {
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    }
    return colors3;
  }, /* @__PURE__ */ Object.create(null));
}
__name(getColorsHighlight, "getColorsHighlight");
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
    colors3[key] = {
      close: "",
      open: ""
    };
    return colors3;
  }, /* @__PURE__ */ Object.create(null));
}
__name(getColorsEmpty, "getColorsEmpty");
function getPrintFunctionName(options) {
  return (options === null || options === void 0 ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS2.printFunctionName;
}
__name(getPrintFunctionName, "getPrintFunctionName");
function getEscapeRegex(options) {
  return (options === null || options === void 0 ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS2.escapeRegex;
}
__name(getEscapeRegex, "getEscapeRegex");
function getEscapeString(options) {
  return (options === null || options === void 0 ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS2.escapeString;
}
__name(getEscapeString, "getEscapeString");
function getConfig(options) {
  return {
    callToJSON: (options === null || options === void 0 ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS2.callToJSON,
    colors: (options === null || options === void 0 ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof (options === null || options === void 0 ? void 0 : options.compareKeys) === "function" || (options === null || options === void 0 ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS2.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: (options === null || options === void 0 ? void 0 : options.min) ? "" : createIndent((options === null || options === void 0 ? void 0 : options.indent) ?? DEFAULT_OPTIONS2.indent),
    maxDepth: (options === null || options === void 0 ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS2.maxDepth,
    maxWidth: (options === null || options === void 0 ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS2.maxWidth,
    min: (options === null || options === void 0 ? void 0 : options.min) ?? DEFAULT_OPTIONS2.min,
    plugins: (options === null || options === void 0 ? void 0 : options.plugins) ?? DEFAULT_OPTIONS2.plugins,
    printBasicPrototype: (options === null || options === void 0 ? void 0 : options.printBasicPrototype) ?? true,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: (options === null || options === void 0 ? void 0 : options.min) ? " " : "\n",
    spacingOuter: (options === null || options === void 0 ? void 0 : options.min) ? "" : "\n"
  };
}
__name(getConfig, "getConfig");
function createIndent(indent) {
  return Array.from({ length: indent + 1 }).join(" ");
}
__name(createIndent, "createIndent");
function format(val, options) {
  if (options) {
    validateOptions2(options);
    if (options.plugins) {
      const plugin2 = findPlugin(options.plugins, val);
      if (plugin2 !== null) {
        return printPlugin(plugin2, val, getConfig(options), "", 0, []);
      }
    }
  }
  const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, getConfig(options), "", 0, []);
}
__name(format, "format");
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin,
  Error: ErrorPlugin
};
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "…";
function colorise(value, styleType) {
  const color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  if (!color) {
    return String(value);
  }
  return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
}
__name(colorise, "colorise");
function normaliseOptions({
  showHidden = false,
  depth = 2,
  colors: colors3 = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = Infinity,
  breakLength = Infinity,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate2 = Infinity,
  stylize = String
} = {}, inspect3) {
  const options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors3),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate2),
    seen,
    inspect: inspect3,
    stylize
  };
  if (options.colors) {
    options.stylize = colorise;
  }
  return options;
}
__name(normaliseOptions, "normaliseOptions");
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate, "isHighSurrogate");
function truncate(string, length, tail = truncator) {
  string = String(string);
  const tailLength = tail.length;
  const stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    if (end > 0 && isHighSurrogate(string[end - 1])) {
      end = end - 1;
    }
    return `${string.slice(0, end)}${tail}`;
  }
  return string;
}
__name(truncate, "truncate");
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  const size = list.length;
  if (size === 0)
    return "";
  const originalLength = options.truncate;
  let output = "";
  let peek = "";
  let truncated = "";
  for (let i = 0; i < size; i += 1) {
    const last = i + 1 === list.length;
    const secondToLast = i + 2 === list.length;
    truncated = `${truncator}(${list.length - i})`;
    const value = list[i];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    const string = peek || inspectItem(value, options) + (last ? "" : separator);
    const nextLength = output.length + string.length;
    const truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList, "inspectList");
function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey, "quoteComplexKey");
function inspectProperty([key, value], options) {
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = `[${options.inspect(key, options)}]`;
  }
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key}: ${value}`;
}
__name(inspectProperty, "inspectProperty");
function inspectArray(array, options) {
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  const listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
  }
  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray, "inspectArray");
var getArrayName = __name((array) => {
  if (typeof Buffer === "function" && array instanceof Buffer) {
    return "Buffer";
  }
  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }
  return array.constructor.name;
}, "getArrayName");
function inspectTypedArray(array, options) {
  const name = getArrayName(array);
  options.truncate -= name.length + 4;
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i = 0; i < array.length; i++) {
    const string = `${options.stylize(truncate(array[i], options.truncate), "number")}${i === array.length - 1 ? "" : ", "}`;
    options.truncate -= string.length;
    if (array[i] !== array.length && options.truncate <= 3) {
      output += `${truncator}(${array.length - array[i] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
  }
  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray, "inspectTypedArray");
function inspectDate(dateObject, options) {
  const stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  const split = stringRepresentation.split("T");
  const date = split[0];
  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate, "inspectDate");
function inspectFunction(func, options) {
  const functionType = func[Symbol.toStringTag] || "Function";
  const name = func.name;
  if (!name) {
    return options.stylize(`[${functionType}]`, "special");
  }
  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
}
__name(inspectFunction, "inspectFunction");
function inspectMapEntry([key, value], options) {
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key} => ${value}`;
}
__name(inspectMapEntry, "inspectMapEntry");
function mapToEntries(map2) {
  const entries = [];
  map2.forEach((value, key) => {
    entries.push([key, value]);
  });
  return entries;
}
__name(mapToEntries, "mapToEntries");
function inspectMap(map2, options) {
  if (map2.size === 0)
    return "Map{}";
  options.truncate -= 7;
  return `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`;
}
__name(inspectMap, "inspectMap");
var isNaN = Number.isNaN || ((i) => i !== i);
function inspectNumber(number, options) {
  if (isNaN(number)) {
    return options.stylize("NaN", "number");
  }
  if (number === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number === 0) {
    return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate(String(number), options.truncate), "number");
}
__name(inspectNumber, "inspectNumber");
function inspectBigInt(number, options) {
  let nums = truncate(number.toString(), options.truncate - 1);
  if (nums !== truncator)
    nums += "n";
  return options.stylize(nums, "bigint");
}
__name(inspectBigInt, "inspectBigInt");
function inspectRegExp(value, options) {
  const flags = value.toString().split("/")[2];
  const sourceLength = options.truncate - (2 + flags.length);
  const source = value.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp, "inspectRegExp");
function arrayFromSet(set) {
  const values = [];
  set.forEach((value) => {
    values.push(value);
  });
  return values;
}
__name(arrayFromSet, "arrayFromSet");
function inspectSet(set, options) {
  if (set.size === 0)
    return "Set{}";
  options.truncate -= 7;
  return `Set{ ${inspectList(arrayFromSet(set), options)} }`;
}
__name(inspectSet, "inspectSet");
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex = 16;
var unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
__name(escape, "escape");
function inspectString(string, options) {
  if (stringEscapeChars.test(string)) {
    string = string.replace(stringEscapeChars, escape);
  }
  return options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
}
__name(inspectString, "inspectString");
function inspectSymbol(value) {
  if ("description" in Symbol.prototype) {
    return value.description ? `Symbol(${value.description})` : "Symbol()";
  }
  return value.toString();
}
__name(inspectSymbol, "inspectSymbol");
var getPromiseValue = __name(() => "Promise{…}", "getPromiseValue");
var promise_default = getPromiseValue;
function inspectObject(object, options) {
  const properties = Object.getOwnPropertyNames(object);
  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object)) {
    return "[Circular]";
  }
  options.seen.push(object);
  const propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty);
  const symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject, "inspectObject");
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
  let name = "";
  if (toStringTag && toStringTag in value) {
    name = value[toStringTag];
  }
  name = name || value.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return `${name}${inspectObject(value, options)}`;
}
__name(inspectClass, "inspectClass");
function inspectArguments(args, options) {
  if (args.length === 0)
    return "Arguments[]";
  options.truncate -= 13;
  return `Arguments[ ${inspectList(args, options)} ]`;
}
__name(inspectArguments, "inspectArguments");
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject2(error, options) {
  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
  const name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? `: ${message}` : "";
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return "[Circular]";
  }
  options.seen.push(error);
  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject2, "inspectObject");
function inspectAttribute([key, value], options) {
  options.truncate -= 3;
  if (!value) {
    return `${options.stylize(String(key), "yellow")}`;
  }
  return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
__name(inspectAttribute, "inspectAttribute");
function inspectNodeCollection(collection, options) {
  return inspectList(collection, options, inspectNode, "\n");
}
__name(inspectNodeCollection, "inspectNodeCollection");
function inspectNode(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
__name(inspectNode, "inspectNode");
function inspectHTML(element, options) {
  const properties = element.getAttributeNames();
  const name = element.tagName.toLowerCase();
  const head = options.stylize(`<${name}`, "special");
  const headClose = options.stylize(`>`, "special");
  const tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
  }
  options.truncate -= propertyContents.length;
  const truncate2 = options.truncate;
  let children = inspectNodeCollection(element.children, options);
  if (children && children.length > truncate2) {
    children = `${truncator}(${element.children.length})`;
  }
  return `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML, "inspectHTML");
var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = Symbol.for("nodejs.util.inspect.custom");
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: __name((value, options) => options.stylize("undefined", "undefined"), "undefined"),
  null: __name((value, options) => options.stylize("null", "null"), "null"),
  boolean: __name((value, options) => options.stylize(String(value), "boolean"), "boolean"),
  Boolean: __name((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: __name((value, options) => options.stylize("WeakSet{…}", "special"), "WeakSet"),
  WeakMap: __name((value, options) => options.stylize("WeakMap{…}", "special"), "WeakMap"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: __name(() => "", "Generator"),
  DataView: __name(() => "", "DataView"),
  ArrayBuffer: __name(() => "", "ArrayBuffer"),
  Error: inspectObject2,
  HTMLCollection: inspectNodeCollection,
  NodeList: inspectNodeCollection
};
var inspectCustom = __name((value, options, type, inspectFn) => {
  if (chaiInspect in value && typeof value[chaiInspect] === "function") {
    return value[chaiInspect](options);
  }
  if (nodeInspect in value && typeof value[nodeInspect] === "function") {
    return value[nodeInspect](options.depth, options, inspectFn);
  }
  if ("inspect" in value && typeof value.inspect === "function") {
    return value.inspect(options.depth, options);
  }
  if ("constructor" in value && constructorMap.has(value.constructor)) {
    return constructorMap.get(value.constructor)(value, options);
  }
  if (stringTagMap[type]) {
    return stringTagMap[type](value, options);
  }
  return "";
}, "inspectCustom");
var toString2 = Object.prototype.toString;
function inspect(value, opts = {}) {
  const options = normaliseOptions(opts, inspect);
  const { customInspect } = options;
  let type = value === null ? "null" : typeof value;
  if (type === "object") {
    type = toString2.call(value).slice(8, -1);
  }
  if (type in baseTypesMap) {
    return baseTypesMap[type](value, options);
  }
  if (customInspect && value) {
    const output = inspectCustom(value, options, type, inspect);
    if (output) {
      if (typeof output === "string")
        return output;
      return inspect(output, options);
    }
  }
  const proto = value ? Object.getPrototypeOf(value) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject(value, options);
  }
  if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
    return inspectHTML(value, options);
  }
  if ("constructor" in value) {
    if (value.constructor !== Object) {
      return inspectClass(value, options);
    }
    return inspectObject(value, options);
  }
  if (value === Object(value)) {
    return inspectObject(value, options);
  }
  return options.stylize(String(value), type);
}
__name(inspect, "inspect");
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;
var PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
function stringify2(object, maxDepth = 10, { maxLength, ...options } = {}) {
  const MAX_LENGTH = maxLength ?? 1e4;
  let result;
  try {
    result = format(object, {
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  } catch {
    result = format(object, {
      callToJSON: false,
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  }
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength,
    ...options
  }) : result;
}
__name(stringify2, "stringify");
var formatRegExp = /%[sdjifoOc%]/g;
function format2(...args) {
  if (typeof args[0] !== "string") {
    const objects = [];
    for (let i2 = 0; i2 < args.length; i2++) {
      objects.push(inspect2(args[i2], {
        depth: 0,
        colors: false
      }));
    }
    return objects.join(" ");
  }
  const len = args.length;
  let i = 1;
  const template = args[0];
  let str2 = String(template).replace(formatRegExp, (x) => {
    if (x === "%%") {
      return "%";
    }
    if (i >= len) {
      return x;
    }
    switch (x) {
      case "%s": {
        const value = args[i++];
        if (typeof value === "bigint") {
          return `${value.toString()}n`;
        }
        if (typeof value === "number" && value === 0 && 1 / value < 0) {
          return "-0";
        }
        if (typeof value === "object" && value !== null) {
          if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) {
            return value.toString();
          }
          return inspect2(value, {
            depth: 0,
            colors: false
          });
        }
        return String(value);
      }
      case "%d": {
        const value = args[i++];
        if (typeof value === "bigint") {
          return `${value.toString()}n`;
        }
        return Number(value).toString();
      }
      case "%i": {
        const value = args[i++];
        if (typeof value === "bigint") {
          return `${value.toString()}n`;
        }
        return Number.parseInt(String(value)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args[i++])).toString();
      case "%o":
        return inspect2(args[i++], {
          showHidden: true,
          showProxy: true
        });
      case "%O":
        return inspect2(args[i++]);
      case "%c": {
        i++;
        return "";
      }
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (err) {
          const m2 = err.message;
          if (m2.includes("circular structure") || m2.includes("cyclic structures") || m2.includes("cyclic object")) {
            return "[Circular]";
          }
          throw err;
        }
      default:
        return x;
    }
  });
  for (let x = args[i]; i < len; x = args[++i]) {
    if (x === null || typeof x !== "object") {
      str2 += ` ${x}`;
    } else {
      str2 += ` ${inspect2(x)}`;
    }
  }
  return str2;
}
__name(format2, "format");
function inspect2(obj, options = {}) {
  if (options.truncate === 0) {
    options.truncate = Number.POSITIVE_INFINITY;
  }
  return inspect(obj, options);
}
__name(inspect2, "inspect");
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");
function assertTypes(value, name, types) {
  const receivedType = typeof value;
  const pass = types.includes(receivedType);
  if (!pass) {
    throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
  }
}
__name(assertTypes, "assertTypes");
function isObject2(item) {
  return item != null && typeof item === "object" && !Array.isArray(item);
}
__name(isObject2, "isObject");
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
__name(isFinalObj, "isFinalObj");
function getType2(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
__name(getType2, "getType");
function collectOwnProperties(obj, collector) {
  const collect = typeof collector === "function" ? collector : (key) => collector.add(key);
  Object.getOwnPropertyNames(obj).forEach(collect);
  Object.getOwnPropertySymbols(obj).forEach(collect);
}
__name(collectOwnProperties, "collectOwnProperties");
function getOwnProperties(obj) {
  const ownProps = /* @__PURE__ */ new Set();
  if (isFinalObj(obj)) {
    return [];
  }
  collectOwnProperties(obj, ownProps);
  return Array.from(ownProps);
}
__name(getOwnProperties, "getOwnProperties");
var defaultCloneOptions = { forceWritable: false };
function deepClone(val, options = defaultCloneOptions) {
  const seen = /* @__PURE__ */ new WeakMap();
  return clone(val, seen, options);
}
__name(deepClone, "deepClone");
function clone(val, seen, options = defaultCloneOptions) {
  let k, out;
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    out = Array.from({ length: k = val.length });
    seen.set(val, out);
    while (k--) {
      out[k] = clone(val[k], seen, options);
    }
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val));
    seen.set(val, out);
    const props = getOwnProperties(val);
    for (const k2 of props) {
      const descriptor = Object.getOwnPropertyDescriptor(val, k2);
      if (!descriptor) {
        continue;
      }
      const cloned = clone(val[k2], seen, options);
      if (options.forceWritable) {
        Object.defineProperty(out, k2, {
          enumerable: descriptor.enumerable,
          configurable: true,
          writable: true,
          value: cloned
        });
      } else if ("get" in descriptor) {
        Object.defineProperty(out, k2, {
          ...descriptor,
          get() {
            return cloned;
          }
        });
      } else {
        Object.defineProperty(out, k2, {
          ...descriptor,
          value: cloned
        });
      }
    }
    return out;
  }
  return val;
}
__name(clone, "clone");
function noop2() {
}
__name(noop2, "noop");
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
var _Diff = class _Diff2 {
  0;
  1;
  constructor(op, text) {
    this[0] = op;
    this[1] = text;
  }
};
__name(_Diff, "Diff");
var Diff = _Diff;
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
__name(diff_commonPrefix, "diff_commonPrefix");
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
    return 0;
  }
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
__name(diff_commonSuffix, "diff_commonSuffix");
function diff_commonOverlap_(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0) {
    return 0;
  }
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2) {
    return text_length;
  }
  let best = 0;
  let length = 1;
  while (true) {
    const pattern = text1.substring(text_length - length);
    const found = text2.indexOf(pattern);
    if (found === -1) {
      return best;
    }
    length += found;
    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
}
__name(diff_commonOverlap_, "diff_commonOverlap_");
function diff_cleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer2 = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer2 < diffs.length) {
    if (diffs[pointer2][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer2;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer2][1];
    } else {
      if (diffs[pointer2][0] === DIFF_INSERT) {
        length_insertions2 += diffs[pointer2][1].length;
      } else {
        length_deletions2 += diffs[pointer2][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer2 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer2++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
  diff_cleanupSemanticLossless(diffs);
  pointer2 = 1;
  while (pointer2 < diffs.length) {
    if (diffs[pointer2 - 1][0] === DIFF_DELETE && diffs[pointer2][0] === DIFF_INSERT) {
      const deletion = diffs[pointer2 - 1][1];
      const insertion = diffs[pointer2][1];
      const overlap_length1 = diff_commonOverlap_(deletion, insertion);
      const overlap_length2 = diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer2 - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer2 + 1][1] = insertion.substring(overlap_length1);
          pointer2++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer2 - 1][0] = DIFF_INSERT;
          diffs[pointer2 - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer2 + 1][0] = DIFF_DELETE;
          diffs[pointer2 + 1][1] = deletion.substring(overlap_length2);
          pointer2++;
        }
      }
      pointer2++;
    }
    pointer2++;
  }
}
__name(diff_cleanupSemantic, "diff_cleanupSemantic");
var nonAlphaNumericRegex_ = /[^a-z0-9]/i;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer2 = 1;
  while (pointer2 < diffs.length - 1) {
    if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer2 - 1][1];
      let edit = diffs[pointer2][1];
      let equality2 = diffs[pointer2 + 1][1];
      const commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer2 - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer2 - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer2 - 1, 1);
          pointer2--;
        }
        diffs[pointer2][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer2 + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer2 + 1, 1);
          pointer2--;
        }
      }
    }
    pointer2++;
  }
}
__name(diff_cleanupSemanticLossless, "diff_cleanupSemanticLossless");
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer2 = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer2 < diffs.length) {
    switch (diffs[pointer2][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer2][1];
        pointer2++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer2][1];
        pointer2++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer2 - count_delete - count_insert > 0 && diffs[pointer2 - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer2 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer2++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer2][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer2][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer2 -= count_delete + count_insert;
          diffs.splice(pointer2, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer2, 0, new Diff(DIFF_DELETE, text_delete));
            pointer2++;
          }
          if (text_insert.length) {
            diffs.splice(pointer2, 0, new Diff(DIFF_INSERT, text_insert));
            pointer2++;
          }
          pointer2++;
        } else if (pointer2 !== 0 && diffs[pointer2 - 1][0] === DIFF_EQUAL) {
          diffs[pointer2 - 1][1] += diffs[pointer2][1];
          diffs.splice(pointer2, 1);
        } else {
          pointer2++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  let changes = false;
  pointer2 = 1;
  while (pointer2 < diffs.length - 1) {
    if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer2][1].substring(diffs[pointer2][1].length - diffs[pointer2 - 1][1].length) === diffs[pointer2 - 1][1]) {
        diffs[pointer2][1] = diffs[pointer2 - 1][1] + diffs[pointer2][1].substring(0, diffs[pointer2][1].length - diffs[pointer2 - 1][1].length);
        diffs[pointer2 + 1][1] = diffs[pointer2 - 1][1] + diffs[pointer2 + 1][1];
        diffs.splice(pointer2 - 1, 1);
        changes = true;
      } else if (diffs[pointer2][1].substring(0, diffs[pointer2 + 1][1].length) === diffs[pointer2 + 1][1]) {
        diffs[pointer2 - 1][1] += diffs[pointer2 + 1][1];
        diffs[pointer2][1] = diffs[pointer2][1].substring(diffs[pointer2 + 1][1].length) + diffs[pointer2 + 1][1];
        diffs.splice(pointer2 + 1, 1);
        changes = true;
      }
    }
    pointer2++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}
__name(diff_cleanupMerge, "diff_cleanupMerge");
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two) {
    return 6;
  }
  const char1 = one.charAt(one.length - 1);
  const char2 = two.charAt(0);
  const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
  const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
  const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
  const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
  const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
  const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
  const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
  const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  if (blankLine1 || blankLine2) {
    return 5;
  } else if (lineBreak1 || lineBreak2) {
    return 4;
  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
    return 3;
  } else if (whitespace1 || whitespace2) {
    return 2;
  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
    return 1;
  }
  return 0;
}
__name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
var NO_DIFF_MESSAGE = "Compared values have no visual difference.";
var SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  Object.defineProperty(build, "__esModule", {
    value: true
  });
  build.default = diffSequence;
  const pkg = "diff-sequences";
  const NOT_YET_SET = 0;
  const countCommonItemsF = __name((aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
      aIndex += 1;
      bIndex += 1;
      nCommon += 1;
    }
    return nCommon;
  }, "countCommonItemsF");
  const countCommonItemsR = __name((aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
      aIndex -= 1;
      bIndex -= 1;
      nCommon += 1;
    }
    return nCommon;
  }, "countCommonItemsR");
  const extendPathsF = __name((d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0;
    let kF = -d;
    let aFirst = aIndexesF[iF];
    let aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF(
      aFirst + 1,
      aEnd,
      bF + aFirst - kF + 1,
      bEnd,
      isCommon
    );
    const nF = d < iMaxF ? d : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
        aFirst = aIndexesF[iF];
      } else {
        aFirst = aIndexPrev1 + 1;
        if (aEnd <= aFirst) {
          return iF - 1;
        }
      }
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  }, "extendPathsF");
  const extendPathsR = __name((d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0;
    let kR = d;
    let aFirst = aIndexesR[iR];
    let aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bR + aFirst - kR - 1,
      isCommon
    );
    const nR = d < iMaxR ? d : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
        aFirst = aIndexesR[iR];
      } else {
        aFirst = aIndexPrev1 - 1;
        if (aFirst < aStart) {
          return iR - 1;
        }
      }
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aFirst - countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
    }
    return iMaxR;
  }, "extendPathsR");
  const extendOverlappablePathsF = __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    const bF = bStart - aStart;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    const kMinOverlapF = -baDeltaLength - (d - 1);
    const kMaxOverlapF = -baDeltaLength + (d - 1);
    let aIndexPrev1 = NOT_YET_SET;
    const nF = d < iMaxF ? d : iMaxF;
    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
      const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];
      const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
      const aFirst = insert ? aLastPrev : aLastPrev + 1;
      const bFirst = bF + aFirst - kF;
      const nCommonF = countCommonItemsF(
        aFirst + 1,
        aEnd,
        bFirst + 1,
        bEnd,
        isCommon
      );
      const aLast = aFirst + nCommonF;
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aLast;
      if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        const iR = (d - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
          const nCommonR = countCommonItemsR(
            aStart,
            aLastPrev,
            bStart,
            bLastPrev,
            isCommon
          );
          const aIndexPrevFirst = aLastPrev - nCommonR;
          const bIndexPrevFirst = bLastPrev - nCommonR;
          const aEndPreceding = aIndexPrevFirst + 1;
          const bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d - 1;
          if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aEndPreceding;
            division.bEndPreceding = bEndPreceding;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aEndPreceding;
            division.bCommonPreceding = bEndPreceding;
          }
          division.nCommonFollowing = nCommonF;
          if (nCommonF !== 0) {
            division.aCommonFollowing = aFirst + 1;
            division.bCommonFollowing = bFirst + 1;
          }
          const aStartFollowing = aLast + 1;
          const bStartFollowing = bFirst + nCommonF + 1;
          division.nChangeFollowing = d - 1;
          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            division.aStartFollowing = aStartFollowing;
            division.bStartFollowing = bStartFollowing;
          }
          return true;
        }
      }
    }
    return false;
  }, "extendOverlappablePathsF");
  const extendOverlappablePathsR = __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    const bR = bEnd - aEnd;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    const kMinOverlapR = baDeltaLength - d;
    const kMaxOverlapR = baDeltaLength + d;
    let aIndexPrev1 = NOT_YET_SET;
    const nR = d < iMaxR ? d : iMaxR;
    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
      const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;
      const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
      const aFirst = insert ? aLastPrev : aLastPrev - 1;
      const bFirst = bR + aFirst - kR;
      const nCommonR = countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bFirst - 1,
        isCommon
      );
      const aLast = aFirst - nCommonR;
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aLast;
      if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        const iF = (d + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          const bLast = bFirst - nCommonR;
          division.nChangePreceding = d;
          if (d === aLast + bLast - aStart - bStart) {
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aLast;
            division.bEndPreceding = bLast;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aLast;
            division.bCommonPreceding = bLast;
          }
          division.nChangeFollowing = d - 1;
          if (d === 1) {
            division.nCommonFollowing = 0;
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
            const nCommonF = countCommonItemsF(
              aLastPrev,
              aEnd,
              bLastPrev,
              bEnd,
              isCommon
            );
            division.nCommonFollowing = nCommonF;
            if (nCommonF !== 0) {
              division.aCommonFollowing = aLastPrev;
              division.bCommonFollowing = bLastPrev;
            }
            const aStartFollowing = aLastPrev + nCommonF;
            const bStartFollowing = bLastPrev + nCommonF;
            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              division.aStartFollowing = aStartFollowing;
              division.bStartFollowing = bStartFollowing;
            }
          }
          return true;
        }
      }
    }
    return false;
  }, "extendOverlappablePathsR");
  const divide = __name((nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    const bF = bStart - aStart;
    const bR = bEnd - aEnd;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    let iMaxF = aLength;
    let iMaxR = aLength;
    aIndexesF[0] = aStart - 1;
    aIndexesR[0] = aEnd;
    if (baDeltaLength % 2 === 0) {
      const dMin = (nChange || baDeltaLength) / 2;
      const dMax = (aLength + bLength) / 2;
      for (let d = 1; d <= dMax; d += 1) {
        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        if (d < dMin) {
          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        } else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsR(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        ) {
          return;
        }
      }
    } else {
      const dMin = ((nChange || baDeltaLength) + 1) / 2;
      const dMax = (aLength + bLength + 1) / 2;
      let d = 1;
      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
      for (d += 1; d <= dMax; d += 1) {
        iMaxR = extendPathsR(
          d - 1,
          aStart,
          bStart,
          bR,
          isCommon,
          aIndexesR,
          iMaxR
        );
        if (d < dMin) {
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        } else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsF(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        ) {
          return;
        }
      }
    }
    throw new Error(
      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
    );
  }, "divide");
  const findSubsequences = __name((nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      transposed = !transposed;
      if (transposed && callbacks.length === 1) {
        const { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = {
          foundSubsequence: __name((nCommon, bCommon, aCommon) => {
            foundSubsequence2(nCommon, aCommon, bCommon);
          }, "foundSubsequence"),
          isCommon: __name((bIndex, aIndex) => isCommon2(aIndex, bIndex), "isCommon")
        };
      }
      const tStart = aStart;
      const tEnd = aEnd;
      aStart = bStart;
      aEnd = bEnd;
      bStart = tStart;
      bEnd = tEnd;
    }
    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide(
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division
    );
    const {
      nChangePreceding,
      aEndPreceding,
      bEndPreceding,
      nCommonPreceding,
      aCommonPreceding,
      bCommonPreceding,
      nCommonFollowing,
      aCommonFollowing,
      bCommonFollowing,
      nChangeFollowing,
      aStartFollowing,
      bStartFollowing
    } = division;
    if (aStart < aEndPreceding && bStart < bEndPreceding) {
      findSubsequences(
        nChangePreceding,
        aStart,
        aEndPreceding,
        bStart,
        bEndPreceding,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }
    if (nCommonPreceding !== 0) {
      foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
    }
    if (nCommonFollowing !== 0) {
      foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
    }
    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
      findSubsequences(
        nChangeFollowing,
        aStartFollowing,
        aEnd,
        bStartFollowing,
        bEnd,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }
  }, "findSubsequences");
  const validateLength = __name((name, arg) => {
    if (typeof arg !== "number") {
      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    }
    if (!Number.isSafeInteger(arg)) {
      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    }
    if (arg < 0) {
      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }
  }, "validateLength");
  const validateCallback = __name((name, arg) => {
    const type = typeof arg;
    if (type !== "function") {
      throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    }
  }, "validateCallback");
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength("aLength", aLength);
    validateLength("bLength", bLength);
    validateCallback("isCommon", isCommon);
    validateCallback("foundSubsequence", foundSubsequence);
    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0) {
      foundSubsequence(nCommonF, 0, 0);
    }
    if (aLength !== nCommonF || bLength !== nCommonF) {
      const aStart = nCommonF;
      const bStart = nCommonF;
      const nCommonR = countCommonItemsR(
        aStart,
        aLength - 1,
        bStart,
        bLength - 1,
        isCommon
      );
      const aEnd = aLength - nCommonR;
      const bEnd = bLength - nCommonR;
      const nCommonFR = nCommonF + nCommonR;
      if (aLength !== nCommonFR && bLength !== nCommonFR) {
        const nChange = 0;
        const transposed = false;
        const callbacks = [
          {
            foundSubsequence,
            isCommon
          }
        ];
        const aIndexesF = [NOT_YET_SET];
        const aIndexesR = [NOT_YET_SET];
        const division = {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        };
        findSubsequences(
          nChange,
          aStart,
          aEnd,
          bStart,
          bEnd,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      }
      if (nCommonR !== 0) {
        foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
  }
  __name(diffSequence, "diffSequence");
  return build;
}
__name(requireBuild, "requireBuild");
var buildExports = requireBuild();
var diffSequences = getDefaultExportFromCjs2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
__name(formatTrailingSpaces, "formatTrailingSpaces");
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
__name(printDiffLine, "printDiffLine");
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
__name(printDeleteLine, "printDeleteLine");
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
__name(printInsertLine, "printInsertLine");
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
__name(printCommonLine, "printCommonLine");
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
__name(createPatchMark, "createPatchMark");
function joinAlignedDiffsNoExpand(diffs, options) {
  const iLength = diffs.length;
  const nContextLines = options.contextLines;
  const nContextLines2 = nContextLines + nContextLines;
  let jLength = iLength;
  let hasExcessAtStartOrEnd = false;
  let nExcessesBetweenChanges = 0;
  let i = 0;
  while (i !== iLength) {
    const iStart = i;
    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {
      i += 1;
    }
    if (iStart !== i) {
      if (iStart === 0) {
        if (i > nContextLines) {
          jLength -= i - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else if (i === iLength) {
        const n = i - iStart;
        if (n > nContextLines) {
          jLength -= n - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else {
        const n = i - iStart;
        if (n > nContextLines2) {
          jLength -= n - nContextLines2;
          nExcessesBetweenChanges += 1;
        }
      }
    }
    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {
      i += 1;
    }
  }
  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  if (nExcessesBetweenChanges !== 0) {
    jLength += nExcessesBetweenChanges + 1;
  } else if (hasExcessAtStartOrEnd) {
    jLength += 1;
  }
  const jLast = jLength - 1;
  const lines = [];
  let jPatchMark = 0;
  if (hasPatch) {
    lines.push("");
  }
  let aStart = 0;
  let bStart = 0;
  let aEnd = 0;
  let bEnd = 0;
  const pushCommonLine = __name((line) => {
    const j = lines.length;
    lines.push(printCommonLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
    bEnd += 1;
  }, "pushCommonLine");
  const pushDeleteLine = __name((line) => {
    const j = lines.length;
    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
  }, "pushDeleteLine");
  const pushInsertLine = __name((line) => {
    const j = lines.length;
    lines.push(printInsertLine(line, j === 0 || j === jLast, options));
    bEnd += 1;
  }, "pushInsertLine");
  i = 0;
  while (i !== iLength) {
    let iStart = i;
    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {
      i += 1;
    }
    if (iStart !== i) {
      if (iStart === 0) {
        if (i > nContextLines) {
          iStart = i - nContextLines;
          aStart = iStart;
          bStart = iStart;
          aEnd = aStart;
          bEnd = bStart;
        }
        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else if (i === iLength) {
        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else {
        const nCommon = i - iStart;
        if (nCommon > nContextLines2) {
          const iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
          jPatchMark = lines.length;
          lines.push("");
          const nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit;
          bStart = bEnd + nOmit;
          aEnd = aStart;
          bEnd = bStart;
          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
        } else {
          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
        }
      }
    }
    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {
      pushDeleteLine(diffs[i][1]);
      i += 1;
    }
    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {
      pushInsertLine(diffs[i][1]);
      i += 1;
    }
  }
  if (hasPatch) {
    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
  }
  return lines.join("\n");
}
__name(joinAlignedDiffsNoExpand, "joinAlignedDiffsNoExpand");
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff2, i, diffs2) => {
    const line = diff2[1];
    const isFirstOrLast = i === 0 || i === diffs2.length - 1;
    switch (diff2[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join("\n");
}
__name(joinAlignedDiffsExpand, "joinAlignedDiffsExpand");
var noColor = __name((string) => string, "noColor");
var DIFF_CONTEXT_DEFAULT = 5;
var DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: s.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: s.red,
    bIndicator: "+",
    changeColor: s.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: s.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: false,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: s.yellow,
    printBasicPrototype: false,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
__name(getDefaultOptions, "getDefaultOptions");
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys === "function" ? compareKeys : void 0;
}
__name(getCompareKeys, "getCompareKeys");
function getContextLines(contextLines) {
  return typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
__name(getContextLines, "getContextLines");
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  };
}
__name(normalizeDiffOptions, "normalizeDiffOptions");
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
__name(isEmptyString, "isEmptyString");
function countChanges(diffs) {
  let a2 = 0;
  let b = 0;
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        a2 += 1;
        break;
      case DIFF_INSERT:
        b += 1;
        break;
    }
  });
  return {
    a: a2,
    b
  };
}
__name(countChanges, "countChanges");
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines) {
    return "";
  }
  let aRest = "";
  let bRest = "";
  if (includeChangeCounts) {
    const aCount = String(changeCounts.a);
    const bCount = String(changeCounts.b);
    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
    const aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
    const bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
    const baCountLengthDiff = bCount.length - aCount.length;
    const aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
    const bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  const a2 = `${aIndicator} ${aAnnotation}${aRest}`;
  const b = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a2)}
${bColor(b)}

`;
}
__name(printAnnotation, "printAnnotation");
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
}
__name(printDiffLines, "printDiffLines");
function diffLinesUnified(aLines, bLines, options) {
  const normalizedOptions = normalizeDiffOptions(options);
  const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
__name(diffLinesUnified, "diffLinesUnified");
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
    aLinesDisplay = [];
    aLinesCompare = [];
  }
  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
    bLinesDisplay = [];
    bLinesCompare = [];
  }
  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  }
  const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);
  let aIndex = 0;
  let bIndex = 0;
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        diff2[1] = aLinesDisplay[aIndex];
        aIndex += 1;
        break;
      case DIFF_INSERT:
        diff2[1] = bLinesDisplay[bIndex];
        bIndex += 1;
        break;
      default:
        diff2[1] = bLinesDisplay[bIndex];
        aIndex += 1;
        bIndex += 1;
    }
  });
  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
__name(diffLinesUnified2, "diffLinesUnified2");
function diffLinesRaw(aLines, bLines, options) {
  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
  const aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length;
  const bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length;
  const truncated = aLength !== aLines.length || bLength !== bLines.length;
  const isCommon = __name((aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], "isCommon");
  const diffs = [];
  let aIndex = 0;
  let bIndex = 0;
  const foundSubsequence = __name((nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1) {
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    }
    for (; bIndex !== bCommon; bIndex += 1) {
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    }
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }
  }, "foundSubsequence");
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  for (; aIndex !== aLength; aIndex += 1) {
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  }
  for (; bIndex !== bLength; bIndex += 1) {
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  }
  return [diffs, truncated];
}
__name(diffLinesRaw, "diffLinesRaw");
function getType3(value) {
  if (value === void 0) {
    return "undefined";
  } else if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (typeof value === "function") {
    return "function";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "string") {
    return "string";
  } else if (typeof value === "bigint") {
    return "bigint";
  } else if (typeof value === "object") {
    if (value != null) {
      if (value.constructor === RegExp) {
        return "regexp";
      } else if (value.constructor === Map) {
        return "map";
      } else if (value.constructor === Set) {
        return "set";
      } else if (value.constructor === Date) {
        return "date";
      }
    }
    return "object";
  } else if (typeof value === "symbol") {
    return "symbol";
  }
  throw new Error(`value of unknown type: ${value}`);
}
__name(getType3, "getType");
function getNewLineSymbol(string) {
  return string.includes("\r\n") ? "\r\n" : "\n";
}
__name(getNewLineSymbol, "getNewLineSymbol");
function diffStrings(a2, b, options) {
  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
  let aLength = a2.length;
  let bLength = b.length;
  if (truncate2) {
    const aMultipleLines = a2.includes("\n");
    const bMultipleLines = b.includes("\n");
    const aNewLineSymbol = getNewLineSymbol(a2);
    const bNewLineSymbol = getNewLineSymbol(b);
    const _a = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a2;
    const _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b;
    aLength = _a.length;
    bLength = _b.length;
  }
  const truncated = aLength !== a2.length || bLength !== b.length;
  const isCommon = __name((aIndex2, bIndex2) => a2[aIndex2] === b[bIndex2], "isCommon");
  let aIndex = 0;
  let bIndex = 0;
  const diffs = [];
  const foundSubsequence = __name((nCommon, aCommon, bCommon) => {
    if (aIndex !== aCommon) {
      diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon)));
    }
    if (bIndex !== bCommon) {
      diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));
    }
    aIndex = aCommon + nCommon;
    bIndex = bCommon + nCommon;
    diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));
  }, "foundSubsequence");
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  if (aIndex !== aLength) {
    diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex)));
  }
  if (bIndex !== bLength) {
    diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));
  }
  return [diffs, truncated];
}
__name(diffStrings, "diffStrings");
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
}
__name(concatenateRelevantDiffs, "concatenateRelevantDiffs");
var _ChangeBuffer = class _ChangeBuffer2 {
  op;
  line;
  lines;
  changeColor;
  constructor(op, changeColor) {
    this.op = op;
    this.line = [];
    this.lines = [];
    this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));
    this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(diff2) {
    this.line.push(diff2);
  }
  // Main input to buffer.
  align(diff2) {
    const string = diff2[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i) => {
        if (i < iLast) {
          this.pushSubstring(substring);
          this.pushLine();
        } else if (substring.length !== 0) {
          this.pushSubstring(substring);
        }
      });
    } else {
      this.pushDiff(diff2);
    }
  }
  // Output from buffer.
  moveLinesTo(lines) {
    if (!this.isLineEmpty()) {
      this.pushLine();
    }
    lines.push(...this.lines);
    this.lines.length = 0;
  }
};
__name(_ChangeBuffer, "ChangeBuffer");
var ChangeBuffer = _ChangeBuffer;
var _CommonBuffer = class _CommonBuffer2 {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(deleteBuffer, insertBuffer) {
    this.deleteBuffer = deleteBuffer;
    this.insertBuffer = insertBuffer;
    this.lines = [];
  }
  pushDiffCommonLine(diff2) {
    this.lines.push(diff2);
  }
  pushDiffChangeLines(diff2) {
    const isDiffEmpty = diff2[1].length === 0;
    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {
      this.deleteBuffer.pushDiff(diff2);
    }
    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {
      this.insertBuffer.pushDiff(diff2);
    }
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines);
    this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff2) {
    const op = diff2[0];
    const string = diff2[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i) => {
        if (i === 0) {
          const subdiff = new Diff(op, substring);
          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
            this.flushChangeLines();
            this.pushDiffCommonLine(subdiff);
          } else {
            this.pushDiffChangeLines(subdiff);
            this.flushChangeLines();
          }
        } else if (i < iLast) {
          this.pushDiffCommonLine(new Diff(op, substring));
        } else if (substring.length !== 0) {
          this.pushDiffChangeLines(new Diff(op, substring));
        }
      });
    } else {
      this.pushDiffChangeLines(diff2);
    }
  }
  // Output from buffer.
  getLines() {
    this.flushChangeLines();
    return this.lines;
  }
};
__name(_CommonBuffer, "CommonBuffer");
var CommonBuffer = _CommonBuffer;
function getAlignedDiffs(diffs, changeColor) {
  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff2);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff2);
        break;
      default:
        commonBuffer.align(diff2);
    }
  });
  return commonBuffer.getLines();
}
__name(getAlignedDiffs, "getAlignedDiffs");
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    const iLast = diffs.length - 1;
    return diffs.some((diff2, i) => diff2[0] === DIFF_EQUAL && (i !== iLast || diff2[1] !== "\n"));
  }
  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
}
__name(hasCommonDiff, "hasCommonDiff");
function diffStringsUnified(a2, b, options) {
  if (a2 !== b && a2.length !== 0 && b.length !== 0) {
    const isMultiline = a2.includes("\n") || b.includes("\n");
    const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}
` : a2, isMultiline ? `${b}
` : b, true, options);
    if (hasCommonDiff(diffs, isMultiline)) {
      const optionsNormalized = normalizeDiffOptions(options);
      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a2.split("\n"), b.split("\n"), options);
}
__name(diffStringsUnified, "diffStringsUnified");
function diffStringsRaw(a2, b, cleanup, options) {
  const [diffs, truncated] = diffStrings(a2, b, options);
  if (cleanup) {
    diff_cleanupSemantic(diffs);
  }
  return [diffs, truncated];
}
__name(diffStringsRaw, "diffStringsRaw");
function getCommonMessage(message, options) {
  const { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
__name(getCommonMessage, "getCommonMessage");
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins;
var PLUGINS2 = [
  ReactTestComponent2,
  ReactElement2,
  DOMElement2,
  DOMCollection2,
  Immutable2,
  AsymmetricMatcher2,
  plugins.Error
];
var FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS2
};
var FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 8,
  plugins: PLUGINS2
};
function diff(a2, b, options) {
  if (Object.is(a2, b)) {
    return "";
  }
  const aType = getType3(a2);
  let expectedType = aType;
  let omitDifference = false;
  if (aType === "object" && typeof a2.asymmetricMatch === "function") {
    if (a2.$$typeof !== Symbol.for("jest.asymmetricMatcher")) {
      return void 0;
    }
    if (typeof a2.getExpectedType !== "function") {
      return void 0;
    }
    expectedType = a2.getExpectedType();
    omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b)) {
    let truncate2 = function(s2) {
      return s2.length <= MAX_LENGTH ? s2 : `${s2.slice(0, MAX_LENGTH)}...`;
    };
    __name(truncate2, "truncate");
    const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);
    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    let aDisplay = format(a2, formatOptions);
    let bDisplay = format(b, formatOptions);
    const MAX_LENGTH = 1e5;
    aDisplay = truncate2(aDisplay);
    bDisplay = truncate2(bDisplay);
    const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`;
    const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (omitDifference) {
    return void 0;
  }
  switch (aType) {
    case "string":
      return diffLinesUnified(a2.split("\n"), b.split("\n"), options);
    case "boolean":
    case "number":
      return comparePrimitive(a2, b, options);
    case "map":
      return compareObjects(sortMap(a2), sortMap(b), options);
    case "set":
      return compareObjects(sortSet(a2), sortSet(b), options);
    default:
      return compareObjects(a2, b, options);
  }
}
__name(diff, "diff");
function comparePrimitive(a2, b, options) {
  const aFormat = format(a2, FORMAT_OPTIONS);
  const bFormat = format(b, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split("\n"), bFormat.split("\n"), options);
}
__name(comparePrimitive, "comparePrimitive");
function sortMap(map2) {
  return new Map(Array.from(map2.entries()).sort());
}
__name(sortMap, "sortMap");
function sortSet(set) {
  return new Set(Array.from(set.values()).sort());
}
__name(sortSet, "sortSet");
function compareObjects(a2, b, options) {
  let difference;
  let hasThrown = false;
  try {
    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b, formatOptions, options);
  } catch {
    hasThrown = true;
  }
  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  if (difference === void 0 || difference === noDiffMessage) {
    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b, formatOptions, options);
    if (difference !== noDiffMessage && !hasThrown) {
      difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`;
    }
  }
  return difference;
}
__name(compareObjects, "compareObjects");
function getFormatOptions(formatOptions, options) {
  const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
  return {
    ...formatOptions,
    compareKeys,
    printBasicPrototype,
    maxDepth: maxDepth ?? formatOptions.maxDepth
  };
}
__name(getFormatOptions, "getFormatOptions");
function getObjectsDifference(a2, b, formatOptions, options) {
  const formatOptionsZeroIndent = {
    ...formatOptions,
    indent: 0
  };
  const aCompare = format(a2, formatOptionsZeroIndent);
  const bCompare = format(b, formatOptionsZeroIndent);
  if (aCompare === bCompare) {
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  } else {
    const aDisplay = format(a2, formatOptions);
    const bDisplay = format(b, formatOptions);
    return diffLinesUnified2(aDisplay.split("\n"), bDisplay.split("\n"), aCompare.split("\n"), bCompare.split("\n"), options);
  }
}
__name(getObjectsDifference, "getObjectsDifference");
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  const type = getType2(data);
  return type === "Object" && typeof data.asymmetricMatch === "function";
}
__name(isAsymmetricMatcher, "isAsymmetricMatcher");
function isReplaceable(obj1, obj2) {
  const obj1Type = getType2(obj1);
  const obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
__name(isReplaceable, "isReplaceable");
function printDiffOrStringify(received, expected, options) {
  const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
  if (typeof expected === "string" && typeof received === "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes("\n") || received.includes("\n")) {
      return diffStringsUnified(expected, received, options);
    }
    const [diffs] = diffStringsRaw(expected, received, true);
    const hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
    const printLabel = getLabelPrinter(aAnnotation, bAnnotation);
    const expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2));
    const receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
    return `${expectedLine}
${receivedLine}`;
  }
  const clonedExpected = deepClone(expected, { forceWritable: true });
  const clonedReceived = deepClone(received, { forceWritable: true });
  const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
  const difference = diff(replacedExpected, replacedActual, options);
  return difference;
}
__name(printDiffOrStringify, "printDiffOrStringify");
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== "undefined" && typeof expected.cause === "undefined") {
    delete actual.cause;
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (!isReplaceable(actual, expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (actualReplaced.has(actual) || expectedReplaced.has(expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  actualReplaced.add(actual);
  expectedReplaced.add(expected);
  getOwnProperties(expected).forEach((key) => {
    const expectedValue = expected[key];
    const actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue)) {
      if (expectedValue.asymmetricMatch(actualValue)) {
        actual[key] = expectedValue;
      }
    } else if (isAsymmetricMatcher(actualValue)) {
      if (actualValue.asymmetricMatch(expectedValue)) {
        expected[key] = actualValue;
      }
    } else if (isReplaceable(actualValue, expectedValue)) {
      const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual;
      expected[key] = replaced.replacedExpected;
    }
  });
  return {
    replacedActual: actual,
    replacedExpected: expected
  };
}
__name(replaceAsymmetricMatcher, "replaceAsymmetricMatcher");
function getLabelPrinter(...strings) {
  const maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
__name(getLabelPrinter, "getLabelPrinter");
var SPACE_SYMBOL = "·";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
__name(replaceTrailingSpaces, "replaceTrailingSpaces");
function printReceived(object) {
  return s.red(replaceTrailingSpaces(stringify2(object)));
}
__name(printReceived, "printReceived");
function printExpected(value) {
  return s.green(replaceTrailingSpaces(stringify2(value)));
}
__name(printExpected, "printExpected");
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
}
__name(getCommonAndChangedSubstrings, "getCommonAndChangedSubstrings");
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v) {
  return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);
}
__name(isImmutable, "isImmutable");
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  if (err instanceof Error) {
    return `<unserializable>: ${err.message}`;
  }
  if (typeof err === "string") {
    return `<unserializable>: ${err}`;
  }
  return "<unserializable>";
}
__name(getUnserializableMessage, "getUnserializableMessage");
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val === "string") {
    return val;
  }
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON === "function") {
    const jsonValue = val.toJSON();
    if (jsonValue && jsonValue !== val && typeof jsonValue === "object") {
      if (typeof val.message === "string") {
        safe(() => jsonValue.message ?? (jsonValue.message = val.message));
      }
      if (typeof val.stack === "string") {
        safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));
      }
      if (typeof val.name === "string") {
        safe(() => jsonValue.name ?? (jsonValue.name = val.name));
      }
      if (val.cause != null) {
        safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));
      }
    }
    return serializeValue(jsonValue, seen);
  }
  if (typeof val === "function") {
    return `Function<${val.name || "anonymous"}>`;
  }
  if (typeof val === "symbol") {
    return val.toString();
  }
  if (typeof val !== "object") {
    return val;
  }
  if (typeof Buffer !== "undefined" && val instanceof Buffer) {
    return `<Buffer(${val.length}) ...>`;
  }
  if (typeof Uint8Array !== "undefined" && val instanceof Uint8Array) {
    return `<Uint8Array(${val.length}) ...>`;
  }
  if (isImmutable(val)) {
    return serializeValue(val.toJSON(), seen);
  }
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") {
    return "Promise";
  }
  if (typeof Element !== "undefined" && val instanceof Element) {
    return val.tagName;
  }
  if (typeof val.asymmetricMatch === "function") {
    return `${val.toString()} ${format2(val.sample)}`;
  }
  if (typeof val.toJSON === "function") {
    return serializeValue(val.toJSON(), seen);
  }
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    const clone2 = new Array(val.length);
    seen.set(val, clone2);
    val.forEach((e, i) => {
      try {
        clone2[i] = serializeValue(e, seen);
      } catch (err) {
        clone2[i] = getUnserializableMessage(err);
      }
    });
    return clone2;
  } else {
    const clone2 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone2);
    let obj = val;
    while (obj && obj !== OBJECT_PROTO) {
      Object.getOwnPropertyNames(obj).forEach((key) => {
        if (key in clone2) {
          return;
        }
        try {
          clone2[key] = serializeValue(val[key], seen);
        } catch (err) {
          delete clone2[key];
          clone2[key] = getUnserializableMessage(err);
        }
      });
      obj = Object.getPrototypeOf(obj);
    }
    return clone2;
  }
}
__name(serializeValue, "serializeValue");
function safe(fn2) {
  try {
    return fn2();
  } catch {
  }
}
__name(safe, "safe");
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
__name(normalizeErrorMessage, "normalizeErrorMessage");
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err !== "object") {
    return { message: String(_err) };
  }
  const err = _err;
  if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) {
    err.diff = printDiffOrStringify(err.actual, err.expected, {
      ...diffOptions,
      ...err.diffOptions
    });
  }
  if ("expected" in err && typeof err.expected !== "string") {
    err.expected = stringify2(err.expected, 10);
  }
  if ("actual" in err && typeof err.actual !== "string") {
    err.actual = stringify2(err.actual, 10);
  }
  try {
    if (typeof err.message === "string") {
      err.message = normalizeErrorMessage(err.message);
    }
  } catch {
  }
  try {
    if (!seen.has(err) && typeof err.cause === "object") {
      seen.add(err);
      err.cause = processError(err.cause, diffOptions, seen);
    }
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e === null || e === void 0 ? void 0 : e.message}
Inner error message: ${err === null || err === void 0 ? void 0 : err.message}`));
  }
}
__name(processError, "processError");

// node_modules/storybook/dist/instrumenter/index.js
var import_client_logger13 = __toESM(require_client_logger());
var import_core_events7 = __toESM(require_core_events());
var import_global11 = __toESM(require_global());
var addons2 = globalThis.__STORYBOOK_ADDONS_PREVIEW;
var alreadyCompletedException = new Error(
  `This function ran after the play function completed. Did you forget to \`await\` it?`
);
var isObject3 = __name((o) => Object.prototype.toString.call(o) === "[object Object]", "isObject");
var isModule = __name((o) => Object.prototype.toString.call(o) === "[object Module]", "isModule");
var isInstrumentable = __name((o) => {
  if (!isObject3(o) && !isModule(o)) {
    return false;
  }
  if (o.constructor === void 0) {
    return true;
  }
  const proto = o.constructor.prototype;
  if (!isObject3(proto)) {
    return false;
  }
  return true;
}, "isInstrumentable");
var construct = __name((obj) => {
  try {
    return new obj.constructor();
  } catch {
    return {};
  }
}, "construct");
var getInitialState = __name(() => ({
  renderPhase: "preparing",
  isDebugging: false,
  isPlaying: false,
  isLocked: false,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), "getInitialState");
var getRetainedState = __name((state3, isDebugging = false) => {
  const calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call) => call.retain);
  if (!calls.length) {
    return void 0;
  }
  const callRefsByResult = new Map(
    Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
  );
  return { cursor: calls.length, calls, callRefsByResult };
}, "getRetainedState");
var _Instrumenter = class _Instrumenter2 {
  constructor() {
    this.detached = false;
    this.initialized = false;
    this.state = {};
    this.loadParentWindowState = __name(() => {
      try {
        this.state = import_global11.global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = true;
      }
    }, "loadParentWindowState");
    this.updateParentWindowState = __name(() => {
      try {
        import_global11.global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = true;
      }
    }, "updateParentWindowState");
    this.loadParentWindowState();
    const resetState = __name(({
      storyId,
      renderPhase,
      isPlaying = true,
      isDebugging = false
    }) => {
      const state3 = this.getState(storyId);
      this.setState(storyId, {
        ...getInitialState(),
        ...getRetainedState(state3, isDebugging),
        renderPhase: renderPhase || state3.renderPhase,
        shadowCalls: isDebugging ? state3.shadowCalls : [],
        chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: isDebugging ? state3.playUntil : void 0,
        isPlaying,
        isDebugging
      });
      this.sync(storyId);
    }, "resetState");
    const start = __name((channel) => ({ storyId, playUntil }) => {
      if (!this.getState(storyId).isDebugging) {
        this.setState(storyId, ({ calls }) => ({
          calls: [],
          shadowCalls: calls.map((call) => ({
            ...call,
            status: "waiting"
            /* WAITING */
          })),
          isDebugging: true
        }));
      }
      const log = this.getLog(storyId);
      this.setState(storyId, ({ shadowCalls }) => {
        if (playUntil || !log.length) {
          return { playUntil };
        }
        const firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);
        return {
          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id
        };
      });
      channel.emit(import_core_events7.FORCE_REMOUNT, { storyId, isDebugging: true });
    }, "start");
    const back = __name((channel) => ({ storyId }) => {
      const log = this.getLog(storyId).filter((call) => !call.ancestors?.length);
      const last = log.reduceRight((res, item, index2) => {
        if (res >= 0 || item.status === "waiting") {
          return res;
        }
        return index2;
      }, -1);
      start(channel)({ storyId, playUntil: log[last - 1]?.callId });
    }, "back");
    const goto = __name((channel) => ({ storyId, callId }) => {
      const { calls, shadowCalls, resolvers } = this.getState(storyId);
      const call = calls.find(({ id }) => id === callId);
      const shadowCall = shadowCalls.find(({ id }) => id === callId);
      if (!call && shadowCall && Object.values(resolvers).length > 0) {
        const nextId = this.getLog(storyId).find(
          (c) => c.status === "waiting"
          /* WAITING */
        )?.callId;
        if (shadowCall.id !== nextId) {
          this.setState(storyId, { playUntil: shadowCall.id });
        }
        Object.values(resolvers).forEach((resolve) => resolve());
      } else {
        start(channel)({ storyId, playUntil: callId });
      }
    }, "goto");
    const next = __name((channel) => ({ storyId }) => {
      const { resolvers } = this.getState(storyId);
      if (Object.values(resolvers).length > 0) {
        Object.values(resolvers).forEach((resolve) => resolve());
      } else {
        const nextId = this.getLog(storyId).find(
          (c) => c.status === "waiting"
          /* WAITING */
        )?.callId;
        if (nextId) {
          start(channel)({ storyId, playUntil: nextId });
        } else {
          end({ storyId });
        }
      }
    }, "next");
    const end = __name(({ storyId }) => {
      this.setState(storyId, { playUntil: void 0, isDebugging: false });
      Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
    }, "end");
    const renderPhaseChanged = __name(({
      storyId,
      newPhase
    }) => {
      const { isDebugging } = this.getState(storyId);
      if (newPhase === "preparing" && isDebugging) {
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      } else if (newPhase === "playing") {
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      }
      if (newPhase === "played") {
        this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: false,
          isPlaying: false,
          isDebugging: false
        });
      } else if (newPhase === "errored") {
        this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: false,
          isPlaying: false
        });
      } else if (newPhase === "aborted") {
        this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: true,
          isPlaying: false
        });
      } else {
        this.setState(storyId, {
          renderPhase: newPhase
        });
      }
      this.sync(storyId);
    }, "renderPhaseChanged");
    if (addons2) {
      addons2.ready().then(() => {
        this.channel = addons2.getChannel();
        this.channel.on(import_core_events7.FORCE_REMOUNT, resetState);
        this.channel.on(import_core_events7.STORY_RENDER_PHASE_CHANGED, renderPhaseChanged);
        this.channel.on(import_core_events7.SET_CURRENT_STORY, () => {
          if (this.initialized) {
            this.cleanup();
          } else {
            this.initialized = true;
          }
        });
        this.channel.on(EVENTS3.START, start(this.channel));
        this.channel.on(EVENTS3.BACK, back(this.channel));
        this.channel.on(EVENTS3.GOTO, goto(this.channel));
        this.channel.on(EVENTS3.NEXT, next(this.channel));
        this.channel.on(EVENTS3.END, end);
      });
    }
  }
  getState(storyId) {
    return this.state[storyId] || getInitialState();
  }
  setState(storyId, update) {
    if (storyId) {
      const state3 = this.getState(storyId);
      const patch = typeof update === "function" ? update(state3) : update;
      this.state = { ...this.state, [storyId]: { ...state3, ...patch } };
      this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (acc, [storyId, state3]) => {
        const retainedState = getRetainedState(state3);
        if (!retainedState) {
          return acc;
        }
        acc[storyId] = Object.assign(getInitialState(), retainedState);
        return acc;
      },
      {}
    );
    const controlStates = {
      detached: this.detached,
      start: false,
      back: false,
      goto: false,
      next: false,
      end: false
    };
    const payload = { controlStates, logItems: [] };
    this.channel?.emit(EVENTS3.SYNC, payload);
    this.updateParentWindowState();
  }
  getLog(storyId) {
    const { calls, shadowCalls } = this.getState(storyId);
    const merged = [...shadowCalls];
    calls.forEach((call, index2) => {
      merged[index2] = call;
    });
    const seen = /* @__PURE__ */ new Set();
    return merged.reduceRight((acc, call) => {
      call.args.forEach((arg) => {
        if (arg?.__callId__) {
          seen.add(arg.__callId__);
        }
      });
      call.path.forEach((node) => {
        if (node.__callId__) {
          seen.add(node.__callId__);
        }
      });
      if ((call.interceptable || call.exception) && !seen.has(call.id)) {
        acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors });
        seen.add(call.id);
      }
      return acc;
    }, []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(obj, options, depth = 0) {
    if (!isInstrumentable(obj)) {
      return obj;
    }
    const { mutate = false, path = [] } = options;
    const keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);
    depth += 1;
    return keys.reduce(
      (acc, key) => {
        const descriptor = getPropertyDescriptor(obj, key);
        if (typeof descriptor?.get === "function") {
          if (descriptor.configurable) {
            const getter = __name(() => descriptor?.get?.bind(obj)?.(), "getter");
            Object.defineProperty(acc, key, {
              get: __name(() => {
                return this.instrument(getter(), { ...options, path: path.concat(key) }, depth);
              }, "get")
            });
          }
          return acc;
        }
        const value = obj[key];
        if (typeof value !== "function") {
          acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth);
          return acc;
        }
        if ("__originalFn__" in value && typeof value.__originalFn__ === "function") {
          acc[key] = value;
          return acc;
        }
        acc[key] = (...args) => this.track(key, value, obj, args, options);
        acc[key].__originalFn__ = value;
        Object.defineProperty(acc[key], "name", { value: key, writable: false });
        if (Object.keys(value).length > 0) {
          Object.assign(
            acc[key],
            this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)
          );
        }
        return acc;
      },
      mutate ? obj : construct(obj)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(method, fn2, object, args, options) {
    const storyId = args?.[0]?.__storyId__ || import_global11.global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId;
    const { cursor, ancestors } = this.getState(storyId);
    this.setState(storyId, { cursor: cursor + 1 });
    const id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`;
    const { path = [], intercept = false, retain = false } = options;
    const interceptable = typeof intercept === "function" ? intercept(method, path) : intercept;
    const call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain };
    const interceptOrInvoke = interceptable && !ancestors.length ? this.intercept : this.invoke;
    const result = interceptOrInvoke.call(this, fn2, object, call, options);
    return this.instrument(result, { ...options, mutate: true, path: [{ __callId__: call.id }] });
  }
  intercept(fn2, object, call, options) {
    const { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId);
    const isChainedUpon = chainedCallIds.has(call.id);
    if (!isDebugging || isChainedUpon || playUntil) {
      if (playUntil === call.id) {
        this.setState(call.storyId, { playUntil: void 0 });
      }
      return this.invoke(fn2, object, call, options);
    }
    return new Promise((resolve) => {
      this.setState(call.storyId, ({ resolvers }) => ({
        isLocked: false,
        resolvers: { ...resolvers, [call.id]: resolve }
      }));
    }).then(() => {
      this.setState(call.storyId, (state3) => {
        const { [call.id]: _, ...resolvers } = state3.resolvers;
        return { isLocked: true, resolvers };
      });
      return this.invoke(fn2, object, call, options);
    });
  }
  invoke(fn2, object, call, options) {
    const { callRefsByResult, renderPhase } = this.getState(call.storyId);
    const maximumDepth = 25;
    const serializeValues = __name((value, depth, seen) => {
      if (seen.includes(value)) {
        return "[Circular]";
      }
      seen = [...seen, value];
      if (depth > maximumDepth) {
        return "...";
      }
      if (callRefsByResult.has(value)) {
        return callRefsByResult.get(value);
      }
      if (value instanceof Array) {
        return value.map((it) => serializeValues(it, ++depth, seen));
      }
      if (value instanceof Date) {
        return { __date__: { value: value.toISOString() } };
      }
      if (value instanceof Error) {
        const { name, message, stack } = value;
        return { __error__: { name, message, stack } };
      }
      if (value instanceof RegExp) {
        const { flags, source } = value;
        return { __regexp__: { flags, source } };
      }
      if (value instanceof import_global11.global.window?.HTMLElement) {
        const { prefix: prefix2, localName, id, classList, innerText } = value;
        const classNames = Array.from(classList);
        return { __element__: { prefix: prefix2, localName, id, classNames, innerText } };
      }
      if (typeof value === "function") {
        return {
          __function__: { name: "getMockName" in value ? value.getMockName() : value.name }
        };
      }
      if (typeof value === "symbol") {
        return { __symbol__: { description: value.description } };
      }
      if (typeof value === "object" && value?.constructor?.name && value?.constructor?.name !== "Object") {
        return { __class__: { name: value.constructor.name } };
      }
      if (Object.prototype.toString.call(value) === "[object Object]") {
        return Object.fromEntries(
          Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
        );
      }
      return value;
    }, "serializeValues");
    const info = {
      ...call,
      args: call.args.map((arg) => serializeValues(arg, 0, []))
    };
    call.path.forEach((ref) => {
      if (ref?.__callId__) {
        this.setState(call.storyId, ({ chainedCallIds }) => ({
          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
        }));
      }
    });
    const handleException = __name((e) => {
      if (e instanceof Error) {
        const { name, message, stack, callId = call.id } = e;
        const {
          showDiff = void 0,
          diff: diff2 = void 0,
          actual = void 0,
          expected = void 0
        } = e.name === "AssertionError" ? processError(e) : e;
        const exception = { name, message, stack, callId, showDiff, diff: diff2, actual, expected };
        this.update({ ...info, status: "error", exception });
        this.setState(call.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [e, { __callId__: call.id, retain: call.retain }]
          ])
        }));
        if (call.ancestors?.length) {
          if (!Object.prototype.hasOwnProperty.call(e, "callId")) {
            Object.defineProperty(e, "callId", { value: call.id });
          }
          throw e;
        }
      }
      throw e;
    }, "handleException");
    try {
      if (renderPhase === "played" && !call.retain) {
        throw alreadyCompletedException;
      }
      const actualArgs = options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args;
      const finalArgs = actualArgs.map((arg) => {
        if (typeof arg !== "function" || isClass(arg) || Object.keys(arg).length) {
          return arg;
        }
        return (...args) => {
          const { cursor, ancestors } = this.getState(call.storyId);
          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });
          const restore = __name(() => this.setState(call.storyId, { cursor, ancestors }), "restore");
          let willRestore = false;
          try {
            const res = arg(...args);
            if (res instanceof Promise) {
              willRestore = true;
              return res.finally(restore);
            }
            return res;
          } finally {
            if (!willRestore) {
              restore();
            }
          }
        };
      });
      const result = fn2.apply(object, finalArgs);
      if (result && ["object", "function", "symbol"].includes(typeof result)) {
        this.setState(call.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [result, { __callId__: call.id, retain: call.retain }]
          ])
        }));
      }
      this.update({
        ...info,
        status: result instanceof Promise ? "active" : "done"
        /* DONE */
      });
      if (result instanceof Promise) {
        return result.then((value) => {
          this.update({
            ...info,
            status: "done"
            /* DONE */
          });
          return value;
        }, handleException);
      }
      return result;
    } catch (e) {
      return handleException(e);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(call) {
    this.channel?.emit(EVENTS3.CALL, call);
    this.setState(call.storyId, ({ calls }) => {
      const callsById = calls.concat(call).reduce((a2, c) => Object.assign(a2, { [c.id]: c }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(callsById).sort(
          (a2, b) => a2.id.localeCompare(b.id, void 0, { numeric: true })
        )
      };
    });
    this.sync(call.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(storyId) {
    const synchronize = __name(() => {
      const { isLocked, isPlaying } = this.getState(storyId);
      const logItems = this.getLog(storyId);
      const pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find(
        (item) => item.status === "waiting"
        /* WAITING */
      )?.callId;
      const hasActive = logItems.some(
        (item) => item.status === "active"
        /* ACTIVE */
      );
      if (this.detached || isLocked || hasActive || logItems.length === 0) {
        const controlStates2 = {
          detached: this.detached,
          start: false,
          back: false,
          goto: false,
          next: false,
          end: false
        };
        const payload2 = { controlStates: controlStates2, logItems };
        this.channel?.emit(EVENTS3.SYNC, payload2);
        return;
      }
      const hasPrevious = logItems.some(
        (item) => item.status === "done" || item.status === "error"
        /* ERROR */
      );
      const controlStates = {
        detached: this.detached,
        start: hasPrevious,
        back: hasPrevious,
        goto: true,
        next: isPlaying,
        end: isPlaying
      };
      const payload = { controlStates, logItems, pausedAt };
      this.channel?.emit(EVENTS3.SYNC, payload);
    }, "synchronize");
    this.setState(storyId, ({ syncTimeout }) => {
      clearTimeout(syncTimeout);
      return { syncTimeout: setTimeout(synchronize, 0) };
    });
  }
};
__name(_Instrumenter, "Instrumenter");
var Instrumenter = _Instrumenter;
function instrument(obj, options = {}) {
  try {
    let forceInstrument = false;
    let skipInstrument = false;
    if (import_global11.global.window?.location?.search?.includes("instrument=true")) {
      forceInstrument = true;
    } else if (import_global11.global.window?.location?.search?.includes("instrument=false")) {
      skipInstrument = true;
    }
    if (import_global11.global.window?.parent === import_global11.global.window && !forceInstrument || skipInstrument) {
      return obj;
    }
    if (import_global11.global.window && !import_global11.global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {
      import_global11.global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();
    }
    const instrumenter = import_global11.global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;
    return instrumenter.instrument(obj, options);
  } catch (e) {
    import_client_logger13.once.warn(e);
    return obj;
  }
}
__name(instrument, "instrument");
function getPropertyDescriptor(obj, propName) {
  let target = obj;
  while (target != null) {
    const descriptor = Object.getOwnPropertyDescriptor(target, propName);
    if (descriptor) {
      return descriptor;
    }
    target = Object.getPrototypeOf(target);
  }
  return void 0;
}
__name(getPropertyDescriptor, "getPropertyDescriptor");
function isClass(obj) {
  if (typeof obj !== "function") {
    return false;
  }
  const descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
  if (!descriptor) {
    return false;
  }
  return !descriptor.writable;
}
__name(isClass, "isClass");

// node_modules/storybook/dist/csf/index.js
var import_preview_api2 = __toESM(require_preview_api());
var import_core_events8 = __toESM(require_core_events());
var import_preview_api3 = __toESM(require_preview_api());
var import_global12 = __toESM(require_global());
var import_global13 = __toESM(require_global());
var import_global14 = __toESM(require_global());
var import_preview_api4 = __toESM(require_preview_api());
var import_global15 = __toESM(require_global());
var import_test2 = __toESM(require_test());
var require_tiny_isequal = __commonJS2({
  "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true }), exports.isEqual = /* @__PURE__ */ (function() {
      var e = Object.prototype.toString, r = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {
        return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));
      } : Object.keys;
      return function(n, a2) {
        return __name(function n2(a22, c, u) {
          var i, s2, l, o = e.call(a22), f2 = e.call(c);
          if (a22 === c) return true;
          if (null == a22 || null == c) return false;
          if (u.indexOf(a22) > -1 && u.indexOf(c) > -1) return true;
          if (u.push(a22, c), o != f2) return false;
          if (i = t(a22), s2 = t(c), i.length != s2.length || i.some(function(e2) {
            return !n2(a22[e2], c[e2], u);
          })) return false;
          switch (o.slice(8, -1)) {
            case "Symbol":
              return a22.valueOf() == c.valueOf();
            case "Date":
            case "Number":
              return +a22 == +c || +a22 != +a22 && +c != +c;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + a22 == "" + c;
            case "Set":
            case "Map":
              i = a22.entries(), s2 = c.entries();
              do {
                if (!n2((l = i.next()).value, s2.next().value, u)) return false;
              } while (!l.done);
              return true;
            case "ArrayBuffer":
              a22 = new Uint8Array(a22), c = new Uint8Array(c);
            case "DataView":
              a22 = new Uint8Array(a22.buffer), c = new Uint8Array(c.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (a22.length != c.length) return false;
              for (l = 0; l < a22.length; l++) if ((l in a22 || l in c) && (l in a22 != l in c || !n2(a22[l], c[l], u))) return false;
              return true;
            case "Object":
              return n2(r(a22), r(c), u);
            default:
              return false;
          }
        }, "n")(n, a2, []);
      };
    })();
  }
});
function toStartCaseStr(str2) {
  return str2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str22, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str22, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/(\s|^)(\w)/g, (str22, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, " ").trim();
}
__name(toStartCaseStr, "toStartCaseStr");
var import_tiny_isequal = __toESM2(require_tiny_isequal(), 1);
var count = __name((vals) => vals.map((v) => typeof v !== "undefined").filter(Boolean).length, "count");
var testValue = __name((cond, value) => {
  const { exists, eq: eq2, neq, truthy } = cond;
  if (count([exists, eq2, neq, truthy]) > 1) {
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq2, neq })}`);
  }
  if (typeof eq2 !== "undefined") {
    return (0, import_tiny_isequal.isEqual)(value, eq2);
  }
  if (typeof neq !== "undefined") {
    return !(0, import_tiny_isequal.isEqual)(value, neq);
  }
  if (typeof exists !== "undefined") {
    const valueExists = typeof value !== "undefined";
    return exists ? valueExists : !valueExists;
  }
  const shouldBeTruthy = typeof truthy === "undefined" ? true : truthy;
  return shouldBeTruthy ? !!value : !value;
}, "testValue");
var includeConditionalArg = __name((argType, args, globals) => {
  if (!argType.if) {
    return true;
  }
  const { arg, global: global52 } = argType.if;
  if (count([arg, global52]) !== 1) {
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global52 })}`);
  }
  const value = arg ? args[arg] : globals[global52];
  return testValue(argType.if, value);
}, "includeConditionalArg");
var addArgs_exports = {};
__export(addArgs_exports, {
  argsEnhancers: () => argsEnhancers
});
var isInInitialArgs = __name((name, initialArgs) => typeof initialArgs[name] === "undefined" && !(name in initialArgs), "isInInitialArgs");
var inferActionsFromArgTypesRegex = __name((context) => {
  const {
    initialArgs,
    argTypes,
    id,
    parameters: { actions }
  } = context;
  if (!actions || actions.disable || !actions.argTypesRegex || !argTypes) {
    return {};
  }
  const argTypesRegex = new RegExp(actions.argTypesRegex);
  const argTypesMatchingRegex = Object.entries(argTypes).filter(
    ([name]) => !!argTypesRegex.test(name)
  );
  return argTypesMatchingRegex.reduce((acc, [name, argType]) => {
    if (isInInitialArgs(name, initialArgs)) {
      acc[name] = action(name, { implicit: true, id });
    }
    return acc;
  }, {});
}, "inferActionsFromArgTypesRegex");
var addActionsFromArgTypes = __name((context) => {
  const {
    initialArgs,
    argTypes,
    parameters: { actions }
  } = context;
  if (actions?.disable || !argTypes) {
    return {};
  }
  const argTypesWithAction = Object.entries(argTypes).filter(([name, argType]) => !!argType.action);
  return argTypesWithAction.reduce((acc, [name, argType]) => {
    if (isInInitialArgs(name, initialArgs)) {
      acc[name] = action(typeof argType.action === "string" ? argType.action : name);
    }
    return acc;
  }, {});
}, "addActionsFromArgTypes");
var argsEnhancers = [
  addActionsFromArgTypes,
  inferActionsFromArgTypesRegex
];
var loaders_exports = {};
__export(loaders_exports, {
  loaders: () => loaders
});
var subscribed = false;
var logActionsWhenMockCalled = __name((context) => {
  const { parameters: parameters2 } = context;
  if (parameters2?.actions?.disable) {
    return;
  }
  if (!subscribed) {
    (0, import_test.onMockCall)((mock, args) => {
      const name = mock.getMockName();
      if (name === "spy") {
        return;
      }
      if (name === "vi.fn()") {
        return;
      }
      if (!/^next\/.*::/.test(name) || [
        "next/router::useRouter()",
        "next/navigation::useRouter()",
        "next/navigation::redirect",
        "next/cache::",
        "next/headers::cookies().set",
        "next/headers::cookies().delete",
        "next/headers::headers().set",
        "next/headers::headers().delete"
      ].some((prefix2) => name.startsWith(prefix2))) {
        action(name)(args);
      }
    });
    subscribed = true;
  }
}, "logActionsWhenMockCalled");
var loaders = [logActionsWhenMockCalled];
var preview_default = __name(() => definePreviewAddon9({
  ...addArgs_exports,
  ...loaders_exports
}), "default");
var { document: document22 } = globalThis;
var isReduceMotionEnabled = __name(() => {
  if (!globalThis?.matchMedia) {
    return false;
  }
  const prefersReduceMotion = globalThis.matchMedia("(prefers-reduced-motion: reduce)");
  return !!prefersReduceMotion?.matches;
}, "isReduceMotionEnabled");
var clearStyles = __name((selector) => {
  const selectors = Array.isArray(selector) ? selector : [selector];
  selectors.forEach(clearStyle);
}, "clearStyles");
var clearStyle = __name((selector) => {
  if (!document22) {
    return;
  }
  const element = document22.getElementById(selector);
  if (element && element.parentElement) {
    element.parentElement.removeChild(element);
  }
}, "clearStyle");
var addGridStyle = __name((selector, css) => {
  if (!document22) {
    return;
  }
  const existingStyle = document22.getElementById(selector);
  if (existingStyle) {
    if (existingStyle.innerHTML !== css) {
      existingStyle.innerHTML = css;
    }
  } else {
    const style = document22.createElement("style");
    style.setAttribute("id", selector);
    style.innerHTML = css;
    document22.head.appendChild(style);
  }
}, "addGridStyle");
var addBackgroundStyle = __name((selector, css, storyId) => {
  if (!document22) {
    return;
  }
  const existingStyle = document22.getElementById(selector);
  if (existingStyle) {
    if (existingStyle.innerHTML !== css) {
      existingStyle.innerHTML = css;
    }
  } else {
    const style = document22.createElement("style");
    style.setAttribute("id", selector);
    style.innerHTML = css;
    const gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`;
    const existingGridStyle = document22.getElementById(gridStyleSelector);
    if (existingGridStyle) {
      existingGridStyle.parentElement?.insertBefore(style, existingGridStyle);
    } else {
      document22.head.appendChild(style);
    }
  }
}, "addBackgroundStyle");
var defaultGrid = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
};
var BG_SELECTOR_BASE = `addon-backgrounds`;
var GRID_SELECTOR_BASE = "addon-backgrounds-grid";
var transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;";
var withBackgroundAndGrid = __name((StoryFn, context) => {
  const { globals = {}, parameters: parameters2 = {}, viewMode, id } = context;
  const {
    options = DEFAULT_BACKGROUNDS,
    disable,
    grid = defaultGrid
  } = parameters2[PARAM_KEY2] || {};
  const data = globals[PARAM_KEY2] || {};
  const backgroundName = typeof data === "string" ? data : data?.value;
  const item = backgroundName ? options[backgroundName] : void 0;
  const value = typeof item === "string" ? item : item?.value || "transparent";
  const showGrid = typeof data === "string" ? false : data.grid || false;
  const shownBackground = !!item && !disable;
  const backgroundSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main";
  const gridSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main";
  const isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded";
  const defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0;
  const { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid;
  const backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`;
  const backgroundTarget = viewMode === "docs" ? id : null;
  (0, import_preview_api.useEffect)(() => {
    const backgroundStyles = `
    ${backgroundSelector} {
      background: ${value} !important;
      ${transitionStyle}
      }`;
    if (!shownBackground) {
      clearStyles(backgroundSelectorId);
      return;
    }
    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);
  const gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;
  (0, import_preview_api.useEffect)(() => {
    if (!showGrid) {
      clearStyles(gridSelectorId);
      return;
    }
    const gridSize = [
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize}px ${cellSize}px`,
      `${cellSize}px ${cellSize}px`
    ].join(", ");
    const gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
    addGridStyle(gridSelectorId, gridStyles);
  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]);
  return StoryFn();
}, "withBackgroundAndGrid");
var decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [];
var parameters = {
  [PARAM_KEY2]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
};
var initialGlobals = {
  [PARAM_KEY2]: { value: void 0, grid: false }
};
var preview_default2 = __name(() => definePreviewAddon9({
  decorators,
  parameters,
  initialGlobals
}), "default");
var { step } = instrument(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: __name(async (label, play, context) => play(context), "step")
  },
  { intercept: true }
);
var preview_default3 = __name(() => definePreviewAddon9({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: step
}), "default");
var iconPaths = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};
var svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(",");
var createElement = __name((type, props = {}, children) => {
  const element = svgElements.includes(type) ? document.createElementNS("http://www.w3.org/2000/svg", type) : document.createElement(type);
  Object.entries(props).forEach(([key, val]) => {
    if (/[A-Z]/.test(key)) {
      if (key === "onClick") {
        element.addEventListener("click", val);
        element.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            val();
          }
        });
      }
      if (key === "onMouseEnter") {
        element.addEventListener("mouseenter", val);
      }
      if (key === "onMouseLeave") {
        element.addEventListener("mouseleave", val);
      }
    } else {
      element.setAttribute(key, val);
    }
  });
  children?.forEach((child) => {
    if (child === null || child === void 0 || child === false) {
      return;
    }
    try {
      element.appendChild(child);
    } catch (e) {
      element.appendChild(document.createTextNode(String(child)));
    }
  });
  return element;
}, "createElement");
var createIcon = __name((name) => iconPaths[name] && createElement(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  iconPaths[name].map(
    (d) => createElement("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d
    })
  )
), "createIcon");
var normalizeOptions = __name((options) => {
  if ("elements" in options) {
    const { elements, color, style } = options;
    return {
      id: void 0,
      priority: 0,
      selectors: elements,
      styles: {
        outline: `2px ${style} ${color}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  const { menu, ...rest } = options;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...rest,
    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
  };
}, "normalizeOptions");
var isFunction = __name((obj) => obj instanceof Function, "isFunction");
var state = /* @__PURE__ */ new Map();
var listeners = /* @__PURE__ */ new Map();
var teardowns = /* @__PURE__ */ new Map();
var useStore = __name((initialValue) => {
  const key = Symbol();
  listeners.set(key, []);
  state.set(key, initialValue);
  const get = __name(() => state.get(key), "get");
  const set = __name((update) => {
    const current = state.get(key);
    const next = isFunction(update) ? update(current) : update;
    if (next !== current) {
      state.set(key, next);
      listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.();
        teardowns.set(listener, listener(next));
      });
    }
  }, "set");
  const subscribe = __name((listener) => {
    listeners.get(key)?.push(listener);
    return () => {
      const list = listeners.get(key);
      if (list) {
        listeners.set(
          key,
          list.filter((l) => l !== listener)
        );
      }
    };
  }, "subscribe");
  const teardown = __name(() => {
    listeners.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.();
      teardowns.delete(listener);
    });
    listeners.delete(key);
    state.delete(key);
  }, "teardown");
  return { get, set, subscribe, teardown };
}, "useStore");
var mapElements = __name((highlights) => {
  const root = document.getElementById("storybook-root");
  const map2 = /* @__PURE__ */ new Map();
  for (const highlight of highlights) {
    const { priority = 0 } = highlight;
    for (const selector of highlight.selectors) {
      const elements = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...root?.querySelectorAll(selector) || []
      ];
      for (const element of elements) {
        const existing = map2.get(element);
        if (!existing || existing.priority <= priority) {
          map2.set(element, {
            ...highlight,
            priority,
            selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
          });
        }
      }
    }
  }
  return map2;
}, "mapElements");
var mapBoxes = __name((elements) => Array.from(elements.entries()).map(([element, { selectors, styles: styles2, hoverStyles, focusStyles, menu }]) => {
  const { top, left, width, height } = element.getBoundingClientRect();
  const { position } = getComputedStyle(element);
  return {
    element,
    selectors,
    styles: styles2,
    hoverStyles,
    focusStyles,
    menu,
    top: position === "fixed" ? top : top + window.scrollY,
    left: position === "fixed" ? left : left + window.scrollX,
    width,
    height
  };
}).sort((a2, b) => b.width * b.height - a2.width * a2.height), "mapBoxes");
var isOverMenu = __name((menuElement, coordinates) => {
  const menu = menuElement.getBoundingClientRect();
  const { x, y } = coordinates;
  return menu?.top && menu?.left && x >= menu.left && x <= menu.left + menu.width && y >= menu.top && y <= menu.top + menu.height;
}, "isOverMenu");
var isTargeted = __name((box, boxElement, coordinates) => {
  if (!boxElement || !coordinates) {
    return false;
  }
  let { left, top, width, height } = box;
  if (height < MIN_TOUCH_AREA_SIZE) {
    top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2);
    height = MIN_TOUCH_AREA_SIZE;
  }
  if (width < MIN_TOUCH_AREA_SIZE) {
    left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2);
    width = MIN_TOUCH_AREA_SIZE;
  }
  if (boxElement.style.position === "fixed") {
    left += window.scrollX;
    top += window.scrollY;
  }
  const { x, y } = coordinates;
  return x >= left && x <= left + width && y >= top && y <= top + height;
}, "isTargeted");
var keepInViewport = __name((element, targetCoordinates, options = {}) => {
  const { x, y } = targetCoordinates;
  const { margin = 5, topOffset = 0, centered = false } = options;
  const { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window;
  const top = Math.min(
    element.style.position === "fixed" ? y - scrollY : y,
    windowHeight - element.clientHeight - margin - topOffset + scrollY
  );
  const leftOffset = centered ? element.clientWidth / 2 : 0;
  const left = element.style.position === "fixed" ? Math.max(Math.min(x - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
    Math.min(x, windowWidth - leftOffset - margin + scrollX),
    leftOffset + margin + scrollX
  );
  Object.assign(element.style, {
    ...left !== x && { left: `${left}px` },
    ...top !== y && { top: `${top}px` }
  });
}, "keepInViewport");
var showPopover = __name((element) => {
  if (window.HTMLElement.prototype.hasOwnProperty("showPopover")) {
    element.showPopover();
  }
}, "showPopover");
var hidePopover = __name((element) => {
  if (window.HTMLElement.prototype.hasOwnProperty("showPopover")) {
    element.hidePopover();
  }
}, "hidePopover");
var getEventDetails = __name((target) => ({
  top: target.top,
  left: target.left,
  width: target.width,
  height: target.height,
  selectors: target.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
    ),
    localName: target.element.localName,
    tagName: target.element.tagName,
    outerHTML: target.element.outerHTML
  }
}), "getEventDetails");
var menuId = "storybook-highlights-menu";
var rootId = "storybook-highlights-root";
var storybookRootId = "storybook-root";
var useHighlights = __name((channel) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) {
    return;
  }
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  const { document: document32 } = globalThis;
  const highlights = useStore([]);
  const elements = useStore(/* @__PURE__ */ new Map());
  const boxes = useStore([]);
  const clickCoords = useStore();
  const hoverCoords = useStore();
  const targets = useStore([]);
  const hovered = useStore([]);
  const focused = useStore();
  const selected = useStore();
  let root = document32.getElementById(rootId);
  highlights.subscribe(() => {
    if (!root) {
      root = createElement("div", { id: rootId });
      document32.body.appendChild(root);
    }
  });
  highlights.subscribe((value) => {
    const storybookRoot = document32.getElementById(storybookRootId);
    if (!storybookRoot) {
      return;
    }
    elements.set(mapElements(value));
    const observer = new MutationObserver(() => elements.set(mapElements(value)));
    observer.observe(storybookRoot, { subtree: true, childList: true });
    return () => {
      observer.disconnect();
    };
  });
  elements.subscribe((value) => {
    const updateBoxes = __name(() => requestAnimationFrame(() => boxes.set(mapBoxes(value))), "updateBoxes");
    const observer = new ResizeObserver(updateBoxes);
    observer.observe(document32.body);
    Array.from(value.keys()).forEach((element) => observer.observe(element));
    const scrollers = Array.from(document32.body.querySelectorAll("*")).filter((el) => {
      const { overflow, overflowX, overflowY } = window.getComputedStyle(el);
      return ["auto", "scroll"].some((o) => [overflow, overflowX, overflowY].includes(o));
    });
    scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes));
    return () => {
      observer.disconnect();
      scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
    };
  });
  elements.subscribe((value) => {
    const sticky = Array.from(value.keys()).filter(({ style }) => style.position === "sticky");
    const updateBoxes = __name(() => requestAnimationFrame(() => {
      boxes.set(
        (current) => current.map((box) => {
          if (sticky.includes(box.element)) {
            const { top, left } = box.element.getBoundingClientRect();
            return { ...box, top: top + window.scrollY, left: left + window.scrollX };
          }
          return box;
        })
      );
    }), "updateBoxes");
    document32.addEventListener("scroll", updateBoxes);
    return () => document32.removeEventListener("scroll", updateBoxes);
  });
  elements.subscribe((value) => {
    targets.set((t) => t.filter(({ element }) => value.has(element)));
  });
  targets.subscribe((value) => {
    if (value.length) {
      selected.set((s2) => value.some((t) => t.element === s2?.element) ? s2 : void 0);
      focused.set((s2) => value.some((t) => t.element === s2?.element) ? s2 : void 0);
    } else {
      selected.set(void 0);
      focused.set(void 0);
      clickCoords.set(void 0);
    }
  });
  const styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
  highlights.subscribe((value) => {
    value.forEach(({ keyframes }) => {
      if (keyframes) {
        let style = styleElementByHighlight.get(keyframes);
        if (!style) {
          style = document32.createElement("style");
          style.setAttribute("data-highlight", "keyframes");
          styleElementByHighlight.set(keyframes, style);
          document32.head.appendChild(style);
        }
        style.innerHTML = keyframes;
      }
    });
    styleElementByHighlight.forEach((style, keyframes) => {
      if (!value.some((v) => v.keyframes === keyframes)) {
        style.remove();
        styleElementByHighlight.delete(keyframes);
      }
    });
  });
  const boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
  boxes.subscribe((value) => {
    value.forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (root && !boxElement) {
        const props = {
          popover: "manual",
          "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
        };
        boxElement = root.appendChild(
          createElement("div", props, [createElement("div")])
        );
        boxElementByTargetElement.set(box.element, boxElement);
      }
    });
    boxElementByTargetElement.forEach((box, element) => {
      if (!value.some(({ element: e }) => e === element)) {
        box.remove();
        boxElementByTargetElement.delete(element);
      }
    });
  });
  boxes.subscribe((value) => {
    const targetable = value.filter((box) => box.menu);
    if (!targetable.length) {
      return;
    }
    const onClick = __name((event) => {
      requestAnimationFrame(() => {
        const menu = document32.getElementById(menuId);
        const coords = { x: event.pageX, y: event.pageY };
        if (menu && !isOverMenu(menu, coords)) {
          const results = targetable.filter((box) => {
            const boxElement = boxElementByTargetElement.get(box.element);
            return isTargeted(box, boxElement, coords);
          });
          clickCoords.set(results.length ? coords : void 0);
          targets.set(results);
        }
      });
    }, "onClick");
    document32.addEventListener("click", onClick);
    return () => document32.removeEventListener("click", onClick);
  });
  const updateHovered = __name(() => {
    const menu = document32.getElementById(menuId);
    const coords = hoverCoords.get();
    if (!coords || menu && isOverMenu(menu, coords)) {
      return;
    }
    hovered.set((current) => {
      const update = boxes.get().filter((box) => {
        const boxElement = boxElementByTargetElement.get(box.element);
        return isTargeted(box, boxElement, coords);
      });
      const existing = current.filter((box) => update.includes(box));
      const additions = update.filter((box) => !current.includes(box));
      const hasRemovals = current.length - existing.length;
      return additions.length || hasRemovals ? [...existing, ...additions] : current;
    });
  }, "updateHovered");
  hoverCoords.subscribe(updateHovered);
  boxes.subscribe(updateHovered);
  const updateBoxStyles = __name(() => {
    const selectedElement = selected.get();
    const targetElements = selectedElement ? [selectedElement] : targets.get();
    const focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get();
    const isMenuOpen = clickCoords.get() !== void 0;
    boxes.get().forEach((box) => {
      const boxElement = boxElementByTargetElement.get(box.element);
      if (boxElement) {
        const isFocused = focusedElement === box;
        const isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
        Object.assign(boxElement.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...box.styles,
          ...isHovered ? box.hoverStyles : {},
          ...isFocused ? box.focusStyles : {},
          position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: MAX_Z_INDEX - 10,
          top: `${box.top}px`,
          left: `${box.left}px`,
          width: `${box.width}px`,
          height: `${box.height}px`,
          margin: 0,
          padding: 0,
          cursor: box.menu && isHovered ? "pointer" : "default",
          pointerEvents: box.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        });
        Object.assign(boxElement.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
          boxSizing: "content-box",
          padding: boxElement.style.outlineWidth || "0px"
        });
        showPopover(boxElement);
      }
    });
  }, "updateBoxStyles");
  boxes.subscribe(updateBoxStyles);
  targets.subscribe(updateBoxStyles);
  hovered.subscribe(updateBoxStyles);
  focused.subscribe(updateBoxStyles);
  selected.subscribe(updateBoxStyles);
  const renderMenu = __name(() => {
    if (!root) {
      return;
    }
    let menu = document32.getElementById(menuId);
    if (menu) {
      menu.innerHTML = "";
    } else {
      const props = { id: menuId, popover: "manual" };
      menu = root.appendChild(createElement("div", props));
      root.appendChild(
        createElement("style", {}, [
          `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    const selectedElement = selected.get();
    const elementList = selectedElement ? [selectedElement] : targets.get();
    if (elementList.length) {
      menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute";
      menu.appendChild(
        createElement(
          "ul",
          { class: "element-list" },
          elementList.map((target) => {
            const selectable = elementList.length > 1 && !!target.menu?.some(
              (group) => group.some(
                (item) => !item.selectors || item.selectors.some((s2) => target.selectors.includes(s2))
              )
            );
            const props = selectable ? {
              class: "selectable",
              onClick: __name(() => selected.set(target), "onClick"),
              onMouseEnter: __name(() => focused.set(target), "onMouseEnter"),
              onMouseLeave: __name(() => focused.set(void 0), "onMouseLeave")
            } : selectedElement ? { class: "selected", onClick: __name(() => selected.set(void 0), "onClick") } : {};
            const asButton = selectable || selectedElement;
            return createElement("li", props, [
              createElement(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
                selectedElement ? createIcon("chevronLeft") : null,
                createElement("code", {}, [target.element.outerHTML]),
                selectable ? createIcon("chevronRight") : null
              ])
            ]);
          })
        )
      );
    }
    if (selected.get() || targets.get().length === 1) {
      const target = selected.get() || targets.get()[0];
      const menuGroups = target.menu?.filter(
        (group) => group.some(
          (item) => !item.selectors || item.selectors.some((s2) => target.selectors.includes(s2))
        )
      );
      if (menuGroups?.length) {
        menu.appendChild(
          createElement(
            "ul",
            { class: "menu-list" },
            menuGroups.map(
              (menuItems) => createElement("li", {}, [
                createElement(
                  "ul",
                  { class: "menu-items" },
                  menuItems.map(
                    ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {
                      const onClick = event && (() => channel.emit(event, id, getEventDetails(target)));
                      return createElement("li", {}, [
                        createElement(
                          onClick ? "button" : "div",
                          onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                          [
                            iconLeft ? createIcon(iconLeft) : null,
                            createElement("div", { class: "menu-item-content" }, [
                              createElement(description ? "strong" : "span", {}, [title]),
                              description && createElement("span", {}, [description])
                            ]),
                            iconRight ? createIcon(iconRight) : null
                          ]
                        )
                      ]);
                    }
                  )
                )
              ])
            )
          )
        );
      }
    }
    const coords = clickCoords.get();
    if (coords) {
      Object.assign(menu.style, {
        display: "block",
        left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
        top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
      });
      showPopover(menu);
      requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: true }));
    } else {
      hidePopover(menu);
      Object.assign(menu.style, { display: "none" });
    }
  }, "renderMenu");
  targets.subscribe(renderMenu);
  selected.subscribe(renderMenu);
  const addHighlight = __name((highlight) => {
    const info = normalizeOptions(highlight);
    highlights.set((value) => {
      const others = info.id ? value.filter((h2) => h2.id !== info.id) : value;
      return info.selectors?.length ? [...others, info] : others;
    });
  }, "addHighlight");
  const removeHighlight = __name((id) => {
    if (id) {
      highlights.set((value) => value.filter((h2) => h2.id !== id));
    }
  }, "removeHighlight");
  const resetState = __name(() => {
    highlights.set([]);
    elements.set(/* @__PURE__ */ new Map());
    boxes.set([]);
    clickCoords.set(void 0);
    hoverCoords.set(void 0);
    targets.set([]);
    hovered.set([]);
    focused.set(void 0);
    selected.set(void 0);
  }, "resetState");
  let removeTimeout;
  const scrollIntoView = __name((target, options) => {
    const id = "scrollIntoView-highlight";
    clearTimeout(removeTimeout);
    removeHighlight(id);
    const element = document32.querySelector(target);
    if (!element) {
      console.warn(`Cannot scroll into view: ${target} not found`);
      return;
    }
    element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
    const keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
    highlights.set((value) => [
      ...value,
      {
        id,
        priority: 1e3,
        selectors: [target],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${keyframeName} 3s linear forwards`
        },
        keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]);
    removeTimeout = setTimeout(() => removeHighlight(id), 3500);
  }, "scrollIntoView");
  const onMouseMove = __name((event) => {
    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
  }, "onMouseMove");
  document32.body.addEventListener("mousemove", onMouseMove);
  channel.on(HIGHLIGHT, addHighlight);
  channel.on(REMOVE_HIGHLIGHT, removeHighlight);
  channel.on(RESET_HIGHLIGHT, resetState);
  channel.on(SCROLL_INTO_VIEW, scrollIntoView);
  channel.on(import_core_events8.STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
    if (newPhase === "loading") {
      resetState();
    }
  });
}, "useHighlights");
if (globalThis?.FEATURES?.highlight && import_preview_api2.addons?.ready) {
  import_preview_api2.addons.ready().then(useHighlights);
}
var preview_default4 = __name(() => definePreviewAddon9({}), "default");
function getDocumentWidthAndHeight() {
  const container = import_global12.global.document.documentElement;
  const height = Math.max(container.scrollHeight, container.offsetHeight);
  const width = Math.max(container.scrollWidth, container.offsetWidth);
  return { width, height };
}
__name(getDocumentWidthAndHeight, "getDocumentWidthAndHeight");
function createCanvas() {
  const canvas = import_global12.global.document.createElement("canvas");
  canvas.id = "storybook-addon-measure";
  const context = canvas.getContext("2d");
  invariant(context != null);
  const { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(canvas, context, { width, height });
  canvas.style.position = "absolute";
  canvas.style.left = "0";
  canvas.style.top = "0";
  canvas.style.zIndex = "2147483647";
  canvas.style.pointerEvents = "none";
  import_global12.global.document.body.appendChild(canvas);
  return { canvas, context, width, height };
}
__name(createCanvas, "createCanvas");
function setCanvasWidthAndHeight(canvas, context, { width, height }) {
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  const scale = import_global12.global.window.devicePixelRatio;
  canvas.width = Math.floor(width * scale);
  canvas.height = Math.floor(height * scale);
  context.scale(scale, scale);
}
__name(setCanvasWidthAndHeight, "setCanvasWidthAndHeight");
var state2 = {};
function init() {
  if (!state2.canvas) {
    state2 = createCanvas();
  }
}
__name(init, "init");
function clear() {
  if (state2.context) {
    state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
  }
}
__name(clear, "clear");
function draw(callback) {
  clear();
  callback(state2.context);
}
__name(draw, "draw");
function rescale() {
  invariant(state2.canvas, "Canvas should exist in the state.");
  invariant(state2.context, "Context should exist in the state.");
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
  const { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height });
  state2.width = width;
  state2.height = height;
}
__name(rescale, "rescale");
function destroy() {
  if (state2.canvas) {
    clear();
    state2.canvas.parentNode?.removeChild(state2.canvas);
    state2 = {};
  }
}
__name(destroy, "destroy");
var colors = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
};
var labelPadding = 6;
function roundedRect(context, { x, y, w, h: h2, r }) {
  x = x - w / 2;
  y = y - h2 / 2;
  if (w < 2 * r) {
    r = w / 2;
  }
  if (h2 < 2 * r) {
    r = h2 / 2;
  }
  context.beginPath();
  context.moveTo(x + r, y);
  context.arcTo(x + w, y, x + w, y + h2, r);
  context.arcTo(x + w, y + h2, x, y + h2, r);
  context.arcTo(x, y + h2, x, y, r);
  context.arcTo(x, y, x + w, y, r);
  context.closePath();
}
__name(roundedRect, "roundedRect");
function positionCoordinate(position, { padding, border, width, height, top, left }) {
  const contentWidth = width - border.left - border.right - padding.left - padding.right;
  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  let x = left + border.left + padding.left;
  let y = top + border.top + padding.top;
  if (position === "top") {
    x += contentWidth / 2;
  } else if (position === "right") {
    x += contentWidth;
    y += contentHeight / 2;
  } else if (position === "bottom") {
    x += contentWidth / 2;
    y += contentHeight;
  } else if (position === "left") {
    y += contentHeight / 2;
  } else if (position === "center") {
    x += contentWidth / 2;
    y += contentHeight / 2;
  }
  return { x, y };
}
__name(positionCoordinate, "positionCoordinate");
function offset(type, position, { margin, border, padding }, labelPaddingSize, external) {
  let shift = __name((dir) => 0, "shift");
  let offsetX = 0;
  let offsetY = 0;
  const locationMultiplier = external ? 1 : 0.5;
  const labelPaddingShift = external ? labelPaddingSize * 2 : 0;
  if (type === "padding") {
    shift = __name((dir) => padding[dir] * locationMultiplier + labelPaddingShift, "shift");
  } else if (type === "border") {
    shift = __name((dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift, "shift");
  } else if (type === "margin") {
    shift = __name((dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift, "shift");
  }
  if (position === "top") {
    offsetY = -shift("top");
  } else if (position === "right") {
    offsetX = shift("right");
  } else if (position === "bottom") {
    offsetY = shift("bottom");
  } else if (position === "left") {
    offsetX = -shift("left");
  }
  return { offsetX, offsetY };
}
__name(offset, "offset");
function collide(a2, b) {
  return Math.abs(a2.x - b.x) < Math.abs(a2.w + b.w) / 2 && Math.abs(a2.y - b.y) < Math.abs(a2.h + b.h) / 2;
}
__name(collide, "collide");
function overlapAdjustment(position, currentRect, prevRect) {
  if (position === "top") {
    currentRect.y = prevRect.y - prevRect.h - labelPadding;
  } else if (position === "right") {
    currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2;
  } else if (position === "bottom") {
    currentRect.y = prevRect.y + prevRect.h + labelPadding;
  } else if (position === "left") {
    currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2;
  }
  return { x: currentRect.x, y: currentRect.y };
}
__name(overlapAdjustment, "overlapAdjustment");
function textWithRect(context, type, { x, y, w, h: h2 }, text) {
  roundedRect(context, { x, y, w, h: h2, r: 3 });
  context.fillStyle = `${colors[type]}dd`;
  context.fill();
  context.strokeStyle = colors[type];
  context.stroke();
  context.fillStyle = colors.text;
  context.fillText(text, x, y);
  roundedRect(context, { x, y, w, h: h2, r: 3 });
  context.fillStyle = `${colors[type]}dd`;
  context.fill();
  context.strokeStyle = colors[type];
  context.stroke();
  context.fillStyle = colors.text;
  context.fillText(text, x, y);
  return { x, y, w, h: h2 };
}
__name(textWithRect, "textWithRect");
function configureText(context, text) {
  context.font = "600 12px monospace";
  context.textBaseline = "middle";
  context.textAlign = "center";
  const metrics = context.measureText(text);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const w = metrics.width + labelPadding * 2;
  const h2 = actualHeight + labelPadding * 2;
  return { w, h: h2 };
}
__name(configureText, "configureText");
function drawLabel(context, measurements, { type, position = "center", text }, prevRect, external = false) {
  let { x, y } = positionCoordinate(position, measurements);
  const { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);
  x += offsetX;
  y += offsetY;
  const { w, h: h2 } = configureText(context, text);
  if (prevRect && collide({ x, y, w, h: h2 }, prevRect)) {
    const adjusted = overlapAdjustment(position, { x, y, w, h: h2 }, prevRect);
    x = adjusted.x;
    y = adjusted.y;
  }
  return textWithRect(context, type, { x, y, w, h: h2 }, text);
}
__name(drawLabel, "drawLabel");
function floatingOffset(alignment, { w, h: h2 }) {
  const deltaW = w * 0.5 + labelPadding;
  const deltaH = h2 * 0.5 + labelPadding;
  return {
    offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
    offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
  };
}
__name(floatingOffset, "floatingOffset");
function drawFloatingLabel(context, measurements, { type, text }) {
  const { floatingAlignment: floatingAlignment2, extremities } = measurements;
  let x = extremities[floatingAlignment2.x];
  let y = extremities[floatingAlignment2.y];
  const { w, h: h2 } = configureText(context, text);
  const { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
    w,
    h: h2
  });
  x += offsetX;
  y += offsetY;
  return textWithRect(context, type, { x, y, w, h: h2 }, text);
}
__name(drawFloatingLabel, "drawFloatingLabel");
function drawStack(context, measurements, stack, external) {
  const rects = [];
  stack.forEach((l, idx) => {
    const rect = external && l.position === "center" ? drawFloatingLabel(context, measurements, l) : drawLabel(context, measurements, l, rects[idx - 1], external);
    rects[idx] = rect;
  });
}
__name(drawStack, "drawStack");
function labelStacks(context, measurements, labels, externalLabels) {
  const stacks = labels.reduce((acc, l) => {
    if (!Object.prototype.hasOwnProperty.call(acc, l.position)) {
      acc[l.position] = [];
    }
    acc[l.position]?.push(l);
    return acc;
  }, {});
  if (stacks.top) {
    drawStack(context, measurements, stacks.top, externalLabels);
  }
  if (stacks.right) {
    drawStack(context, measurements, stacks.right, externalLabels);
  }
  if (stacks.bottom) {
    drawStack(context, measurements, stacks.bottom, externalLabels);
  }
  if (stacks.left) {
    drawStack(context, measurements, stacks.left, externalLabels);
  }
  if (stacks.center) {
    drawStack(context, measurements, stacks.center, externalLabels);
  }
}
__name(labelStacks, "labelStacks");
var colors2 = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
};
var SMALL_NODE_SIZE = 30;
function pxToNumber(px) {
  return parseInt(px.replace("px", ""), 10);
}
__name(pxToNumber, "pxToNumber");
function round(value) {
  return Number.isInteger(value) ? value : value.toFixed(2);
}
__name(round, "round");
function filterZeroValues(labels) {
  return labels.filter((l) => l.text !== 0 && l.text !== "0");
}
__name(filterZeroValues, "filterZeroValues");
function floatingAlignment(extremities) {
  const windowExtremities = {
    top: import_global13.global.window.scrollY,
    bottom: import_global13.global.window.scrollY + import_global13.global.window.innerHeight,
    left: import_global13.global.window.scrollX,
    right: import_global13.global.window.scrollX + import_global13.global.window.innerWidth
  };
  const distances = {
    top: Math.abs(windowExtremities.top - extremities.top),
    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
    left: Math.abs(windowExtremities.left - extremities.left),
    right: Math.abs(windowExtremities.right - extremities.right)
  };
  return {
    x: distances.left > distances.right ? "left" : "right",
    y: distances.top > distances.bottom ? "top" : "bottom"
  };
}
__name(floatingAlignment, "floatingAlignment");
function measureElement(element) {
  const style = import_global13.global.getComputedStyle(element);
  let { top, left, right, bottom, width, height } = element.getBoundingClientRect();
  const {
    marginTop,
    marginBottom,
    marginLeft,
    marginRight,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    borderBottomWidth,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth
  } = style;
  top = top + import_global13.global.window.scrollY;
  left = left + import_global13.global.window.scrollX;
  bottom = bottom + import_global13.global.window.scrollY;
  right = right + import_global13.global.window.scrollX;
  const margin = {
    top: pxToNumber(marginTop),
    bottom: pxToNumber(marginBottom),
    left: pxToNumber(marginLeft),
    right: pxToNumber(marginRight)
  };
  const padding = {
    top: pxToNumber(paddingTop),
    bottom: pxToNumber(paddingBottom),
    left: pxToNumber(paddingLeft),
    right: pxToNumber(paddingRight)
  };
  const border = {
    top: pxToNumber(borderTopWidth),
    bottom: pxToNumber(borderBottomWidth),
    left: pxToNumber(borderLeftWidth),
    right: pxToNumber(borderRightWidth)
  };
  const extremities = {
    top: top - margin.top,
    bottom: bottom + margin.bottom,
    left: left - margin.left,
    right: right + margin.right
  };
  return {
    margin,
    padding,
    border,
    top,
    left,
    bottom,
    right,
    width,
    height,
    extremities,
    floatingAlignment: floatingAlignment(extremities)
  };
}
__name(measureElement, "measureElement");
function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
  const marginHeight = height + margin.bottom + margin.top;
  context.fillStyle = colors2.margin;
  context.fillRect(left, top - margin.top, width, margin.top);
  context.fillRect(right, top - margin.top, margin.right, marginHeight);
  context.fillRect(left, bottom, width, margin.bottom);
  context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
  const marginLabels = [
    {
      type: "margin",
      text: round(margin.top),
      position: "top"
    },
    {
      type: "margin",
      text: round(margin.right),
      position: "right"
    },
    {
      type: "margin",
      text: round(margin.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: round(margin.left),
      position: "left"
    }
  ];
  return filterZeroValues(marginLabels);
}
__name(drawMargin, "drawMargin");
function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
  const paddingWidth = width - border.left - border.right;
  const paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.padding;
  context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top);
  context.fillRect(
    right - padding.right - border.right,
    top + padding.top + border.top,
    padding.right,
    paddingHeight
  );
  context.fillRect(
    left + border.left,
    bottom - padding.bottom - border.bottom,
    paddingWidth,
    padding.bottom
  );
  context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
  const paddingLabels = [
    {
      type: "padding",
      text: padding.top,
      position: "top"
    },
    {
      type: "padding",
      text: padding.right,
      position: "right"
    },
    {
      type: "padding",
      text: padding.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: padding.left,
      position: "left"
    }
  ];
  return filterZeroValues(paddingLabels);
}
__name(drawPadding, "drawPadding");
function drawBorder(context, { border, width, height, top, left, bottom, right }) {
  const borderHeight = height - border.top - border.bottom;
  context.fillStyle = colors2.border;
  context.fillRect(left, top, width, border.top);
  context.fillRect(left, bottom - border.bottom, width, border.bottom);
  context.fillRect(left, top + border.top, border.left, borderHeight);
  context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
  const borderLabels = [
    {
      type: "border",
      text: border.top,
      position: "top"
    },
    {
      type: "border",
      text: border.right,
      position: "right"
    },
    {
      type: "border",
      text: border.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: border.left,
      position: "left"
    }
  ];
  return filterZeroValues(borderLabels);
}
__name(drawBorder, "drawBorder");
function drawContent(context, { padding, border, width, height, top, left }) {
  const contentWidth = width - border.left - border.right - padding.left - padding.right;
  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.content;
  context.fillRect(
    left + border.left + padding.left,
    top + border.top + padding.top,
    contentWidth,
    contentHeight
  );
  return [
    {
      type: "content",
      position: "center",
      text: `${round(contentWidth)} x ${round(contentHeight)}`
    }
  ];
}
__name(drawContent, "drawContent");
function drawBoxModel(element) {
  return (context) => {
    if (element && context) {
      const measurements = measureElement(element);
      const marginLabels = drawMargin(context, measurements);
      const paddingLabels = drawPadding(context, measurements);
      const borderLabels = drawBorder(context, measurements);
      const contentLabels = drawContent(context, measurements);
      const externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
      labelStacks(
        context,
        measurements,
        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
        externalLabels
      );
    }
  };
}
__name(drawBoxModel, "drawBoxModel");
function drawSelectedElement(element) {
  draw(drawBoxModel(element));
}
__name(drawSelectedElement, "drawSelectedElement");
var deepElementFromPoint = __name((x, y) => {
  const element = import_global14.global.document.elementFromPoint(x, y);
  const crawlShadows = __name((node) => {
    if (node && node.shadowRoot) {
      const nestedElement = node.shadowRoot.elementFromPoint(x, y);
      if (node.isEqualNode(nestedElement)) {
        return node;
      }
      if (nestedElement.shadowRoot) {
        return crawlShadows(nestedElement);
      }
      return nestedElement;
    }
    return node;
  }, "crawlShadows");
  const shadowElement = crawlShadows(element);
  return shadowElement || element;
}, "deepElementFromPoint");
var nodeAtPointerRef;
var pointer = { x: 0, y: 0 };
function findAndDrawElement(x, y) {
  nodeAtPointerRef = deepElementFromPoint(x, y);
  drawSelectedElement(nodeAtPointerRef);
}
__name(findAndDrawElement, "findAndDrawElement");
var withMeasure = __name((StoryFn, context) => {
  const { measureEnabled } = context.globals || {};
  (0, import_preview_api3.useEffect)(() => {
    if (typeof globalThis.document === "undefined") {
      return;
    }
    const onPointerMove = __name((event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation();
        pointer.x = event.clientX;
        pointer.y = event.clientY;
      });
    }, "onPointerMove");
    globalThis.document.addEventListener("pointermove", onPointerMove);
    return () => {
      globalThis.document.removeEventListener("pointermove", onPointerMove);
    };
  }, []);
  (0, import_preview_api3.useEffect)(() => {
    const onPointerOver = __name((event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation();
        findAndDrawElement(event.clientX, event.clientY);
      });
    }, "onPointerOver");
    const onResize = __name(() => {
      window.requestAnimationFrame(() => {
        rescale();
      });
    }, "onResize");
    if (context.viewMode === "story" && measureEnabled) {
      globalThis.document.addEventListener("pointerover", onPointerOver);
      init();
      globalThis.window.addEventListener("resize", onResize);
      findAndDrawElement(pointer.x, pointer.y);
    }
    return () => {
      globalThis.window.removeEventListener("resize", onResize);
      destroy();
    };
  }, [measureEnabled, context.viewMode]);
  return StoryFn();
}, "withMeasure");
var decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [];
var initialGlobals2 = {
  [PARAM_KEY22]: false
};
var preview_default5 = __name(() => definePreviewAddon9({
  decorators: decorators2,
  initialGlobals: initialGlobals2
}), "default");
var clearStyles2 = __name((selector) => {
  const selectors = Array.isArray(selector) ? selector : [selector];
  selectors.forEach(clearStyle2);
}, "clearStyles");
var clearStyle2 = __name((input) => {
  const selector = typeof input === "string" ? input : input.join("");
  const element = import_global15.global.document.getElementById(selector);
  if (element && element.parentElement) {
    element.parentElement.removeChild(element);
  }
}, "clearStyle");
var addOutlineStyles = __name((selector, css) => {
  const existingStyle = import_global15.global.document.getElementById(selector);
  if (existingStyle) {
    if (existingStyle.innerHTML !== css) {
      existingStyle.innerHTML = css;
    }
  } else {
    const style = import_global15.global.document.createElement("style");
    style.setAttribute("id", selector);
    style.innerHTML = css;
    import_global15.global.document.head.appendChild(style);
  }
}, "addOutlineStyles");
function outlineCSS(selector) {
  return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
__name(outlineCSS, "outlineCSS");
var withOutline = __name((StoryFn, context) => {
  const globals = context.globals || {};
  const isActive = [true, "true"].includes(globals[PARAM_KEY3]);
  const isInDocs = context.viewMode === "docs";
  const outlineStyles = (0, import_preview_api4.useMemo)(() => {
    const selector = isInDocs ? `[data-story-block="true"]` : ".sb-show-main";
    return outlineCSS(selector);
  }, [context]);
  (0, import_preview_api4.useEffect)(() => {
    const selectorId = isInDocs ? `addon-outline-docs-${context.id}` : `addon-outline`;
    if (!isActive) {
      clearStyles2(selectorId);
    } else {
      addOutlineStyles(selectorId, outlineStyles);
    }
    return () => {
      clearStyles2(selectorId);
    };
  }, [isActive, outlineStyles, context]);
  return StoryFn();
}, "withOutline");
var decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [];
var initialGlobals3 = {
  [PARAM_KEY3]: false
};
var preview_default6 = __name(() => definePreviewAddon9({ decorators: decorators3, initialGlobals: initialGlobals3 }), "default");
var resetAllMocksLoader = __name(({ parameters: parameters2 }) => {
  if (parameters2?.test?.mockReset === true) {
    (0, import_test2.resetAllMocks)();
  } else if (parameters2?.test?.clearMocks === true) {
    (0, import_test2.clearAllMocks)();
  } else if (parameters2?.test?.restoreMocks !== false) {
    (0, import_test2.restoreAllMocks)();
  }
}, "resetAllMocksLoader");
var traverseArgs = __name((value, depth = 0, key) => {
  if (depth > 5) {
    return value;
  }
  if (value == null) {
    return value;
  }
  if ((0, import_test2.isMockFunction)(value)) {
    if (key) {
      value.mockName(key);
    }
    return value;
  }
  if (typeof value === "function" && "isAction" in value && value.isAction && !("implicit" in value && value.implicit)) {
    const mock = (0, import_test2.fn)(value);
    if (key) {
      mock.mockName(key);
    }
    return mock;
  }
  if (Array.isArray(value)) {
    depth++;
    for (let i = 0; i < value.length; i++) {
      if (Object.getOwnPropertyDescriptor(value, i)?.writable) {
        value[i] = traverseArgs(value[i], depth);
      }
    }
    return value;
  }
  if (typeof value === "object" && value.constructor === Object) {
    depth++;
    for (const [k, v] of Object.entries(value)) {
      if (Object.getOwnPropertyDescriptor(value, k)?.writable) {
        value[k] = traverseArgs(v, depth, k);
      }
    }
    return value;
  }
  return value;
}, "traverseArgs");
var nameSpiesAndWrapActionsInSpies = __name(({ initialArgs }) => {
  traverseArgs(initialArgs);
}, "nameSpiesAndWrapActionsInSpies");
var patchedFocus = false;
var enhanceContext = __name(async (context) => {
  if (globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement) {
    context.canvas = (0, import_test2.within)(context.canvasElement);
  }
  const clipboard = globalThis.window?.navigator?.clipboard;
  if (clipboard) {
    context.userEvent = instrument(
      { userEvent: import_test2.uninstrumentedUserEvent.setup() },
      {
        intercept: true,
        getKeys: __name((obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"), "getKeys")
      }
    ).userEvent;
    Object.defineProperty(globalThis.window.navigator, "clipboard", {
      get: __name(() => clipboard, "get"),
      configurable: true
    });
    let currentFocus = HTMLElement.prototype.focus;
    if (!patchedFocus) {
      Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: true,
          set: __name((newFocus) => {
            currentFocus = newFocus;
            patchedFocus = true;
          }, "set"),
          get: __name(() => {
            return currentFocus;
          }, "get")
        }
      });
    }
  }
}, "enhanceContext");
var preview_default7 = __name(() => definePreviewAddon9({
  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
}), "default");
var initialGlobals4 = {
  [PARAM_KEY]: { value: void 0, isRotated: false }
};
var preview_default8 = __name(() => definePreviewAddon9({
  initialGlobals: initialGlobals4
}), "default");
function getCoreAnnotations() {
  return [
    // @ts-expect-error CJS fallback
    (preview_default5.default ?? preview_default5)(),
    // @ts-expect-error CJS fallback
    (preview_default2.default ?? preview_default2)(),
    // @ts-expect-error CJS fallback
    (preview_default4.default ?? preview_default4)(),
    // @ts-expect-error CJS fallback
    (preview_default6.default ?? preview_default6)(),
    // @ts-expect-error CJS fallback
    (preview_default8.default ?? preview_default8)(),
    // @ts-expect-error CJS fallback
    (preview_default.default ?? preview_default)(),
    // @ts-expect-error CJS fallback
    (preview_default3.default ?? preview_default3)(),
    // @ts-expect-error CJS fallback
    (preview_default7.default ?? preview_default7)()
  ];
}
__name(getCoreAnnotations, "getCoreAnnotations");
function definePreview(input) {
  let composed;
  const preview = {
    _tag: "Preview",
    input,
    get composed() {
      if (composed) {
        return composed;
      }
      const { addons: addons22, ...rest } = input;
      composed = normalizeProjectAnnotations(
        composeConfigs([...getCoreAnnotations(), ...addons22 ?? [], rest])
      );
      return composed;
    },
    meta(meta) {
      return defineMeta(meta, this);
    }
  };
  globalThis.globalProjectAnnotations = preview.composed;
  return preview;
}
__name(definePreview, "definePreview");
function definePreviewAddon9(preview) {
  return preview;
}
__name(definePreviewAddon9, "definePreviewAddon");
function isPreview(input) {
  return input != null && typeof input === "object" && "_tag" in input && input?._tag === "Preview";
}
__name(isPreview, "isPreview");
function isMeta(input) {
  return input != null && typeof input === "object" && "_tag" in input && input?._tag === "Meta";
}
__name(isMeta, "isMeta");
function defineMeta(input, preview) {
  return {
    _tag: "Meta",
    input,
    preview,
    // @ts-expect-error hard
    story(story = {}) {
      return defineStory(typeof story === "function" ? { render: story } : story, this);
    }
  };
}
__name(defineMeta, "defineMeta");
function isStory(input) {
  return input != null && typeof input === "object" && "_tag" in input && input?._tag === "Story";
}
__name(isStory, "isStory");
function defineStory(input, meta) {
  let composed;
  const compose = __name(() => {
    if (!composed) {
      composed = composeStory(
        input,
        meta.input,
        void 0,
        meta.preview.composed
      );
    }
    return composed;
  }, "compose");
  const __children = [];
  return {
    _tag: "Story",
    input,
    meta,
    // @ts-expect-error this is a private property used only once in renderers/react/src/preview
    __compose: compose,
    __children,
    get composed() {
      const composed2 = compose();
      const { args, argTypes, parameters: parameters2, id, tags, globals, storyName: name } = composed2;
      return { args, argTypes, parameters: parameters2, id, tags, name, globals };
    },
    get play() {
      return input.play ?? meta.input?.play ?? (async () => {
      });
    },
    async run(context) {
      await compose().run(context);
    },
    test(name, overridesOrTestFn, testFn) {
      const annotations = typeof overridesOrTestFn !== "function" ? overridesOrTestFn : {};
      const testFunction = typeof overridesOrTestFn !== "function" ? testFn : overridesOrTestFn;
      const play = mountDestructured(this.play) || mountDestructured(testFunction) ? async ({ context }) => {
        await this.play?.(context);
        await testFunction(context);
      } : async (context) => {
        await this.play?.(context);
        await testFunction(context);
      };
      const test2 = this.extend({
        ...annotations,
        name,
        tags: ["test-fn", "!autodocs", ...annotations.tags ?? []],
        play
      });
      __children.push(test2);
      return test2;
    },
    extend(input2) {
      return defineStory(
        {
          ...this.input,
          ...input2,
          args: { ...this.input.args || {}, ...input2.args },
          argTypes: combineParameters(this.input.argTypes, input2.argTypes),
          afterEach: [
            ...normalizeArrays(this.input?.afterEach ?? []),
            ...normalizeArrays(input2.afterEach ?? [])
          ],
          beforeEach: [
            ...normalizeArrays(this.input?.beforeEach ?? []),
            ...normalizeArrays(input2.beforeEach ?? [])
          ],
          decorators: [
            ...normalizeArrays(this.input?.decorators ?? []),
            ...normalizeArrays(input2.decorators ?? [])
          ],
          globals: { ...this.input.globals, ...input2.globals },
          loaders: [
            ...normalizeArrays(this.input?.loaders ?? []),
            ...normalizeArrays(input2.loaders ?? [])
          ],
          parameters: combineParameters(this.input.parameters, input2.parameters),
          tags: combineTags2(...this.input.tags ?? [], ...input2.tags ?? [])
        },
        this.meta
      );
    }
  };
}
__name(defineStory, "defineStory");
function getStoryChildren(story) {
  if ("__children" in story) {
    return story.__children;
  }
  return [];
}
__name(getStoryChildren, "getStoryChildren");
var sanitize = __name((string) => {
  return string.toLowerCase().replace(/[ ’–—―′¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}, "sanitize");
var sanitizeSafe = __name((string, part) => {
  const sanitized = sanitize(string);
  if (sanitized === "") {
    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
  }
  return sanitized;
}, "sanitizeSafe");
var toId = __name((kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`, "toId");
var toTestId = __name((parentId, testName2) => `${parentId}:${sanitizeSafe(testName2, "test")}`, "toTestId");
var storyNameFromExport = __name((key) => toStartCaseStr(key), "storyNameFromExport");
function matches2(storyKey, arrayOrRegex) {
  if (Array.isArray(arrayOrRegex)) {
    return arrayOrRegex.includes(storyKey);
  }
  return storyKey.match(arrayOrRegex);
}
__name(matches2, "matches");
function isExportStory(key, { includeStories, excludeStories }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    key !== "__esModule" && (!includeStories || matches2(key, includeStories)) && (!excludeStories || !matches2(key, excludeStories))
  );
}
__name(isExportStory, "isExportStory");
var parseKind = __name((kind, { rootSeparator, groupSeparator }) => {
  const [root, remainder] = kind.split(rootSeparator, 2);
  const groups = (remainder || kind).split(groupSeparator).filter((i) => !!i);
  return {
    root: remainder ? root : null,
    groups
  };
}, "parseKind");
var combineTags2 = __name((...tags) => {
  const result = tags.reduce((acc, tag) => {
    if (tag.startsWith("!")) {
      acc.delete(tag.slice(1));
    } else {
      acc.add(tag);
    }
    return acc;
  }, /* @__PURE__ */ new Set());
  return Array.from(result);
}, "combineTags");

export {
  SNIPPET_RENDERED,
  SourceType,
  isTestEnvironment,
  require_channels,
  includeConditionalArg,
  getCoreAnnotations,
  definePreview,
  definePreviewAddon9,
  isPreview,
  isMeta,
  isStory,
  getStoryChildren,
  sanitize,
  toId,
  toTestId,
  storyNameFromExport,
  isExportStory,
  parseKind,
  combineTags2
};
//# sourceMappingURL=chunk-4ZEM2PHZ.js.map
