import CJS_COMPAT_NODE_URL_yq6slfj5rh from 'node:url';
import CJS_COMPAT_NODE_PATH_yq6slfj5rh from 'node:path';
import CJS_COMPAT_NODE_MODULE_yq6slfj5rh from "node:module";

var __filename = CJS_COMPAT_NODE_URL_yq6slfj5rh.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_yq6slfj5rh.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_yq6slfj5rh.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  execa,
  resolvePackageDir
} from "./_node-chunks/chunk-6UDAZSI3.js";
import {
  any,
  getAddonNames,
  up
} from "./_node-chunks/chunk-PNNLYDKS.js";
import {
  DOCUMENTATION_LINK,
  SUPPORTED_FRAMEWORKS
} from "./_node-chunks/chunk-YXDSXLVO.js";
import {
  dirname,
  join,
  relative,
  resolve
} from "./_node-chunks/chunk-HVQVIFNZ.js";
import {
  require_compare,
  require_constants,
  require_debug,
  require_gte,
  require_identifiers,
  require_parse_options,
  require_re,
  require_semver
} from "./_node-chunks/chunk-5MMKANN2.js";
import {
  __commonJS,
  __name,
  __toESM
} from "./_node-chunks/chunk-DMVKAJJ2.js";

// ../../node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../../node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse = /* @__PURE__ */ __name((version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    }, "parse");
    module.exports = parse;
  }
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var valid = /* @__PURE__ */ __name((version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    }, "valid");
    module.exports = valid;
  }
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var clean = /* @__PURE__ */ __name((version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }, "clean");
    module.exports = clean;
  }
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = /* @__PURE__ */ __name((version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    }, "inc");
    module.exports = inc;
  }
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var diff = /* @__PURE__ */ __name((version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    }, "diff");
    module.exports = diff;
  }
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var major = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).major, "major");
    module.exports = major;
  }
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).minor, "minor");
    module.exports = minor;
  }
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).patch, "patch");
    module.exports = patch;
  }
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var prerelease = /* @__PURE__ */ __name((version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }, "prerelease");
    module.exports = prerelease;
  }
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var rcompare = /* @__PURE__ */ __name((a, b, loose) => compare(b, a, loose), "rcompare");
    module.exports = rcompare;
  }
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var compareLoose = /* @__PURE__ */ __name((a, b) => compare(a, b, true), "compareLoose");
    module.exports = compareLoose;
  }
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = /* @__PURE__ */ __name((a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }, "compareBuild");
    module.exports = compareBuild;
  }
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(a, b, loose)), "sort");
    module.exports = sort;
  }
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(b, a, loose)), "rsort");
    module.exports = rsort;
  }
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) > 0, "gt");
    module.exports = gt;
  }
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) < 0, "lt");
    module.exports = lt;
  }
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var eq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) === 0, "eq");
    module.exports = eq;
  }
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var neq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) !== 0, "neq");
    module.exports = neq;
  }
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) <= 0, "lte");
    module.exports = lte;
  }
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = /* @__PURE__ */ __name((a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    }, "cmp");
    module.exports = cmp;
  }
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce2 = /* @__PURE__ */ __name((version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    }, "coerce");
    module.exports = coerce2;
  }
});

// ../../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../../node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      static {
        __name(this, "Range");
      }
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = /* @__PURE__ */ __name((c) => c.value === "<0.0.0-0", "isNullSet");
    var isAny = /* @__PURE__ */ __name((c) => c.value === "", "isAny");
    var isSatisfiable = /* @__PURE__ */ __name((comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }, "isSatisfiable");
    var parseComparator = /* @__PURE__ */ __name((comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }, "parseComparator");
    var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
    var replaceTildes = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    }, "replaceTildes");
    var replaceTilde = /* @__PURE__ */ __name((comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    }, "replaceTilde");
    var replaceCarets = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    }, "replaceCarets");
    var replaceCaret = /* @__PURE__ */ __name((comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }, "replaceCaret");
    var replaceXRanges = /* @__PURE__ */ __name((comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    }, "replaceXRanges");
    var replaceXRange = /* @__PURE__ */ __name((comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    }, "replaceXRange");
    var replaceStars = /* @__PURE__ */ __name((comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }, "replaceStars");
    var replaceGTE0 = /* @__PURE__ */ __name((comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    }, "replaceGTE0");
    var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    }, "hyphenReplace");
    var testSet = /* @__PURE__ */ __name((set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }, "testSet");
  }
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static {
        __name(this, "Comparator");
      }
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies2 = /* @__PURE__ */ __name((version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }, "satisfies");
    module.exports = satisfies2;
  }
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var toComparators = /* @__PURE__ */ __name((range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" ")), "toComparators");
    module.exports = toComparators;
  }
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = /* @__PURE__ */ __name((versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }, "maxSatisfying");
    module.exports = maxSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = /* @__PURE__ */ __name((versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }, "minSatisfying");
    module.exports = minSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = /* @__PURE__ */ __name((range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }, "minVersion");
    module.exports = minVersion;
  }
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var validRange = /* @__PURE__ */ __name((range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }, "validRange");
    module.exports = validRange;
  }
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = /* @__PURE__ */ __name((version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }, "outside");
    module.exports = outside;
  }
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var gtr = /* @__PURE__ */ __name((version, range, options) => outside(version, range, ">", options), "gtr");
    module.exports = gtr;
  }
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var ltr = /* @__PURE__ */ __name((version, range, options) => outside(version, range, "<", options), "ltr");
    module.exports = ltr;
  }
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var intersects = /* @__PURE__ */ __name((r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    }, "intersects");
    module.exports = intersects;
  }
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies2(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    var subset = /* @__PURE__ */ __name((sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    }, "subset");
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = /* @__PURE__ */ __name((sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies2(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies2(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    }, "simpleSubset");
    var higherGT = /* @__PURE__ */ __name((a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    }, "higherGT");
    var lowerLT = /* @__PURE__ */ __name((a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    }, "lowerLT");
    module.exports = subset;
  }
});

// ../../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/semver/index.js"(exports, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// src/postinstall.ts
import { existsSync } from "node:fs";
import * as fs2 from "node:fs/promises";
import { writeFile } from "node:fs/promises";
import { isAbsolute, posix, sep } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { babelParse, generate, traverse } from "storybook/internal/babel";
import {
  JsPackageManagerFactory,
  formatFileContent,
  getInterpretedFile,
  getProjectRoot,
  isCI as isCI2,
  loadMainConfig,
  scanAndTransformFiles,
  transformImportFiles
} from "storybook/internal/common";
import { experimental_loadStorybook } from "storybook/internal/core-server";
import { readConfig, writeConfig } from "storybook/internal/csf-tools";
import { logger as logger2 } from "storybook/internal/node-logger";

// ../../node_modules/empathic/package.mjs
function up2(options) {
  return up("package.json", options);
}
__name(up2, "up");

// src/postinstall.ts
var import_semver = __toESM(require_semver2(), 1);
import prompts from "prompts";
import { dedent } from "ts-dedent";

// src/postinstall-logger.ts
import { isCI } from "storybook/internal/common";
import { colors, logger } from "storybook/internal/node-logger";
var fancy = process.platform !== "win32" || isCI() || process.env.TERM === "xterm-256color";
var step = colors.gray("\u203A");
var info = colors.blue(fancy ? "\u2139" : "i");
var success = colors.green(fancy ? "\u2714" : "\u221A");
var warning = colors.orange(fancy ? "\u26A0" : "\u203C");
var error = colors.red(fancy ? "\u2716" : "\xD7");
var baseOptions = {
  borderStyle: "round",
  padding: 1
};
var print = /* @__PURE__ */ __name((message, options) => {
  logger.line(1);
  logger.logBox(message, { ...baseOptions, ...options });
}, "print");
var printInfo = /* @__PURE__ */ __name((title, message, options) => print(message, { borderColor: "blue", title, ...options }), "printInfo");
var printWarning = /* @__PURE__ */ __name((title, message, options) => print(message, { borderColor: "yellow", title, ...options }), "printWarning");
var printError = /* @__PURE__ */ __name((title, message, options) => print(message, { borderColor: "red", title, ...options }), "printError");
var printSuccess = /* @__PURE__ */ __name((title, message, options) => print(message, { borderColor: "green", title, ...options }), "printSuccess");

// src/updateVitestFile.ts
import * as fs from "node:fs/promises";
var loadTemplate = /* @__PURE__ */ __name(async (name, replacements) => {
  let template = await fs.readFile(
    join(resolvePackageDir("@storybook/addon-vitest"), "templates", name),
    "utf8"
  );
  Object.entries(replacements).forEach(([key, value]) => template = template.replace(key, value));
  return template;
}, "loadTemplate");
var mergeProperties = /* @__PURE__ */ __name((source, target) => {
  for (const sourceProp of source) {
    if (sourceProp.type === "ObjectProperty") {
      const targetProp = target.find(
        (p) => sourceProp.key.type === "Identifier" && p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === sourceProp.key.name
      );
      if (targetProp && targetProp.type === "ObjectProperty") {
        if (sourceProp.value.type === "ObjectExpression" && targetProp.value.type === "ObjectExpression") {
          mergeProperties(sourceProp.value.properties, targetProp.value.properties);
        } else if (sourceProp.value.type === "ArrayExpression" && targetProp.value.type === "ArrayExpression") {
          targetProp.value.elements.push(...sourceProp.value.elements);
        } else {
          targetProp.value = sourceProp.value;
        }
      } else {
        target.push(sourceProp);
      }
    }
  }
}, "mergeProperties");
var updateConfigFile = /* @__PURE__ */ __name((source, target) => {
  let updated = false;
  const sourceExportDefault = source.program.body.find(
    (n) => n.type === "ExportDefaultDeclaration"
  );
  if (!sourceExportDefault || sourceExportDefault.declaration.type !== "CallExpression") {
    return false;
  }
  const targetExportDefault = target.program.body.find(
    (n) => n.type === "ExportDefaultDeclaration"
  );
  if (!targetExportDefault) {
    return false;
  }
  if (targetExportDefault.declaration.type === "CallExpression" && targetExportDefault.declaration.callee.type === "Identifier" && targetExportDefault.declaration.callee.name === "defineConfig" && targetExportDefault.declaration.arguments.length > 0 && targetExportDefault.declaration.arguments[0].type === "ArrowFunctionExpression") {
    return false;
  }
  let canHandleConfig = false;
  if (targetExportDefault.declaration.type === "ObjectExpression") {
    canHandleConfig = true;
  } else if (targetExportDefault.declaration.type === "CallExpression" && targetExportDefault.declaration.callee.type === "Identifier" && targetExportDefault.declaration.callee.name === "defineConfig" && targetExportDefault.declaration.arguments[0]?.type === "ObjectExpression") {
    canHandleConfig = true;
  } else if (targetExportDefault.declaration.type === "CallExpression" && targetExportDefault.declaration.callee.type === "Identifier" && targetExportDefault.declaration.callee.name === "mergeConfig" && targetExportDefault.declaration.arguments.length >= 2) {
    canHandleConfig = true;
  }
  if (!canHandleConfig) {
    return false;
  }
  for (const sourceNode of source.program.body) {
    if (sourceNode.type === "ImportDeclaration") {
      if (!target.program.body.some(
        (targetNode) => targetNode.type === sourceNode.type && targetNode.specifiers.some((s) => s.local.name === sourceNode.specifiers[0].local.name)
      )) {
        const lastImport = target.program.body.findLastIndex((n) => n.type === "ImportDeclaration");
        target.program.body.splice(lastImport + 1, 0, sourceNode);
      }
    } else if (sourceNode.type === "VariableDeclaration") {
      if (!target.program.body.some(
        (targetNode) => targetNode.type === sourceNode.type && targetNode.declarations.some(
          (d) => "name" in d.id && "name" in sourceNode.declarations[0].id && d.id.name === sourceNode.declarations[0].id.name
        )
      )) {
        const lastImport = target.program.body.findLastIndex((n) => n.type === "ImportDeclaration");
        target.program.body.splice(lastImport + 1, 0, sourceNode);
      }
    } else if (sourceNode.type === "ExportDefaultDeclaration") {
      const exportDefault = target.program.body.find((n) => n.type === "ExportDefaultDeclaration");
      if (exportDefault && sourceNode.declaration.type === "CallExpression" && sourceNode.declaration.arguments.length > 0 && sourceNode.declaration.arguments[0].type === "ObjectExpression") {
        const { properties } = sourceNode.declaration.arguments[0];
        if (exportDefault.declaration.type === "ObjectExpression") {
          mergeProperties(properties, exportDefault.declaration.properties);
          updated = true;
        } else if (exportDefault.declaration.type === "CallExpression" && exportDefault.declaration.callee.type === "Identifier" && exportDefault.declaration.callee.name === "defineConfig" && exportDefault.declaration.arguments[0]?.type === "ObjectExpression") {
          mergeProperties(properties, exportDefault.declaration.arguments[0].properties);
          updated = true;
        } else if (exportDefault.declaration.type === "CallExpression" && exportDefault.declaration.callee.type === "Identifier" && exportDefault.declaration.callee.name === "mergeConfig" && exportDefault.declaration.arguments.length >= 2) {
          const configObjectNodes = [];
          for (const arg of exportDefault.declaration.arguments) {
            if (arg?.type === "CallExpression" && arg.callee.type === "Identifier" && arg.callee.name === "defineConfig" && arg.arguments[0]?.type === "ObjectExpression") {
              configObjectNodes.push(arg.arguments[0]);
            } else if (arg?.type === "ObjectExpression") {
              configObjectNodes.push(arg);
            }
          }
          const configObjectWithTest = configObjectNodes.find(
            (obj) => obj.properties.some(
              (p) => p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === "test"
            )
          );
          const targetConfigObject = configObjectWithTest || configObjectNodes[0];
          if (!targetConfigObject) {
            return false;
          }
          const existingTestProp = targetConfigObject.properties.find(
            (p) => p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === "test"
          );
          if (existingTestProp && existingTestProp.value.type === "ObjectExpression") {
            const templateTestProp = properties.find(
              (p) => p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === "test"
            );
            if (templateTestProp && templateTestProp.value.type === "ObjectExpression") {
              const workspaceOrProjectsProp = templateTestProp.value.properties.find(
                (p) => p.type === "ObjectProperty" && p.key.type === "Identifier" && (p.key.name === "workspace" || p.key.name === "projects")
              );
              if (workspaceOrProjectsProp && workspaceOrProjectsProp.value.type === "ArrayExpression") {
                const coverageProp = existingTestProp.value.properties.find(
                  (p) => p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === "coverage"
                );
                const testPropsWithoutCoverage = existingTestProp.value.properties.filter(
                  (p) => p !== coverageProp
                );
                const testConfigForProject = {
                  type: "ObjectExpression",
                  properties: testPropsWithoutCoverage
                };
                const existingTestProject = {
                  type: "ObjectExpression",
                  properties: [
                    {
                      type: "ObjectProperty",
                      key: { type: "Identifier", name: "extends" },
                      value: { type: "BooleanLiteral", value: true },
                      computed: false,
                      shorthand: false
                    },
                    {
                      type: "ObjectProperty",
                      key: { type: "Identifier", name: "test" },
                      value: testConfigForProject,
                      computed: false,
                      shorthand: false
                    }
                  ]
                };
                workspaceOrProjectsProp.value.elements.unshift(existingTestProject);
                targetConfigObject.properties = targetConfigObject.properties.filter(
                  (p) => p !== existingTestProp
                );
                if (coverageProp && templateTestProp.value.type === "ObjectExpression") {
                  templateTestProp.value.properties.unshift(coverageProp);
                }
                mergeProperties(properties, targetConfigObject.properties);
              } else {
                mergeProperties(properties, targetConfigObject.properties);
              }
            } else {
              mergeProperties(properties, targetConfigObject.properties);
            }
          } else {
            mergeProperties(properties, targetConfigObject.properties);
          }
          updated = true;
        }
      }
    }
  }
  return updated;
}, "updateConfigFile");
var updateWorkspaceFile = /* @__PURE__ */ __name((source, target) => {
  let updated = false;
  for (const sourceNode of source.program.body) {
    if (sourceNode.type === "ImportDeclaration") {
      if (!target.program.body.some(
        (targetNode) => targetNode.type === sourceNode.type && targetNode.source.value === sourceNode.source.value && targetNode.specifiers.some((s) => s.local.name === sourceNode.specifiers[0].local.name)
      )) {
        const lastImport = target.program.body.findLastIndex((n) => n.type === "ImportDeclaration");
        target.program.body.splice(lastImport + 1, 0, sourceNode);
      }
    } else if (sourceNode.type === "VariableDeclaration") {
      if (!target.program.body.some(
        (targetNode) => targetNode.type === sourceNode.type && targetNode.declarations.some(
          (d) => "name" in d.id && "name" in sourceNode.declarations[0].id && d.id.name === sourceNode.declarations[0].id.name
        )
      )) {
        const lastImport = target.program.body.findLastIndex((n) => n.type === "ImportDeclaration");
        target.program.body.splice(lastImport + 1, 0, sourceNode);
      }
    } else if (sourceNode.type === "ExportDefaultDeclaration") {
      const exportDefault = target.program.body.find((n) => n.type === "ExportDefaultDeclaration");
      if (exportDefault && sourceNode.declaration.type === "CallExpression" && sourceNode.declaration.arguments.length > 0 && sourceNode.declaration.arguments[0].type === "ArrayExpression" && sourceNode.declaration.arguments[0].elements.length > 0) {
        const { elements } = sourceNode.declaration.arguments[0];
        if (exportDefault.declaration.type === "ArrayExpression") {
          exportDefault.declaration.elements.push(...elements);
          updated = true;
        } else if (exportDefault.declaration.type === "CallExpression" && exportDefault.declaration.callee.type === "Identifier" && exportDefault.declaration.callee.name === "defineWorkspace" && exportDefault.declaration.arguments[0]?.type === "ArrayExpression") {
          exportDefault.declaration.arguments[0].elements.push(...elements);
          updated = true;
        }
      }
    }
  }
  return updated;
}, "updateWorkspaceFile");

// src/postinstall.ts
var ADDON_NAME = "@storybook/addon-vitest";
var EXTENSIONS = [".ts", ".tsx", ".js", ".jsx", ".cts", ".mts", ".cjs", ".mjs"];
var addonA11yName = "@storybook/addon-a11y";
var hasErrors = false;
function nameMatches(name, pattern) {
  if (name === pattern) {
    return true;
  }
  if (name.includes(`${pattern}${sep}`)) {
    return true;
  }
  if (name.includes(`${pattern}${posix.sep}`)) {
    return true;
  }
  return false;
}
__name(nameMatches, "nameMatches");
var logErrors = /* @__PURE__ */ __name((...args) => {
  hasErrors = true;
  printError(...args);
}, "logErrors");
var findFile = /* @__PURE__ */ __name((basename, extensions = EXTENSIONS) => any(
  extensions.map((ext) => basename + ext),
  { last: getProjectRoot() }
), "findFile");
async function postInstall(options) {
  printSuccess(
    "\u{1F44B} Howdy!",
    dedent`
      I'm the installation helper for ${ADDON_NAME}

      Hold on for a moment while I look at your project and get it set up...
    `
  );
  const packageManager = JsPackageManagerFactory.getPackageManager({
    force: options.packageManager
  });
  const vitestVersionSpecifier = await packageManager.getInstalledVersion("vitest");
  const coercedVitestVersion = vitestVersionSpecifier ? (0, import_semver.coerce)(vitestVersionSpecifier) : null;
  const isVitest3_2To4 = vitestVersionSpecifier ? (0, import_semver.satisfies)(vitestVersionSpecifier, ">=3.2.0 <4.0.0") : false;
  const isVitest4OrNewer = vitestVersionSpecifier ? (0, import_semver.satisfies)(vitestVersionSpecifier, ">=4.0.0") : true;
  const info2 = await getStorybookInfo(options);
  const allDeps = packageManager.getAllDependencies();
  const dependencies = [
    "vitest",
    "playwright",
    isVitest4OrNewer ? "@vitest/browser-playwright" : "@vitest/browser"
  ];
  const uniqueDependencies = dependencies.filter((p) => !allDeps[p]);
  const mainJsPath = getInterpretedFile(resolve(options.configDir, "main"));
  const config = await readConfig(mainJsPath);
  const hasCustomWebpackConfig = !!config.getFieldNode(["webpackFinal"]);
  const isInteractive = process.stdout.isTTY && !isCI2();
  if (nameMatches(info2.frameworkPackageName, "@storybook/nextjs") && !hasCustomWebpackConfig) {
    const out = options.yes || !isInteractive ? { migrateToNextjsVite: !!options.yes } : await prompts({
      type: "confirm",
      name: "migrateToNextjsVite",
      message: dedent`
            The addon requires the use of @storybook/nextjs-vite to work with Next.js.
            https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}#install-and-set-up

            Do you want to migrate?
          `,
      initial: true
    });
    if (out.migrateToNextjsVite) {
      await packageManager.addDependencies({ type: "devDependencies", skipInstall: true }, [
        "@storybook/nextjs-vite"
      ]);
      await packageManager.removeDependencies(["@storybook/nextjs"]);
      traverse(config._ast, {
        StringLiteral(path) {
          if (path.node.value === "@storybook/nextjs") {
            path.node.value = "@storybook/nextjs-vite";
          }
        }
      });
      await writeConfig(config, mainJsPath);
      info2.frameworkPackageName = "@storybook/nextjs-vite";
      info2.builderPackageName = "@storybook/builder-vite";
      await scanAndTransformFiles({
        promptMessage: "Enter a glob to scan for all @storybook/nextjs imports to substitute with @storybook/nextjs-vite:",
        force: options.yes,
        dryRun: false,
        transformFn: /* @__PURE__ */ __name((files, options2, dryRun) => transformImportFiles(files, options2, dryRun), "transformFn"),
        transformOptions: {
          "@storybook/nextjs": "@storybook/nextjs-vite"
        }
      });
    }
  }
  const annotationsImport = SUPPORTED_FRAMEWORKS.find(
    (f) => nameMatches(info2.frameworkPackageName, f)
  ) ? info2.frameworkPackageName === "@storybook/nextjs" ? "@storybook/nextjs-vite" : info2.frameworkPackageName : null;
  const isRendererSupported = !!annotationsImport;
  const prerequisiteCheck = /* @__PURE__ */ __name(async () => {
    const reasons = [];
    if (hasCustomWebpackConfig) {
      reasons.push("\u2022 The addon can not be used with a custom Webpack configuration.");
    }
    if (!nameMatches(info2.frameworkPackageName, "@storybook/nextjs") && !nameMatches(info2.builderPackageName, "@storybook/builder-vite")) {
      reasons.push(
        "\u2022 The addon can only be used with a Vite-based Storybook framework or Next.js."
      );
    }
    if (!isRendererSupported) {
      reasons.push(dedent`
        • The addon cannot yet be used with ${info2.frameworkPackageName}
      `);
    }
    if (coercedVitestVersion && !(0, import_semver.satisfies)(coercedVitestVersion, ">=3.0.0")) {
      reasons.push(dedent`
        • The addon requires Vitest 3.0.0 or higher. You are currently using ${vitestVersionSpecifier}.
          Please update all of your Vitest dependencies and try again.
      `);
    }
    const mswVersionSpecifier = await packageManager.getInstalledVersion("msw");
    const coercedMswVersion = mswVersionSpecifier ? (0, import_semver.coerce)(mswVersionSpecifier) : null;
    if (coercedMswVersion && !(0, import_semver.satisfies)(coercedMswVersion, ">=2.0.0")) {
      reasons.push(dedent`
        • The addon uses Vitest behind the scenes, which supports only version 2 and above of MSW. However, we have detected version ${coercedMswVersion.version} in this project.
        Please update the 'msw' package and try again.
      `);
    }
    if (nameMatches(info2.frameworkPackageName, "@storybook/nextjs")) {
      const nextVersion = await packageManager.getInstalledVersion("next");
      if (!nextVersion) {
        reasons.push(dedent`
          • You are using @storybook/nextjs without having "next" installed.
            Please install "next" or use a different Storybook framework integration and try again.
        `);
      }
    }
    if (reasons.length > 0) {
      reasons.unshift(
        `@storybook/addon-vitest's automated setup failed due to the following package incompatibilities:`
      );
      reasons.push("--------------------------------");
      reasons.push(
        dedent`
          You can fix these issues and rerun the command to reinstall. If you wish to roll back the installation, remove ${ADDON_NAME} from the "addons" array
          in your main Storybook config file and remove the dependency from your package.json file.
        `
      );
      if (!isRendererSupported) {
        reasons.push(
          dedent`
            Please check the documentation for more information about its requirements and installation:
            https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}
          `
        );
      } else {
        reasons.push(
          dedent`
            Fear not, however, you can follow the manual installation process instead at:
            https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}#manual-setup
          `
        );
      }
      return reasons.map((r) => r.trim()).join("\n\n");
    }
    return null;
  }, "prerequisiteCheck");
  const result = await prerequisiteCheck();
  if (result) {
    logErrors("\u26D4\uFE0F Sorry!", result);
    logger2.line(1);
    return;
  }
  if (info2.frameworkPackageName === "@storybook/nextjs") {
    printInfo(
      "\u{1F37F} Just so you know...",
      dedent`
        It looks like you're using Next.js.

        Adding "@storybook/nextjs-vite/vite-plugin" so you can use it with Vitest.

        More info about the plugin at https://github.com/storybookjs/vite-plugin-storybook-nextjs
      `
    );
    try {
      const storybookVersion = await packageManager.getInstalledVersion("storybook");
      uniqueDependencies.push(`@storybook/nextjs-vite@^${storybookVersion}`);
    } catch (e) {
      console.error("Failed to install @storybook/nextjs-vite. Please install it manually");
    }
  }
  const v8Version = await packageManager.getInstalledVersion("@vitest/coverage-v8");
  const istanbulVersion = await packageManager.getInstalledVersion("@vitest/coverage-istanbul");
  if (!v8Version && !istanbulVersion) {
    printInfo(
      "\u{1F648} Let me cover this for you",
      dedent`
        You don't seem to have a coverage reporter installed. Vitest needs either V8 or Istanbul to generate coverage reports.

        Adding "@vitest/coverage-v8" to enable coverage reporting.
        Read more about Vitest coverage providers at https://vitest.dev/guide/coverage.html#coverage-providers
      `
    );
    uniqueDependencies.push(`@vitest/coverage-v8`);
  }
  const versionedDependencies = uniqueDependencies.map((p) => {
    if (p.includes("vitest")) {
      return vitestVersionSpecifier ? `${p}@${vitestVersionSpecifier}` : p;
    }
    return p;
  });
  if (versionedDependencies.length > 0) {
    await packageManager.addDependencies(
      { type: "devDependencies", skipInstall: true },
      versionedDependencies
    );
    logger2.line(1);
    logger2.plain(`${step} Installing dependencies:`);
    logger2.plain("  " + versionedDependencies.join(", "));
  }
  await packageManager.installDependencies();
  logger2.line(1);
  if (options.skipInstall) {
    logger2.plain("Skipping Playwright installation, please run this command manually:");
    logger2.plain("  npx playwright install chromium --with-deps");
  } else {
    logger2.plain(`${step} Configuring Playwright with Chromium (this might take some time):`);
    logger2.plain("  npx playwright install chromium --with-deps");
    try {
      await packageManager.executeCommand({
        command: "npx",
        args: ["playwright", "install", "chromium", "--with-deps"]
      });
    } catch (e) {
      console.error("Failed to install Playwright. Please install it manually");
    }
  }
  const fileExtension = allDeps.typescript || findFile("tsconfig", [...EXTENSIONS, ".json"]) ? "ts" : "js";
  const vitestSetupFile = resolve(options.configDir, `vitest.setup.${fileExtension}`);
  if (existsSync(vitestSetupFile)) {
    logErrors(
      "\u{1F6A8} Oh no!",
      dedent`
        Found an existing Vitest setup file:
        ${vitestSetupFile}

        Please refer to the documentation to complete the setup manually:
        https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}#manual-setup
      `
    );
    logger2.line(1);
    return;
  }
  logger2.line(1);
  logger2.plain(`${step} Creating a Vitest setup file for Storybook:`);
  logger2.plain(`  ${vitestSetupFile}`);
  const previewExists = EXTENSIONS.map((ext) => resolve(options.configDir, `preview${ext}`)).some(
    existsSync
  );
  const imports = [`import { setProjectAnnotations } from '${annotationsImport}';`];
  const projectAnnotations = [];
  if (previewExists) {
    imports.push(`import * as projectAnnotations from './preview';`);
    projectAnnotations.push("projectAnnotations");
  }
  await writeFile(
    vitestSetupFile,
    dedent`
      ${imports.join("\n")}

      // This is an important step to apply the right configuration when testing your stories.
      // More info at: https://storybook.js.org/docs/api/portable-stories/portable-stories-vitest#setprojectannotations
      setProjectAnnotations([${projectAnnotations.join(", ")}]);
    `
  );
  const vitestWorkspaceFile = findFile("vitest.workspace", [".ts", ".js", ".json"]);
  const viteConfigFile = findFile("vite.config");
  const vitestConfigFile = findFile("vitest.config");
  const vitestShimFile = findFile("vitest.shims.d");
  const rootConfig = vitestConfigFile || viteConfigFile;
  if (fileExtension === "ts" && !vitestShimFile) {
    await writeFile(
      "vitest.shims.d.ts",
      isVitest4OrNewer ? '/// <reference types="@vitest/browser-playwright" />' : '/// <reference types="@vitest/browser/providers/playwright" />'
    );
  }
  const getTemplateName = /* @__PURE__ */ __name(() => {
    if (isVitest4OrNewer) {
      return "vitest.config.4.template.ts";
    } else if (isVitest3_2To4) {
      return "vitest.config.3.2.template.ts";
    }
    return "vitest.config.template.ts";
  }, "getTemplateName");
  if (vitestWorkspaceFile) {
    const workspaceTemplate = await loadTemplate("vitest.workspace.template.ts", {
      EXTENDS_WORKSPACE: viteConfigFile ? relative(dirname(vitestWorkspaceFile), viteConfigFile) : "",
      CONFIG_DIR: options.configDir,
      SETUP_FILE: relative(dirname(vitestWorkspaceFile), vitestSetupFile)
    }).then((t) => t.replace(`
  'ROOT_CONFIG',`, "").replace(/\s+extends: '',/, ""));
    const workspaceFile = await fs2.readFile(vitestWorkspaceFile, "utf8");
    const source = babelParse(workspaceTemplate);
    const target = babelParse(workspaceFile);
    const updated = updateWorkspaceFile(source, target);
    if (updated) {
      logger2.line(1);
      logger2.plain(`${step} Updating your Vitest workspace file:`);
      logger2.plain(`  ${vitestWorkspaceFile}`);
      const formattedContent = await formatFileContent(vitestWorkspaceFile, generate(target).code);
      await writeFile(vitestWorkspaceFile, formattedContent);
    } else {
      logErrors(
        "\u{1F6A8} Oh no!",
        dedent`
          Could not update existing Vitest workspace file:
          ${vitestWorkspaceFile}

          I was able to configure most of the addon but could not safely extend
          your existing workspace file automatically, you must do it yourself.

          Please refer to the documentation to complete the setup manually:
          https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}#manual-setup
        `
      );
      logger2.line(1);
      return;
    }
  } else if (rootConfig) {
    let target, updated;
    const configFile = await fs2.readFile(rootConfig, "utf8");
    const configFileHasTypeReference = configFile.match(
      /\/\/\/\s*<reference\s+types=["']vitest\/config["']\s*\/>/
    );
    const templateName = getTemplateName();
    if (templateName) {
      const configTemplate = await loadTemplate(templateName, {
        CONFIG_DIR: options.configDir,
        SETUP_FILE: relative(dirname(rootConfig), vitestSetupFile)
      });
      const source = babelParse(configTemplate);
      target = babelParse(configFile);
      updated = updateConfigFile(source, target);
    }
    if (target && updated) {
      logger2.line(1);
      logger2.plain(`${step} Updating your ${vitestConfigFile ? "Vitest" : "Vite"} config file:`);
      logger2.plain(`  ${rootConfig}`);
      const formattedContent = await formatFileContent(rootConfig, generate(target).code);
      const shouldAddReference = !configFileHasTypeReference && !vitestConfigFile;
      await writeFile(
        rootConfig,
        shouldAddReference ? '/// <reference types="vitest/config" />\n' + formattedContent : formattedContent
      );
    } else {
      logErrors(
        "\u{1F6A8} Oh no!",
        dedent`
        We were unable to update your existing ${vitestConfigFile ? "Vitest" : "Vite"} config file.

        Please refer to the documentation to complete the setup manually:
        https://storybook.js.org/docs/writing-tests/integrations/vitest-addon#manual-setup
      `
      );
    }
  } else {
    const newConfigFile = resolve(`vitest.config.${fileExtension}`);
    const configTemplate = await loadTemplate(getTemplateName(), {
      CONFIG_DIR: options.configDir,
      SETUP_FILE: relative(dirname(newConfigFile), vitestSetupFile)
    });
    logger2.line(1);
    logger2.plain(`${step} Creating a Vitest config file:`);
    logger2.plain(`  ${newConfigFile}`);
    const formattedContent = await formatFileContent(newConfigFile, configTemplate);
    await writeFile(newConfigFile, formattedContent);
  }
  const a11yAddon = info2.addons.find((addon) => addon.includes(addonA11yName));
  if (a11yAddon) {
    try {
      logger2.plain(`${step} Setting up ${addonA11yName} for @storybook/addon-vitest:`);
      await execa(
        "storybook",
        [
          "automigrate",
          "addon-a11y-addon-test",
          "--loglevel",
          "silent",
          "--yes",
          "--skip-doctor",
          ...options.packageManager ? ["--package-manager", options.packageManager] : [],
          ...options.skipInstall ? ["--skip-install"] : [],
          ...options.configDir !== ".storybook" ? ["--config-dir", `"${options.configDir}"`] : []
        ],
        {
          stdio: "inherit"
        }
      );
    } catch (e) {
      logErrors(
        "\u{1F6A8} Oh no!",
        dedent`
        We have detected that you have ${addonA11yName} installed but could not automatically set it up for @storybook/addon-vitest:

        ${e instanceof Error ? e.message : String(e)}

        Please refer to the documentation to complete the setup manually:
        https://storybook.js.org/docs/writing-tests/accessibility-testing#test-addon-integration
      `
      );
    }
  }
  const runCommand = rootConfig ? `npx vitest --project=storybook` : `npx vitest`;
  if (!hasErrors) {
    printSuccess(
      "\u{1F389} All done!",
      dedent`
        @storybook/addon-vitest is now configured and you're ready to run your tests!
  
        Here are a couple of tips to get you started:
        • You can run tests with "${runCommand}"
        • When using the Vitest extension in your editor, all of your stories will be shown as tests!
  
        Check the documentation for more information about its features and options at:
        https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}
      `
    );
  } else {
    printWarning(
      "\u26A0\uFE0F Done, but with errors!",
      dedent`
        @storybook/addon-vitest was installed successfully, but there were some errors during the setup process.

        Please refer to the documentation to complete the setup manually and check the errors above:
        https://storybook.js.org/docs/next/${DOCUMENTATION_LINK}#manual-setup
      `
    );
  }
  logger2.line(1);
}
__name(postInstall, "postInstall");
async function getPackageNameFromPath(input) {
  const path = input.startsWith("file://") ? fileURLToPath(input) : input;
  if (!isAbsolute(path)) {
    return path;
  }
  const packageJsonPath = up2({ cwd: path });
  if (!packageJsonPath) {
    throw new Error(`Could not find package.json in path: ${path}`);
  }
  const { default: packageJson } = await import(pathToFileURL(packageJsonPath).href, {
    with: { type: "json" }
  });
  return packageJson.name;
}
__name(getPackageNameFromPath, "getPackageNameFromPath");
async function getStorybookInfo({ configDir, packageManager: pkgMgr }) {
  const packageManager = JsPackageManagerFactory.getPackageManager({ force: pkgMgr, configDir });
  const { packageJson } = packageManager.primaryPackageJson;
  const config = await loadMainConfig({ configDir });
  const { presets } = await experimental_loadStorybook({
    configDir,
    packageJson
  });
  const framework = await presets.apply("framework", {});
  const core = await presets.apply("core", {});
  const { builder, renderer } = core;
  if (!builder) {
    throw new Error("Could not detect your Storybook builder.");
  }
  const frameworkPackageName = await getPackageNameFromPath(
    typeof framework === "string" ? framework : framework.name
  );
  const builderPackageName = await getPackageNameFromPath(
    typeof builder === "string" ? builder : builder.name
  );
  let rendererPackageName;
  if (renderer) {
    rendererPackageName = await getPackageNameFromPath(renderer);
  }
  return {
    frameworkPackageName,
    builderPackageName,
    rendererPackageName,
    addons: getAddonNames(config)
  };
}
__name(getStorybookInfo, "getStorybookInfo");
export {
  postInstall as default
};
