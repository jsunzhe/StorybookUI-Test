import CJS_COMPAT_NODE_URL_yq6slfj5rh from 'node:url';
import CJS_COMPAT_NODE_PATH_yq6slfj5rh from 'node:path';
import CJS_COMPAT_NODE_MODULE_yq6slfj5rh from "node:module";

var __filename = CJS_COMPAT_NODE_URL_yq6slfj5rh.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_yq6slfj5rh.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_yq6slfj5rh.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  log
} from "../_node-chunks/chunk-FEN3MRFP.js";
import {
  any,
  errorToErrorLike
} from "../_node-chunks/chunk-PNNLYDKS.js";
import {
  ADDON_ID,
  COVERAGE_DIRECTORY,
  STATUS_TYPE_ID_A11Y,
  STATUS_TYPE_ID_COMPONENT_TEST,
  storeOptions
} from "../_node-chunks/chunk-YXDSXLVO.js";
import "../_node-chunks/chunk-APXF44MI.js";
import {
  dirname,
  join,
  normalize,
  path
} from "../_node-chunks/chunk-HVQVIFNZ.js";
import {
  __name
} from "../_node-chunks/chunk-DMVKAJJ2.js";

// src/node/vitest.ts
import process2 from "node:process";
import { Channel } from "storybook/internal/channels";
import {
  experimental_UniversalStore,
  experimental_getStatusStore,
  experimental_getTestProviderStore
} from "storybook/internal/core-server";

// ../../node_modules/es-toolkit/dist/function/debounce.mjs
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = void 0;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke = /* @__PURE__ */ __name(() => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = void 0;
      pendingArgs = null;
    }
  }, "invoke");
  const onTimerEnd = /* @__PURE__ */ __name(() => {
    if (trailing) {
      invoke();
    }
    cancel();
  }, "onTimerEnd");
  let timeoutId = null;
  const schedule = /* @__PURE__ */ __name(() => {
    if (timeoutId != null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
      onTimerEnd();
    }, debounceMs);
  }, "schedule");
  const cancelTimer = /* @__PURE__ */ __name(() => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  }, "cancelTimer");
  const cancel = /* @__PURE__ */ __name(() => {
    cancelTimer();
    pendingThis = void 0;
    pendingArgs = null;
  }, "cancel");
  const flush = /* @__PURE__ */ __name(() => {
    invoke();
  }, "flush");
  const debounced = /* @__PURE__ */ __name(function(...args) {
    if (signal?.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId == null;
    schedule();
    if (leading && isFirstCall) {
      invoke();
    }
  }, "debounced");
  debounced.schedule = schedule;
  debounced.cancel = cancel;
  debounced.flush = flush;
  signal?.addEventListener("abort", cancel, { once: true });
  return debounced;
}
__name(debounce, "debounce");

// ../../node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
__name(partial, "partial");
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = /* @__PURE__ */ __name(function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  }, "partialed");
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
__name(partialImpl, "partialImpl");
var placeholderSymbol = Symbol("partial.placeholder");
partial.placeholder = placeholderSymbol;

// ../../node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
__name(partialRight, "partialRight");
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = /* @__PURE__ */ __name(function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  }, "partialedRight");
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
__name(partialRightImpl, "partialRightImpl");
var placeholderSymbol2 = Symbol("partialRight.placeholder");
partialRight.placeholder = placeholderSymbol2;

// ../../node_modules/es-toolkit/dist/function/retry.mjs
var DEFAULT_RETRIES = Number.POSITIVE_INFINITY;

// ../../node_modules/es-toolkit/dist/function/throttle.mjs
function throttle(func, throttleMs, { signal, edges = ["leading", "trailing"] } = {}) {
  let pendingAt = null;
  const debounced = debounce(func, throttleMs, { signal, edges });
  const throttled = /* @__PURE__ */ __name(function(...args) {
    if (pendingAt == null) {
      pendingAt = Date.now();
    } else {
      if (Date.now() - pendingAt >= throttleMs) {
        pendingAt = Date.now();
        debounced.cancel();
      }
    }
    debounced(...args);
  }, "throttled");
  throttled.cancel = debounced.cancel;
  throttled.flush = debounced.flush;
  return throttled;
}
__name(throttle, "throttle");

// src/node/vitest-manager.ts
import { existsSync } from "node:fs";
import { getProjectRoot, resolvePathInStorybookCache } from "storybook/internal/common";

// ../../node_modules/slash/index.js
function slash(path2) {
  const isExtendedLengthPath = path2.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path2;
  }
  return path2.replace(/\\/g, "/");
}
__name(slash, "slash");

// src/node/reporter.ts
var StorybookReporter = class {
  constructor(testManager) {
    this.testManager = testManager;
  }
  static {
    __name(this, "StorybookReporter");
  }
  onInit(ctx) {
    this.ctx = ctx;
  }
  onTestCaseResult(testCase) {
    const { storyId, reports } = testCase.meta();
    const testResult = testCase.result();
    this.testManager.onTestCaseResult({
      storyId,
      testResult,
      reports
    });
  }
  async onTestRunEnd(testModules, unhandledErrors) {
    const totalTestCount = testModules.flatMap(
      (t) => Array.from(t.children.allTests("passed")).concat(Array.from(t.children.allTests("failed")))
    ).length;
    const testModulesErrors = testModules.flatMap((t) => t.errors());
    const serializedErrors = unhandledErrors.concat(testModulesErrors).map((e) => {
      return {
        ...e,
        name: e.name,
        message: e.message,
        stack: e.stack?.replace(e.message, ""),
        cause: e.cause
      };
    });
    this.testManager.onTestRunEnd({
      totalTestCount,
      unhandledErrors: serializedErrors
    });
    this.clearVitestState();
  }
  // TODO: Clearing the whole internal state of Vitest might be too aggressive
  async clearVitestState() {
    this.ctx.state.filesMap.clear();
    this.ctx.state.pathsSet.clear();
    this.ctx.state.idMap.clear();
    this.ctx.state.errorsSet.clear();
    this.ctx.state.processTimeoutCauses?.clear();
  }
};

// src/node/vitest-manager.ts
var VITEST_CONFIG_FILE_EXTENSIONS = ["mts", "mjs", "cts", "cjs", "ts", "tsx", "js", "jsx"];
var VITEST_WORKSPACE_FILE_EXTENSION = ["ts", "js", "json"];
process.env.VITEST_STORYBOOK = "true";
var DOUBLE_SPACES = "  ";
var getTestName = /* @__PURE__ */ __name((name) => `${name}${DOUBLE_SPACES}`, "getTestName");
var VitestManager = class {
  constructor(testManager) {
    this.testManager = testManager;
    this.vitest = null;
    this.vitestStartupCounter = 0;
    this.vitestRestartPromise = null;
    this.runningPromise = null;
  }
  static {
    __name(this, "VitestManager");
  }
  async startVitest({ coverage }) {
    const { createVitest } = await import("vitest/node");
    const storybookCoverageReporter = [
      "@storybook/addon-vitest/internal/coverage-reporter",
      {
        testManager: this.testManager,
        coverageOptions: this.vitest?.config?.coverage
      }
    ];
    const coverageOptions = coverage ? {
      enabled: true,
      clean: true,
      cleanOnRerun: true,
      reportOnFailure: true,
      reporter: [["html", {}], storybookCoverageReporter],
      reportsDirectory: resolvePathInStorybookCache(COVERAGE_DIRECTORY)
    } : { enabled: false };
    const vitestWorkspaceConfig = any(
      [
        ...VITEST_WORKSPACE_FILE_EXTENSION.map((ext) => `vitest.workspace.${ext}`),
        ...VITEST_CONFIG_FILE_EXTENSIONS.map((ext) => `vitest.config.${ext}`)
      ],
      { last: getProjectRoot() }
    );
    const projectName = "storybook:" + process.env.STORYBOOK_CONFIG_DIR;
    try {
      this.vitest = await createVitest("test", {
        root: vitestWorkspaceConfig ? dirname(vitestWorkspaceConfig) : process.cwd(),
        watch: true,
        passWithNoTests: false,
        project: [projectName],
        // TODO:
        // Do we want to enable Vite's default reporter?
        // The output in the terminal might be too spamy and it might be better to
        // find a way to just show errors and warnings for example
        // Otherwise it might be hard for the user to discover Storybook related logs
        reporters: ["default", new StorybookReporter(this.testManager)],
        coverage: coverageOptions
      });
    } catch (err) {
      const originalMessage = String(err.message);
      if (originalMessage.includes("Found multiple projects")) {
        const custom = [
          "Storybook was unable to start the test run because you have multiple Vitest projects (or browsers) in headed mode.",
          "Please set `headless: true` in your Storybook vitest config.\n\n"
        ].join("\n");
        if (!originalMessage.startsWith(custom)) {
          err.message = `${custom}${originalMessage}`;
        }
      }
      throw err;
    }
    if (this.vitest) {
      this.vitest.onCancel(() => {
      });
    }
    try {
      await this.vitest.init();
    } catch (e) {
      let message = "Failed to initialize Vitest";
      const isV8 = e.message?.includes("@vitest/coverage-v8");
      const isIstanbul = e.message?.includes("@vitest/coverage-istanbul");
      if (e.message?.includes("Failed to load url") && (isIstanbul || isV8) || // Vitest will sometimes not throw the correct missing-package-detection error, so we have to check for this as well
      e instanceof TypeError && e?.message === "Cannot read properties of undefined (reading 'name')") {
        const coveragePackage = isIstanbul ? "coverage-istanbul" : "coverage-v8";
        message += `

Please install the @vitest/${coveragePackage} package to collect coverage
`;
      }
      this.testManager.reportFatalError(message, e);
      return;
    }
    await this.setupWatchers();
  }
  async restartVitest({ coverage }) {
    await this.vitestRestartPromise;
    this.vitestRestartPromise = new Promise(async (resolve, reject) => {
      try {
        await this.runningPromise;
        await this.vitest?.close();
        await this.startVitest({ coverage });
        resolve();
      } catch (e) {
        reject(e);
      } finally {
        this.vitestRestartPromise = null;
      }
    });
    return this.vitestRestartPromise;
  }
  resetGlobalTestNamePattern() {
    this.vitest?.setGlobalTestNamePattern("");
  }
  updateLastChanged(filepath) {
    this.vitest.projects.forEach(({ browser, vite, server }) => {
      if (server) {
        const serverMods = server.moduleGraph.getModulesByFile(filepath);
        serverMods?.forEach((mod) => server.moduleGraph.invalidateModule(mod));
      }
      if (vite) {
        const serverMods = vite.moduleGraph.getModulesByFile(filepath);
        serverMods?.forEach((mod) => vite.moduleGraph.invalidateModule(mod));
      }
      if (browser) {
        const browserMods = browser.vite.moduleGraph.getModulesByFile(filepath);
        browserMods?.forEach((mod) => browser.vite.moduleGraph.invalidateModule(mod));
      }
    });
  }
  async fetchStories(requestStoryIds) {
    const indexUrl = this.testManager.store.getState().indexUrl;
    if (!indexUrl) {
      throw new Error(
        "Tried to fetch stories to test, but the index URL was not set in the store yet."
      );
    }
    try {
      const index = await Promise.race([
        fetch(indexUrl).then((res) => res.json()),
        new Promise((_, reject) => setTimeout(reject, 3e3, new Error("Request took too long")))
      ]);
      const storyIds = requestStoryIds || Object.keys(index.entries);
      return storyIds.map((id) => index.entries[id]).filter((story) => story.type === "story");
    } catch (e) {
      log("Failed to fetch story index: " + e.message);
      return [];
    }
  }
  filterTestSpecifications(testSpecifications, stories) {
    const filteredTestSpecifications = [];
    const filteredStoryIds = [];
    const storiesByImportPath = {};
    for (const story of stories) {
      const absoluteImportPath = path.join(process.cwd(), story.importPath);
      if (!storiesByImportPath[absoluteImportPath]) {
        storiesByImportPath[absoluteImportPath] = [];
      }
      storiesByImportPath[absoluteImportPath].push(story);
    }
    for (const testSpecification of testSpecifications) {
      const { env = {} } = testSpecification.project.config;
      const include = env.__VITEST_INCLUDE_TAGS__?.split(",").filter(Boolean) ?? ["test"];
      const exclude = env.__VITEST_EXCLUDE_TAGS__?.split(",").filter(Boolean) ?? [];
      const skip = env.__VITEST_SKIP_TAGS__?.split(",").filter(Boolean) ?? [];
      const storiesInTestSpecification = storiesByImportPath[testSpecification.moduleId] ?? [];
      const filteredStories = storiesInTestSpecification.filter((story) => {
        if (include.length && !include.some((tag) => story.tags?.includes(tag))) {
          return false;
        }
        if (exclude.some((tag) => story.tags?.includes(tag))) {
          return false;
        }
        return true;
      });
      if (!filteredStories.length) {
        continue;
      }
      if (!this.testManager.store.getState().watching) {
        this.updateLastChanged(testSpecification.moduleId);
      }
      filteredTestSpecifications.push(testSpecification);
      filteredStoryIds.push(
        ...filteredStories.filter((story) => !skip.some((tag) => story.tags?.includes(tag))).map((story) => story.id)
      );
    }
    return { filteredTestSpecifications, filteredStoryIds };
  }
  async runTests(runPayload) {
    const { watching, config } = this.testManager.store.getState();
    const coverageShouldBeEnabled = config.coverage && !watching && (runPayload?.storyIds?.length ?? 0) === 0;
    const currentCoverage = this.vitest?.config.coverage?.enabled;
    if (!this.vitest) {
      await this.startVitest({ coverage: coverageShouldBeEnabled });
    } else if (currentCoverage !== coverageShouldBeEnabled) {
      await this.restartVitest({ coverage: coverageShouldBeEnabled });
    } else {
      await this.vitestRestartPromise;
    }
    this.resetGlobalTestNamePattern();
    await this.cancelCurrentRun();
    const testSpecifications = await this.getStorybookTestSpecifications();
    const allStories = await this.fetchStories();
    const filteredStories = runPayload.storyIds ? allStories.filter((story) => runPayload.storyIds?.includes(story.id)) : allStories;
    const isSingleStoryRun = runPayload.storyIds?.length === 1;
    if (isSingleStoryRun) {
      const selectedStory = filteredStories.find((story) => story.id === runPayload.storyIds?.[0]);
      if (!selectedStory) {
        throw new Error(`Story ${runPayload.storyIds?.[0]} not found`);
      }
      const storyName = selectedStory.name;
      let regex;
      const isParentStory = allStories.some((story) => selectedStory.id === story.parent);
      const hasParentStory = allStories.some((story) => selectedStory.parent === story.id);
      if (isParentStory) {
        const parentName = getTestName(selectedStory.name);
        regex = new RegExp(`^${parentName}`);
      } else if (hasParentStory) {
        const parentStory = allStories.find((story) => story.id === selectedStory.parent);
        if (!parentStory) {
          throw new Error(`Parent story not found for story ${selectedStory.id}`);
        }
        const parentName = getTestName(parentStory.name);
        regex = new RegExp(`^${parentName} ${storyName}$`);
      } else {
        regex = new RegExp(`^${storyName}$`);
      }
      this.vitest.setGlobalTestNamePattern(regex);
    }
    const { filteredTestSpecifications, filteredStoryIds } = this.filterTestSpecifications(
      testSpecifications,
      filteredStories
    );
    this.testManager.store.setState((s) => ({
      ...s,
      currentRun: {
        ...s.currentRun,
        totalTestCount: filteredStoryIds.length
      }
    }));
    await this.vitest.runTestSpecifications(filteredTestSpecifications, true);
    this.resetGlobalTestNamePattern();
  }
  async cancelCurrentRun() {
    await this.vitest?.cancelCurrentRun("keyboard-input");
    await this.runningPromise;
  }
  async getStorybookTestSpecifications() {
    const globTestSpecifications = await this.vitest?.globTestSpecifications() ?? [];
    return globTestSpecifications.filter(
      (workspaceSpec) => this.isStorybookProject(workspaceSpec.project)
    ) ?? [];
  }
  async runAffectedTestsAfterChange(changedFilePath, event) {
    const id = slash(changedFilePath);
    this.vitest?.logger.clearHighlightCache(id);
    this.updateLastChanged(id);
    if (event === "add") {
      const project = this.vitest?.projects.find(this.isStorybookProject.bind(this));
      project?.matchesTestGlob(id);
    }
    if (!this.testManager.store.getState().watching) {
      return;
    }
    if (!this.vitest) {
      return;
    }
    this.resetGlobalTestNamePattern();
    const storybookProject = this.vitest.projects.find((p) => this.isStorybookProject(p));
    const previewAnnotationSpecifications = this.testManager.store.getState().previewAnnotations.map((previewAnnotation) => {
      return {
        project: storybookProject ?? this.vitest.projects[0],
        moduleId: typeof previewAnnotation === "string" ? previewAnnotation : previewAnnotation.absolute
      };
    });
    const setupFilesSpecifications = this.vitest.projects.flatMap(
      (project) => project.config.setupFiles.map((setupFile) => ({
        project,
        moduleId: setupFile
      }))
    );
    const syntheticGlobalTestSpecifications = previewAnnotationSpecifications.concat(setupFilesSpecifications);
    const testSpecifications = await this.getStorybookTestSpecifications();
    const allStories = await this.fetchStories();
    let affectsGlobalFiles = false;
    const affectedTestSpecifications = (await Promise.all(
      syntheticGlobalTestSpecifications.concat(testSpecifications).map(async (testSpecification) => {
        const dependencies = await this.getTestDependencies(testSpecification);
        if (changedFilePath === testSpecification.moduleId || dependencies.has(changedFilePath)) {
          if (syntheticGlobalTestSpecifications.includes(testSpecification)) {
            affectsGlobalFiles = true;
          }
          return testSpecification;
        }
      })
    )).filter(Boolean);
    const testSpecificationsToRun = affectsGlobalFiles ? testSpecifications : affectedTestSpecifications;
    if (!testSpecificationsToRun.length) {
      return;
    }
    const { filteredTestSpecifications, filteredStoryIds } = this.filterTestSpecifications(
      testSpecificationsToRun,
      allStories
    );
    await this.testManager.runTestsWithState({
      storyIds: filteredStoryIds,
      triggeredBy: "watch",
      callback: /* @__PURE__ */ __name(async () => {
        this.testManager.store.setState((s) => ({
          ...s,
          currentRun: {
            ...s.currentRun,
            totalTestCount: filteredStoryIds.length
          }
        }));
        await this.vitest.cancelCurrentRun("keyboard-input");
        await this.runningPromise;
        await this.vitest.runTestSpecifications(filteredTestSpecifications, false);
      }, "callback")
    });
  }
  // This is an adaptation of Vitest's own implementation
  // see https://github.com/vitest-dev/vitest/blob/14409088166152c920ce7fa4ad4c0ba57149b869/packages/vitest/src/node/specifications.ts#L171-L198
  async getTestDependencies(spec) {
    const deps = /* @__PURE__ */ new Set();
    const addImports = /* @__PURE__ */ __name(async (project, filepath) => {
      if (deps.has(filepath)) {
        return;
      }
      deps.add(filepath);
      const mod = project.vite.moduleGraph.getModuleById(filepath);
      const transformed = mod?.ssrTransformResult || await project.vite.transformRequest(filepath, { ssr: true });
      if (!transformed) {
        return;
      }
      const dependencies = [...transformed.deps ?? [], ...transformed.dynamicDeps ?? []];
      await Promise.all(
        dependencies.map(async (dep) => {
          const fsPath = dep.startsWith("/@fs/") ? dep.slice(process.platform === "win32" ? 5 : 4) : join(project.config.root, dep);
          if (!fsPath.includes("node_modules") && !deps.has(fsPath) && existsSync(fsPath)) {
            await addImports(project, fsPath);
          }
        })
      );
    }, "addImports");
    await addImports(spec.project, spec.moduleId);
    deps.delete(spec.moduleId);
    return deps;
  }
  async registerVitestConfigListener() {
    this.vitest.vite.watcher.on("change", async (file) => {
      const isConfig = normalize(file) === this.vitest?.vite?.config.configFile;
      if (isConfig) {
        log("Restarting Vitest due to config change");
        const { watching, config } = this.testManager.store.getState();
        await this.restartVitest({ coverage: config.coverage && !watching });
      }
    });
  }
  async setupWatchers() {
    this.resetGlobalTestNamePattern();
    this.vitest.vite.watcher.removeAllListeners("change");
    this.vitest.vite.watcher.removeAllListeners("add");
    this.vitest.vite.watcher.on(
      "change",
      (file) => this.runAffectedTestsAfterChange(file, "change")
    );
    this.vitest.vite.watcher.on("add", (file) => {
      this.runAffectedTestsAfterChange(file, "add");
    });
    this.registerVitestConfigListener();
  }
  isStorybookProject(project) {
    return !!project.config.env?.__STORYBOOK_URL__;
  }
};

// src/node/test-manager.ts
var testStateToStatusValueMap = {
  pending: "status-value:pending",
  passed: "status-value:success",
  warning: "status-value:warning",
  failed: "status-value:error",
  skipped: "status-value:unknown"
};
var TestManager = class _TestManager {
  constructor(options) {
    this.batchedTestCaseResults = [];
    /**
     * Throttled function to process batched test case results.
     *
     * This function:
     *
     * 1. Takes all batched test case results and clears the batch
     * 2. Updates the store state with new test counts (component tests and a11y tests)
     * 3. Adjusts the totalTestCount if more tests were run than initially anticipated
     * 4. Creates status objects for component tests and updates the component test status store
     * 5. Creates status objects for a11y tests (if any) and updates the a11y status store
     *
     * The throttling (500ms) is necessary as the channel would otherwise get overwhelmed with events,
     * eventually causing the manager and dev server to lose connection.
     */
    this.throttledFlushTestCaseResults = throttle(() => {
      const testCaseResultsToFlush = this.batchedTestCaseResults;
      this.batchedTestCaseResults = [];
      this.store.setState((s) => {
        let { success: ctSuccess, error: ctError } = s.currentRun.componentTestCount;
        let { success: a11ySuccess, warning: a11yWarning, error: a11yError } = s.currentRun.a11yCount;
        testCaseResultsToFlush.forEach(({ testResult, reports }) => {
          if (testResult.state === "passed") {
            ctSuccess++;
          } else if (testResult.state === "failed") {
            ctError++;
          }
          reports?.filter((r) => r.type === "a11y").forEach((report) => {
            if (report.status === "passed") {
              a11ySuccess++;
            } else if (report.status === "warning") {
              a11yWarning++;
            } else if (report.status === "failed") {
              a11yError++;
            }
          });
        });
        const finishedTestCount = ctSuccess + ctError;
        return {
          ...s,
          currentRun: {
            ...s.currentRun,
            componentTestCount: { success: ctSuccess, error: ctError },
            a11yCount: { success: a11ySuccess, warning: a11yWarning, error: a11yError },
            // in some cases successes and errors can exceed the anticipated totalTestCount
            // e.g. when testing more tests than the stories we know about upfront
            // in those cases, we set the totalTestCount to the sum of successes and errors
            totalTestCount: finishedTestCount > (s.currentRun.totalTestCount ?? 0) ? finishedTestCount : s.currentRun.totalTestCount
          }
        };
      });
      const componentTestStatuses = testCaseResultsToFlush.map(({ storyId, testResult }) => ({
        storyId,
        typeId: STATUS_TYPE_ID_COMPONENT_TEST,
        value: testStateToStatusValueMap[testResult.state],
        title: "Component tests",
        description: testResult.errors?.map((error) => error.stack || error.message).join("\n") ?? "",
        sidebarContextMenu: false
      }));
      this.componentTestStatusStore.set(componentTestStatuses);
      const a11yStatuses = testCaseResultsToFlush.flatMap(
        ({ storyId, reports }) => reports?.filter((r) => r.type === "a11y").map((a11yReport) => ({
          storyId,
          typeId: STATUS_TYPE_ID_A11Y,
          value: testStateToStatusValueMap[a11yReport.status],
          title: "Accessibility tests",
          description: "",
          sidebarContextMenu: false
        }))
      ).filter((a11yStatus) => a11yStatus !== void 0);
      if (a11yStatuses.length > 0) {
        this.a11yStatusStore.set(a11yStatuses);
      }
    }, 500);
    this.store = options.store;
    this.componentTestStatusStore = options.componentTestStatusStore;
    this.a11yStatusStore = options.a11yStatusStore;
    this.testProviderStore = options.testProviderStore;
    this.onReady = options.onReady;
    this.storybookOptions = options.storybookOptions;
    this.vitestManager = new VitestManager(this);
    this.store.subscribe("TRIGGER_RUN", this.handleTriggerRunEvent.bind(this));
    this.store.subscribe("CANCEL_RUN", this.handleCancelEvent.bind(this));
    this.store.untilReady().then(() => {
      return this.vitestManager.startVitest({ coverage: this.store.getState().config.coverage });
    }).then(() => this.onReady?.()).catch((e) => {
      this.reportFatalError("Failed to start Vitest", e);
    });
  }
  static {
    __name(this, "TestManager");
  }
  async handleTriggerRunEvent(event) {
    await this.runTestsWithState({
      storyIds: event.payload.storyIds,
      triggeredBy: event.payload.triggeredBy,
      callback: /* @__PURE__ */ __name(async () => {
        try {
          await this.vitestManager.vitestRestartPromise;
          await this.vitestManager.runTests(event.payload);
        } catch (err) {
          this.reportFatalError("Failed to run tests", err);
          throw err;
        }
      }, "callback")
    });
  }
  async handleCancelEvent() {
    try {
      this.store.setState((s) => ({
        ...s,
        cancelling: true
      }));
      await this.vitestManager.cancelCurrentRun();
    } catch (err) {
      this.reportFatalError("Failed to cancel tests", err);
    } finally {
      this.store.setState((s) => ({
        ...s,
        cancelling: false
      }));
    }
  }
  async runTestsWithState({
    storyIds,
    triggeredBy,
    callback
  }) {
    this.componentTestStatusStore.unset(storyIds);
    this.a11yStatusStore.unset(storyIds);
    this.store.setState((s) => ({
      ...s,
      currentRun: {
        ...storeOptions.initialState.currentRun,
        triggeredBy,
        startedAt: Date.now(),
        storyIds,
        config: s.config
      }
    }));
    process.env.VITEST_STORYBOOK_CONFIG = JSON.stringify(this.store.getState().config);
    await this.testProviderStore.runWithState(async () => {
      await callback();
      this.store.send({
        type: "TEST_RUN_COMPLETED",
        payload: this.store.getState().currentRun
      });
      if (this.store.getState().currentRun.unhandledErrors.length > 0) {
        throw new Error("Tests completed but there are unhandled errors");
      }
    });
  }
  onTestModuleCollected(collectedTestCount) {
    this.store.setState((s) => ({
      ...s,
      currentRun: {
        ...s.currentRun,
        totalTestCount: (s.currentRun.totalTestCount ?? 0) + collectedTestCount
      }
    }));
  }
  onTestCaseResult(result) {
    const { storyId, testResult, reports } = result;
    if (!storyId) {
      return;
    }
    this.batchedTestCaseResults.push({ storyId, testResult, reports });
    this.throttledFlushTestCaseResults();
  }
  onTestRunEnd(endResult) {
    this.throttledFlushTestCaseResults.flush();
    this.store.setState((s) => ({
      ...s,
      currentRun: {
        ...s.currentRun,
        // when the test run is finished, we can set the totalTestCount to the actual number of tests run
        // this number can be lower than the total number of tests we anticipated upfront
        // e.g. when some tests where skipped without us knowing about it upfront
        totalTestCount: endResult.totalTestCount,
        unhandledErrors: endResult.unhandledErrors,
        finishedAt: Date.now()
      }
    }));
  }
  onCoverageCollected(coverageSummary) {
    this.store.setState((s) => ({
      ...s,
      currentRun: { ...s.currentRun, coverageSummary }
    }));
  }
  async reportFatalError(message, error) {
    await this.store.untilReady();
    this.store.send({
      type: "FATAL_ERROR",
      payload: {
        message,
        error: errorToErrorLike(error)
      }
    });
  }
  static async start(options) {
    return new Promise((resolve) => {
      const testManager = new _TestManager({
        ...options,
        onReady: /* @__PURE__ */ __name(() => {
          resolve(testManager);
          options.onReady?.();
        }, "onReady")
      });
    });
  }
};

// src/node/vitest.ts
var UniversalStore = experimental_UniversalStore;
var getStatusStore = experimental_getStatusStore;
var getTestProviderStore = experimental_getTestProviderStore;
var channel = new Channel({
  async: true,
  transport: {
    send: /* @__PURE__ */ __name((event) => {
      process2.send?.(event);
    }, "send"),
    setHandler: /* @__PURE__ */ __name((handler) => {
      process2.on("message", handler);
    }, "setHandler")
  }
});
UniversalStore.__prepare(channel, UniversalStore.Environment.SERVER);
var store = UniversalStore.create(storeOptions);
new TestManager({
  store,
  componentTestStatusStore: getStatusStore(STATUS_TYPE_ID_COMPONENT_TEST),
  a11yStatusStore: getStatusStore(STATUS_TYPE_ID_A11Y),
  testProviderStore: getTestProviderStore(ADDON_ID),
  onReady: /* @__PURE__ */ __name(() => {
    process2.send?.({ type: "ready" });
  }, "onReady"),
  storybookOptions: {
    configDir: process2.env.STORYBOOK_CONFIG_DIR || ""
  }
});
var exit = /* @__PURE__ */ __name((code = 0) => {
  channel?.removeAllListeners();
  process2.exit(code);
}, "exit");
var createUnhandledErrorHandler = /* @__PURE__ */ __name((message) => async (error) => {
  try {
    const payload = {
      message,
      error: {
        message: error.message,
        name: error.name,
        stack: error.stack,
        cause: error.cause
      }
    };
    process2.send?.({
      type: "uncaught-error",
      payload
    });
  } finally {
    exit(1);
  }
}, "createUnhandledErrorHandler");
process2.on(
  "uncaughtException",
  createUnhandledErrorHandler("Uncaught exception in the test runner process")
);
process2.on(
  "unhandledRejection",
  createUnhandledErrorHandler("Unhandled rejection in the test runner process")
);
process2.on("exit", exit);
process2.on("SIGINT", () => exit(0));
process2.on("SIGTERM", () => exit(0));
